{
    "version": "https://jsonfeed.org/version/1",
    "title": "Security Advisory for Rust crates",
    "home_page_url": "https://github.com/advisories?query=type%3Areviewed+ecosystem%3Arust",
    "feed_url": "https://azu.github.io/github-advisory-database-rss/rust.json",
    "description": "Security Advisory for Rust crates on GitHub",
    "items": [
        {
            "content_html": "<p>In SP1’s STARK verifier, the prover provided <code>chip_ordering</code> is used to fetch the index of the chips that have preprocessed columns. Prior to v4.0.0, the validation that this <code>chip_ordering</code> correctly provides these indexes was missing. In v4.0.0, this was fixed by adding a check that the indexed chip’s name is equal to the name stored in the verifying key’s chip information. </p>\n<p>In the recursive verifier, every verifier program is generated beforehand and later checked for correctness by requiring a merkle proof to the precomputed merkle root of valid verifier keys. Therefore, the recursive verifier and the on-chain verifier were not affected by this vulnerability. </p>\n<p>This code was audited twice, once as a part of the audit by KALOS and once by Cantina for v1.0.0. This bug was found by the Succinct team during preparation of v4.0.0. Out of abundance of caution, we will be deprecating all previous versions and freeze the corresponding verifiers.</p>\n<p>Furthermore, in the recursive verifier, the <code>is_complete</code> boolean flag is used to flag a proof of complete execution. Prior to v4.0.0, this flag was underconstrained in parts of our recursive verifier, such as the first layer of the recursion. In v4.0.0, this bug was fixed by adding appropriate calls to the <code>assert_complete</code> function, which constrains the correctness of the <code>is_complete</code> flag. This code was a part of the audit for v3.0.0. This bug affects the soundness of the Rust SDK for verifying compressed proofs, and the soundness of on-chain verifier for deferred proofs. </p>\n<p>This issue was found by a combined effort from Aligned, LambdaClass and 3MI Labs, and was also independently found by Succinct during the preparation of v4.0.0. </p>\n<p>Lastly, SP1’s STARK verifier relied on logic inside Plonky3, one SP1's core dependencies, to check that the polynomial evaluation claims are correct using a FRI-based polynomial commitment scheme. To batch this check, multiple polynomial evaluation claims are combined using a random linear combination. Prior to v4.0.0, the individual evaluation claims were not observed into the challenger before sampling the coefficient for the random linear combination.In v4.0.0, this was fixed by observing all the evaluation claims into the challenger correctly inside of Plonky3.</p>\n<p>This bug was found by external researchers, and we have worked closely with the Plonky3 team to mitigate this vulnerability. We will be deprecating all previous versions and freezing their verifiers to ensure that versions with the vulnerability will not be used in production.</p>\n<h3 id=\"references\">References</h3>\n<ul>\n<li><a href=\"https://github.com/succinctlabs/sp1/security/advisories/GHSA-c873-wfhp-wx5m\">https://github.com/succinctlabs/sp1/security/advisories/GHSA-c873-wfhp-wx5m</a></li>\n<li><a href=\"https://github.com/advisories/GHSA-c873-wfhp-wx5m\">https://github.com/advisories/GHSA-c873-wfhp-wx5m</a></li>\n</ul>\n",
            "url": "https://github.com/advisories/GHSA-c873-wfhp-wx5m",
            "title": "[sp1-stark]  SP1 has missing verifier checks and fiat-shamir observations",
            "date_modified": "2025-01-15T21:25:58.000Z",
            "date_published": "2025-01-15T21:25:54.000Z",
            "author": {
                "name": "GitHub",
                "url": "https://github.com/advisories/GHSA-c873-wfhp-wx5m"
            },
            "tags": [
                "severity"
            ]
        },
        {
            "content_html": "<p>Vaultwarden v1.32.5 was discovered to contain an authenticated reflected cross-site scripting (XSS) vulnerability via the component /api/core/mod.rs.</p>\n<h3 id=\"references\">References</h3>\n<ul>\n<li><a href=\"https://nvd.nist.gov/vuln/detail/CVE-2024-55226\">https://nvd.nist.gov/vuln/detail/CVE-2024-55226</a></li>\n<li><a href=\"https://github.com/dani-garcia/vaultwarden/releases/tag/1.32.4\">https://github.com/dani-garcia/vaultwarden/releases/tag/1.32.4</a></li>\n<li><a href=\"https://github.com/dani-garcia/vaultwarden/releases/tag/1.32.5\">https://github.com/dani-garcia/vaultwarden/releases/tag/1.32.5</a></li>\n<li><a href=\"https://insinuator.net/2024/11/vulnerability-disclosure-authentication-bypass-in-vaultwarden-versions-1-32-5\">https://insinuator.net/2024/11/vulnerability-disclosure-authentication-bypass-in-vaultwarden-versions-1-32-5</a></li>\n<li><a href=\"https://github.com/advisories/GHSA-vprm-27pv-jp3w\">https://github.com/advisories/GHSA-vprm-27pv-jp3w</a></li>\n</ul>\n",
            "url": "https://github.com/advisories/GHSA-vprm-27pv-jp3w",
            "title": "[vaultwarden] Vaultwarden authenticated reflected cross-site scripting (XSS) vulnerability",
            "date_modified": "2025-01-09T23:14:11.000Z",
            "date_published": "2025-01-09T21:31:32.000Z",
            "author": {
                "name": "GitHub",
                "url": "https://github.com/advisories/GHSA-vprm-27pv-jp3w"
            },
            "tags": [
                "severity"
            ]
        },
        {
            "content_html": "<p>An issue in the component src/api/identity.rs of Vaultwarden prior to v1.32.5 allows attackers to impersonate users, including Administrators, via a crafted authorization request.</p>\n<h3 id=\"references\">References</h3>\n<ul>\n<li><a href=\"https://nvd.nist.gov/vuln/detail/CVE-2024-55225\">https://nvd.nist.gov/vuln/detail/CVE-2024-55225</a></li>\n<li><a href=\"https://github.com/dani-garcia/vaultwarden/releases/tag/1.32.4\">https://github.com/dani-garcia/vaultwarden/releases/tag/1.32.4</a></li>\n<li><a href=\"https://github.com/dani-garcia/vaultwarden/releases/tag/1.32.5\">https://github.com/dani-garcia/vaultwarden/releases/tag/1.32.5</a></li>\n<li><a href=\"https://insinuator.net/2024/11/vulnerability-disclosure-authentication-bypass-in-vaultwarden-versions-1-32-5\">https://insinuator.net/2024/11/vulnerability-disclosure-authentication-bypass-in-vaultwarden-versions-1-32-5</a></li>\n<li><a href=\"https://github.com/dani-garcia/vaultwarden/commit/20d9e885bfcd7df7828d92c6e59ed5fe7b40a879\">https://github.com/dani-garcia/vaultwarden/commit/20d9e885bfcd7df7828d92c6e59ed5fe7b40a879</a></li>\n<li><a href=\"https://github.com/dani-garcia/vaultwarden/commit/37c14c3c69b244ec50f5c62b4c9260171607c1d8\">https://github.com/dani-garcia/vaultwarden/commit/37c14c3c69b244ec50f5c62b4c9260171607c1d8</a></li>\n<li><a href=\"https://github.com/advisories/GHSA-x7m9-mv49-fv73\">https://github.com/advisories/GHSA-x7m9-mv49-fv73</a></li>\n</ul>\n",
            "url": "https://github.com/advisories/GHSA-x7m9-mv49-fv73",
            "title": "[vaultwarden] Vaultwarden vulnerable to user impersonation",
            "date_modified": "2025-01-10T18:38:02.000Z",
            "date_published": "2025-01-09T21:31:32.000Z",
            "author": {
                "name": "GitHub",
                "url": "https://github.com/advisories/GHSA-x7m9-mv49-fv73"
            },
            "tags": [
                "severity"
            ]
        },
        {
            "content_html": "<p>An HTML injection vulnerability in Vaultwarden prior to v1.32.5 allows attackers to execute arbitrary code via injecting a crafted payload into the username field of an e-mail message.</p>\n<h3 id=\"references\">References</h3>\n<ul>\n<li><a href=\"https://nvd.nist.gov/vuln/detail/CVE-2024-55224\">https://nvd.nist.gov/vuln/detail/CVE-2024-55224</a></li>\n<li><a href=\"https://github.com/dani-garcia/vaultwarden/releases/tag/1.32.4\">https://github.com/dani-garcia/vaultwarden/releases/tag/1.32.4</a></li>\n<li><a href=\"https://github.com/dani-garcia/vaultwarden/releases/tag/1.32.5\">https://github.com/dani-garcia/vaultwarden/releases/tag/1.32.5</a></li>\n<li><a href=\"https://insinuator.net/2024/11/vulnerability-disclosure-authentication-bypass-in-vaultwarden-versions-1-32-5\">https://insinuator.net/2024/11/vulnerability-disclosure-authentication-bypass-in-vaultwarden-versions-1-32-5</a></li>\n<li><a href=\"https://github.com/advisories/GHSA-g5x8-v2ch-gj2g\">https://github.com/advisories/GHSA-g5x8-v2ch-gj2g</a></li>\n</ul>\n",
            "url": "https://github.com/advisories/GHSA-g5x8-v2ch-gj2g",
            "title": "[vaultwarden] Vaultwarden HTML injection vulnerability",
            "date_modified": "2025-01-09T23:13:15.000Z",
            "date_published": "2025-01-09T21:31:32.000Z",
            "author": {
                "name": "GitHub",
                "url": "https://github.com/advisories/GHSA-g5x8-v2ch-gj2g"
            },
            "tags": [
                "severity"
            ]
        },
        {
            "content_html": "<h3 id=\"impact\">Impact</h3>\n<p>Versions of the matrix-sdk-crypto Rust crate before 0.8.0 lack a dedicated mechanism to notify that a user's cryptographic identity has changed from a verified to an unverified one, which could cause client applications relying on the SDK to overlook such changes.</p>\n<h3 id=\"patches\">Patches</h3>\n<p>matrix-sdk-crypto 0.8.0 adds a new <code>VerificationLevel::VerificationViolation</code> enum variant which indicates that a previously verified identity has been changed.</p>\n<h3 id=\"workarounds\">Workarounds</h3>\n<p>N/A</p>\n<h3 id=\"references\">References</h3>\n<ul>\n<li>Patch: <a href=\"https://github.com/matrix-org/matrix-rust-sdk/pull/3795\">https://github.com/matrix-org/matrix-rust-sdk/pull/3795</a></li>\n</ul>\n<h3 id=\"references-1\">References</h3>\n<ul>\n<li><a href=\"https://github.com/matrix-org/matrix-rust-sdk/security/advisories/GHSA-r5vf-wf4h-82gg\">https://github.com/matrix-org/matrix-rust-sdk/security/advisories/GHSA-r5vf-wf4h-82gg</a></li>\n<li><a href=\"https://github.com/matrix-org/matrix-rust-sdk/pull/3795\">https://github.com/matrix-org/matrix-rust-sdk/pull/3795</a></li>\n<li><a href=\"https://nvd.nist.gov/vuln/detail/CVE-2024-52813\">https://nvd.nist.gov/vuln/detail/CVE-2024-52813</a></li>\n<li><a href=\"https://github.com/advisories/GHSA-r5vf-wf4h-82gg\">https://github.com/advisories/GHSA-r5vf-wf4h-82gg</a></li>\n</ul>\n",
            "url": "https://github.com/advisories/GHSA-r5vf-wf4h-82gg",
            "title": "[matrix-sdk-crypto] matrix-sdk-crypto missing facility to signal rotation of a verified cryptographic identity",
            "date_modified": "2025-01-07T18:39:25.000Z",
            "date_published": "2025-01-07T15:25:52.000Z",
            "author": {
                "name": "GitHub",
                "url": "https://github.com/advisories/GHSA-r5vf-wf4h-82gg"
            },
            "tags": [
                "severity"
            ]
        },
        {
            "content_html": "<h3 id=\"summary\">Summary</h3>\n<p>When you send a request with the <code>Authorization</code> header to one domain, and the response asks to redirect to a different domain, Deno's<code>fetch()</code> redirect handling creates a follow-up redirect request that keeps the original <code>Authorization</code> header, leaking its content to that second domain.</p>\n<h3 id=\"details\">Details</h3>\n<p>The <a href=\"https://fetch.spec.whatwg.org/#ref-for-cors-non-wildcard-request-header-name\">right behavior</a> would be to drop the <code>Authorization</code> header instead, in this scenario. The same is generally applied to <code>Cookie</code> and <code>Proxy-Authorization</code> headers, and is done for not only host changes, but also protocol/port changes. Generally referred to as \"origin\".</p>\n<p>The <a href=\"https://docs.deno.com/runtime/reference/web_platform_apis/#:~:text=Deno%20does%20not%20follow%20the,leaking%20authenticated%20data%20cross%20origin.\">documentation</a> states: </p>\n<blockquote>\n<p>Deno does not follow the same-origin policy, because the Deno user agent currently does not have the concept of origins, and it does not have a cookie jar. This means Deno <strong>does not need</strong> to protect against leaking authenticated data cross origin </p>\n</blockquote>\n<h3 id=\"reproduction\">Reproduction</h3>\n<pre><code class=\"language-ts\">const ac = new AbortController()\n\nconst server1 = Deno.serve({ port: 3001, signal: ac.signal }, (req) =&gt; {\n  return new Response(null, {\n    status: 302,\n    headers: {\n      'location': 'http://localhost:3002/redirected'\n    },\n  })\n})\n\nconst server2 = Deno.serve({ port: 3002, signal: ac.signal }, (req) =&gt; {\n  const body = JSON.stringify({\n    url: req.url,\n    hasAuth: req.headers.has('authorization'),\n  })\n  return new Response(body, {\n    status: 200,\n    headers: {'content-type': 'application/json'},\n  })\n})\n\nasync function main() {\n  const response = await fetch(\"http://localhost:3001/\", {\n    headers: {authorization: 'Bearer foo'}\n  })\n  const body = await response.json()\n  \n  ac.abort()\n  \n  if (body.hasAuth) {\n    console.error('ERROR: Authorization header should not be present after cross-origin redirect')\n  } else {\n    console.log('SUCCESS: Authorization header is not present after cross-origin redirect')\n  }\n}\n\nsetTimeout(main, 500)\n</code></pre>\n<h3 id=\"references\">References</h3>\n<ul>\n<li><a href=\"https://github.com/denoland/deno/security/advisories/GHSA-f27p-cmv8-xhm6\">https://github.com/denoland/deno/security/advisories/GHSA-f27p-cmv8-xhm6</a></li>\n<li><a href=\"https://nvd.nist.gov/vuln/detail/CVE-2025-21620\">https://nvd.nist.gov/vuln/detail/CVE-2025-21620</a></li>\n<li><a href=\"https://github.com/advisories/GHSA-f27p-cmv8-xhm6\">https://github.com/advisories/GHSA-f27p-cmv8-xhm6</a></li>\n</ul>\n",
            "url": "https://github.com/advisories/GHSA-f27p-cmv8-xhm6",
            "title": "[deno] fetch: Authorization headers not dropped when redirecting cross-origin",
            "date_modified": "2025-01-07T02:52:56.000Z",
            "date_published": "2025-01-06T22:27:09.000Z",
            "author": {
                "name": "GitHub",
                "url": "https://github.com/advisories/GHSA-f27p-cmv8-xhm6"
            },
            "tags": [
                "severity"
            ]
        },
        {
            "content_html": "<h3 id=\"summary\">Summary</h3>\n<p>When you send a request with the <code>Authorization</code> header to one domain, and the response asks to redirect to a different domain, Deno's<code>fetch()</code> redirect handling creates a follow-up redirect request that keeps the original <code>Authorization</code> header, leaking its content to that second domain.</p>\n<h3 id=\"details\">Details</h3>\n<p>The <a href=\"https://fetch.spec.whatwg.org/#ref-for-cors-non-wildcard-request-header-name\">right behavior</a> would be to drop the <code>Authorization</code> header instead, in this scenario. The same is generally applied to <code>Cookie</code> and <code>Proxy-Authorization</code> headers, and is done for not only host changes, but also protocol/port changes. Generally referred to as \"origin\".</p>\n<p>The <a href=\"https://docs.deno.com/runtime/reference/web_platform_apis/#:~:text=Deno%20does%20not%20follow%20the,leaking%20authenticated%20data%20cross%20origin.\">documentation</a> states: </p>\n<blockquote>\n<p>Deno does not follow the same-origin policy, because the Deno user agent currently does not have the concept of origins, and it does not have a cookie jar. This means Deno <strong>does not need</strong> to protect against leaking authenticated data cross origin </p>\n</blockquote>\n<h3 id=\"reproduction\">Reproduction</h3>\n<pre><code class=\"language-ts\">const ac = new AbortController()\n\nconst server1 = Deno.serve({ port: 3001, signal: ac.signal }, (req) =&gt; {\n  return new Response(null, {\n    status: 302,\n    headers: {\n      'location': 'http://localhost:3002/redirected'\n    },\n  })\n})\n\nconst server2 = Deno.serve({ port: 3002, signal: ac.signal }, (req) =&gt; {\n  const body = JSON.stringify({\n    url: req.url,\n    hasAuth: req.headers.has('authorization'),\n  })\n  return new Response(body, {\n    status: 200,\n    headers: {'content-type': 'application/json'},\n  })\n})\n\nasync function main() {\n  const response = await fetch(\"http://localhost:3001/\", {\n    headers: {authorization: 'Bearer foo'}\n  })\n  const body = await response.json()\n  \n  ac.abort()\n  \n  if (body.hasAuth) {\n    console.error('ERROR: Authorization header should not be present after cross-origin redirect')\n  } else {\n    console.log('SUCCESS: Authorization header is not present after cross-origin redirect')\n  }\n}\n\nsetTimeout(main, 500)\n</code></pre>\n<h3 id=\"references\">References</h3>\n<ul>\n<li><a href=\"https://github.com/denoland/deno/security/advisories/GHSA-f27p-cmv8-xhm6\">https://github.com/denoland/deno/security/advisories/GHSA-f27p-cmv8-xhm6</a></li>\n<li><a href=\"https://nvd.nist.gov/vuln/detail/CVE-2025-21620\">https://nvd.nist.gov/vuln/detail/CVE-2025-21620</a></li>\n<li><a href=\"https://github.com/advisories/GHSA-f27p-cmv8-xhm6\">https://github.com/advisories/GHSA-f27p-cmv8-xhm6</a></li>\n</ul>\n",
            "url": "https://github.com/advisories/GHSA-f27p-cmv8-xhm6",
            "title": "[deno] fetch: Authorization headers not dropped when redirecting cross-origin",
            "date_modified": "2025-01-07T02:52:56.000Z",
            "date_published": "2025-01-06T22:27:09.000Z",
            "author": {
                "name": "GitHub",
                "url": "https://github.com/advisories/GHSA-f27p-cmv8-xhm6"
            },
            "tags": [
                "severity"
            ]
        },
        {
            "content_html": "<h3 id=\"summary\">Summary</h3>\n<p>When you send a request with the <code>Authorization</code> header to one domain, and the response asks to redirect to a different domain, Deno's<code>fetch()</code> redirect handling creates a follow-up redirect request that keeps the original <code>Authorization</code> header, leaking its content to that second domain.</p>\n<h3 id=\"details\">Details</h3>\n<p>The <a href=\"https://fetch.spec.whatwg.org/#ref-for-cors-non-wildcard-request-header-name\">right behavior</a> would be to drop the <code>Authorization</code> header instead, in this scenario. The same is generally applied to <code>Cookie</code> and <code>Proxy-Authorization</code> headers, and is done for not only host changes, but also protocol/port changes. Generally referred to as \"origin\".</p>\n<p>The <a href=\"https://docs.deno.com/runtime/reference/web_platform_apis/#:~:text=Deno%20does%20not%20follow%20the,leaking%20authenticated%20data%20cross%20origin.\">documentation</a> states: </p>\n<blockquote>\n<p>Deno does not follow the same-origin policy, because the Deno user agent currently does not have the concept of origins, and it does not have a cookie jar. This means Deno <strong>does not need</strong> to protect against leaking authenticated data cross origin </p>\n</blockquote>\n<h3 id=\"reproduction\">Reproduction</h3>\n<pre><code class=\"language-ts\">const ac = new AbortController()\n\nconst server1 = Deno.serve({ port: 3001, signal: ac.signal }, (req) =&gt; {\n  return new Response(null, {\n    status: 302,\n    headers: {\n      'location': 'http://localhost:3002/redirected'\n    },\n  })\n})\n\nconst server2 = Deno.serve({ port: 3002, signal: ac.signal }, (req) =&gt; {\n  const body = JSON.stringify({\n    url: req.url,\n    hasAuth: req.headers.has('authorization'),\n  })\n  return new Response(body, {\n    status: 200,\n    headers: {'content-type': 'application/json'},\n  })\n})\n\nasync function main() {\n  const response = await fetch(\"http://localhost:3001/\", {\n    headers: {authorization: 'Bearer foo'}\n  })\n  const body = await response.json()\n  \n  ac.abort()\n  \n  if (body.hasAuth) {\n    console.error('ERROR: Authorization header should not be present after cross-origin redirect')\n  } else {\n    console.log('SUCCESS: Authorization header is not present after cross-origin redirect')\n  }\n}\n\nsetTimeout(main, 500)\n</code></pre>\n<h3 id=\"references\">References</h3>\n<ul>\n<li><a href=\"https://github.com/denoland/deno/security/advisories/GHSA-f27p-cmv8-xhm6\">https://github.com/denoland/deno/security/advisories/GHSA-f27p-cmv8-xhm6</a></li>\n<li><a href=\"https://nvd.nist.gov/vuln/detail/CVE-2025-21620\">https://nvd.nist.gov/vuln/detail/CVE-2025-21620</a></li>\n<li><a href=\"https://github.com/advisories/GHSA-f27p-cmv8-xhm6\">https://github.com/advisories/GHSA-f27p-cmv8-xhm6</a></li>\n</ul>\n",
            "url": "https://github.com/advisories/GHSA-f27p-cmv8-xhm6",
            "title": "[deno_fetch] fetch: Authorization headers not dropped when redirecting cross-origin",
            "date_modified": "2025-01-07T02:52:56.000Z",
            "date_published": "2025-01-06T22:27:09.000Z",
            "author": {
                "name": "GitHub",
                "url": "https://github.com/advisories/GHSA-f27p-cmv8-xhm6"
            },
            "tags": [
                "severity"
            ]
        },
        {
            "content_html": "<p>This crate uses a number of cryptographic algorithms that are no longer considered secure and it uses them in ways that do not guarantee the integrity of the encrypted data.</p>\n<p><code>MagicCrypt64</code> uses the insecure DES block cipher in CBC mode without authentication. This allows for practical brute force and padding oracle attacks and does not protect the integrity of the encrypted data. Key and IV are generated from user input using CRC64, which is not at all a key derivation function.</p>\n<p><code>MagicCrypt64</code>, <code>MagicCrypt128</code>, <code>MagicCrypt192</code>, and <code>MagicCrypt256</code> are all vulnerable to padding-oracle attacks. None of them protect the integrity of the ciphertext. Furthermore, none use password-based key derivation functions, even though the key is intended to be generated from a password.</p>\n<p>Each of the implementations are unsound in that they use uninitialized memory without <code>MaybeUninit</code> or equivalent structures.</p>\n<p>For more information, visit the <a href=\"https://github.com/magiclen/rust-magiccrypt/issues/17\">issue</a>.</p>\n<h3 id=\"references\">References</h3>\n<ul>\n<li><a href=\"https://github.com/magiclen/rust-magiccrypt/issues/17\">https://github.com/magiclen/rust-magiccrypt/issues/17</a></li>\n<li><a href=\"https://rustsec.org/advisories/RUSTSEC-2024-0430.html\">https://rustsec.org/advisories/RUSTSEC-2024-0430.html</a></li>\n<li><a href=\"https://github.com/advisories/GHSA-gmx7-gr5q-85w5\">https://github.com/advisories/GHSA-gmx7-gr5q-85w5</a></li>\n</ul>\n",
            "url": "https://github.com/advisories/GHSA-gmx7-gr5q-85w5",
            "title": "[magic-crypt] magic-crypt uses insecure cryptographic algorithms",
            "date_modified": "2024-12-30T16:53:25.000Z",
            "date_published": "2024-12-30T16:53:24.000Z",
            "author": {
                "name": "GitHub",
                "url": "https://github.com/advisories/GHSA-gmx7-gr5q-85w5"
            },
            "tags": [
                "severity"
            ]
        },
        {
            "content_html": "<p>We consider <code>as_slice</code> and <code>as_slice_mut</code> unsound because: the pointer with any bit patterns could be cast to the slice of arbitrary types. The pointer could be created by unsafe new and deprecated <code>from_parts</code>. We consider that <code>from_parts</code> should be removed in latest version because it will help trigger unsoundness in <code>as_slice</code>. With new declared as unsafe, <code>as_slice</code> should also declared as unsafe.  </p>\n<p>This was patched in by marking two functions as <code>unsafe</code>.</p>\n<h3 id=\"references\">References</h3>\n<ul>\n<li><a href=\"https://github.com/betrusted-io/xous-core/issues/410\">https://github.com/betrusted-io/xous-core/issues/410</a></li>\n<li><a href=\"https://github.com/betrusted-io/xous-core/pull/411\">https://github.com/betrusted-io/xous-core/pull/411</a></li>\n<li><a href=\"https://rustsec.org/advisories/RUSTSEC-2024-0431.html\">https://rustsec.org/advisories/RUSTSEC-2024-0431.html</a></li>\n<li><a href=\"https://github.com/advisories/GHSA-gv7f-5qqh-vxfx\">https://github.com/advisories/GHSA-gv7f-5qqh-vxfx</a></li>\n</ul>\n",
            "url": "https://github.com/advisories/GHSA-gv7f-5qqh-vxfx",
            "title": "[xous] xous has unsound usages of `core::slice::from_raw_parts` ",
            "date_modified": "2024-12-30T16:52:49.000Z",
            "date_published": "2024-12-30T16:52:46.000Z",
            "author": {
                "name": "GitHub",
                "url": "https://github.com/advisories/GHSA-gv7f-5qqh-vxfx"
            },
            "tags": [
                "severity"
            ]
        },
        {
            "content_html": "<p>A new decloaking technique for nearly all VPN implementations has been found, which allows attackers to inject entries into the routing tables of unsuspecting victims using DHCP option 121. This allows attackers to redirect traffic, which is supposed to be sent encrypted over the VPN, through the physical interface handling DHCP for the network the victim's computer is connected to, effectively bypassing the VPN connection.</p>\n<h3 id=\"impact\">Impact</h3>\n<p>All users are potentially affected, as this attack vector can be used against <em>any</em> VPN implementation without mitigations in place.</p>\n<h3 id=\"patches\">Patches</h3>\n<p>Currently, there are no existing mitigations employed by Quincy.</p>\n<h3 id=\"workarounds\">Workarounds</h3>\n<p>Disabling DHCP option 121 in the DHCP client is a potential workaround, as it prevents this kind of attack.</p>\n<h3 id=\"references\">References</h3>\n<p><a href=\"https://www.leviathansecurity.com/blog/tunnelvision\">https://www.leviathansecurity.com/blog/tunnelvision</a></p>\n<h3 id=\"references-1\">References</h3>\n<ul>\n<li><a href=\"https://github.com/M0dEx/quincy/security/advisories/GHSA-hqmp-g7ph-x543\">https://github.com/M0dEx/quincy/security/advisories/GHSA-hqmp-g7ph-x543</a></li>\n<li><a href=\"https://www.leviathansecurity.com/blog/tunnelvision\">https://www.leviathansecurity.com/blog/tunnelvision</a></li>\n<li><a href=\"https://github.com/advisories/GHSA-hqmp-g7ph-x543\">https://github.com/advisories/GHSA-hqmp-g7ph-x543</a></li>\n</ul>\n",
            "url": "https://github.com/advisories/GHSA-hqmp-g7ph-x543",
            "title": "[quincy] TunnelVision - decloaking VPNs using DHCP",
            "date_modified": "2024-12-27T18:12:48.000Z",
            "date_published": "2024-12-27T18:12:47.000Z",
            "author": {
                "name": "GitHub",
                "url": "https://github.com/advisories/GHSA-hqmp-g7ph-x543"
            },
            "tags": [
                "severity"
            ]
        },
        {
            "content_html": "<p>The <code>VariantStrIter::impl_get</code> function (called internally by implementations of the <code>Iterator</code> and <code>DoubleEndedIterator</code> traits for this type) was unsound, resulting in undefined behaviour.</p>\n<p>An immutable reference <code>&amp;p</code> to a <code>*mut libc::c_char</code> pointer initialized to <code>NULL</code> was passed as an argument to a C function that that mutates the pointer behind <code>&amp;p</code> in-place (i.e. as an out-argument), which was unsound. After changes in recent versions of the Rust compiler, these unsound writes through <code>&amp;p</code> now seem to be completely disregarded when building the <code>glib</code> crate with optimizations.</p>\n<p>This subsequently caused all calls of <code>VariantStrIter::impl_get</code> to violate the safety requirements of the <code>std::ffi::CStr::from_ptr</code> function - which requires its argument to be a valid pointer to a C-style string - resulting in crashes due to <code>NULL</code> pointer dereferences.</p>\n<p>This was fixed by passing the out-argument pointer explitly as <code>&amp;mut p</code> instead of <code>&amp;p</code>.</p>\n<p>This issue has been present since this code was initially added in <code>glib</code> v0.15.0. The mismatch in mutability was likely missed (and not raised as an error by the compiler) because the C function wrapped by <code>VariantStrIter::impl_get</code> is variadic (<code>glib_sys::g_variant_get_child</code>), and the pointer in question is one of the variadic arguments.</p>\n<h3 id=\"references\">References</h3>\n<ul>\n<li><a href=\"https://github.com/gtk-rs/gtk-rs-core/pull/1343\">https://github.com/gtk-rs/gtk-rs-core/pull/1343</a></li>\n<li><a href=\"https://rustsec.org/advisories/RUSTSEC-2024-0429.html\">https://rustsec.org/advisories/RUSTSEC-2024-0429.html</a></li>\n<li><a href=\"https://github.com/advisories/GHSA-wrw7-89jp-8q8g\">https://github.com/advisories/GHSA-wrw7-89jp-8q8g</a></li>\n</ul>\n",
            "url": "https://github.com/advisories/GHSA-wrw7-89jp-8q8g",
            "title": "[glib] Unsoundness in `Iterator` and `DoubleEndedIterator` impls for `glib::VariantStrIter`",
            "date_modified": "2024-12-23T20:19:26.000Z",
            "date_published": "2024-12-23T20:19:24.000Z",
            "author": {
                "name": "GitHub",
                "url": "https://github.com/advisories/GHSA-wrw7-89jp-8q8g"
            },
            "tags": [
                "severity"
            ]
        },
        {
            "content_html": "<p>The library provides a safe public API <code>unpack</code> to cast <code>u8</code> array to arbitrary types, which can cause to undefined behaviors. The length check of array can only prevent out-of-bound access on the return type. However, it can't prevent misaligned pointer when casting <code>u8</code> pointer to a type aligned to larger bytes. For example, if we assign <code>u16</code> to <code>T</code>, <strong>misaligned raw pointer dereference</strong> could happen and cause to panic. Even if we pass the type aligned to same byte as <code>u8</code> (e.g., <code>bool</code>), it could construct a illegal type since <code>bool</code> can only have 0 or 1 as bit patterns, which is also an undefined behavior. The further exploits of the bug here are still not clear, so we would report this issue as unsound.  </p>\n<p>The details of PoC to reproduce undefined behavior are provided in the <a href=\"https://github.com/solana-labs/solana-program-library/issues/5243\">issue</a>.  </p>\n<h3 id=\"references\">References</h3>\n<ul>\n<li><a href=\"https://github.com/solana-labs/solana-program-library/issues/5243\">https://github.com/solana-labs/solana-program-library/issues/5243</a></li>\n<li><a href=\"https://rustsec.org/advisories/RUSTSEC-2024-0426.html\">https://rustsec.org/advisories/RUSTSEC-2024-0426.html</a></li>\n<li><a href=\"https://github.com/advisories/GHSA-h6xm-c6r4-vmwf\">https://github.com/advisories/GHSA-h6xm-c6r4-vmwf</a></li>\n</ul>\n",
            "url": "https://github.com/advisories/GHSA-h6xm-c6r4-vmwf",
            "title": "[spl-token-swap] Unsound usages of `u8` type casting in spl-token-swap",
            "date_modified": "2024-12-23T19:29:46.000Z",
            "date_published": "2024-12-23T19:29:44.000Z",
            "author": {
                "name": "GitHub",
                "url": "https://github.com/advisories/GHSA-h6xm-c6r4-vmwf"
            },
            "tags": [
                "severity"
            ]
        },
        {
            "content_html": "<p>The library breaks the safety assumptions when using unsafe API <code>slice::from_raw_parts_mut</code>. The pointer passed to <code>from_raw_parts_mut</code> is misaligned by casting <code>u8</code> to <code>u16</code> raw pointer directly, which is unsound. The bug is patched by using <code>align_offset</code>, which could make sure the memory address is aligned to 2 bytes for <code>u16</code>.  </p>\n<p>This was patched in 0.11.2 in the <a href=\"https://github.com/AFLplusplus/LibAFL/pull/1530/commits/5a60cb31ef587d71d09d534bba39bd3973c4b35d\">commit</a>.</p>\n<h3 id=\"references\">References</h3>\n<ul>\n<li><a href=\"https://github.com/AFLplusplus/LibAFL/issues/1526\">https://github.com/AFLplusplus/LibAFL/issues/1526</a></li>\n<li><a href=\"https://github.com/AFLplusplus/LibAFL/pull/1530\">https://github.com/AFLplusplus/LibAFL/pull/1530</a></li>\n<li><a href=\"https://github.com/AFLplusplus/LibAFL/pull/1530/commits/5a60cb31ef587d71d09d534bba39bd3973c4b35d\">https://github.com/AFLplusplus/LibAFL/pull/1530/commits/5a60cb31ef587d71d09d534bba39bd3973c4b35d</a></li>\n<li><a href=\"https://github.com/AFLplusplus/LibAFL/commit/f70a16a09a8096d3c50159dd8a912a75c2af157c\">https://github.com/AFLplusplus/LibAFL/commit/f70a16a09a8096d3c50159dd8a912a75c2af157c</a></li>\n<li><a href=\"https://rustsec.org/advisories/RUSTSEC-2024-0424.html\">https://rustsec.org/advisories/RUSTSEC-2024-0424.html</a></li>\n<li><a href=\"https://github.com/advisories/GHSA-f7qj-v3vp-4856\">https://github.com/advisories/GHSA-f7qj-v3vp-4856</a></li>\n</ul>\n",
            "url": "https://github.com/advisories/GHSA-f7qj-v3vp-4856",
            "title": "[libafl] libafl has unsound usages of `core::slice::from_raw_parts_mut` ",
            "date_modified": "2024-12-23T19:30:20.000Z",
            "date_published": "2024-12-23T19:28:19.000Z",
            "author": {
                "name": "GitHub",
                "url": "https://github.com/advisories/GHSA-f7qj-v3vp-4856"
            },
            "tags": [
                "severity"
            ]
        },
        {
            "content_html": "<p>An issue was identified in the <code>VmFd::create_device function</code>, leading to undefined behavior and miscompilations on rustc 1.82.0 and newer due to the function's violation of Rust's pointer safety rules.</p>\n<p>The function downcasted a mutable reference to its <code>struct kvm_create_device</code> argument to an immutable pointer, and then proceeded to pass this pointer to a mutating system call. Rustc 1.82.0 and newer elides subsequent reads of this structure's fields, meaning code will not see the value written by the kernel into the <code>fd</code> member. Instead, the code will observe the value that this field was initialized to prior to calling <code>VmFd::create_device</code> (usually, 0).</p>\n<p>The issue started in kvm-ioctls 0.1.0 and was fixed in 0.19.1 by correctly using\na mutable pointer.</p>\n<h3 id=\"references\">References</h3>\n<ul>\n<li><a href=\"https://github.com/rust-vmm/kvm/pull/298\">https://github.com/rust-vmm/kvm/pull/298</a></li>\n<li><a href=\"https://rustsec.org/advisories/RUSTSEC-2024-0428.html\">https://rustsec.org/advisories/RUSTSEC-2024-0428.html</a></li>\n<li><a href=\"https://github.com/advisories/GHSA-3qx8-rv27-j6gp\">https://github.com/advisories/GHSA-3qx8-rv27-j6gp</a></li>\n</ul>\n",
            "url": "https://github.com/advisories/GHSA-3qx8-rv27-j6gp",
            "title": "[kvm-ioctls] Undefined behaviour in `kvm_ioctls::ioctls::vm::VmFd::create_device`",
            "date_modified": "2024-12-23T19:26:38.000Z",
            "date_published": "2024-12-23T19:26:37.000Z",
            "author": {
                "name": "GitHub",
                "url": "https://github.com/advisories/GHSA-3qx8-rv27-j6gp"
            },
            "tags": [
                "severity"
            ]
        },
        {
            "content_html": "<p>A plugin name containing a path separator may allow an attacker to execute an arbitrary binary.</p>\n<p>Such a plugin name can be provided to the <code>rage</code> CLI through an attacker-controlled recipient or identity string, or to the following <code>age</code> APIs when the <code>plugin</code> feature flag is enabled:</p>\n<ul>\n<li><a href=\"https://docs.rs/age/0.11.0/age/plugin/struct.Identity.html#impl-FromStr-for-Identity\"><code>age::plugin::Identity::from_str</code></a> (or equivalently <a href=\"https://doc.rust-lang.org/stable/core/primitive.str.html#method.parse\"><code>str::parse::&lt;age::plugin::Identity&gt;()</code></a>)</li>\n<li><a href=\"https://docs.rs/age/0.11.0/age/plugin/struct.Identity.html#method.default_for_plugin\"><code>age::plugin::Identity::default_for_plugin</code></a></li>\n<li><a href=\"https://docs.rs/age/0.11.0/age/plugin/struct.IdentityPluginV1.html#method.new\"><code>age::plugin::IdentityPluginV1::new</code></a></li>\n<li><a href=\"https://docs.rs/age/0.11.0/age/plugin/struct.Recipient.html#impl-FromStr-for-Recipient\"><code>age::plugin::Recipient::from_str</code></a> (or equivalently <a href=\"https://doc.rust-lang.org/stable/core/primitive.str.html#method.parse\"><code>str::parse::&lt;age::plugin::Recipient&gt;()</code></a>)</li>\n<li><a href=\"https://docs.rs/age/0.11.0/age/plugin/struct.RecipientPluginV1.html#method.new\"><code>age::plugin::RecipientPluginV1::new</code></a></li>\n</ul>\n<p>On UNIX systems, a directory matching <code>age-plugin-*</code> needs to exist in the working directory for the attack to succeed.</p>\n<p>The binary is executed with a single flag, either <code>--age-plugin=recipient-v1</code> or <code>--age-plugin=identity-v1</code>. The standard input includes the recipient or identity string,  and the random file key (if encrypting) or the header of the file (if decrypting). The format is constrained by the <a href=\"https://c2sp.org/age-plugin\">age-plugin</a> protocol.</p>\n<p>An equivalent issue was fixed in <a href=\"https://github.com/FiloSottile/age\">the reference Go implementation of age</a>, see advisory <a href=\"https://github.com/FiloSottile/age/security/advisories/GHSA-32gq-x56h-299c\">GHSA-32gq-x56h-299c</a>.</p>\n<p>Thanks to ⬡-49016 for reporting this issue.</p>\n<h3 id=\"references\">References</h3>\n<ul>\n<li><a href=\"https://github.com/str4d/rage/security/advisories/GHSA-4fg7-vxc8-qx5w\">https://github.com/str4d/rage/security/advisories/GHSA-4fg7-vxc8-qx5w</a></li>\n<li><a href=\"https://github.com/str4d/rage/commit/703152ecfa86f27952a35b57dd525ed39396a227\">https://github.com/str4d/rage/commit/703152ecfa86f27952a35b57dd525ed39396a227</a></li>\n<li><a href=\"https://rustsec.org/advisories/RUSTSEC-2024-0432.html\">https://rustsec.org/advisories/RUSTSEC-2024-0432.html</a></li>\n<li><a href=\"https://rustsec.org/advisories/RUSTSEC-2024-0433.html\">https://rustsec.org/advisories/RUSTSEC-2024-0433.html</a></li>\n<li><a href=\"https://github.com/advisories/GHSA-4fg7-vxc8-qx5w\">https://github.com/advisories/GHSA-4fg7-vxc8-qx5w</a></li>\n</ul>\n",
            "url": "https://github.com/advisories/GHSA-4fg7-vxc8-qx5w",
            "title": "[rage] rage vulnerable to malicious plugin names, recipients, or identities causing arbitrary binary execution",
            "date_modified": "2025-01-03T19:29:42.000Z",
            "date_published": "2024-12-18T18:21:55.000Z",
            "author": {
                "name": "GitHub",
                "url": "https://github.com/advisories/GHSA-4fg7-vxc8-qx5w"
            },
            "tags": [
                "severity"
            ]
        },
        {
            "content_html": "<p>A plugin name containing a path separator may allow an attacker to execute an arbitrary binary.</p>\n<p>Such a plugin name can be provided to the <code>rage</code> CLI through an attacker-controlled recipient or identity string, or to the following <code>age</code> APIs when the <code>plugin</code> feature flag is enabled:</p>\n<ul>\n<li><a href=\"https://docs.rs/age/0.11.0/age/plugin/struct.Identity.html#impl-FromStr-for-Identity\"><code>age::plugin::Identity::from_str</code></a> (or equivalently <a href=\"https://doc.rust-lang.org/stable/core/primitive.str.html#method.parse\"><code>str::parse::&lt;age::plugin::Identity&gt;()</code></a>)</li>\n<li><a href=\"https://docs.rs/age/0.11.0/age/plugin/struct.Identity.html#method.default_for_plugin\"><code>age::plugin::Identity::default_for_plugin</code></a></li>\n<li><a href=\"https://docs.rs/age/0.11.0/age/plugin/struct.IdentityPluginV1.html#method.new\"><code>age::plugin::IdentityPluginV1::new</code></a></li>\n<li><a href=\"https://docs.rs/age/0.11.0/age/plugin/struct.Recipient.html#impl-FromStr-for-Recipient\"><code>age::plugin::Recipient::from_str</code></a> (or equivalently <a href=\"https://doc.rust-lang.org/stable/core/primitive.str.html#method.parse\"><code>str::parse::&lt;age::plugin::Recipient&gt;()</code></a>)</li>\n<li><a href=\"https://docs.rs/age/0.11.0/age/plugin/struct.RecipientPluginV1.html#method.new\"><code>age::plugin::RecipientPluginV1::new</code></a></li>\n</ul>\n<p>On UNIX systems, a directory matching <code>age-plugin-*</code> needs to exist in the working directory for the attack to succeed.</p>\n<p>The binary is executed with a single flag, either <code>--age-plugin=recipient-v1</code> or <code>--age-plugin=identity-v1</code>. The standard input includes the recipient or identity string,  and the random file key (if encrypting) or the header of the file (if decrypting). The format is constrained by the <a href=\"https://c2sp.org/age-plugin\">age-plugin</a> protocol.</p>\n<p>An equivalent issue was fixed in <a href=\"https://github.com/FiloSottile/age\">the reference Go implementation of age</a>, see advisory <a href=\"https://github.com/FiloSottile/age/security/advisories/GHSA-32gq-x56h-299c\">GHSA-32gq-x56h-299c</a>.</p>\n<p>Thanks to ⬡-49016 for reporting this issue.</p>\n<h3 id=\"references\">References</h3>\n<ul>\n<li><a href=\"https://github.com/str4d/rage/security/advisories/GHSA-4fg7-vxc8-qx5w\">https://github.com/str4d/rage/security/advisories/GHSA-4fg7-vxc8-qx5w</a></li>\n<li><a href=\"https://github.com/str4d/rage/commit/703152ecfa86f27952a35b57dd525ed39396a227\">https://github.com/str4d/rage/commit/703152ecfa86f27952a35b57dd525ed39396a227</a></li>\n<li><a href=\"https://rustsec.org/advisories/RUSTSEC-2024-0432.html\">https://rustsec.org/advisories/RUSTSEC-2024-0432.html</a></li>\n<li><a href=\"https://rustsec.org/advisories/RUSTSEC-2024-0433.html\">https://rustsec.org/advisories/RUSTSEC-2024-0433.html</a></li>\n<li><a href=\"https://github.com/advisories/GHSA-4fg7-vxc8-qx5w\">https://github.com/advisories/GHSA-4fg7-vxc8-qx5w</a></li>\n</ul>\n",
            "url": "https://github.com/advisories/GHSA-4fg7-vxc8-qx5w",
            "title": "[rage] rage vulnerable to malicious plugin names, recipients, or identities causing arbitrary binary execution",
            "date_modified": "2025-01-03T19:29:42.000Z",
            "date_published": "2024-12-18T18:21:55.000Z",
            "author": {
                "name": "GitHub",
                "url": "https://github.com/advisories/GHSA-4fg7-vxc8-qx5w"
            },
            "tags": [
                "severity"
            ]
        },
        {
            "content_html": "<p>A plugin name containing a path separator may allow an attacker to execute an arbitrary binary.</p>\n<p>Such a plugin name can be provided to the <code>rage</code> CLI through an attacker-controlled recipient or identity string, or to the following <code>age</code> APIs when the <code>plugin</code> feature flag is enabled:</p>\n<ul>\n<li><a href=\"https://docs.rs/age/0.11.0/age/plugin/struct.Identity.html#impl-FromStr-for-Identity\"><code>age::plugin::Identity::from_str</code></a> (or equivalently <a href=\"https://doc.rust-lang.org/stable/core/primitive.str.html#method.parse\"><code>str::parse::&lt;age::plugin::Identity&gt;()</code></a>)</li>\n<li><a href=\"https://docs.rs/age/0.11.0/age/plugin/struct.Identity.html#method.default_for_plugin\"><code>age::plugin::Identity::default_for_plugin</code></a></li>\n<li><a href=\"https://docs.rs/age/0.11.0/age/plugin/struct.IdentityPluginV1.html#method.new\"><code>age::plugin::IdentityPluginV1::new</code></a></li>\n<li><a href=\"https://docs.rs/age/0.11.0/age/plugin/struct.Recipient.html#impl-FromStr-for-Recipient\"><code>age::plugin::Recipient::from_str</code></a> (or equivalently <a href=\"https://doc.rust-lang.org/stable/core/primitive.str.html#method.parse\"><code>str::parse::&lt;age::plugin::Recipient&gt;()</code></a>)</li>\n<li><a href=\"https://docs.rs/age/0.11.0/age/plugin/struct.RecipientPluginV1.html#method.new\"><code>age::plugin::RecipientPluginV1::new</code></a></li>\n</ul>\n<p>On UNIX systems, a directory matching <code>age-plugin-*</code> needs to exist in the working directory for the attack to succeed.</p>\n<p>The binary is executed with a single flag, either <code>--age-plugin=recipient-v1</code> or <code>--age-plugin=identity-v1</code>. The standard input includes the recipient or identity string,  and the random file key (if encrypting) or the header of the file (if decrypting). The format is constrained by the <a href=\"https://c2sp.org/age-plugin\">age-plugin</a> protocol.</p>\n<p>An equivalent issue was fixed in <a href=\"https://github.com/FiloSottile/age\">the reference Go implementation of age</a>, see advisory <a href=\"https://github.com/FiloSottile/age/security/advisories/GHSA-32gq-x56h-299c\">GHSA-32gq-x56h-299c</a>.</p>\n<p>Thanks to ⬡-49016 for reporting this issue.</p>\n<h3 id=\"references\">References</h3>\n<ul>\n<li><a href=\"https://github.com/str4d/rage/security/advisories/GHSA-4fg7-vxc8-qx5w\">https://github.com/str4d/rage/security/advisories/GHSA-4fg7-vxc8-qx5w</a></li>\n<li><a href=\"https://github.com/str4d/rage/commit/703152ecfa86f27952a35b57dd525ed39396a227\">https://github.com/str4d/rage/commit/703152ecfa86f27952a35b57dd525ed39396a227</a></li>\n<li><a href=\"https://rustsec.org/advisories/RUSTSEC-2024-0432.html\">https://rustsec.org/advisories/RUSTSEC-2024-0432.html</a></li>\n<li><a href=\"https://rustsec.org/advisories/RUSTSEC-2024-0433.html\">https://rustsec.org/advisories/RUSTSEC-2024-0433.html</a></li>\n<li><a href=\"https://github.com/advisories/GHSA-4fg7-vxc8-qx5w\">https://github.com/advisories/GHSA-4fg7-vxc8-qx5w</a></li>\n</ul>\n",
            "url": "https://github.com/advisories/GHSA-4fg7-vxc8-qx5w",
            "title": "[rage] rage vulnerable to malicious plugin names, recipients, or identities causing arbitrary binary execution",
            "date_modified": "2025-01-03T19:29:42.000Z",
            "date_published": "2024-12-18T18:21:55.000Z",
            "author": {
                "name": "GitHub",
                "url": "https://github.com/advisories/GHSA-4fg7-vxc8-qx5w"
            },
            "tags": [
                "severity"
            ]
        },
        {
            "content_html": "<p>A plugin name containing a path separator may allow an attacker to execute an arbitrary binary.</p>\n<p>Such a plugin name can be provided to the <code>rage</code> CLI through an attacker-controlled recipient or identity string, or to the following <code>age</code> APIs when the <code>plugin</code> feature flag is enabled:</p>\n<ul>\n<li><a href=\"https://docs.rs/age/0.11.0/age/plugin/struct.Identity.html#impl-FromStr-for-Identity\"><code>age::plugin::Identity::from_str</code></a> (or equivalently <a href=\"https://doc.rust-lang.org/stable/core/primitive.str.html#method.parse\"><code>str::parse::&lt;age::plugin::Identity&gt;()</code></a>)</li>\n<li><a href=\"https://docs.rs/age/0.11.0/age/plugin/struct.Identity.html#method.default_for_plugin\"><code>age::plugin::Identity::default_for_plugin</code></a></li>\n<li><a href=\"https://docs.rs/age/0.11.0/age/plugin/struct.IdentityPluginV1.html#method.new\"><code>age::plugin::IdentityPluginV1::new</code></a></li>\n<li><a href=\"https://docs.rs/age/0.11.0/age/plugin/struct.Recipient.html#impl-FromStr-for-Recipient\"><code>age::plugin::Recipient::from_str</code></a> (or equivalently <a href=\"https://doc.rust-lang.org/stable/core/primitive.str.html#method.parse\"><code>str::parse::&lt;age::plugin::Recipient&gt;()</code></a>)</li>\n<li><a href=\"https://docs.rs/age/0.11.0/age/plugin/struct.RecipientPluginV1.html#method.new\"><code>age::plugin::RecipientPluginV1::new</code></a></li>\n</ul>\n<p>On UNIX systems, a directory matching <code>age-plugin-*</code> needs to exist in the working directory for the attack to succeed.</p>\n<p>The binary is executed with a single flag, either <code>--age-plugin=recipient-v1</code> or <code>--age-plugin=identity-v1</code>. The standard input includes the recipient or identity string,  and the random file key (if encrypting) or the header of the file (if decrypting). The format is constrained by the <a href=\"https://c2sp.org/age-plugin\">age-plugin</a> protocol.</p>\n<p>An equivalent issue was fixed in <a href=\"https://github.com/FiloSottile/age\">the reference Go implementation of age</a>, see advisory <a href=\"https://github.com/FiloSottile/age/security/advisories/GHSA-32gq-x56h-299c\">GHSA-32gq-x56h-299c</a>.</p>\n<p>Thanks to ⬡-49016 for reporting this issue.</p>\n<h3 id=\"references\">References</h3>\n<ul>\n<li><a href=\"https://github.com/str4d/rage/security/advisories/GHSA-4fg7-vxc8-qx5w\">https://github.com/str4d/rage/security/advisories/GHSA-4fg7-vxc8-qx5w</a></li>\n<li><a href=\"https://github.com/str4d/rage/commit/703152ecfa86f27952a35b57dd525ed39396a227\">https://github.com/str4d/rage/commit/703152ecfa86f27952a35b57dd525ed39396a227</a></li>\n<li><a href=\"https://rustsec.org/advisories/RUSTSEC-2024-0432.html\">https://rustsec.org/advisories/RUSTSEC-2024-0432.html</a></li>\n<li><a href=\"https://rustsec.org/advisories/RUSTSEC-2024-0433.html\">https://rustsec.org/advisories/RUSTSEC-2024-0433.html</a></li>\n<li><a href=\"https://github.com/advisories/GHSA-4fg7-vxc8-qx5w\">https://github.com/advisories/GHSA-4fg7-vxc8-qx5w</a></li>\n</ul>\n",
            "url": "https://github.com/advisories/GHSA-4fg7-vxc8-qx5w",
            "title": "[rage] rage vulnerable to malicious plugin names, recipients, or identities causing arbitrary binary execution",
            "date_modified": "2025-01-03T19:29:42.000Z",
            "date_published": "2024-12-18T18:21:55.000Z",
            "author": {
                "name": "GitHub",
                "url": "https://github.com/advisories/GHSA-4fg7-vxc8-qx5w"
            },
            "tags": [
                "severity"
            ]
        },
        {
            "content_html": "<p>A plugin name containing a path separator may allow an attacker to execute an arbitrary binary.</p>\n<p>Such a plugin name can be provided to the <code>rage</code> CLI through an attacker-controlled recipient or identity string, or to the following <code>age</code> APIs when the <code>plugin</code> feature flag is enabled:</p>\n<ul>\n<li><a href=\"https://docs.rs/age/0.11.0/age/plugin/struct.Identity.html#impl-FromStr-for-Identity\"><code>age::plugin::Identity::from_str</code></a> (or equivalently <a href=\"https://doc.rust-lang.org/stable/core/primitive.str.html#method.parse\"><code>str::parse::&lt;age::plugin::Identity&gt;()</code></a>)</li>\n<li><a href=\"https://docs.rs/age/0.11.0/age/plugin/struct.Identity.html#method.default_for_plugin\"><code>age::plugin::Identity::default_for_plugin</code></a></li>\n<li><a href=\"https://docs.rs/age/0.11.0/age/plugin/struct.IdentityPluginV1.html#method.new\"><code>age::plugin::IdentityPluginV1::new</code></a></li>\n<li><a href=\"https://docs.rs/age/0.11.0/age/plugin/struct.Recipient.html#impl-FromStr-for-Recipient\"><code>age::plugin::Recipient::from_str</code></a> (or equivalently <a href=\"https://doc.rust-lang.org/stable/core/primitive.str.html#method.parse\"><code>str::parse::&lt;age::plugin::Recipient&gt;()</code></a>)</li>\n<li><a href=\"https://docs.rs/age/0.11.0/age/plugin/struct.RecipientPluginV1.html#method.new\"><code>age::plugin::RecipientPluginV1::new</code></a></li>\n</ul>\n<p>On UNIX systems, a directory matching <code>age-plugin-*</code> needs to exist in the working directory for the attack to succeed.</p>\n<p>The binary is executed with a single flag, either <code>--age-plugin=recipient-v1</code> or <code>--age-plugin=identity-v1</code>. The standard input includes the recipient or identity string,  and the random file key (if encrypting) or the header of the file (if decrypting). The format is constrained by the <a href=\"https://c2sp.org/age-plugin\">age-plugin</a> protocol.</p>\n<p>An equivalent issue was fixed in <a href=\"https://github.com/FiloSottile/age\">the reference Go implementation of age</a>, see advisory <a href=\"https://github.com/FiloSottile/age/security/advisories/GHSA-32gq-x56h-299c\">GHSA-32gq-x56h-299c</a>.</p>\n<p>Thanks to ⬡-49016 for reporting this issue.</p>\n<h3 id=\"references\">References</h3>\n<ul>\n<li><a href=\"https://github.com/str4d/rage/security/advisories/GHSA-4fg7-vxc8-qx5w\">https://github.com/str4d/rage/security/advisories/GHSA-4fg7-vxc8-qx5w</a></li>\n<li><a href=\"https://github.com/str4d/rage/commit/703152ecfa86f27952a35b57dd525ed39396a227\">https://github.com/str4d/rage/commit/703152ecfa86f27952a35b57dd525ed39396a227</a></li>\n<li><a href=\"https://rustsec.org/advisories/RUSTSEC-2024-0432.html\">https://rustsec.org/advisories/RUSTSEC-2024-0432.html</a></li>\n<li><a href=\"https://rustsec.org/advisories/RUSTSEC-2024-0433.html\">https://rustsec.org/advisories/RUSTSEC-2024-0433.html</a></li>\n<li><a href=\"https://github.com/advisories/GHSA-4fg7-vxc8-qx5w\">https://github.com/advisories/GHSA-4fg7-vxc8-qx5w</a></li>\n</ul>\n",
            "url": "https://github.com/advisories/GHSA-4fg7-vxc8-qx5w",
            "title": "[rage] rage vulnerable to malicious plugin names, recipients, or identities causing arbitrary binary execution",
            "date_modified": "2025-01-03T19:29:42.000Z",
            "date_published": "2024-12-18T18:21:55.000Z",
            "author": {
                "name": "GitHub",
                "url": "https://github.com/advisories/GHSA-4fg7-vxc8-qx5w"
            },
            "tags": [
                "severity"
            ]
        }
    ]
}