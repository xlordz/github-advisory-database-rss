{
    "version": "https://jsonfeed.org/version/1",
    "title": "Security Advisory for Rust crates",
    "home_page_url": "https://github.com/advisories?query=type%3Areviewed+ecosystem%3Arust",
    "feed_url": "https://azu.github.io/github-advisory-database-rss/rust.json",
    "description": "Security Advisory for Rust crates on GitHub",
    "items": [
        {
            "content_html": "<h1 id=\"impact\">Impact</h1>\n<h2 id=\"summary\">Summary</h2>\n<p>A vulnerability in Apollo Router's usage of Apollo Compiler allowed queries with deeply nested and reused named fragments to be prohibitively expensive to validate. This could lead to excessive resource consumption and denial of service.</p>\n<h2 id=\"details\">Details</h2>\n<p>Named fragments were being processed once per fragment spread in some cases during query validation, leading to exponential resource usage when deeply nested and reused fragments were involved.</p>\n<h2 id=\"fixmitigation\">Fix/Mitigation</h2>\n<p>Apollo Router's usage of Apollo Compiler has been updated so that validation logic processes each named fragment only once, preventing redundant traversal.</p>\n<h1 id=\"patches\">Patches</h1>\n<p>This has been remediated in <code>apollo-router</code> versions 1.61.2 and 2.1.1.</p>\n<h1 id=\"workarounds\">Workarounds</h1>\n<p>The only known workaround is \"Safelisting with IDs only\" per <a href=\"https://www.apollographql.com/docs/graphos/routing/security/persisted-queries#router-security-levels\">Safelisting with Persisted Queries - Apollo GraphQL Docs</a>. The \"Safelisting\" security level is not sufficient, since that level allows freeform GraphQL queries to be sent to Apollo Router.</p>\n<h1 id=\"references\">References</h1>\n<p><a href=\"https://www.apollographql.com/docs/graphos/reference/federation/query-plans\">Query Planning Documentation</a></p>\n<h2 id=\"acknowledgements\">Acknowledgements</h2>\n<p>We appreciate the efforts of the security community in identifying and improving the performance and security of query validation mechanisms.</p>\n<h3 id=\"references-1\">References</h3>\n<ul>\n<li><a href=\"https://github.com/apollographql/router/security/advisories/GHSA-3j43-9v8v-cp3f\">https://github.com/apollographql/router/security/advisories/GHSA-3j43-9v8v-cp3f</a></li>\n<li><a href=\"https://github.com/apollographql/router/commit/ab6675a63174715ea6ff50881fc957831d4e9564\">https://github.com/apollographql/router/commit/ab6675a63174715ea6ff50881fc957831d4e9564</a></li>\n<li><a href=\"https://github.com/apollographql/router/commit/bba032e183b861348a466d3123c7137a1ae18952\">https://github.com/apollographql/router/commit/bba032e183b861348a466d3123c7137a1ae18952</a></li>\n<li><a href=\"https://github.com/advisories/GHSA-3j43-9v8v-cp3f\">https://github.com/advisories/GHSA-3j43-9v8v-cp3f</a></li>\n</ul>\n",
            "url": "https://github.com/advisories/GHSA-3j43-9v8v-cp3f",
            "title": "[apollo-router] Apollo Router Query Validation Vulnerable to Excessive Resource Consumption via Named Fragment Processing",
            "date_modified": "2025-04-07T19:00:32.000Z",
            "date_published": "2025-04-07T19:00:30.000Z",
            "author": {
                "name": "GitHub",
                "url": "https://github.com/advisories/GHSA-3j43-9v8v-cp3f"
            },
            "tags": [
                "severity"
            ]
        },
        {
            "content_html": "<h1 id=\"impact\">Impact</h1>\n<h2 id=\"summary\">Summary</h2>\n<p>A vulnerability in Apollo Router's usage of Apollo Compiler allowed queries with deeply nested and reused named fragments to be prohibitively expensive to validate. This could lead to excessive resource consumption and denial of service.</p>\n<h2 id=\"details\">Details</h2>\n<p>Named fragments were being processed once per fragment spread in some cases during query validation, leading to exponential resource usage when deeply nested and reused fragments were involved.</p>\n<h2 id=\"fixmitigation\">Fix/Mitigation</h2>\n<p>Apollo Router's usage of Apollo Compiler has been updated so that validation logic processes each named fragment only once, preventing redundant traversal.</p>\n<h1 id=\"patches\">Patches</h1>\n<p>This has been remediated in <code>apollo-router</code> versions 1.61.2 and 2.1.1.</p>\n<h1 id=\"workarounds\">Workarounds</h1>\n<p>The only known workaround is \"Safelisting with IDs only\" per <a href=\"https://www.apollographql.com/docs/graphos/routing/security/persisted-queries#router-security-levels\">Safelisting with Persisted Queries - Apollo GraphQL Docs</a>. The \"Safelisting\" security level is not sufficient, since that level allows freeform GraphQL queries to be sent to Apollo Router.</p>\n<h1 id=\"references\">References</h1>\n<p><a href=\"https://www.apollographql.com/docs/graphos/reference/federation/query-plans\">Query Planning Documentation</a></p>\n<h2 id=\"acknowledgements\">Acknowledgements</h2>\n<p>We appreciate the efforts of the security community in identifying and improving the performance and security of query validation mechanisms.</p>\n<h3 id=\"references-1\">References</h3>\n<ul>\n<li><a href=\"https://github.com/apollographql/router/security/advisories/GHSA-3j43-9v8v-cp3f\">https://github.com/apollographql/router/security/advisories/GHSA-3j43-9v8v-cp3f</a></li>\n<li><a href=\"https://github.com/apollographql/router/commit/ab6675a63174715ea6ff50881fc957831d4e9564\">https://github.com/apollographql/router/commit/ab6675a63174715ea6ff50881fc957831d4e9564</a></li>\n<li><a href=\"https://github.com/apollographql/router/commit/bba032e183b861348a466d3123c7137a1ae18952\">https://github.com/apollographql/router/commit/bba032e183b861348a466d3123c7137a1ae18952</a></li>\n<li><a href=\"https://github.com/advisories/GHSA-3j43-9v8v-cp3f\">https://github.com/advisories/GHSA-3j43-9v8v-cp3f</a></li>\n</ul>\n",
            "url": "https://github.com/advisories/GHSA-3j43-9v8v-cp3f",
            "title": "[apollo-router] Apollo Router Query Validation Vulnerable to Excessive Resource Consumption via Named Fragment Processing",
            "date_modified": "2025-04-07T19:00:32.000Z",
            "date_published": "2025-04-07T19:00:30.000Z",
            "author": {
                "name": "GitHub",
                "url": "https://github.com/advisories/GHSA-3j43-9v8v-cp3f"
            },
            "tags": [
                "severity"
            ]
        },
        {
            "content_html": "<h1 id=\"impact\">Impact</h1>\n<h2 id=\"summary\">Summary</h2>\n<p>A vulnerability in Apollo Router allowed certain queries to bypass configured operation limits, specifically due to integer overflow.</p>\n<h2 id=\"details\">Details</h2>\n<p>The operation limits plugin uses unsigned 32-bit integers to track limit counters (e.g. for a query's height). If a counter exceeded the maximum value for this data type (4,294,967,295), it wrapped around to 0, unintentionally allowing queries to bypass configured thresholds. This could occur for large queries if the payload limit were sufficiently increased, but could also occur for small queries with deeply nested and reused named fragments.</p>\n<h2 id=\"fixmitigation\">Fix/Mitigation</h2>\n<p>Logic was updated to ensure counter overflow is handled correctly and does not wrap around to 0.</p>\n<h1 id=\"patches\">Patches</h1>\n<p>This has been remediated in <code>apollo-router</code> versions 1.61.2 and 2.1.1.</p>\n<h1 id=\"workarounds\">Workarounds</h1>\n<p>The only known workaround is \"Safelisting\" or \"Safelisting with IDs only\" per <a href=\"https://www.apollographql.com/docs/graphos/routing/security/persisted-queries#router-security-levels\">Safelisting with Persisted Queries - Apollo GraphQL Docs</a>.</p>\n<h2 id=\"acknowledgements\">Acknowledgements</h2>\n<p>We appreciate the efforts of the security community in identifying and improving the performance and security of operation limiting mechanisms.</p>\n<h3 id=\"references\">References</h3>\n<ul>\n<li><a href=\"https://github.com/apollographql/router/security/advisories/GHSA-84m6-5m72-45fp\">https://github.com/apollographql/router/security/advisories/GHSA-84m6-5m72-45fp</a></li>\n<li><a href=\"https://github.com/apollographql/router/commit/ab6675a63174715ea6ff50881fc957831d4e9564\">https://github.com/apollographql/router/commit/ab6675a63174715ea6ff50881fc957831d4e9564</a></li>\n<li><a href=\"https://github.com/apollographql/router/commit/bba032e183b861348a466d3123c7137a1ae18952\">https://github.com/apollographql/router/commit/bba032e183b861348a466d3123c7137a1ae18952</a></li>\n<li><a href=\"https://github.com/advisories/GHSA-84m6-5m72-45fp\">https://github.com/advisories/GHSA-84m6-5m72-45fp</a></li>\n</ul>\n",
            "url": "https://github.com/advisories/GHSA-84m6-5m72-45fp",
            "title": "[apollo-router] Apollo Router Operation Limits Vulnerable to Bypass via Integer Overflow",
            "date_modified": "2025-04-07T18:59:22.000Z",
            "date_published": "2025-04-07T18:59:21.000Z",
            "author": {
                "name": "GitHub",
                "url": "https://github.com/advisories/GHSA-84m6-5m72-45fp"
            },
            "tags": [
                "severity"
            ]
        },
        {
            "content_html": "<h1 id=\"impact\">Impact</h1>\n<h2 id=\"summary\">Summary</h2>\n<p>A vulnerability in Apollo Router allowed certain queries to bypass configured operation limits, specifically due to integer overflow.</p>\n<h2 id=\"details\">Details</h2>\n<p>The operation limits plugin uses unsigned 32-bit integers to track limit counters (e.g. for a query's height). If a counter exceeded the maximum value for this data type (4,294,967,295), it wrapped around to 0, unintentionally allowing queries to bypass configured thresholds. This could occur for large queries if the payload limit were sufficiently increased, but could also occur for small queries with deeply nested and reused named fragments.</p>\n<h2 id=\"fixmitigation\">Fix/Mitigation</h2>\n<p>Logic was updated to ensure counter overflow is handled correctly and does not wrap around to 0.</p>\n<h1 id=\"patches\">Patches</h1>\n<p>This has been remediated in <code>apollo-router</code> versions 1.61.2 and 2.1.1.</p>\n<h1 id=\"workarounds\">Workarounds</h1>\n<p>The only known workaround is \"Safelisting\" or \"Safelisting with IDs only\" per <a href=\"https://www.apollographql.com/docs/graphos/routing/security/persisted-queries#router-security-levels\">Safelisting with Persisted Queries - Apollo GraphQL Docs</a>.</p>\n<h2 id=\"acknowledgements\">Acknowledgements</h2>\n<p>We appreciate the efforts of the security community in identifying and improving the performance and security of operation limiting mechanisms.</p>\n<h3 id=\"references\">References</h3>\n<ul>\n<li><a href=\"https://github.com/apollographql/router/security/advisories/GHSA-84m6-5m72-45fp\">https://github.com/apollographql/router/security/advisories/GHSA-84m6-5m72-45fp</a></li>\n<li><a href=\"https://github.com/apollographql/router/commit/ab6675a63174715ea6ff50881fc957831d4e9564\">https://github.com/apollographql/router/commit/ab6675a63174715ea6ff50881fc957831d4e9564</a></li>\n<li><a href=\"https://github.com/apollographql/router/commit/bba032e183b861348a466d3123c7137a1ae18952\">https://github.com/apollographql/router/commit/bba032e183b861348a466d3123c7137a1ae18952</a></li>\n<li><a href=\"https://github.com/advisories/GHSA-84m6-5m72-45fp\">https://github.com/advisories/GHSA-84m6-5m72-45fp</a></li>\n</ul>\n",
            "url": "https://github.com/advisories/GHSA-84m6-5m72-45fp",
            "title": "[apollo-router] Apollo Router Operation Limits Vulnerable to Bypass via Integer Overflow",
            "date_modified": "2025-04-07T18:59:22.000Z",
            "date_published": "2025-04-07T18:59:21.000Z",
            "author": {
                "name": "GitHub",
                "url": "https://github.com/advisories/GHSA-84m6-5m72-45fp"
            },
            "tags": [
                "severity"
            ]
        },
        {
            "content_html": "<h1 id=\"impact\">Impact</h1>\n<h2 id=\"summary\">Summary</h2>\n<p>A vulnerability in Apollo Router allowed queries with deeply nested and reused named fragments to be prohibitively expensive to query plan, specifically during named fragment expansion. This could lead to excessive resource consumption and denial of service.</p>\n<h2 id=\"details\">Details</h2>\n<p>Named fragments were being expanded once per fragment spread during query planning, leading to exponential resource usage when deeply nested and reused fragments were involved.</p>\n<h2 id=\"fixmitigation\">Fix/Mitigation</h2>\n<p>A new <strong>Query Fragment Expansion Limit</strong> metric has been introduced:</p>\n<ul>\n<li>This metric computes the number of selections a query would have if its fragment spreads were fully expanded.</li>\n<li>The metric is checked against a limit to prevent excessive computation.</li>\n</ul>\n<h1 id=\"patches\">Patches</h1>\n<p>This has been remediated in <code>apollo-router</code> versions 1.61.2 and 2.1.1.</p>\n<h1 id=\"workarounds\">Workarounds</h1>\n<p>The only known workaround is \"Safelisting\" or \"Safelisting with IDs only\" per <a href=\"https://www.apollographql.com/docs/graphos/routing/security/persisted-queries#router-security-levels\">Safelisting with Persisted Queries - Apollo GraphQL Docs</a>.</p>\n<h1 id=\"references\">References</h1>\n<p><a href=\"https://www.apollographql.com/docs/graphos/reference/federation/query-plans\">Query Planning Documentation</a></p>\n<h2 id=\"acknowledgements\">Acknowledgements</h2>\n<p>We appreciate the efforts of the security community in identifying and improving the performance and security of query planning mechanisms.</p>\n<h3 id=\"references-1\">References</h3>\n<ul>\n<li><a href=\"https://github.com/apollographql/router/security/advisories/GHSA-75m2-jhh5-j5g2\">https://github.com/apollographql/router/security/advisories/GHSA-75m2-jhh5-j5g2</a></li>\n<li><a href=\"https://github.com/apollographql/router/commit/ab6675a63174715ea6ff50881fc957831d4e9564\">https://github.com/apollographql/router/commit/ab6675a63174715ea6ff50881fc957831d4e9564</a></li>\n<li><a href=\"https://github.com/apollographql/router/commit/bba032e183b861348a466d3123c7137a1ae18952\">https://github.com/apollographql/router/commit/bba032e183b861348a466d3123c7137a1ae18952</a></li>\n<li><a href=\"https://github.com/advisories/GHSA-75m2-jhh5-j5g2\">https://github.com/advisories/GHSA-75m2-jhh5-j5g2</a></li>\n</ul>\n",
            "url": "https://github.com/advisories/GHSA-75m2-jhh5-j5g2",
            "title": "[apollo-router] Apollo Router Query Planner Vulnerable to Excessive Resource Consumption via Named Fragment Expansion",
            "date_modified": "2025-04-07T18:58:02.000Z",
            "date_published": "2025-04-07T18:57:56.000Z",
            "author": {
                "name": "GitHub",
                "url": "https://github.com/advisories/GHSA-75m2-jhh5-j5g2"
            },
            "tags": [
                "severity"
            ]
        },
        {
            "content_html": "<h1 id=\"impact\">Impact</h1>\n<h2 id=\"summary\">Summary</h2>\n<p>A vulnerability in Apollo Router allowed queries with deeply nested and reused named fragments to be prohibitively expensive to query plan, specifically during named fragment expansion. This could lead to excessive resource consumption and denial of service.</p>\n<h2 id=\"details\">Details</h2>\n<p>Named fragments were being expanded once per fragment spread during query planning, leading to exponential resource usage when deeply nested and reused fragments were involved.</p>\n<h2 id=\"fixmitigation\">Fix/Mitigation</h2>\n<p>A new <strong>Query Fragment Expansion Limit</strong> metric has been introduced:</p>\n<ul>\n<li>This metric computes the number of selections a query would have if its fragment spreads were fully expanded.</li>\n<li>The metric is checked against a limit to prevent excessive computation.</li>\n</ul>\n<h1 id=\"patches\">Patches</h1>\n<p>This has been remediated in <code>apollo-router</code> versions 1.61.2 and 2.1.1.</p>\n<h1 id=\"workarounds\">Workarounds</h1>\n<p>The only known workaround is \"Safelisting\" or \"Safelisting with IDs only\" per <a href=\"https://www.apollographql.com/docs/graphos/routing/security/persisted-queries#router-security-levels\">Safelisting with Persisted Queries - Apollo GraphQL Docs</a>.</p>\n<h1 id=\"references\">References</h1>\n<p><a href=\"https://www.apollographql.com/docs/graphos/reference/federation/query-plans\">Query Planning Documentation</a></p>\n<h2 id=\"acknowledgements\">Acknowledgements</h2>\n<p>We appreciate the efforts of the security community in identifying and improving the performance and security of query planning mechanisms.</p>\n<h3 id=\"references-1\">References</h3>\n<ul>\n<li><a href=\"https://github.com/apollographql/router/security/advisories/GHSA-75m2-jhh5-j5g2\">https://github.com/apollographql/router/security/advisories/GHSA-75m2-jhh5-j5g2</a></li>\n<li><a href=\"https://github.com/apollographql/router/commit/ab6675a63174715ea6ff50881fc957831d4e9564\">https://github.com/apollographql/router/commit/ab6675a63174715ea6ff50881fc957831d4e9564</a></li>\n<li><a href=\"https://github.com/apollographql/router/commit/bba032e183b861348a466d3123c7137a1ae18952\">https://github.com/apollographql/router/commit/bba032e183b861348a466d3123c7137a1ae18952</a></li>\n<li><a href=\"https://github.com/advisories/GHSA-75m2-jhh5-j5g2\">https://github.com/advisories/GHSA-75m2-jhh5-j5g2</a></li>\n</ul>\n",
            "url": "https://github.com/advisories/GHSA-75m2-jhh5-j5g2",
            "title": "[apollo-router] Apollo Router Query Planner Vulnerable to Excessive Resource Consumption via Named Fragment Expansion",
            "date_modified": "2025-04-07T18:58:02.000Z",
            "date_published": "2025-04-07T18:57:56.000Z",
            "author": {
                "name": "GitHub",
                "url": "https://github.com/advisories/GHSA-75m2-jhh5-j5g2"
            },
            "tags": [
                "severity"
            ]
        },
        {
            "content_html": "<h1 id=\"impact\">Impact</h1>\n<h2 id=\"summary\">Summary</h2>\n<p>A vulnerability in Apollo Router allowed queries with deeply nested and reused named fragments to be prohibitively expensive to query plan, specifically due to internal optimizations being frequently bypassed. This could lead to excessive resource consumption and denial of service.</p>\n<h2 id=\"details\">Details</h2>\n<p>The query planner includes an optimization that significantly speeds up planning for applicable GraphQL selections. However, queries with deeply nested and reused named fragments can generate many selections where this optimization does not apply, leading to significantly longer planning times. Because the query planner does not enforce a timeout, a small number of such queries can exhaust router's thread pool, rendering it inoperable.</p>\n<h2 id=\"fixmitigation\">Fix/Mitigation</h2>\n<ul>\n<li>A new <strong>Query Optimization Limit</strong> metric has been added:<ul>\n<li>This metric approximates the number of selections that cannot be skipped by the existing optimization.</li>\n<li>The metric is checked against a limit to prevent excessive computation.</li>\n</ul>\n</li>\n</ul>\n<p>Given the complexity of query planning optimizations, we will continue refining these solutions based on real-world performance and accuracy tests.</p>\n<h1 id=\"patches\">Patches</h1>\n<p>This has been remediated in <code>apollo-router</code> versions 1.61.2 and 2.1.1.</p>\n<h1 id=\"workarounds\">Workarounds</h1>\n<p>The only known workaround is \"Safelisting\" or \"Safelisting with IDs only\" per <a href=\"https://www.apollographql.com/docs/graphos/routing/security/persisted-queries#router-security-levels\">Safelisting with Persisted Queries - Apollo GraphQL Docs</a>.</p>\n<h1 id=\"references\">References</h1>\n<p><a href=\"https://www.apollographql.com/docs/graphos/reference/federation/query-plans\">Query Planning Documentation</a></p>\n<h2 id=\"acknowledgements\">Acknowledgements</h2>\n<p>We appreciate the efforts of the security community in identifying and improving the performance and security of query planning mechanisms.</p>\n<h3 id=\"references-1\">References</h3>\n<ul>\n<li><a href=\"https://github.com/apollographql/router/security/advisories/GHSA-94hh-jmq8-2fgp\">https://github.com/apollographql/router/security/advisories/GHSA-94hh-jmq8-2fgp</a></li>\n<li><a href=\"https://github.com/apollographql/router/commit/ab6675a63174715ea6ff50881fc957831d4e9564\">https://github.com/apollographql/router/commit/ab6675a63174715ea6ff50881fc957831d4e9564</a></li>\n<li><a href=\"https://github.com/apollographql/router/commit/bba032e183b861348a466d3123c7137a1ae18952\">https://github.com/apollographql/router/commit/bba032e183b861348a466d3123c7137a1ae18952</a></li>\n<li><a href=\"https://github.com/advisories/GHSA-94hh-jmq8-2fgp\">https://github.com/advisories/GHSA-94hh-jmq8-2fgp</a></li>\n</ul>\n",
            "url": "https://github.com/advisories/GHSA-94hh-jmq8-2fgp",
            "title": "[apollo-router] Apollo Router Query Planner Vulnerable to Excessive Resource Consumption via Optimization Bypass",
            "date_modified": "2025-04-07T18:56:32.000Z",
            "date_published": "2025-04-07T18:56:30.000Z",
            "author": {
                "name": "GitHub",
                "url": "https://github.com/advisories/GHSA-94hh-jmq8-2fgp"
            },
            "tags": [
                "severity"
            ]
        },
        {
            "content_html": "<h1 id=\"impact\">Impact</h1>\n<h2 id=\"summary\">Summary</h2>\n<p>A vulnerability in Apollo Router allowed queries with deeply nested and reused named fragments to be prohibitively expensive to query plan, specifically due to internal optimizations being frequently bypassed. This could lead to excessive resource consumption and denial of service.</p>\n<h2 id=\"details\">Details</h2>\n<p>The query planner includes an optimization that significantly speeds up planning for applicable GraphQL selections. However, queries with deeply nested and reused named fragments can generate many selections where this optimization does not apply, leading to significantly longer planning times. Because the query planner does not enforce a timeout, a small number of such queries can exhaust router's thread pool, rendering it inoperable.</p>\n<h2 id=\"fixmitigation\">Fix/Mitigation</h2>\n<ul>\n<li>A new <strong>Query Optimization Limit</strong> metric has been added:<ul>\n<li>This metric approximates the number of selections that cannot be skipped by the existing optimization.</li>\n<li>The metric is checked against a limit to prevent excessive computation.</li>\n</ul>\n</li>\n</ul>\n<p>Given the complexity of query planning optimizations, we will continue refining these solutions based on real-world performance and accuracy tests.</p>\n<h1 id=\"patches\">Patches</h1>\n<p>This has been remediated in <code>apollo-router</code> versions 1.61.2 and 2.1.1.</p>\n<h1 id=\"workarounds\">Workarounds</h1>\n<p>The only known workaround is \"Safelisting\" or \"Safelisting with IDs only\" per <a href=\"https://www.apollographql.com/docs/graphos/routing/security/persisted-queries#router-security-levels\">Safelisting with Persisted Queries - Apollo GraphQL Docs</a>.</p>\n<h1 id=\"references\">References</h1>\n<p><a href=\"https://www.apollographql.com/docs/graphos/reference/federation/query-plans\">Query Planning Documentation</a></p>\n<h2 id=\"acknowledgements\">Acknowledgements</h2>\n<p>We appreciate the efforts of the security community in identifying and improving the performance and security of query planning mechanisms.</p>\n<h3 id=\"references-1\">References</h3>\n<ul>\n<li><a href=\"https://github.com/apollographql/router/security/advisories/GHSA-94hh-jmq8-2fgp\">https://github.com/apollographql/router/security/advisories/GHSA-94hh-jmq8-2fgp</a></li>\n<li><a href=\"https://github.com/apollographql/router/commit/ab6675a63174715ea6ff50881fc957831d4e9564\">https://github.com/apollographql/router/commit/ab6675a63174715ea6ff50881fc957831d4e9564</a></li>\n<li><a href=\"https://github.com/apollographql/router/commit/bba032e183b861348a466d3123c7137a1ae18952\">https://github.com/apollographql/router/commit/bba032e183b861348a466d3123c7137a1ae18952</a></li>\n<li><a href=\"https://github.com/advisories/GHSA-94hh-jmq8-2fgp\">https://github.com/advisories/GHSA-94hh-jmq8-2fgp</a></li>\n</ul>\n",
            "url": "https://github.com/advisories/GHSA-94hh-jmq8-2fgp",
            "title": "[apollo-router] Apollo Router Query Planner Vulnerable to Excessive Resource Consumption via Optimization Bypass",
            "date_modified": "2025-04-07T18:56:32.000Z",
            "date_published": "2025-04-07T18:56:30.000Z",
            "author": {
                "name": "GitHub",
                "url": "https://github.com/advisories/GHSA-94hh-jmq8-2fgp"
            },
            "tags": [
                "severity"
            ]
        },
        {
            "content_html": "<h3 id=\"summary\">Summary</h3>\n<p>Jujutsu 0.28.0 and earlier rely on versions of gitoxide that use SHA-1 hash implementations without any collision detection, leaving them vulnerable to hash collision attacks.</p>\n<h3 id=\"details\">Details</h3>\n<p>This is a result of the underlying <a href=\"https://github.com/GitoxideLabs/gitoxide/security/advisories/GHSA-2frx-2596-x5r6\">CVE-2025-31130 / GHSA-2frx-2596-x5r6</a> vulnerability in the gitoxide library Jujutsu uses to interact with Git repositories; see that advisory for technical details. This separate advisory is being issued due to the downstream impact on users of Jujutsu.</p>\n<h3 id=\"impact\">Impact</h3>\n<p>An attacker with the ability to mount a collision attack on SHA-1 like the <a href=\"https://shattered.io/\">SHAttered</a> or <a href=\"https://sha-mbles.github.io/\">SHA-1 is a Shambles</a> attacks could create two distinct Git objects with the same hash. This is becoming increasingly affordable for well‐resourced attackers, with the Shambles researchers in 2020 estimating $45k for a chosen‐prefix collision or $11k for a classical collision, and projecting less than $10k for a chosen‐prefix collision by 2025. The result could be used to disguise malicious repository contents, or potentially exploit assumptions in Jujutsu’s logic to cause further vulnerabilities.</p>\n<h3 id=\"references\">References</h3>\n<ul>\n<li><a href=\"https://github.com/jj-vcs/jj/security/advisories/GHSA-794x-2rpg-rfgr\">https://github.com/jj-vcs/jj/security/advisories/GHSA-794x-2rpg-rfgr</a></li>\n<li><a href=\"https://github.com/jj-vcs/jj/commit/350da7d013773377aec0d3a4bf4374d3c941460e\">https://github.com/jj-vcs/jj/commit/350da7d013773377aec0d3a4bf4374d3c941460e</a></li>\n<li><a href=\"https://github.com/advisories/GHSA-794x-2rpg-rfgr\">https://github.com/advisories/GHSA-794x-2rpg-rfgr</a></li>\n</ul>\n",
            "url": "https://github.com/advisories/GHSA-794x-2rpg-rfgr",
            "title": "[jj-cli] Jujutsu does not have SHA-1 collision detection",
            "date_modified": "2025-04-07T16:40:26.000Z",
            "date_published": "2025-04-07T16:40:25.000Z",
            "author": {
                "name": "GitHub",
                "url": "https://github.com/advisories/GHSA-794x-2rpg-rfgr"
            },
            "tags": [
                "severity"
            ]
        },
        {
            "content_html": "<h3 id=\"summary\">Summary</h3>\n<p>Jujutsu 0.28.0 and earlier rely on versions of gitoxide that use SHA-1 hash implementations without any collision detection, leaving them vulnerable to hash collision attacks.</p>\n<h3 id=\"details\">Details</h3>\n<p>This is a result of the underlying <a href=\"https://github.com/GitoxideLabs/gitoxide/security/advisories/GHSA-2frx-2596-x5r6\">CVE-2025-31130 / GHSA-2frx-2596-x5r6</a> vulnerability in the gitoxide library Jujutsu uses to interact with Git repositories; see that advisory for technical details. This separate advisory is being issued due to the downstream impact on users of Jujutsu.</p>\n<h3 id=\"impact\">Impact</h3>\n<p>An attacker with the ability to mount a collision attack on SHA-1 like the <a href=\"https://shattered.io/\">SHAttered</a> or <a href=\"https://sha-mbles.github.io/\">SHA-1 is a Shambles</a> attacks could create two distinct Git objects with the same hash. This is becoming increasingly affordable for well‐resourced attackers, with the Shambles researchers in 2020 estimating $45k for a chosen‐prefix collision or $11k for a classical collision, and projecting less than $10k for a chosen‐prefix collision by 2025. The result could be used to disguise malicious repository contents, or potentially exploit assumptions in Jujutsu’s logic to cause further vulnerabilities.</p>\n<h3 id=\"references\">References</h3>\n<ul>\n<li><a href=\"https://github.com/jj-vcs/jj/security/advisories/GHSA-794x-2rpg-rfgr\">https://github.com/jj-vcs/jj/security/advisories/GHSA-794x-2rpg-rfgr</a></li>\n<li><a href=\"https://github.com/jj-vcs/jj/commit/350da7d013773377aec0d3a4bf4374d3c941460e\">https://github.com/jj-vcs/jj/commit/350da7d013773377aec0d3a4bf4374d3c941460e</a></li>\n<li><a href=\"https://github.com/advisories/GHSA-794x-2rpg-rfgr\">https://github.com/advisories/GHSA-794x-2rpg-rfgr</a></li>\n</ul>\n",
            "url": "https://github.com/advisories/GHSA-794x-2rpg-rfgr",
            "title": "[jj-lib] Jujutsu does not have SHA-1 collision detection",
            "date_modified": "2025-04-07T16:40:26.000Z",
            "date_published": "2025-04-07T16:40:25.000Z",
            "author": {
                "name": "GitHub",
                "url": "https://github.com/advisories/GHSA-794x-2rpg-rfgr"
            },
            "tags": [
                "severity"
            ]
        },
        {
            "content_html": "<p>When a <code>Some(...)</code> value was passed to the <code>properties</code> argument of either of these functions, a use-after-free would result.</p>\n<p>In practice this would nearly always result in OpenSSL treating the properties as an empty string (due to <code>CString::drop</code>'s behavior).</p>\n<p>The maintainers thank <a href=\"https://github.com/quitbug/\">quitbug</a> for reporting this vulnerability to us.</p>\n<h3 id=\"references\">References</h3>\n<ul>\n<li><a href=\"https://github.com/sfackler/rust-openssl/pull/2390\">https://github.com/sfackler/rust-openssl/pull/2390</a></li>\n<li><a href=\"https://github.com/sfackler/rust-openssl/commit/87085bd67896b7f92e6de35d081f607a334beae4\">https://github.com/sfackler/rust-openssl/commit/87085bd67896b7f92e6de35d081f607a334beae4</a></li>\n<li><a href=\"https://rustsec.org/advisories/RUSTSEC-2025-0022.html\">https://rustsec.org/advisories/RUSTSEC-2025-0022.html</a></li>\n<li><a href=\"https://github.com/advisories/GHSA-4fcv-w3qc-ppgg\">https://github.com/advisories/GHSA-4fcv-w3qc-ppgg</a></li>\n</ul>\n",
            "url": "https://github.com/advisories/GHSA-4fcv-w3qc-ppgg",
            "title": "[openssl] rust-openssl Use-After-Free in `Md::fetch` and `Cipher::fetch`",
            "date_modified": "2025-04-04T20:31:09.000Z",
            "date_published": "2025-04-04T20:31:08.000Z",
            "author": {
                "name": "GitHub",
                "url": "https://github.com/advisories/GHSA-4fcv-w3qc-ppgg"
            },
            "tags": [
                "severity"
            ]
        },
        {
            "content_html": "<h3 id=\"summary\">Summary</h3>\n<p>gitoxide uses SHA-1 hash implementations without any collision detection, leaving it vulnerable to hash collision attacks.</p>\n<h3 id=\"details\">Details</h3>\n<p>gitoxide uses the <code>sha1_smol</code> or <code>sha1</code> crate, both of which implement standard SHA-1 without any mitigations for collision attacks. This means that two distinct Git objects with colliding SHA-1 hashes would break the Git object model and integrity checks when used with gitoxide.</p>\n<p>The SHA-1 function is considered cryptographically insecure. However, in the wake of the SHAttered attacks, this issue was mitigated in Git 2.13.0 in 2017 by using the <a href=\"https://github.com/crmarcstevens/sha1collisiondetection\">sha1collisiondetection</a> algorithm by default and producing an error when known SHA-1 collisions are detected. Git is in the process of migrating to using SHA-256 for object hashes, but this has not been rolled out widely yet and gitoxide does not support SHA-256 object hashes.</p>\n<h3 id=\"poc\">PoC</h3>\n<p>The following program demonstrates the problem, using the two <a href=\"https://shattered.io/\">SHAttered PDFs</a>:</p>\n<pre><code class=\"language-rust\">use sha1_checked::{CollisionResult, Digest};\n\nfn sha1_oid_of_file(filename: &amp;str) -&gt; gix::ObjectId {\n    let mut hasher = gix::features::hash::hasher(gix::hash::Kind::Sha1);\n    hasher.update(&amp;std::fs::read(filename).unwrap());\n    gix::ObjectId::Sha1(hasher.digest())\n}\n\nfn sha1dc_oid_of_file(filename: &amp;str) -&gt; Result&lt;gix::ObjectId, String&gt; {\n    // Matches Git’s behaviour.\n    let mut hasher = sha1_checked::Builder::default().safe_hash(false).build();\n    hasher.update(&amp;std::fs::read(filename).unwrap());\n    match hasher.try_finalize() {\n        CollisionResult::Ok(digest) =&gt; Ok(gix::ObjectId::Sha1(digest.into())),\n        CollisionResult::Mitigated(_) =&gt; unreachable!(),\n        CollisionResult::Collision(digest) =&gt; Err(format!(\n            \"Collision attack: {}\",\n            gix::ObjectId::Sha1(digest.into()).to_hex()\n        )),\n    }\n}\n\nfn main() {\n    dbg!(sha1_oid_of_file(\"shattered-1.pdf\"));\n    dbg!(sha1_oid_of_file(\"shattered-2.pdf\"));\n    dbg!(sha1dc_oid_of_file(\"shattered-1.pdf\"));\n    dbg!(sha1dc_oid_of_file(\"shattered-2.pdf\"));\n}\n</code></pre>\n<p>The output is as follows:</p>\n<pre><code>[src/main.rs:24:5] sha1_oid_of_file(\"shattered-1.pdf\") = Sha1(38762cf7f55934b34d179ae6a4c80cadccbb7f0a)\n[src/main.rs:25:5] sha1_oid_of_file(\"shattered-2.pdf\") = Sha1(38762cf7f55934b34d179ae6a4c80cadccbb7f0a)\n[src/main.rs:26:5] sha1dc_oid_of_file(\"shattered-1.pdf\") = Err(\n    \"Collision attack: 38762cf7f55934b34d179ae6a4c80cadccbb7f0a\",\n)\n[src/main.rs:27:5] sha1dc_oid_of_file(\"shattered-2.pdf\") = Err(\n    \"Collision attack: 38762cf7f55934b34d179ae6a4c80cadccbb7f0a\",\n)\n</code></pre>\n<p>The latter behaviour matches Git.</p>\n<p>Since the SHAttered PDFs are not in a valid format for Git objects, a direct proof‐of‐concept using higher‐level APIs cannot be immediately demonstrated without significant computational resources.</p>\n<h3 id=\"impact\">Impact</h3>\n<p>An attacker with the ability to mount a collision attack on SHA-1 like the <a href=\"https://shattered.io/\">SHAttered</a> or <a href=\"https://sha-mbles.github.io/\">SHA-1 is a Shambles</a> attacks could create two distinct Git objects with the same hash. This is becoming increasingly affordable for well‐resourced attackers, with the Shambles researchers in 2020 estimating $45k for a chosen‐prefix collision or $11k for a classical collision, and projecting less than $10k for a chosen‐prefix collision by 2025. The result could be used to disguise malicious repository contents, or potentially exploit assumptions in the logic of programs using gitoxide to cause further vulnerabilities.</p>\n<p>This vulnerability affects any user of gitoxide, including <code>gix-*</code> library crates, that reads or writes Git objects.</p>\n<h3 id=\"references\">References</h3>\n<ul>\n<li><a href=\"https://github.com/GitoxideLabs/gitoxide/security/advisories/GHSA-2frx-2596-x5r6\">https://github.com/GitoxideLabs/gitoxide/security/advisories/GHSA-2frx-2596-x5r6</a></li>\n<li><a href=\"https://nvd.nist.gov/vuln/detail/CVE-2025-31130\">https://nvd.nist.gov/vuln/detail/CVE-2025-31130</a></li>\n<li><a href=\"https://github.com/GitoxideLabs/gitoxide/commit/4660f7a6f71873311f68f170b0f1f6659a02829d\">https://github.com/GitoxideLabs/gitoxide/commit/4660f7a6f71873311f68f170b0f1f6659a02829d</a></li>\n<li><a href=\"https://rustsec.org/advisories/RUSTSEC-2025-0021.html\">https://rustsec.org/advisories/RUSTSEC-2025-0021.html</a></li>\n<li><a href=\"https://github.com/advisories/GHSA-2frx-2596-x5r6\">https://github.com/advisories/GHSA-2frx-2596-x5r6</a></li>\n</ul>\n",
            "url": "https://github.com/advisories/GHSA-2frx-2596-x5r6",
            "title": "[gix-worktree-state] gitoxide does not detect SHA-1 collision attacks",
            "date_modified": "2025-04-04T16:06:11.000Z",
            "date_published": "2025-04-04T16:06:08.000Z",
            "author": {
                "name": "GitHub",
                "url": "https://github.com/advisories/GHSA-2frx-2596-x5r6"
            },
            "tags": [
                "severity"
            ]
        },
        {
            "content_html": "<h3 id=\"summary\">Summary</h3>\n<p>gitoxide uses SHA-1 hash implementations without any collision detection, leaving it vulnerable to hash collision attacks.</p>\n<h3 id=\"details\">Details</h3>\n<p>gitoxide uses the <code>sha1_smol</code> or <code>sha1</code> crate, both of which implement standard SHA-1 without any mitigations for collision attacks. This means that two distinct Git objects with colliding SHA-1 hashes would break the Git object model and integrity checks when used with gitoxide.</p>\n<p>The SHA-1 function is considered cryptographically insecure. However, in the wake of the SHAttered attacks, this issue was mitigated in Git 2.13.0 in 2017 by using the <a href=\"https://github.com/crmarcstevens/sha1collisiondetection\">sha1collisiondetection</a> algorithm by default and producing an error when known SHA-1 collisions are detected. Git is in the process of migrating to using SHA-256 for object hashes, but this has not been rolled out widely yet and gitoxide does not support SHA-256 object hashes.</p>\n<h3 id=\"poc\">PoC</h3>\n<p>The following program demonstrates the problem, using the two <a href=\"https://shattered.io/\">SHAttered PDFs</a>:</p>\n<pre><code class=\"language-rust\">use sha1_checked::{CollisionResult, Digest};\n\nfn sha1_oid_of_file(filename: &amp;str) -&gt; gix::ObjectId {\n    let mut hasher = gix::features::hash::hasher(gix::hash::Kind::Sha1);\n    hasher.update(&amp;std::fs::read(filename).unwrap());\n    gix::ObjectId::Sha1(hasher.digest())\n}\n\nfn sha1dc_oid_of_file(filename: &amp;str) -&gt; Result&lt;gix::ObjectId, String&gt; {\n    // Matches Git’s behaviour.\n    let mut hasher = sha1_checked::Builder::default().safe_hash(false).build();\n    hasher.update(&amp;std::fs::read(filename).unwrap());\n    match hasher.try_finalize() {\n        CollisionResult::Ok(digest) =&gt; Ok(gix::ObjectId::Sha1(digest.into())),\n        CollisionResult::Mitigated(_) =&gt; unreachable!(),\n        CollisionResult::Collision(digest) =&gt; Err(format!(\n            \"Collision attack: {}\",\n            gix::ObjectId::Sha1(digest.into()).to_hex()\n        )),\n    }\n}\n\nfn main() {\n    dbg!(sha1_oid_of_file(\"shattered-1.pdf\"));\n    dbg!(sha1_oid_of_file(\"shattered-2.pdf\"));\n    dbg!(sha1dc_oid_of_file(\"shattered-1.pdf\"));\n    dbg!(sha1dc_oid_of_file(\"shattered-2.pdf\"));\n}\n</code></pre>\n<p>The output is as follows:</p>\n<pre><code>[src/main.rs:24:5] sha1_oid_of_file(\"shattered-1.pdf\") = Sha1(38762cf7f55934b34d179ae6a4c80cadccbb7f0a)\n[src/main.rs:25:5] sha1_oid_of_file(\"shattered-2.pdf\") = Sha1(38762cf7f55934b34d179ae6a4c80cadccbb7f0a)\n[src/main.rs:26:5] sha1dc_oid_of_file(\"shattered-1.pdf\") = Err(\n    \"Collision attack: 38762cf7f55934b34d179ae6a4c80cadccbb7f0a\",\n)\n[src/main.rs:27:5] sha1dc_oid_of_file(\"shattered-2.pdf\") = Err(\n    \"Collision attack: 38762cf7f55934b34d179ae6a4c80cadccbb7f0a\",\n)\n</code></pre>\n<p>The latter behaviour matches Git.</p>\n<p>Since the SHAttered PDFs are not in a valid format for Git objects, a direct proof‐of‐concept using higher‐level APIs cannot be immediately demonstrated without significant computational resources.</p>\n<h3 id=\"impact\">Impact</h3>\n<p>An attacker with the ability to mount a collision attack on SHA-1 like the <a href=\"https://shattered.io/\">SHAttered</a> or <a href=\"https://sha-mbles.github.io/\">SHA-1 is a Shambles</a> attacks could create two distinct Git objects with the same hash. This is becoming increasingly affordable for well‐resourced attackers, with the Shambles researchers in 2020 estimating $45k for a chosen‐prefix collision or $11k for a classical collision, and projecting less than $10k for a chosen‐prefix collision by 2025. The result could be used to disguise malicious repository contents, or potentially exploit assumptions in the logic of programs using gitoxide to cause further vulnerabilities.</p>\n<p>This vulnerability affects any user of gitoxide, including <code>gix-*</code> library crates, that reads or writes Git objects.</p>\n<h3 id=\"references\">References</h3>\n<ul>\n<li><a href=\"https://github.com/GitoxideLabs/gitoxide/security/advisories/GHSA-2frx-2596-x5r6\">https://github.com/GitoxideLabs/gitoxide/security/advisories/GHSA-2frx-2596-x5r6</a></li>\n<li><a href=\"https://nvd.nist.gov/vuln/detail/CVE-2025-31130\">https://nvd.nist.gov/vuln/detail/CVE-2025-31130</a></li>\n<li><a href=\"https://github.com/GitoxideLabs/gitoxide/commit/4660f7a6f71873311f68f170b0f1f6659a02829d\">https://github.com/GitoxideLabs/gitoxide/commit/4660f7a6f71873311f68f170b0f1f6659a02829d</a></li>\n<li><a href=\"https://rustsec.org/advisories/RUSTSEC-2025-0021.html\">https://rustsec.org/advisories/RUSTSEC-2025-0021.html</a></li>\n<li><a href=\"https://github.com/advisories/GHSA-2frx-2596-x5r6\">https://github.com/advisories/GHSA-2frx-2596-x5r6</a></li>\n</ul>\n",
            "url": "https://github.com/advisories/GHSA-2frx-2596-x5r6",
            "title": "[gix-worktree] gitoxide does not detect SHA-1 collision attacks",
            "date_modified": "2025-04-04T16:06:11.000Z",
            "date_published": "2025-04-04T16:06:08.000Z",
            "author": {
                "name": "GitHub",
                "url": "https://github.com/advisories/GHSA-2frx-2596-x5r6"
            },
            "tags": [
                "severity"
            ]
        },
        {
            "content_html": "<h3 id=\"summary\">Summary</h3>\n<p>gitoxide uses SHA-1 hash implementations without any collision detection, leaving it vulnerable to hash collision attacks.</p>\n<h3 id=\"details\">Details</h3>\n<p>gitoxide uses the <code>sha1_smol</code> or <code>sha1</code> crate, both of which implement standard SHA-1 without any mitigations for collision attacks. This means that two distinct Git objects with colliding SHA-1 hashes would break the Git object model and integrity checks when used with gitoxide.</p>\n<p>The SHA-1 function is considered cryptographically insecure. However, in the wake of the SHAttered attacks, this issue was mitigated in Git 2.13.0 in 2017 by using the <a href=\"https://github.com/crmarcstevens/sha1collisiondetection\">sha1collisiondetection</a> algorithm by default and producing an error when known SHA-1 collisions are detected. Git is in the process of migrating to using SHA-256 for object hashes, but this has not been rolled out widely yet and gitoxide does not support SHA-256 object hashes.</p>\n<h3 id=\"poc\">PoC</h3>\n<p>The following program demonstrates the problem, using the two <a href=\"https://shattered.io/\">SHAttered PDFs</a>:</p>\n<pre><code class=\"language-rust\">use sha1_checked::{CollisionResult, Digest};\n\nfn sha1_oid_of_file(filename: &amp;str) -&gt; gix::ObjectId {\n    let mut hasher = gix::features::hash::hasher(gix::hash::Kind::Sha1);\n    hasher.update(&amp;std::fs::read(filename).unwrap());\n    gix::ObjectId::Sha1(hasher.digest())\n}\n\nfn sha1dc_oid_of_file(filename: &amp;str) -&gt; Result&lt;gix::ObjectId, String&gt; {\n    // Matches Git’s behaviour.\n    let mut hasher = sha1_checked::Builder::default().safe_hash(false).build();\n    hasher.update(&amp;std::fs::read(filename).unwrap());\n    match hasher.try_finalize() {\n        CollisionResult::Ok(digest) =&gt; Ok(gix::ObjectId::Sha1(digest.into())),\n        CollisionResult::Mitigated(_) =&gt; unreachable!(),\n        CollisionResult::Collision(digest) =&gt; Err(format!(\n            \"Collision attack: {}\",\n            gix::ObjectId::Sha1(digest.into()).to_hex()\n        )),\n    }\n}\n\nfn main() {\n    dbg!(sha1_oid_of_file(\"shattered-1.pdf\"));\n    dbg!(sha1_oid_of_file(\"shattered-2.pdf\"));\n    dbg!(sha1dc_oid_of_file(\"shattered-1.pdf\"));\n    dbg!(sha1dc_oid_of_file(\"shattered-2.pdf\"));\n}\n</code></pre>\n<p>The output is as follows:</p>\n<pre><code>[src/main.rs:24:5] sha1_oid_of_file(\"shattered-1.pdf\") = Sha1(38762cf7f55934b34d179ae6a4c80cadccbb7f0a)\n[src/main.rs:25:5] sha1_oid_of_file(\"shattered-2.pdf\") = Sha1(38762cf7f55934b34d179ae6a4c80cadccbb7f0a)\n[src/main.rs:26:5] sha1dc_oid_of_file(\"shattered-1.pdf\") = Err(\n    \"Collision attack: 38762cf7f55934b34d179ae6a4c80cadccbb7f0a\",\n)\n[src/main.rs:27:5] sha1dc_oid_of_file(\"shattered-2.pdf\") = Err(\n    \"Collision attack: 38762cf7f55934b34d179ae6a4c80cadccbb7f0a\",\n)\n</code></pre>\n<p>The latter behaviour matches Git.</p>\n<p>Since the SHAttered PDFs are not in a valid format for Git objects, a direct proof‐of‐concept using higher‐level APIs cannot be immediately demonstrated without significant computational resources.</p>\n<h3 id=\"impact\">Impact</h3>\n<p>An attacker with the ability to mount a collision attack on SHA-1 like the <a href=\"https://shattered.io/\">SHAttered</a> or <a href=\"https://sha-mbles.github.io/\">SHA-1 is a Shambles</a> attacks could create two distinct Git objects with the same hash. This is becoming increasingly affordable for well‐resourced attackers, with the Shambles researchers in 2020 estimating $45k for a chosen‐prefix collision or $11k for a classical collision, and projecting less than $10k for a chosen‐prefix collision by 2025. The result could be used to disguise malicious repository contents, or potentially exploit assumptions in the logic of programs using gitoxide to cause further vulnerabilities.</p>\n<p>This vulnerability affects any user of gitoxide, including <code>gix-*</code> library crates, that reads or writes Git objects.</p>\n<h3 id=\"references\">References</h3>\n<ul>\n<li><a href=\"https://github.com/GitoxideLabs/gitoxide/security/advisories/GHSA-2frx-2596-x5r6\">https://github.com/GitoxideLabs/gitoxide/security/advisories/GHSA-2frx-2596-x5r6</a></li>\n<li><a href=\"https://nvd.nist.gov/vuln/detail/CVE-2025-31130\">https://nvd.nist.gov/vuln/detail/CVE-2025-31130</a></li>\n<li><a href=\"https://github.com/GitoxideLabs/gitoxide/commit/4660f7a6f71873311f68f170b0f1f6659a02829d\">https://github.com/GitoxideLabs/gitoxide/commit/4660f7a6f71873311f68f170b0f1f6659a02829d</a></li>\n<li><a href=\"https://rustsec.org/advisories/RUSTSEC-2025-0021.html\">https://rustsec.org/advisories/RUSTSEC-2025-0021.html</a></li>\n<li><a href=\"https://github.com/advisories/GHSA-2frx-2596-x5r6\">https://github.com/advisories/GHSA-2frx-2596-x5r6</a></li>\n</ul>\n",
            "url": "https://github.com/advisories/GHSA-2frx-2596-x5r6",
            "title": "[gix-traverse] gitoxide does not detect SHA-1 collision attacks",
            "date_modified": "2025-04-04T16:06:11.000Z",
            "date_published": "2025-04-04T16:06:08.000Z",
            "author": {
                "name": "GitHub",
                "url": "https://github.com/advisories/GHSA-2frx-2596-x5r6"
            },
            "tags": [
                "severity"
            ]
        },
        {
            "content_html": "<h3 id=\"summary\">Summary</h3>\n<p>gitoxide uses SHA-1 hash implementations without any collision detection, leaving it vulnerable to hash collision attacks.</p>\n<h3 id=\"details\">Details</h3>\n<p>gitoxide uses the <code>sha1_smol</code> or <code>sha1</code> crate, both of which implement standard SHA-1 without any mitigations for collision attacks. This means that two distinct Git objects with colliding SHA-1 hashes would break the Git object model and integrity checks when used with gitoxide.</p>\n<p>The SHA-1 function is considered cryptographically insecure. However, in the wake of the SHAttered attacks, this issue was mitigated in Git 2.13.0 in 2017 by using the <a href=\"https://github.com/crmarcstevens/sha1collisiondetection\">sha1collisiondetection</a> algorithm by default and producing an error when known SHA-1 collisions are detected. Git is in the process of migrating to using SHA-256 for object hashes, but this has not been rolled out widely yet and gitoxide does not support SHA-256 object hashes.</p>\n<h3 id=\"poc\">PoC</h3>\n<p>The following program demonstrates the problem, using the two <a href=\"https://shattered.io/\">SHAttered PDFs</a>:</p>\n<pre><code class=\"language-rust\">use sha1_checked::{CollisionResult, Digest};\n\nfn sha1_oid_of_file(filename: &amp;str) -&gt; gix::ObjectId {\n    let mut hasher = gix::features::hash::hasher(gix::hash::Kind::Sha1);\n    hasher.update(&amp;std::fs::read(filename).unwrap());\n    gix::ObjectId::Sha1(hasher.digest())\n}\n\nfn sha1dc_oid_of_file(filename: &amp;str) -&gt; Result&lt;gix::ObjectId, String&gt; {\n    // Matches Git’s behaviour.\n    let mut hasher = sha1_checked::Builder::default().safe_hash(false).build();\n    hasher.update(&amp;std::fs::read(filename).unwrap());\n    match hasher.try_finalize() {\n        CollisionResult::Ok(digest) =&gt; Ok(gix::ObjectId::Sha1(digest.into())),\n        CollisionResult::Mitigated(_) =&gt; unreachable!(),\n        CollisionResult::Collision(digest) =&gt; Err(format!(\n            \"Collision attack: {}\",\n            gix::ObjectId::Sha1(digest.into()).to_hex()\n        )),\n    }\n}\n\nfn main() {\n    dbg!(sha1_oid_of_file(\"shattered-1.pdf\"));\n    dbg!(sha1_oid_of_file(\"shattered-2.pdf\"));\n    dbg!(sha1dc_oid_of_file(\"shattered-1.pdf\"));\n    dbg!(sha1dc_oid_of_file(\"shattered-2.pdf\"));\n}\n</code></pre>\n<p>The output is as follows:</p>\n<pre><code>[src/main.rs:24:5] sha1_oid_of_file(\"shattered-1.pdf\") = Sha1(38762cf7f55934b34d179ae6a4c80cadccbb7f0a)\n[src/main.rs:25:5] sha1_oid_of_file(\"shattered-2.pdf\") = Sha1(38762cf7f55934b34d179ae6a4c80cadccbb7f0a)\n[src/main.rs:26:5] sha1dc_oid_of_file(\"shattered-1.pdf\") = Err(\n    \"Collision attack: 38762cf7f55934b34d179ae6a4c80cadccbb7f0a\",\n)\n[src/main.rs:27:5] sha1dc_oid_of_file(\"shattered-2.pdf\") = Err(\n    \"Collision attack: 38762cf7f55934b34d179ae6a4c80cadccbb7f0a\",\n)\n</code></pre>\n<p>The latter behaviour matches Git.</p>\n<p>Since the SHAttered PDFs are not in a valid format for Git objects, a direct proof‐of‐concept using higher‐level APIs cannot be immediately demonstrated without significant computational resources.</p>\n<h3 id=\"impact\">Impact</h3>\n<p>An attacker with the ability to mount a collision attack on SHA-1 like the <a href=\"https://shattered.io/\">SHAttered</a> or <a href=\"https://sha-mbles.github.io/\">SHA-1 is a Shambles</a> attacks could create two distinct Git objects with the same hash. This is becoming increasingly affordable for well‐resourced attackers, with the Shambles researchers in 2020 estimating $45k for a chosen‐prefix collision or $11k for a classical collision, and projecting less than $10k for a chosen‐prefix collision by 2025. The result could be used to disguise malicious repository contents, or potentially exploit assumptions in the logic of programs using gitoxide to cause further vulnerabilities.</p>\n<p>This vulnerability affects any user of gitoxide, including <code>gix-*</code> library crates, that reads or writes Git objects.</p>\n<h3 id=\"references\">References</h3>\n<ul>\n<li><a href=\"https://github.com/GitoxideLabs/gitoxide/security/advisories/GHSA-2frx-2596-x5r6\">https://github.com/GitoxideLabs/gitoxide/security/advisories/GHSA-2frx-2596-x5r6</a></li>\n<li><a href=\"https://nvd.nist.gov/vuln/detail/CVE-2025-31130\">https://nvd.nist.gov/vuln/detail/CVE-2025-31130</a></li>\n<li><a href=\"https://github.com/GitoxideLabs/gitoxide/commit/4660f7a6f71873311f68f170b0f1f6659a02829d\">https://github.com/GitoxideLabs/gitoxide/commit/4660f7a6f71873311f68f170b0f1f6659a02829d</a></li>\n<li><a href=\"https://rustsec.org/advisories/RUSTSEC-2025-0021.html\">https://rustsec.org/advisories/RUSTSEC-2025-0021.html</a></li>\n<li><a href=\"https://github.com/advisories/GHSA-2frx-2596-x5r6\">https://github.com/advisories/GHSA-2frx-2596-x5r6</a></li>\n</ul>\n",
            "url": "https://github.com/advisories/GHSA-2frx-2596-x5r6",
            "title": "[gix-status] gitoxide does not detect SHA-1 collision attacks",
            "date_modified": "2025-04-04T16:06:11.000Z",
            "date_published": "2025-04-04T16:06:08.000Z",
            "author": {
                "name": "GitHub",
                "url": "https://github.com/advisories/GHSA-2frx-2596-x5r6"
            },
            "tags": [
                "severity"
            ]
        },
        {
            "content_html": "<h3 id=\"summary\">Summary</h3>\n<p>gitoxide uses SHA-1 hash implementations without any collision detection, leaving it vulnerable to hash collision attacks.</p>\n<h3 id=\"details\">Details</h3>\n<p>gitoxide uses the <code>sha1_smol</code> or <code>sha1</code> crate, both of which implement standard SHA-1 without any mitigations for collision attacks. This means that two distinct Git objects with colliding SHA-1 hashes would break the Git object model and integrity checks when used with gitoxide.</p>\n<p>The SHA-1 function is considered cryptographically insecure. However, in the wake of the SHAttered attacks, this issue was mitigated in Git 2.13.0 in 2017 by using the <a href=\"https://github.com/crmarcstevens/sha1collisiondetection\">sha1collisiondetection</a> algorithm by default and producing an error when known SHA-1 collisions are detected. Git is in the process of migrating to using SHA-256 for object hashes, but this has not been rolled out widely yet and gitoxide does not support SHA-256 object hashes.</p>\n<h3 id=\"poc\">PoC</h3>\n<p>The following program demonstrates the problem, using the two <a href=\"https://shattered.io/\">SHAttered PDFs</a>:</p>\n<pre><code class=\"language-rust\">use sha1_checked::{CollisionResult, Digest};\n\nfn sha1_oid_of_file(filename: &amp;str) -&gt; gix::ObjectId {\n    let mut hasher = gix::features::hash::hasher(gix::hash::Kind::Sha1);\n    hasher.update(&amp;std::fs::read(filename).unwrap());\n    gix::ObjectId::Sha1(hasher.digest())\n}\n\nfn sha1dc_oid_of_file(filename: &amp;str) -&gt; Result&lt;gix::ObjectId, String&gt; {\n    // Matches Git’s behaviour.\n    let mut hasher = sha1_checked::Builder::default().safe_hash(false).build();\n    hasher.update(&amp;std::fs::read(filename).unwrap());\n    match hasher.try_finalize() {\n        CollisionResult::Ok(digest) =&gt; Ok(gix::ObjectId::Sha1(digest.into())),\n        CollisionResult::Mitigated(_) =&gt; unreachable!(),\n        CollisionResult::Collision(digest) =&gt; Err(format!(\n            \"Collision attack: {}\",\n            gix::ObjectId::Sha1(digest.into()).to_hex()\n        )),\n    }\n}\n\nfn main() {\n    dbg!(sha1_oid_of_file(\"shattered-1.pdf\"));\n    dbg!(sha1_oid_of_file(\"shattered-2.pdf\"));\n    dbg!(sha1dc_oid_of_file(\"shattered-1.pdf\"));\n    dbg!(sha1dc_oid_of_file(\"shattered-2.pdf\"));\n}\n</code></pre>\n<p>The output is as follows:</p>\n<pre><code>[src/main.rs:24:5] sha1_oid_of_file(\"shattered-1.pdf\") = Sha1(38762cf7f55934b34d179ae6a4c80cadccbb7f0a)\n[src/main.rs:25:5] sha1_oid_of_file(\"shattered-2.pdf\") = Sha1(38762cf7f55934b34d179ae6a4c80cadccbb7f0a)\n[src/main.rs:26:5] sha1dc_oid_of_file(\"shattered-1.pdf\") = Err(\n    \"Collision attack: 38762cf7f55934b34d179ae6a4c80cadccbb7f0a\",\n)\n[src/main.rs:27:5] sha1dc_oid_of_file(\"shattered-2.pdf\") = Err(\n    \"Collision attack: 38762cf7f55934b34d179ae6a4c80cadccbb7f0a\",\n)\n</code></pre>\n<p>The latter behaviour matches Git.</p>\n<p>Since the SHAttered PDFs are not in a valid format for Git objects, a direct proof‐of‐concept using higher‐level APIs cannot be immediately demonstrated without significant computational resources.</p>\n<h3 id=\"impact\">Impact</h3>\n<p>An attacker with the ability to mount a collision attack on SHA-1 like the <a href=\"https://shattered.io/\">SHAttered</a> or <a href=\"https://sha-mbles.github.io/\">SHA-1 is a Shambles</a> attacks could create two distinct Git objects with the same hash. This is becoming increasingly affordable for well‐resourced attackers, with the Shambles researchers in 2020 estimating $45k for a chosen‐prefix collision or $11k for a classical collision, and projecting less than $10k for a chosen‐prefix collision by 2025. The result could be used to disguise malicious repository contents, or potentially exploit assumptions in the logic of programs using gitoxide to cause further vulnerabilities.</p>\n<p>This vulnerability affects any user of gitoxide, including <code>gix-*</code> library crates, that reads or writes Git objects.</p>\n<h3 id=\"references\">References</h3>\n<ul>\n<li><a href=\"https://github.com/GitoxideLabs/gitoxide/security/advisories/GHSA-2frx-2596-x5r6\">https://github.com/GitoxideLabs/gitoxide/security/advisories/GHSA-2frx-2596-x5r6</a></li>\n<li><a href=\"https://nvd.nist.gov/vuln/detail/CVE-2025-31130\">https://nvd.nist.gov/vuln/detail/CVE-2025-31130</a></li>\n<li><a href=\"https://github.com/GitoxideLabs/gitoxide/commit/4660f7a6f71873311f68f170b0f1f6659a02829d\">https://github.com/GitoxideLabs/gitoxide/commit/4660f7a6f71873311f68f170b0f1f6659a02829d</a></li>\n<li><a href=\"https://rustsec.org/advisories/RUSTSEC-2025-0021.html\">https://rustsec.org/advisories/RUSTSEC-2025-0021.html</a></li>\n<li><a href=\"https://github.com/advisories/GHSA-2frx-2596-x5r6\">https://github.com/advisories/GHSA-2frx-2596-x5r6</a></li>\n</ul>\n",
            "url": "https://github.com/advisories/GHSA-2frx-2596-x5r6",
            "title": "[gix-revwalk] gitoxide does not detect SHA-1 collision attacks",
            "date_modified": "2025-04-04T16:06:11.000Z",
            "date_published": "2025-04-04T16:06:08.000Z",
            "author": {
                "name": "GitHub",
                "url": "https://github.com/advisories/GHSA-2frx-2596-x5r6"
            },
            "tags": [
                "severity"
            ]
        },
        {
            "content_html": "<h3 id=\"summary\">Summary</h3>\n<p>gitoxide uses SHA-1 hash implementations without any collision detection, leaving it vulnerable to hash collision attacks.</p>\n<h3 id=\"details\">Details</h3>\n<p>gitoxide uses the <code>sha1_smol</code> or <code>sha1</code> crate, both of which implement standard SHA-1 without any mitigations for collision attacks. This means that two distinct Git objects with colliding SHA-1 hashes would break the Git object model and integrity checks when used with gitoxide.</p>\n<p>The SHA-1 function is considered cryptographically insecure. However, in the wake of the SHAttered attacks, this issue was mitigated in Git 2.13.0 in 2017 by using the <a href=\"https://github.com/crmarcstevens/sha1collisiondetection\">sha1collisiondetection</a> algorithm by default and producing an error when known SHA-1 collisions are detected. Git is in the process of migrating to using SHA-256 for object hashes, but this has not been rolled out widely yet and gitoxide does not support SHA-256 object hashes.</p>\n<h3 id=\"poc\">PoC</h3>\n<p>The following program demonstrates the problem, using the two <a href=\"https://shattered.io/\">SHAttered PDFs</a>:</p>\n<pre><code class=\"language-rust\">use sha1_checked::{CollisionResult, Digest};\n\nfn sha1_oid_of_file(filename: &amp;str) -&gt; gix::ObjectId {\n    let mut hasher = gix::features::hash::hasher(gix::hash::Kind::Sha1);\n    hasher.update(&amp;std::fs::read(filename).unwrap());\n    gix::ObjectId::Sha1(hasher.digest())\n}\n\nfn sha1dc_oid_of_file(filename: &amp;str) -&gt; Result&lt;gix::ObjectId, String&gt; {\n    // Matches Git’s behaviour.\n    let mut hasher = sha1_checked::Builder::default().safe_hash(false).build();\n    hasher.update(&amp;std::fs::read(filename).unwrap());\n    match hasher.try_finalize() {\n        CollisionResult::Ok(digest) =&gt; Ok(gix::ObjectId::Sha1(digest.into())),\n        CollisionResult::Mitigated(_) =&gt; unreachable!(),\n        CollisionResult::Collision(digest) =&gt; Err(format!(\n            \"Collision attack: {}\",\n            gix::ObjectId::Sha1(digest.into()).to_hex()\n        )),\n    }\n}\n\nfn main() {\n    dbg!(sha1_oid_of_file(\"shattered-1.pdf\"));\n    dbg!(sha1_oid_of_file(\"shattered-2.pdf\"));\n    dbg!(sha1dc_oid_of_file(\"shattered-1.pdf\"));\n    dbg!(sha1dc_oid_of_file(\"shattered-2.pdf\"));\n}\n</code></pre>\n<p>The output is as follows:</p>\n<pre><code>[src/main.rs:24:5] sha1_oid_of_file(\"shattered-1.pdf\") = Sha1(38762cf7f55934b34d179ae6a4c80cadccbb7f0a)\n[src/main.rs:25:5] sha1_oid_of_file(\"shattered-2.pdf\") = Sha1(38762cf7f55934b34d179ae6a4c80cadccbb7f0a)\n[src/main.rs:26:5] sha1dc_oid_of_file(\"shattered-1.pdf\") = Err(\n    \"Collision attack: 38762cf7f55934b34d179ae6a4c80cadccbb7f0a\",\n)\n[src/main.rs:27:5] sha1dc_oid_of_file(\"shattered-2.pdf\") = Err(\n    \"Collision attack: 38762cf7f55934b34d179ae6a4c80cadccbb7f0a\",\n)\n</code></pre>\n<p>The latter behaviour matches Git.</p>\n<p>Since the SHAttered PDFs are not in a valid format for Git objects, a direct proof‐of‐concept using higher‐level APIs cannot be immediately demonstrated without significant computational resources.</p>\n<h3 id=\"impact\">Impact</h3>\n<p>An attacker with the ability to mount a collision attack on SHA-1 like the <a href=\"https://shattered.io/\">SHAttered</a> or <a href=\"https://sha-mbles.github.io/\">SHA-1 is a Shambles</a> attacks could create two distinct Git objects with the same hash. This is becoming increasingly affordable for well‐resourced attackers, with the Shambles researchers in 2020 estimating $45k for a chosen‐prefix collision or $11k for a classical collision, and projecting less than $10k for a chosen‐prefix collision by 2025. The result could be used to disguise malicious repository contents, or potentially exploit assumptions in the logic of programs using gitoxide to cause further vulnerabilities.</p>\n<p>This vulnerability affects any user of gitoxide, including <code>gix-*</code> library crates, that reads or writes Git objects.</p>\n<h3 id=\"references\">References</h3>\n<ul>\n<li><a href=\"https://github.com/GitoxideLabs/gitoxide/security/advisories/GHSA-2frx-2596-x5r6\">https://github.com/GitoxideLabs/gitoxide/security/advisories/GHSA-2frx-2596-x5r6</a></li>\n<li><a href=\"https://nvd.nist.gov/vuln/detail/CVE-2025-31130\">https://nvd.nist.gov/vuln/detail/CVE-2025-31130</a></li>\n<li><a href=\"https://github.com/GitoxideLabs/gitoxide/commit/4660f7a6f71873311f68f170b0f1f6659a02829d\">https://github.com/GitoxideLabs/gitoxide/commit/4660f7a6f71873311f68f170b0f1f6659a02829d</a></li>\n<li><a href=\"https://rustsec.org/advisories/RUSTSEC-2025-0021.html\">https://rustsec.org/advisories/RUSTSEC-2025-0021.html</a></li>\n<li><a href=\"https://github.com/advisories/GHSA-2frx-2596-x5r6\">https://github.com/advisories/GHSA-2frx-2596-x5r6</a></li>\n</ul>\n",
            "url": "https://github.com/advisories/GHSA-2frx-2596-x5r6",
            "title": "[gix-revision] gitoxide does not detect SHA-1 collision attacks",
            "date_modified": "2025-04-04T16:06:11.000Z",
            "date_published": "2025-04-04T16:06:08.000Z",
            "author": {
                "name": "GitHub",
                "url": "https://github.com/advisories/GHSA-2frx-2596-x5r6"
            },
            "tags": [
                "severity"
            ]
        },
        {
            "content_html": "<h3 id=\"summary\">Summary</h3>\n<p>gitoxide uses SHA-1 hash implementations without any collision detection, leaving it vulnerable to hash collision attacks.</p>\n<h3 id=\"details\">Details</h3>\n<p>gitoxide uses the <code>sha1_smol</code> or <code>sha1</code> crate, both of which implement standard SHA-1 without any mitigations for collision attacks. This means that two distinct Git objects with colliding SHA-1 hashes would break the Git object model and integrity checks when used with gitoxide.</p>\n<p>The SHA-1 function is considered cryptographically insecure. However, in the wake of the SHAttered attacks, this issue was mitigated in Git 2.13.0 in 2017 by using the <a href=\"https://github.com/crmarcstevens/sha1collisiondetection\">sha1collisiondetection</a> algorithm by default and producing an error when known SHA-1 collisions are detected. Git is in the process of migrating to using SHA-256 for object hashes, but this has not been rolled out widely yet and gitoxide does not support SHA-256 object hashes.</p>\n<h3 id=\"poc\">PoC</h3>\n<p>The following program demonstrates the problem, using the two <a href=\"https://shattered.io/\">SHAttered PDFs</a>:</p>\n<pre><code class=\"language-rust\">use sha1_checked::{CollisionResult, Digest};\n\nfn sha1_oid_of_file(filename: &amp;str) -&gt; gix::ObjectId {\n    let mut hasher = gix::features::hash::hasher(gix::hash::Kind::Sha1);\n    hasher.update(&amp;std::fs::read(filename).unwrap());\n    gix::ObjectId::Sha1(hasher.digest())\n}\n\nfn sha1dc_oid_of_file(filename: &amp;str) -&gt; Result&lt;gix::ObjectId, String&gt; {\n    // Matches Git’s behaviour.\n    let mut hasher = sha1_checked::Builder::default().safe_hash(false).build();\n    hasher.update(&amp;std::fs::read(filename).unwrap());\n    match hasher.try_finalize() {\n        CollisionResult::Ok(digest) =&gt; Ok(gix::ObjectId::Sha1(digest.into())),\n        CollisionResult::Mitigated(_) =&gt; unreachable!(),\n        CollisionResult::Collision(digest) =&gt; Err(format!(\n            \"Collision attack: {}\",\n            gix::ObjectId::Sha1(digest.into()).to_hex()\n        )),\n    }\n}\n\nfn main() {\n    dbg!(sha1_oid_of_file(\"shattered-1.pdf\"));\n    dbg!(sha1_oid_of_file(\"shattered-2.pdf\"));\n    dbg!(sha1dc_oid_of_file(\"shattered-1.pdf\"));\n    dbg!(sha1dc_oid_of_file(\"shattered-2.pdf\"));\n}\n</code></pre>\n<p>The output is as follows:</p>\n<pre><code>[src/main.rs:24:5] sha1_oid_of_file(\"shattered-1.pdf\") = Sha1(38762cf7f55934b34d179ae6a4c80cadccbb7f0a)\n[src/main.rs:25:5] sha1_oid_of_file(\"shattered-2.pdf\") = Sha1(38762cf7f55934b34d179ae6a4c80cadccbb7f0a)\n[src/main.rs:26:5] sha1dc_oid_of_file(\"shattered-1.pdf\") = Err(\n    \"Collision attack: 38762cf7f55934b34d179ae6a4c80cadccbb7f0a\",\n)\n[src/main.rs:27:5] sha1dc_oid_of_file(\"shattered-2.pdf\") = Err(\n    \"Collision attack: 38762cf7f55934b34d179ae6a4c80cadccbb7f0a\",\n)\n</code></pre>\n<p>The latter behaviour matches Git.</p>\n<p>Since the SHAttered PDFs are not in a valid format for Git objects, a direct proof‐of‐concept using higher‐level APIs cannot be immediately demonstrated without significant computational resources.</p>\n<h3 id=\"impact\">Impact</h3>\n<p>An attacker with the ability to mount a collision attack on SHA-1 like the <a href=\"https://shattered.io/\">SHAttered</a> or <a href=\"https://sha-mbles.github.io/\">SHA-1 is a Shambles</a> attacks could create two distinct Git objects with the same hash. This is becoming increasingly affordable for well‐resourced attackers, with the Shambles researchers in 2020 estimating $45k for a chosen‐prefix collision or $11k for a classical collision, and projecting less than $10k for a chosen‐prefix collision by 2025. The result could be used to disguise malicious repository contents, or potentially exploit assumptions in the logic of programs using gitoxide to cause further vulnerabilities.</p>\n<p>This vulnerability affects any user of gitoxide, including <code>gix-*</code> library crates, that reads or writes Git objects.</p>\n<h3 id=\"references\">References</h3>\n<ul>\n<li><a href=\"https://github.com/GitoxideLabs/gitoxide/security/advisories/GHSA-2frx-2596-x5r6\">https://github.com/GitoxideLabs/gitoxide/security/advisories/GHSA-2frx-2596-x5r6</a></li>\n<li><a href=\"https://nvd.nist.gov/vuln/detail/CVE-2025-31130\">https://nvd.nist.gov/vuln/detail/CVE-2025-31130</a></li>\n<li><a href=\"https://github.com/GitoxideLabs/gitoxide/commit/4660f7a6f71873311f68f170b0f1f6659a02829d\">https://github.com/GitoxideLabs/gitoxide/commit/4660f7a6f71873311f68f170b0f1f6659a02829d</a></li>\n<li><a href=\"https://rustsec.org/advisories/RUSTSEC-2025-0021.html\">https://rustsec.org/advisories/RUSTSEC-2025-0021.html</a></li>\n<li><a href=\"https://github.com/advisories/GHSA-2frx-2596-x5r6\">https://github.com/advisories/GHSA-2frx-2596-x5r6</a></li>\n</ul>\n",
            "url": "https://github.com/advisories/GHSA-2frx-2596-x5r6",
            "title": "[gix-ref] gitoxide does not detect SHA-1 collision attacks",
            "date_modified": "2025-04-04T16:06:11.000Z",
            "date_published": "2025-04-04T16:06:08.000Z",
            "author": {
                "name": "GitHub",
                "url": "https://github.com/advisories/GHSA-2frx-2596-x5r6"
            },
            "tags": [
                "severity"
            ]
        },
        {
            "content_html": "<h3 id=\"summary\">Summary</h3>\n<p>gitoxide uses SHA-1 hash implementations without any collision detection, leaving it vulnerable to hash collision attacks.</p>\n<h3 id=\"details\">Details</h3>\n<p>gitoxide uses the <code>sha1_smol</code> or <code>sha1</code> crate, both of which implement standard SHA-1 without any mitigations for collision attacks. This means that two distinct Git objects with colliding SHA-1 hashes would break the Git object model and integrity checks when used with gitoxide.</p>\n<p>The SHA-1 function is considered cryptographically insecure. However, in the wake of the SHAttered attacks, this issue was mitigated in Git 2.13.0 in 2017 by using the <a href=\"https://github.com/crmarcstevens/sha1collisiondetection\">sha1collisiondetection</a> algorithm by default and producing an error when known SHA-1 collisions are detected. Git is in the process of migrating to using SHA-256 for object hashes, but this has not been rolled out widely yet and gitoxide does not support SHA-256 object hashes.</p>\n<h3 id=\"poc\">PoC</h3>\n<p>The following program demonstrates the problem, using the two <a href=\"https://shattered.io/\">SHAttered PDFs</a>:</p>\n<pre><code class=\"language-rust\">use sha1_checked::{CollisionResult, Digest};\n\nfn sha1_oid_of_file(filename: &amp;str) -&gt; gix::ObjectId {\n    let mut hasher = gix::features::hash::hasher(gix::hash::Kind::Sha1);\n    hasher.update(&amp;std::fs::read(filename).unwrap());\n    gix::ObjectId::Sha1(hasher.digest())\n}\n\nfn sha1dc_oid_of_file(filename: &amp;str) -&gt; Result&lt;gix::ObjectId, String&gt; {\n    // Matches Git’s behaviour.\n    let mut hasher = sha1_checked::Builder::default().safe_hash(false).build();\n    hasher.update(&amp;std::fs::read(filename).unwrap());\n    match hasher.try_finalize() {\n        CollisionResult::Ok(digest) =&gt; Ok(gix::ObjectId::Sha1(digest.into())),\n        CollisionResult::Mitigated(_) =&gt; unreachable!(),\n        CollisionResult::Collision(digest) =&gt; Err(format!(\n            \"Collision attack: {}\",\n            gix::ObjectId::Sha1(digest.into()).to_hex()\n        )),\n    }\n}\n\nfn main() {\n    dbg!(sha1_oid_of_file(\"shattered-1.pdf\"));\n    dbg!(sha1_oid_of_file(\"shattered-2.pdf\"));\n    dbg!(sha1dc_oid_of_file(\"shattered-1.pdf\"));\n    dbg!(sha1dc_oid_of_file(\"shattered-2.pdf\"));\n}\n</code></pre>\n<p>The output is as follows:</p>\n<pre><code>[src/main.rs:24:5] sha1_oid_of_file(\"shattered-1.pdf\") = Sha1(38762cf7f55934b34d179ae6a4c80cadccbb7f0a)\n[src/main.rs:25:5] sha1_oid_of_file(\"shattered-2.pdf\") = Sha1(38762cf7f55934b34d179ae6a4c80cadccbb7f0a)\n[src/main.rs:26:5] sha1dc_oid_of_file(\"shattered-1.pdf\") = Err(\n    \"Collision attack: 38762cf7f55934b34d179ae6a4c80cadccbb7f0a\",\n)\n[src/main.rs:27:5] sha1dc_oid_of_file(\"shattered-2.pdf\") = Err(\n    \"Collision attack: 38762cf7f55934b34d179ae6a4c80cadccbb7f0a\",\n)\n</code></pre>\n<p>The latter behaviour matches Git.</p>\n<p>Since the SHAttered PDFs are not in a valid format for Git objects, a direct proof‐of‐concept using higher‐level APIs cannot be immediately demonstrated without significant computational resources.</p>\n<h3 id=\"impact\">Impact</h3>\n<p>An attacker with the ability to mount a collision attack on SHA-1 like the <a href=\"https://shattered.io/\">SHAttered</a> or <a href=\"https://sha-mbles.github.io/\">SHA-1 is a Shambles</a> attacks could create two distinct Git objects with the same hash. This is becoming increasingly affordable for well‐resourced attackers, with the Shambles researchers in 2020 estimating $45k for a chosen‐prefix collision or $11k for a classical collision, and projecting less than $10k for a chosen‐prefix collision by 2025. The result could be used to disguise malicious repository contents, or potentially exploit assumptions in the logic of programs using gitoxide to cause further vulnerabilities.</p>\n<p>This vulnerability affects any user of gitoxide, including <code>gix-*</code> library crates, that reads or writes Git objects.</p>\n<h3 id=\"references\">References</h3>\n<ul>\n<li><a href=\"https://github.com/GitoxideLabs/gitoxide/security/advisories/GHSA-2frx-2596-x5r6\">https://github.com/GitoxideLabs/gitoxide/security/advisories/GHSA-2frx-2596-x5r6</a></li>\n<li><a href=\"https://nvd.nist.gov/vuln/detail/CVE-2025-31130\">https://nvd.nist.gov/vuln/detail/CVE-2025-31130</a></li>\n<li><a href=\"https://github.com/GitoxideLabs/gitoxide/commit/4660f7a6f71873311f68f170b0f1f6659a02829d\">https://github.com/GitoxideLabs/gitoxide/commit/4660f7a6f71873311f68f170b0f1f6659a02829d</a></li>\n<li><a href=\"https://rustsec.org/advisories/RUSTSEC-2025-0021.html\">https://rustsec.org/advisories/RUSTSEC-2025-0021.html</a></li>\n<li><a href=\"https://github.com/advisories/GHSA-2frx-2596-x5r6\">https://github.com/advisories/GHSA-2frx-2596-x5r6</a></li>\n</ul>\n",
            "url": "https://github.com/advisories/GHSA-2frx-2596-x5r6",
            "title": "[gix-protocol] gitoxide does not detect SHA-1 collision attacks",
            "date_modified": "2025-04-04T16:06:11.000Z",
            "date_published": "2025-04-04T16:06:08.000Z",
            "author": {
                "name": "GitHub",
                "url": "https://github.com/advisories/GHSA-2frx-2596-x5r6"
            },
            "tags": [
                "severity"
            ]
        },
        {
            "content_html": "<h3 id=\"summary\">Summary</h3>\n<p>gitoxide uses SHA-1 hash implementations without any collision detection, leaving it vulnerable to hash collision attacks.</p>\n<h3 id=\"details\">Details</h3>\n<p>gitoxide uses the <code>sha1_smol</code> or <code>sha1</code> crate, both of which implement standard SHA-1 without any mitigations for collision attacks. This means that two distinct Git objects with colliding SHA-1 hashes would break the Git object model and integrity checks when used with gitoxide.</p>\n<p>The SHA-1 function is considered cryptographically insecure. However, in the wake of the SHAttered attacks, this issue was mitigated in Git 2.13.0 in 2017 by using the <a href=\"https://github.com/crmarcstevens/sha1collisiondetection\">sha1collisiondetection</a> algorithm by default and producing an error when known SHA-1 collisions are detected. Git is in the process of migrating to using SHA-256 for object hashes, but this has not been rolled out widely yet and gitoxide does not support SHA-256 object hashes.</p>\n<h3 id=\"poc\">PoC</h3>\n<p>The following program demonstrates the problem, using the two <a href=\"https://shattered.io/\">SHAttered PDFs</a>:</p>\n<pre><code class=\"language-rust\">use sha1_checked::{CollisionResult, Digest};\n\nfn sha1_oid_of_file(filename: &amp;str) -&gt; gix::ObjectId {\n    let mut hasher = gix::features::hash::hasher(gix::hash::Kind::Sha1);\n    hasher.update(&amp;std::fs::read(filename).unwrap());\n    gix::ObjectId::Sha1(hasher.digest())\n}\n\nfn sha1dc_oid_of_file(filename: &amp;str) -&gt; Result&lt;gix::ObjectId, String&gt; {\n    // Matches Git’s behaviour.\n    let mut hasher = sha1_checked::Builder::default().safe_hash(false).build();\n    hasher.update(&amp;std::fs::read(filename).unwrap());\n    match hasher.try_finalize() {\n        CollisionResult::Ok(digest) =&gt; Ok(gix::ObjectId::Sha1(digest.into())),\n        CollisionResult::Mitigated(_) =&gt; unreachable!(),\n        CollisionResult::Collision(digest) =&gt; Err(format!(\n            \"Collision attack: {}\",\n            gix::ObjectId::Sha1(digest.into()).to_hex()\n        )),\n    }\n}\n\nfn main() {\n    dbg!(sha1_oid_of_file(\"shattered-1.pdf\"));\n    dbg!(sha1_oid_of_file(\"shattered-2.pdf\"));\n    dbg!(sha1dc_oid_of_file(\"shattered-1.pdf\"));\n    dbg!(sha1dc_oid_of_file(\"shattered-2.pdf\"));\n}\n</code></pre>\n<p>The output is as follows:</p>\n<pre><code>[src/main.rs:24:5] sha1_oid_of_file(\"shattered-1.pdf\") = Sha1(38762cf7f55934b34d179ae6a4c80cadccbb7f0a)\n[src/main.rs:25:5] sha1_oid_of_file(\"shattered-2.pdf\") = Sha1(38762cf7f55934b34d179ae6a4c80cadccbb7f0a)\n[src/main.rs:26:5] sha1dc_oid_of_file(\"shattered-1.pdf\") = Err(\n    \"Collision attack: 38762cf7f55934b34d179ae6a4c80cadccbb7f0a\",\n)\n[src/main.rs:27:5] sha1dc_oid_of_file(\"shattered-2.pdf\") = Err(\n    \"Collision attack: 38762cf7f55934b34d179ae6a4c80cadccbb7f0a\",\n)\n</code></pre>\n<p>The latter behaviour matches Git.</p>\n<p>Since the SHAttered PDFs are not in a valid format for Git objects, a direct proof‐of‐concept using higher‐level APIs cannot be immediately demonstrated without significant computational resources.</p>\n<h3 id=\"impact\">Impact</h3>\n<p>An attacker with the ability to mount a collision attack on SHA-1 like the <a href=\"https://shattered.io/\">SHAttered</a> or <a href=\"https://sha-mbles.github.io/\">SHA-1 is a Shambles</a> attacks could create two distinct Git objects with the same hash. This is becoming increasingly affordable for well‐resourced attackers, with the Shambles researchers in 2020 estimating $45k for a chosen‐prefix collision or $11k for a classical collision, and projecting less than $10k for a chosen‐prefix collision by 2025. The result could be used to disguise malicious repository contents, or potentially exploit assumptions in the logic of programs using gitoxide to cause further vulnerabilities.</p>\n<p>This vulnerability affects any user of gitoxide, including <code>gix-*</code> library crates, that reads or writes Git objects.</p>\n<h3 id=\"references\">References</h3>\n<ul>\n<li><a href=\"https://github.com/GitoxideLabs/gitoxide/security/advisories/GHSA-2frx-2596-x5r6\">https://github.com/GitoxideLabs/gitoxide/security/advisories/GHSA-2frx-2596-x5r6</a></li>\n<li><a href=\"https://nvd.nist.gov/vuln/detail/CVE-2025-31130\">https://nvd.nist.gov/vuln/detail/CVE-2025-31130</a></li>\n<li><a href=\"https://github.com/GitoxideLabs/gitoxide/commit/4660f7a6f71873311f68f170b0f1f6659a02829d\">https://github.com/GitoxideLabs/gitoxide/commit/4660f7a6f71873311f68f170b0f1f6659a02829d</a></li>\n<li><a href=\"https://rustsec.org/advisories/RUSTSEC-2025-0021.html\">https://rustsec.org/advisories/RUSTSEC-2025-0021.html</a></li>\n<li><a href=\"https://github.com/advisories/GHSA-2frx-2596-x5r6\">https://github.com/advisories/GHSA-2frx-2596-x5r6</a></li>\n</ul>\n",
            "url": "https://github.com/advisories/GHSA-2frx-2596-x5r6",
            "title": "[gix-negotiate] gitoxide does not detect SHA-1 collision attacks",
            "date_modified": "2025-04-04T16:06:11.000Z",
            "date_published": "2025-04-04T16:06:08.000Z",
            "author": {
                "name": "GitHub",
                "url": "https://github.com/advisories/GHSA-2frx-2596-x5r6"
            },
            "tags": [
                "severity"
            ]
        }
    ]
}