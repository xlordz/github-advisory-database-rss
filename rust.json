{
    "version": "https://jsonfeed.org/version/1",
    "title": "Security Advisory for Rust crates",
    "home_page_url": "https://github.com/advisories?query=type%3Areviewed+ecosystem%3Arust",
    "feed_url": "https://azu.github.io/github-advisory-database-rss/rust.json",
    "description": "Security Advisory for Rust crates on GitHub",
    "items": [
        {
            "content_html": "<p>Affected versions of this crate allowed for a bias when generating random polynomials for Shamir Secret Sharing, where instead of being within the range <code>[0, 255]</code> they were instead in the range <code>[1, 255]</code>. A description from Cure53, who originally found the issue, is available:</p>\n<blockquote>\n<p>The correct method to select a random polynomial would be to select all coefficients (including the most significant coefficient) uniformly in the range 0..255 (inclusive). Otherwise, knowledge that a coefficient in a polynomial cannot be 0 permits the exclusion of single byte values for the shared secret given one share less than required. [...] Exploiting this weakness necessitates sharing the same secret multiple times. In this scenario, an attacker could exclude an exponential number of values for each of the shared bytes until sufficiently few values remain for brute forcing.  Cure53 estimates that under ideal circumstances (e.g., a 2-out-of-N scheme) a shared secret can be reconstructed if the same secret has been distributed 500-1500 times.</p>\n</blockquote>\n<p>Secrets that have been shared a low amount of times (ideally, once) would not be impacted. However, secrets that are repeatedly shared may be vulnerable, especially if the shares are still available, and should be rotated.</p>\n<p>The vulnerability does not impact reconstitution of secrets: secrets that have already been split can be recombined without issue.</p>\n<p>The flaw can be corrected by changing the lower bound of the polynomial coefficient range in the <code>sharks::math::random_polynomial</code> function to <code>0</code>. The <code>blahaj</code> crate has been made available with a fixed version of the code, after attempts to reach the maintainer of the <code>sharks</code> crate were unsuccessful.</p>\n<h3 id=\"references\">References</h3>\n<ul>\n<li><a href=\"https://git.distrust.co/public/blahaj/commit/4faab1cd33d455f0ca2ccc7208093fd6c18e0767\">https://git.distrust.co/public/blahaj/commit/4faab1cd33d455f0ca2ccc7208093fd6c18e0767</a></li>\n<li><a href=\"https://rustsec.org/advisories/RUSTSEC-2024-0398.html\">https://rustsec.org/advisories/RUSTSEC-2024-0398.html</a></li>\n<li><a href=\"https://github.com/advisories/GHSA-jp37-5qhw-mffw\">https://github.com/advisories/GHSA-jp37-5qhw-mffw</a></li>\n</ul>\n",
            "url": "https://github.com/advisories/GHSA-jp37-5qhw-mffw",
            "title": "[sharks] Sharks has a Bias of Polynomial Coefficients in Secret Sharing",
            "date_modified": "2024-11-18T20:03:26.000Z",
            "date_published": "2024-11-18T20:03:25.000Z",
            "author": {
                "name": "GitHub",
                "url": "https://github.com/advisories/GHSA-jp37-5qhw-mffw"
            },
            "tags": [
                "severity"
            ]
        },
        {
            "content_html": "<p>A denial of service vulnerability was found in zlib-rs, triggered by specially constructed input. This input causes a stack overflow, resulting in the process using zlib-rs to crash.</p>\n<h3 id=\"impact\">Impact</h3>\n<p>Due to the way LLVM handles the zlib-rs codebase, tail calls were not guaranteed. This caused certain input patterns to result in a large number of stack frames being required, quickly resulting in a stack overflow. These are unlikely to occur in practice, but a dedicated attacker can construct malicious input files.</p>\n<p>After stack overflows were found by @inahga with a fuzzer, we dove into the assembly, and found some cases where the stack grew</p>\n<pre><code class=\"language-asm\">.LBB109_326:\n    mov rdi, rbx\n    call zlib_rs::inflate::State::type_do\n    jmp .LBB109_311\n\n.LBB109_311:\n    lea rsp, [rbp - 40]\n    pop rbx\n    pop r12\n    pop r13\n    pop r14\n    pop r15\n    pop rbp\n    .cfi_def_cfa rsp, 8\n    ret\n</code></pre>\n<p>LLVM wants to centralize the cleanup before the return (many other blocks jump to <code>LBB109_311</code>), thereby invalidating a tail call to <code>type_do</code>. We were not able to get rid of this call without introducing one elsewhere: we just don't currently have the power to tell LLVM what we want it to do.</p>\n<p>So, we switch back to loop+match waiting for changes to rust to make a more efficient implementation possible. Performance-wise, the damage is relatively minimal: we're just slower in cases where we already were slower than C. We are faster in cases where the relevant code is barely touched (in these cases the logic quickly moves into a hot inner loop and just spends most of its time there).</p>\n<h3 id=\"patches\">Patches</h3>\n<p>Version 0.4.0 patches the problem and is no longer vulnerable.</p>\n<h3 id=\"workarounds\">Workarounds</h3>\n<p>Users of zlib-rs should upgrade to the latest version. Users could alternatively run zlib-rs in a separate process to prevent a stack overflow crashing the entire program. In some situations a signal handler can be used to catch a stack overflow happening.</p>\n<h3 id=\"references\">References</h3>\n<ul>\n<li><a href=\"https://github.com/trifectatechfoundation/zlib-rs/security/advisories/GHSA-j3px-q95c-9683\">https://github.com/trifectatechfoundation/zlib-rs/security/advisories/GHSA-j3px-q95c-9683</a></li>\n<li><a href=\"https://github.com/advisories/GHSA-j3px-q95c-9683\">https://github.com/advisories/GHSA-j3px-q95c-9683</a></li>\n</ul>\n",
            "url": "https://github.com/advisories/GHSA-j3px-q95c-9683",
            "title": "[libz-rs-sys-cdylib] zlib-rs stack overflow during decompression with malicious input",
            "date_modified": "2024-11-14T18:09:34.000Z",
            "date_published": "2024-11-14T18:09:33.000Z",
            "author": {
                "name": "GitHub",
                "url": "https://github.com/advisories/GHSA-j3px-q95c-9683"
            },
            "tags": [
                "severity"
            ]
        },
        {
            "content_html": "<p>A denial of service vulnerability was found in zlib-rs, triggered by specially constructed input. This input causes a stack overflow, resulting in the process using zlib-rs to crash.</p>\n<h3 id=\"impact\">Impact</h3>\n<p>Due to the way LLVM handles the zlib-rs codebase, tail calls were not guaranteed. This caused certain input patterns to result in a large number of stack frames being required, quickly resulting in a stack overflow. These are unlikely to occur in practice, but a dedicated attacker can construct malicious input files.</p>\n<p>After stack overflows were found by @inahga with a fuzzer, we dove into the assembly, and found some cases where the stack grew</p>\n<pre><code class=\"language-asm\">.LBB109_326:\n    mov rdi, rbx\n    call zlib_rs::inflate::State::type_do\n    jmp .LBB109_311\n\n.LBB109_311:\n    lea rsp, [rbp - 40]\n    pop rbx\n    pop r12\n    pop r13\n    pop r14\n    pop r15\n    pop rbp\n    .cfi_def_cfa rsp, 8\n    ret\n</code></pre>\n<p>LLVM wants to centralize the cleanup before the return (many other blocks jump to <code>LBB109_311</code>), thereby invalidating a tail call to <code>type_do</code>. We were not able to get rid of this call without introducing one elsewhere: we just don't currently have the power to tell LLVM what we want it to do.</p>\n<p>So, we switch back to loop+match waiting for changes to rust to make a more efficient implementation possible. Performance-wise, the damage is relatively minimal: we're just slower in cases where we already were slower than C. We are faster in cases where the relevant code is barely touched (in these cases the logic quickly moves into a hot inner loop and just spends most of its time there).</p>\n<h3 id=\"patches\">Patches</h3>\n<p>Version 0.4.0 patches the problem and is no longer vulnerable.</p>\n<h3 id=\"workarounds\">Workarounds</h3>\n<p>Users of zlib-rs should upgrade to the latest version. Users could alternatively run zlib-rs in a separate process to prevent a stack overflow crashing the entire program. In some situations a signal handler can be used to catch a stack overflow happening.</p>\n<h3 id=\"references\">References</h3>\n<ul>\n<li><a href=\"https://github.com/trifectatechfoundation/zlib-rs/security/advisories/GHSA-j3px-q95c-9683\">https://github.com/trifectatechfoundation/zlib-rs/security/advisories/GHSA-j3px-q95c-9683</a></li>\n<li><a href=\"https://github.com/advisories/GHSA-j3px-q95c-9683\">https://github.com/advisories/GHSA-j3px-q95c-9683</a></li>\n</ul>\n",
            "url": "https://github.com/advisories/GHSA-j3px-q95c-9683",
            "title": "[libz-rs-sys] zlib-rs stack overflow during decompression with malicious input",
            "date_modified": "2024-11-14T18:09:34.000Z",
            "date_published": "2024-11-14T18:09:33.000Z",
            "author": {
                "name": "GitHub",
                "url": "https://github.com/advisories/GHSA-j3px-q95c-9683"
            },
            "tags": [
                "severity"
            ]
        },
        {
            "content_html": "<p>A denial of service vulnerability was found in zlib-rs, triggered by specially constructed input. This input causes a stack overflow, resulting in the process using zlib-rs to crash.</p>\n<h3 id=\"impact\">Impact</h3>\n<p>Due to the way LLVM handles the zlib-rs codebase, tail calls were not guaranteed. This caused certain input patterns to result in a large number of stack frames being required, quickly resulting in a stack overflow. These are unlikely to occur in practice, but a dedicated attacker can construct malicious input files.</p>\n<p>After stack overflows were found by @inahga with a fuzzer, we dove into the assembly, and found some cases where the stack grew</p>\n<pre><code class=\"language-asm\">.LBB109_326:\n    mov rdi, rbx\n    call zlib_rs::inflate::State::type_do\n    jmp .LBB109_311\n\n.LBB109_311:\n    lea rsp, [rbp - 40]\n    pop rbx\n    pop r12\n    pop r13\n    pop r14\n    pop r15\n    pop rbp\n    .cfi_def_cfa rsp, 8\n    ret\n</code></pre>\n<p>LLVM wants to centralize the cleanup before the return (many other blocks jump to <code>LBB109_311</code>), thereby invalidating a tail call to <code>type_do</code>. We were not able to get rid of this call without introducing one elsewhere: we just don't currently have the power to tell LLVM what we want it to do.</p>\n<p>So, we switch back to loop+match waiting for changes to rust to make a more efficient implementation possible. Performance-wise, the damage is relatively minimal: we're just slower in cases where we already were slower than C. We are faster in cases where the relevant code is barely touched (in these cases the logic quickly moves into a hot inner loop and just spends most of its time there).</p>\n<h3 id=\"patches\">Patches</h3>\n<p>Version 0.4.0 patches the problem and is no longer vulnerable.</p>\n<h3 id=\"workarounds\">Workarounds</h3>\n<p>Users of zlib-rs should upgrade to the latest version. Users could alternatively run zlib-rs in a separate process to prevent a stack overflow crashing the entire program. In some situations a signal handler can be used to catch a stack overflow happening.</p>\n<h3 id=\"references\">References</h3>\n<ul>\n<li><a href=\"https://github.com/trifectatechfoundation/zlib-rs/security/advisories/GHSA-j3px-q95c-9683\">https://github.com/trifectatechfoundation/zlib-rs/security/advisories/GHSA-j3px-q95c-9683</a></li>\n<li><a href=\"https://github.com/advisories/GHSA-j3px-q95c-9683\">https://github.com/advisories/GHSA-j3px-q95c-9683</a></li>\n</ul>\n",
            "url": "https://github.com/advisories/GHSA-j3px-q95c-9683",
            "title": "[zlib-rs] zlib-rs stack overflow during decompression with malicious input",
            "date_modified": "2024-11-14T18:09:34.000Z",
            "date_published": "2024-11-14T18:09:33.000Z",
            "author": {
                "name": "GitHub",
                "url": "https://github.com/advisories/GHSA-j3px-q95c-9683"
            },
            "tags": [
                "severity"
            ]
        },
        {
            "content_html": "<h3 id=\"impact\">Impact</h3>\n<p>s2n-tls uses the Linux atexit function to register functions that clean up the global state when the process exits. In multi-threaded environments, the atexit handler may clean up state which is still in use by other threads. When this occurs, the exiting process may experience a segmentation fault or other undefined behavior. </p>\n<p>Customers of AWS services do not need to take action. Applications using s2n-tls should upgrade to the most recent release of s2n-tls.</p>\n<p><strong>Impacted versions</strong>: &lt; v1.5.9.</p>\n<h3 id=\"patches\">Patches</h3>\n<p>The patch commit <a href=\"https://github.com/aws/s2n-tls/commit/493b77167dc367c394de23cfe78a029298e2a254\">493b771</a> is included in s2n-tls v1.5.9 [1]</p>\n<h3 id=\"workarounds\">Workarounds</h3>\n<p>The atexit handler may be disabled by calling <code>s2n_disable_atexit()</code> prior to initializing s2n-tls. The atexit handler is off by default in the patched versions. For further details, refer to <a href=\"https://github.com/aws/s2n-tls/blob/main/docs/usage-guide/topics/ch02-initialization.md\">s2n-tls Usage Guide: Initialization and Teardown</a>.</p>\n<p>If you have any questions or comments about this advisory, we ask that you contact AWS/Amazon Security via our vulnerability reporting page [2] or directly via email to <a href=\"mailto:aws-security@amazon.com\">aws-security@amazon.com</a>. Please do not create a public GitHub issue.</p>\n<p>[1] <a href=\"https://github.com/aws/s2n-tls/releases/tag/v1.5.9\">https://github.com/aws/s2n-tls/releases/tag/v1.5.9</a>\n[2] Vulnerability reporting page: <a href=\"https://aws.amazon.com/security/vulnerability-reporting\">https://aws.amazon.com/security/vulnerability-reporting</a></p>\n<h3 id=\"references\">References</h3>\n<ul>\n<li><a href=\"https://github.com/aws/s2n-tls/security/advisories/GHSA-rp9h-rf7g-hwgr\">https://github.com/aws/s2n-tls/security/advisories/GHSA-rp9h-rf7g-hwgr</a></li>\n<li><a href=\"https://github.com/aws/s2n-tls/commit/493b77167dc367c394de23cfe78a029298e2a254\">https://github.com/aws/s2n-tls/commit/493b77167dc367c394de23cfe78a029298e2a254</a></li>\n<li><a href=\"https://github.com/aws/s2n-tls/releases/tag/v1.5.9\">https://github.com/aws/s2n-tls/releases/tag/v1.5.9</a></li>\n<li><a href=\"https://github.com/advisories/GHSA-rp9h-rf7g-hwgr\">https://github.com/advisories/GHSA-rp9h-rf7g-hwgr</a></li>\n</ul>\n",
            "url": "https://github.com/advisories/GHSA-rp9h-rf7g-hwgr",
            "title": "[s2n-tls] s2n-tls has undefined behavior at process exit",
            "date_modified": "2024-11-14T15:45:56.000Z",
            "date_published": "2024-11-14T15:45:55.000Z",
            "author": {
                "name": "GitHub",
                "url": "https://github.com/advisories/GHSA-rp9h-rf7g-hwgr"
            },
            "tags": [
                "severity"
            ]
        },
        {
            "content_html": "<p>This crate depended on a promise regarding alignments made by the author of the mimalloc allocator to avoid using aligned allocation functions where possible for performance reasons.\nSince then, the mimalloc allocator's logic changed, making it break this promise.\nThis caused this crate to return memory with an incorrect alignment for some allocations, particularly those with large alignments.\nThe flaw was fixed by always using the aligned allocation functions.</p>\n<h3 id=\"references\">References</h3>\n<ul>\n<li><a href=\"https://github.com/purpleprotocol/mimalloc_rust/issues/87\">https://github.com/purpleprotocol/mimalloc_rust/issues/87</a></li>\n<li><a href=\"https://rustsec.org/advisories/RUSTSEC-2022-0094.html\">https://rustsec.org/advisories/RUSTSEC-2022-0094.html</a></li>\n<li><a href=\"https://github.com/advisories/GHSA-g23h-7vf9-xc25\">https://github.com/advisories/GHSA-g23h-7vf9-xc25</a></li>\n</ul>\n",
            "url": "https://github.com/advisories/GHSA-g23h-7vf9-xc25",
            "title": "[mimalloc] Mimalloc Can Allocate Memory with Bad Alignment",
            "date_modified": "2024-11-12T21:21:37.000Z",
            "date_published": "2024-11-12T21:21:36.000Z",
            "author": {
                "name": "GitHub",
                "url": "https://github.com/advisories/GHSA-g23h-7vf9-xc25"
            },
            "tags": [
                "severity"
            ]
        },
        {
            "content_html": "<p>Challenge derivation in non-interactive ZK proofs was ambiguous and that could lead to security vulnerability (however, it's unknown if it could be exploited).</p>\n<h3 id=\"references\">References</h3>\n<ul>\n<li><a href=\"https://github.com/dfns/paillier-zk/pull/49\">https://github.com/dfns/paillier-zk/pull/49</a></li>\n<li><a href=\"https://rustsec.org/advisories/RUSTSEC-2024-0391.html\">https://rustsec.org/advisories/RUSTSEC-2024-0391.html</a></li>\n<li><a href=\"https://github.com/advisories/GHSA-fpr5-jp2j-4q2f\">https://github.com/advisories/GHSA-fpr5-jp2j-4q2f</a></li>\n</ul>\n",
            "url": "https://github.com/advisories/GHSA-fpr5-jp2j-4q2f",
            "title": "[paillier-zk] paillier-zk has ambiguous challenge derivation",
            "date_modified": "2024-11-12T21:20:27.000Z",
            "date_published": "2024-11-12T21:20:26.000Z",
            "author": {
                "name": "GitHub",
                "url": "https://github.com/advisories/GHSA-fpr5-jp2j-4q2f"
            },
            "tags": [
                "severity"
            ]
        },
        {
            "content_html": "<p>Challenge derivation in non-interactive ZK proofs was ambiguous and that could lead to security vulnerability (however, it's unknown if it could be exploited).</p>\n<h3 id=\"references\">References</h3>\n<ul>\n<li><a href=\"https://github.com/dfns/cggmp21/pull/103\">https://github.com/dfns/cggmp21/pull/103</a></li>\n<li><a href=\"https://rustsec.org/advisories/RUSTSEC-2024-0393.html\">https://rustsec.org/advisories/RUSTSEC-2024-0393.html</a></li>\n<li><a href=\"https://github.com/advisories/GHSA-rm66-9gh4-4gp8\">https://github.com/advisories/GHSA-rm66-9gh4-4gp8</a></li>\n</ul>\n",
            "url": "https://github.com/advisories/GHSA-rm66-9gh4-4gp8",
            "title": "[cggmp21] cggmp21 vulnerable to ambiguous challenge derivation",
            "date_modified": "2024-11-12T20:54:59.000Z",
            "date_published": "2024-11-12T20:54:58.000Z",
            "author": {
                "name": "GitHub",
                "url": "https://github.com/advisories/GHSA-rm66-9gh4-4gp8"
            },
            "tags": [
                "severity"
            ]
        },
        {
            "content_html": "<p>An invalid use of <code>MaybeUninit::uninit().assume_init()</code> in <code>simd-json-derive</code>'s derive macro can cause undefined behavior. The original code used <code>MaybeUninit</code> to avoid initialisation of the struct and then set the fields using <code>ptr::write</code>. The undefined behavior triggered by this misuse of <code>MaybeUninit</code> can lead to invlaid memory access and panics in binaries compiled in release mode (aka simd-json-derive prior to version 0.12 has UB and optimizes into some nonsense)</p>\n<p>The version <code>0.12.0</code> removes this section of code, avoiding the use of MaybeUninit alltogether.</p>\n<h3 id=\"references\">References</h3>\n<ul>\n<li><a href=\"https://github.com/simd-lite/simd-json-derive/issues/67\">https://github.com/simd-lite/simd-json-derive/issues/67</a></li>\n<li><a href=\"https://rustsec.org/advisories/RUSTSEC-2023-0087.html\">https://rustsec.org/advisories/RUSTSEC-2023-0087.html</a></li>\n<li><a href=\"https://github.com/advisories/GHSA-pqpw-89w5-82v5\">https://github.com/advisories/GHSA-pqpw-89w5-82v5</a></li>\n</ul>\n",
            "url": "https://github.com/advisories/GHSA-pqpw-89w5-82v5",
            "title": "[simd-json-derive] `simd-json-derive` vulnerable to `MaybeUninit` misuse",
            "date_modified": "2024-11-12T20:53:55.000Z",
            "date_published": "2024-11-12T20:53:54.000Z",
            "author": {
                "name": "GitHub",
                "url": "https://github.com/advisories/GHSA-pqpw-89w5-82v5"
            },
            "tags": [
                "severity"
            ]
        },
        {
            "content_html": "<p>Challenge derivation in non-interactive ZK proofs was ambiguous and that could lead to security vulnerability (however, it's unknown if it could be exploited).</p>\n<h3 id=\"references\">References</h3>\n<ul>\n<li><a href=\"https://github.com/dfns/cggmp21/pull/103\">https://github.com/dfns/cggmp21/pull/103</a></li>\n<li><a href=\"https://rustsec.org/advisories/RUSTSEC-2024-0392.html\">https://rustsec.org/advisories/RUSTSEC-2024-0392.html</a></li>\n<li><a href=\"https://github.com/advisories/GHSA-7jjx-3qw9-j6h6\">https://github.com/advisories/GHSA-7jjx-3qw9-j6h6</a></li>\n</ul>\n",
            "url": "https://github.com/advisories/GHSA-7jjx-3qw9-j6h6",
            "title": "[cggmp21-keygen] cggmp21-keygen has ambiguous challenge derivation",
            "date_modified": "2024-11-12T20:53:01.000Z",
            "date_published": "2024-11-12T20:53:00.000Z",
            "author": {
                "name": "GitHub",
                "url": "https://github.com/advisories/GHSA-7jjx-3qw9-j6h6"
            },
            "tags": [
                "severity"
            ]
        },
        {
            "content_html": "<p><code>fast-float</code> contains multiple soundness issues:</p>\n<ol>\n<li><a href=\"https://github.com/aldanor/fast-float-rust/issues/28\">Undefined behavior when checking input length</a>, which has been merged but no package <a href=\"https://github.com/aldanor/fast-float-rust/issues/35\">pubished</a>.</li>\n<li><a href=\"https://github.com/aldanor/fast-float-rust/issues/37\">Many functions marked as safe with non-local safety guarantees</a></li>\n</ol>\n<p>The library is also unmaintained.</p>\n<h2 id=\"alternatives\">Alternatives</h2>\n<p>For quickly parsing floating-point numbers third-party crates are generally no longer needed. A fast float parsing algorithm by the author of <code>lexical</code> has been <a href=\"https://github.com/rust-lang/rust/pull/86761\">merged</a> into libcore. When requiring direct parsing from bytes and/or partial parsers, the <a href=\"https://crates.io/crates/fast-float2\"><code>fast-float2</code></a> fork of <code>fast-float</code> containing these security patches and reduces overall usage of unsafe.</p>\n<h3 id=\"references\">References</h3>\n<ul>\n<li><a href=\"https://github.com/aldanor/fast-float-rust/issues/28\">https://github.com/aldanor/fast-float-rust/issues/28</a></li>\n<li><a href=\"https://github.com/aldanor/fast-float-rust/issues/35\">https://github.com/aldanor/fast-float-rust/issues/35</a></li>\n<li><a href=\"https://github.com/aldanor/fast-float-rust/issues/37\">https://github.com/aldanor/fast-float-rust/issues/37</a></li>\n<li><a href=\"https://rustsec.org/advisories/RUSTSEC-2024-0379.html\">https://rustsec.org/advisories/RUSTSEC-2024-0379.html</a></li>\n<li><a href=\"https://github.com/advisories/GHSA-x8jh-xj3x-gx3c\">https://github.com/advisories/GHSA-x8jh-xj3x-gx3c</a></li>\n</ul>\n",
            "url": "https://github.com/advisories/GHSA-x8jh-xj3x-gx3c",
            "title": "[fast-float] `fast-float` has multiple soundness issues",
            "date_modified": "2024-11-12T20:48:39.000Z",
            "date_published": "2024-11-12T20:48:39.000Z",
            "author": {
                "name": "GitHub",
                "url": "https://github.com/advisories/GHSA-x8jh-xj3x-gx3c"
            },
            "tags": [
                "severity"
            ]
        },
        {
            "content_html": "<p>wasm3 at commit 139076a contains a memory leak in the Read_utf8 function.</p>\n<h3 id=\"references\">References</h3>\n<ul>\n<li><a href=\"https://nvd.nist.gov/vuln/detail/CVE-2024-27529\">https://nvd.nist.gov/vuln/detail/CVE-2024-27529</a></li>\n<li><a href=\"https://github.com/wasm3/wasm3/issues/462\">https://github.com/wasm3/wasm3/issues/462</a></li>\n<li><a href=\"https://gist.github.com/haruki3hhh/ac70bd83b9c0ed1de6289d818488da78\">https://gist.github.com/haruki3hhh/ac70bd83b9c0ed1de6289d818488da78</a></li>\n<li><a href=\"https://github.com/wasm3/wasm3/pull/490\">https://github.com/wasm3/wasm3/pull/490</a></li>\n<li><a href=\"https://github.com/wasm3/wasm3/commit/526c1251b64e6e9fdc0d40c768ae46cd20338594\">https://github.com/wasm3/wasm3/commit/526c1251b64e6e9fdc0d40c768ae46cd20338594</a></li>\n<li><a href=\"https://github.com/advisories/GHSA-fmq6-4w57-2w3v\">https://github.com/advisories/GHSA-fmq6-4w57-2w3v</a></li>\n</ul>\n",
            "url": "https://github.com/advisories/GHSA-fmq6-4w57-2w3v",
            "title": "[wasm3] wasm3 uncontrolled memory allocation vulnerability",
            "date_modified": "2024-11-18T21:26:12.000Z",
            "date_published": "2024-11-09T00:30:42.000Z",
            "author": {
                "name": "GitHub",
                "url": "https://github.com/advisories/GHSA-fmq6-4w57-2w3v"
            },
            "tags": [
                "severity"
            ]
        },
        {
            "content_html": "<p>During proof generation, the prover must observe all values sent to the verifier to generate valid Fiat-Shamir challenges. Prior to v3.0.0 the cumulative sum of the permutation argument was not observed when sampling zeta, which is a random challenge sampled to force the constraints to be true. In v3.0.0, this is fixed by observing the cumulative sum into the challenger, which can is done by observing the commit to the entire permutation trace.</p>\n<p>While this vulnerability is theoretically present in v2.0.0 and below, exploiting it is quite a difficult task as the cumulative sum one can get from manipulation is essentially random. It requires practically infeasible amount of computation and deep knowledge of cryptographic attacks to carry out.</p>\n<p>This issue was discovered during the audit of SP1 V3.0.0 and was officially fixed on October 17th. Out of abundance of caution, we will be deprecating all versions of SP1 before 3.0.0.</p>\n<h3 id=\"references\">References</h3>\n<ul>\n<li><a href=\"https://github.com/succinctlabs/sp1/security/advisories/GHSA-8m24-3cfx-9fjw\">https://github.com/succinctlabs/sp1/security/advisories/GHSA-8m24-3cfx-9fjw</a></li>\n<li><a href=\"https://github.com/succinctlabs/sp1/commit/79884ffb1a2d10bfd2c272f864033577a052468a\">https://github.com/succinctlabs/sp1/commit/79884ffb1a2d10bfd2c272f864033577a052468a</a></li>\n<li><a href=\"https://github.com/advisories/GHSA-8m24-3cfx-9fjw\">https://github.com/advisories/GHSA-8m24-3cfx-9fjw</a></li>\n</ul>\n",
            "url": "https://github.com/advisories/GHSA-8m24-3cfx-9fjw",
            "title": "[sp1-recursion-circuit] sp1 has insufficient observation of cumulative sum",
            "date_modified": "2024-11-08T16:44:16.000Z",
            "date_published": "2024-11-08T16:44:15.000Z",
            "author": {
                "name": "GitHub",
                "url": "https://github.com/advisories/GHSA-8m24-3cfx-9fjw"
            },
            "tags": [
                "severity"
            ]
        },
        {
            "content_html": "<h3 id=\"impact\">Impact</h3>\n<p>Specially crafted Git repositories can cause <code>jj</code> to write files outside the clone.</p>\n<h3 id=\"patches\">Patches</h3>\n<p>Fixed in 0.23.0.</p>\n<h3 id=\"workarounds\">Workarounds</h3>\n<p>Not much other than to not clone repositories from untrusted sources.</p>\n<h3 id=\"references\">References</h3>\n<p>Here's the original report from @joernchen:</p>\n<blockquote>\n<p>When cloning a crafted Git repository it is possible to let <code>jj</code> write\ninto arbitrary directories. This can be achieved by having file objects\nwhich contain path traversals.</p>\n<p>Reproduction steps:</p>\n<p>Apply the following patch to Git version v.2.47.0:</p>\n<pre><code class=\"language-diff\">diff --git a/path.c b/path.c\nindex 93491bab14..2f47e69fd1 100644\n--- a/path.c\n+++ b/path.c\n@@ -44,11 +44,11 @@ struct strbuf *get_pathname(void)\n\n static const char *cleanup_path(const char *path)\n {\n-       /* Clean it up */\n+       /* Clean it up\n        if (skip_prefix(path, \"./\", &amp;path)) {\n                while (*path == '/')\n                        path++;\n-       }\n+       }*/\n        return path;\n }\n\n@@ -1101,7 +1101,9 @@ int normalize_path_copy_len(char *dst, const char *src, int *prefix_len)\n\n int normalize_path_copy(char *dst, const char *src)\n {\n-       return normalize_path_copy_len(dst, src, NULL);\n+//     return normalize_path_copy_len(dst, src, NULL);\n+       memcpy(dst, src, strlen(dst));\n+       return 0;\n }\n\n int strbuf_normalize_path(struct strbuf *src)\ndiff --git a/read-cache.c b/read-cache.c\nindex 3c078afadb..2eb44cb26f 100644\n--- a/read-cache.c\n+++ b/read-cache.c\n@@ -977,6 +977,7 @@ static enum verify_path_result verify_path_internal(const char *path,\n                                                    unsigned mode)\n {\n        char c = 0;\n+       return PATH_OK;\n\n        if (has_dos_drive_prefix(path))\n                return PATH_INVALID;\n</code></pre>\n<p>With this patched <code>git</code> binary we can now apply a crafted\npatch containing a path traversal to a repository.</p>\n<p>The patch would look like:</p>\n<pre><code class=\"language-patch\">From ecea96264bd3f9785e5ebec8640be4847ba28e22 Mon Sep 17 00:00:00 2001\nFrom: joernchen &lt;[joernchen@phenoelit.de](mailto:joernchen@phenoelit.de)&gt;\nDate: Sun, 13 Oct 2024 18:09:50 +0200\nSubject: [PATCH] z123\n\n---\n z | 0\n 1 file changed, 0 insertions(+), 0 deletions(-)\n create mode 100644 z\n\ndiff --git a/../joernchen_was_here b/../joernchen_was_here\nnew file mode 100644\nindex 0000000..e69de29\n--\n2.46.1\n</code></pre>\n<p>Note the traversal <code>../joernchen_was_here</code> in the patch. This now can be committed to a repository\nusing the modified <code>git</code> binary:</p>\n<pre><code class=\"language-bash\">mkdir demo\ncd demo\ngit init\n./path/to/modified/git/git --exec-path=./path/to/modified/git am the_traversal.patch\nrm ../joernchen_was_here # remove the file the modified git wrote\n</code></pre>\n<p>Now, when cloning that repository with <code>jj git clone</code> the path traversal will write above the worktree\ndirectory, allowing arbitrary file writes.</p>\n<p>I've attached a tar.gz with the demo repo so you don't have to mess with the patched Git at all. For\nreproduction it should be sufficient to do <code>jj git clone demo.git</code> after unpacking the tarball.</p>\n<p>The demo repository after being cloned with <code>jj</code> will create an empty file <code>joernchen_was_here</code> right next\nto the <code>demo</code> directory to demonstrate the traversal.</p>\n</blockquote>\n<h3 id=\"references-1\">References</h3>\n<ul>\n<li><a href=\"https://github.com/martinvonz/jj/security/advisories/GHSA-88h5-6w7m-5w56\">https://github.com/martinvonz/jj/security/advisories/GHSA-88h5-6w7m-5w56</a></li>\n<li><a href=\"https://nvd.nist.gov/vuln/detail/CVE-2024-51990\">https://nvd.nist.gov/vuln/detail/CVE-2024-51990</a></li>\n<li><a href=\"https://github.com/advisories/GHSA-88h5-6w7m-5w56\">https://github.com/advisories/GHSA-88h5-6w7m-5w56</a></li>\n</ul>\n",
            "url": "https://github.com/advisories/GHSA-88h5-6w7m-5w56",
            "title": "[jj-lib] jj vulnerable to path traversal via crafted Git repositories",
            "date_modified": "2024-11-07T16:18:47.000Z",
            "date_published": "2024-11-07T16:18:44.000Z",
            "author": {
                "name": "GitHub",
                "url": "https://github.com/advisories/GHSA-88h5-6w7m-5w56"
            },
            "tags": [
                "severity"
            ]
        },
        {
            "content_html": "<h3 id=\"impact\">Impact</h3>\n<p>cap-std's filesystem sandbox implementation on Windows blocks access to special device filenames such as \"COM1\", \"COM2\", \"LPT0\", \"LPT1\", and so on, however it did not block access to the special device filenames which use superscript digits, such as \"COM¹\", \"COM²\", \"LPT⁰\", \"LPT¹\", and so on. Untrusted filesystem paths could bypass the sandbox and access devices through those special device filenames with superscript digits, and through them provide access peripheral devices connected to the computer, or network resources mapped to those devices. This can include modems, printers, network printers, and any other device connected to a serial or parallel port, including emulated USB serial ports.</p>\n<h3 id=\"patches\">Patches</h3>\n<p>The bug is fixed in <a href=\"https://github.com/bytecodealliance/cap-std/pull/371\">https://github.com/bytecodealliance/cap-std/pull/371</a>, which is published in cap-primitives 3.4.1, cap-std 3.4.1, and cap-async-std 3.4.1.</p>\n<h3 id=\"workarounds\">Workarounds</h3>\n<p>There are no known workarounds for this issue. Affected Windows users are recommended to upgrade.</p>\n<h3 id=\"references\">References</h3>\n<ul>\n<li><a href=\"https://learn.microsoft.com/en-us/windows/win32/fileio/naming-a-file#naming-conventions\">Microsoft's documentation</a> of the special device filenames</li>\n<li><a href=\"https://en.wikipedia.org/wiki/ISO/IEC_8859-1\">ISO-8859-1</a></li>\n<li><a href=\"https://github.com/bytecodealliance/cap-std/pull/371\">https://github.com/bytecodealliance/cap-std/pull/371</a></li>\n</ul>\n<h3 id=\"references-1\">References</h3>\n<ul>\n<li><a href=\"https://github.com/bytecodealliance/cap-std/security/advisories/GHSA-hxf5-99xg-86hw\">https://github.com/bytecodealliance/cap-std/security/advisories/GHSA-hxf5-99xg-86hw</a></li>\n<li><a href=\"https://github.com/bytecodealliance/cap-std/pull/371\">https://github.com/bytecodealliance/cap-std/pull/371</a></li>\n<li><a href=\"https://en.wikipedia.org/wiki/ISO/IEC_8859-1\">https://en.wikipedia.org/wiki/ISO/IEC_8859-1</a></li>\n<li><a href=\"https://learn.microsoft.com/en-us/windows/win32/fileio/naming-a-file#naming-conventions\">https://learn.microsoft.com/en-us/windows/win32/fileio/naming-a-file#naming-conventions</a></li>\n<li><a href=\"https://nvd.nist.gov/vuln/detail/CVE-2024-51756\">https://nvd.nist.gov/vuln/detail/CVE-2024-51756</a></li>\n<li><a href=\"https://github.com/bytecodealliance/cap-std/commit/dcc3818039761331fbeacbb3a40c542b65b5ebf7\">https://github.com/bytecodealliance/cap-std/commit/dcc3818039761331fbeacbb3a40c542b65b5ebf7</a></li>\n<li><a href=\"https://github.com/advisories/GHSA-hxf5-99xg-86hw\">https://github.com/advisories/GHSA-hxf5-99xg-86hw</a></li>\n</ul>\n",
            "url": "https://github.com/advisories/GHSA-hxf5-99xg-86hw",
            "title": "[cap-primitives] cap-std doesn't fully sandbox all the Windows device filenames",
            "date_modified": "2024-11-06T14:28:27.000Z",
            "date_published": "2024-11-05T22:19:59.000Z",
            "author": {
                "name": "GitHub",
                "url": "https://github.com/advisories/GHSA-hxf5-99xg-86hw"
            },
            "tags": [
                "severity"
            ]
        },
        {
            "content_html": "<h3 id=\"impact\">Impact</h3>\n<p>cap-std's filesystem sandbox implementation on Windows blocks access to special device filenames such as \"COM1\", \"COM2\", \"LPT0\", \"LPT1\", and so on, however it did not block access to the special device filenames which use superscript digits, such as \"COM¹\", \"COM²\", \"LPT⁰\", \"LPT¹\", and so on. Untrusted filesystem paths could bypass the sandbox and access devices through those special device filenames with superscript digits, and through them provide access peripheral devices connected to the computer, or network resources mapped to those devices. This can include modems, printers, network printers, and any other device connected to a serial or parallel port, including emulated USB serial ports.</p>\n<h3 id=\"patches\">Patches</h3>\n<p>The bug is fixed in <a href=\"https://github.com/bytecodealliance/cap-std/pull/371\">https://github.com/bytecodealliance/cap-std/pull/371</a>, which is published in cap-primitives 3.4.1, cap-std 3.4.1, and cap-async-std 3.4.1.</p>\n<h3 id=\"workarounds\">Workarounds</h3>\n<p>There are no known workarounds for this issue. Affected Windows users are recommended to upgrade.</p>\n<h3 id=\"references\">References</h3>\n<ul>\n<li><a href=\"https://learn.microsoft.com/en-us/windows/win32/fileio/naming-a-file#naming-conventions\">Microsoft's documentation</a> of the special device filenames</li>\n<li><a href=\"https://en.wikipedia.org/wiki/ISO/IEC_8859-1\">ISO-8859-1</a></li>\n<li><a href=\"https://github.com/bytecodealliance/cap-std/pull/371\">https://github.com/bytecodealliance/cap-std/pull/371</a></li>\n</ul>\n<h3 id=\"references-1\">References</h3>\n<ul>\n<li><a href=\"https://github.com/bytecodealliance/cap-std/security/advisories/GHSA-hxf5-99xg-86hw\">https://github.com/bytecodealliance/cap-std/security/advisories/GHSA-hxf5-99xg-86hw</a></li>\n<li><a href=\"https://github.com/bytecodealliance/cap-std/pull/371\">https://github.com/bytecodealliance/cap-std/pull/371</a></li>\n<li><a href=\"https://en.wikipedia.org/wiki/ISO/IEC_8859-1\">https://en.wikipedia.org/wiki/ISO/IEC_8859-1</a></li>\n<li><a href=\"https://learn.microsoft.com/en-us/windows/win32/fileio/naming-a-file#naming-conventions\">https://learn.microsoft.com/en-us/windows/win32/fileio/naming-a-file#naming-conventions</a></li>\n<li><a href=\"https://nvd.nist.gov/vuln/detail/CVE-2024-51756\">https://nvd.nist.gov/vuln/detail/CVE-2024-51756</a></li>\n<li><a href=\"https://github.com/bytecodealliance/cap-std/commit/dcc3818039761331fbeacbb3a40c542b65b5ebf7\">https://github.com/bytecodealliance/cap-std/commit/dcc3818039761331fbeacbb3a40c542b65b5ebf7</a></li>\n<li><a href=\"https://github.com/advisories/GHSA-hxf5-99xg-86hw\">https://github.com/advisories/GHSA-hxf5-99xg-86hw</a></li>\n</ul>\n",
            "url": "https://github.com/advisories/GHSA-hxf5-99xg-86hw",
            "title": "[cap-async-std] cap-std doesn't fully sandbox all the Windows device filenames",
            "date_modified": "2024-11-06T14:28:27.000Z",
            "date_published": "2024-11-05T22:19:59.000Z",
            "author": {
                "name": "GitHub",
                "url": "https://github.com/advisories/GHSA-hxf5-99xg-86hw"
            },
            "tags": [
                "severity"
            ]
        },
        {
            "content_html": "<h3 id=\"impact\">Impact</h3>\n<p>cap-std's filesystem sandbox implementation on Windows blocks access to special device filenames such as \"COM1\", \"COM2\", \"LPT0\", \"LPT1\", and so on, however it did not block access to the special device filenames which use superscript digits, such as \"COM¹\", \"COM²\", \"LPT⁰\", \"LPT¹\", and so on. Untrusted filesystem paths could bypass the sandbox and access devices through those special device filenames with superscript digits, and through them provide access peripheral devices connected to the computer, or network resources mapped to those devices. This can include modems, printers, network printers, and any other device connected to a serial or parallel port, including emulated USB serial ports.</p>\n<h3 id=\"patches\">Patches</h3>\n<p>The bug is fixed in <a href=\"https://github.com/bytecodealliance/cap-std/pull/371\">https://github.com/bytecodealliance/cap-std/pull/371</a>, which is published in cap-primitives 3.4.1, cap-std 3.4.1, and cap-async-std 3.4.1.</p>\n<h3 id=\"workarounds\">Workarounds</h3>\n<p>There are no known workarounds for this issue. Affected Windows users are recommended to upgrade.</p>\n<h3 id=\"references\">References</h3>\n<ul>\n<li><a href=\"https://learn.microsoft.com/en-us/windows/win32/fileio/naming-a-file#naming-conventions\">Microsoft's documentation</a> of the special device filenames</li>\n<li><a href=\"https://en.wikipedia.org/wiki/ISO/IEC_8859-1\">ISO-8859-1</a></li>\n<li><a href=\"https://github.com/bytecodealliance/cap-std/pull/371\">https://github.com/bytecodealliance/cap-std/pull/371</a></li>\n</ul>\n<h3 id=\"references-1\">References</h3>\n<ul>\n<li><a href=\"https://github.com/bytecodealliance/cap-std/security/advisories/GHSA-hxf5-99xg-86hw\">https://github.com/bytecodealliance/cap-std/security/advisories/GHSA-hxf5-99xg-86hw</a></li>\n<li><a href=\"https://github.com/bytecodealliance/cap-std/pull/371\">https://github.com/bytecodealliance/cap-std/pull/371</a></li>\n<li><a href=\"https://en.wikipedia.org/wiki/ISO/IEC_8859-1\">https://en.wikipedia.org/wiki/ISO/IEC_8859-1</a></li>\n<li><a href=\"https://learn.microsoft.com/en-us/windows/win32/fileio/naming-a-file#naming-conventions\">https://learn.microsoft.com/en-us/windows/win32/fileio/naming-a-file#naming-conventions</a></li>\n<li><a href=\"https://nvd.nist.gov/vuln/detail/CVE-2024-51756\">https://nvd.nist.gov/vuln/detail/CVE-2024-51756</a></li>\n<li><a href=\"https://github.com/bytecodealliance/cap-std/commit/dcc3818039761331fbeacbb3a40c542b65b5ebf7\">https://github.com/bytecodealliance/cap-std/commit/dcc3818039761331fbeacbb3a40c542b65b5ebf7</a></li>\n<li><a href=\"https://github.com/advisories/GHSA-hxf5-99xg-86hw\">https://github.com/advisories/GHSA-hxf5-99xg-86hw</a></li>\n</ul>\n",
            "url": "https://github.com/advisories/GHSA-hxf5-99xg-86hw",
            "title": "[cap-std] cap-std doesn't fully sandbox all the Windows device filenames",
            "date_modified": "2024-11-06T14:28:27.000Z",
            "date_published": "2024-11-05T22:19:59.000Z",
            "author": {
                "name": "GitHub",
                "url": "https://github.com/advisories/GHSA-hxf5-99xg-86hw"
            },
            "tags": [
                "severity"
            ]
        },
        {
            "content_html": "<h3 id=\"impact\">Impact</h3>\n<p>Wasmtime's filesystem sandbox implementation on Windows blocks access to special device filenames such as \"COM1\", \"COM2\", \"LPT0\", \"LPT1\", and so on, however it did not block access to the special device filenames which use superscript digits, such as \"COM¹\", \"COM²\", \"LPT⁰\", \"LPT¹\", and so on. Untrusted Wasm programs that are given access to any filesystem directory could bypass the sandbox and access devices through those special device filenames with superscript digits, and through them gain access peripheral devices connected to the computer, or network resources mapped to those devices. This can include modems, printers, network printers, and any other device connected to a serial or parallel port, including emulated USB serial ports.</p>\n<h3 id=\"patches\">Patches</h3>\n<p>Patch releases for Wasmtime have been issued as 24.0.2, 25.0.3, and 26.0.1. Users of Wasmtime 23.0.x and prior are recommended to upgrade to one of these patched versions.</p>\n<h3 id=\"workarounds\">Workarounds</h3>\n<p>There are no known workarounds for this issue. Affected Windows users are recommended to upgrade.</p>\n<h3 id=\"references\">References</h3>\n<ul>\n<li><a href=\"https://learn.microsoft.com/en-us/windows/win32/fileio/naming-a-file#naming-conventions\">Microsoft's documentation</a> of the special device filenames</li>\n<li><a href=\"https://en.wikipedia.org/wiki/ISO/IEC_8859-1\">ISO-8859-1</a></li>\n<li><a href=\"https://github.com/bytecodealliance/cap-std/pull/371\">The original PR reporting the issue</a></li>\n</ul>\n<h3 id=\"references-1\">References</h3>\n<ul>\n<li><a href=\"https://github.com/bytecodealliance/wasmtime/security/advisories/GHSA-c2f5-jxjv-2hh8\">https://github.com/bytecodealliance/wasmtime/security/advisories/GHSA-c2f5-jxjv-2hh8</a></li>\n<li><a href=\"https://github.com/bytecodealliance/cap-std/pull/371\">https://github.com/bytecodealliance/cap-std/pull/371</a></li>\n<li><a href=\"https://en.wikipedia.org/wiki/ISO/IEC_8859-1\">https://en.wikipedia.org/wiki/ISO/IEC_8859-1</a></li>\n<li><a href=\"https://learn.microsoft.com/en-us/windows/win32/fileio/naming-a-file#naming-conventions\">https://learn.microsoft.com/en-us/windows/win32/fileio/naming-a-file#naming-conventions</a></li>\n<li><a href=\"https://nvd.nist.gov/vuln/detail/CVE-2024-51745\">https://nvd.nist.gov/vuln/detail/CVE-2024-51745</a></li>\n<li><a href=\"https://github.com/advisories/GHSA-c2f5-jxjv-2hh8\">https://github.com/advisories/GHSA-c2f5-jxjv-2hh8</a></li>\n</ul>\n",
            "url": "https://github.com/advisories/GHSA-c2f5-jxjv-2hh8",
            "title": "[wasmtime] Wasmtime doesn't fully sandbox all the Windows device filenames",
            "date_modified": "2024-11-06T14:28:17.000Z",
            "date_published": "2024-11-05T22:18:49.000Z",
            "author": {
                "name": "GitHub",
                "url": "https://github.com/advisories/GHSA-c2f5-jxjv-2hh8"
            },
            "tags": [
                "severity"
            ]
        },
        {
            "content_html": "<h3 id=\"impact\">Impact</h3>\n<p>Wasmtime's filesystem sandbox implementation on Windows blocks access to special device filenames such as \"COM1\", \"COM2\", \"LPT0\", \"LPT1\", and so on, however it did not block access to the special device filenames which use superscript digits, such as \"COM¹\", \"COM²\", \"LPT⁰\", \"LPT¹\", and so on. Untrusted Wasm programs that are given access to any filesystem directory could bypass the sandbox and access devices through those special device filenames with superscript digits, and through them gain access peripheral devices connected to the computer, or network resources mapped to those devices. This can include modems, printers, network printers, and any other device connected to a serial or parallel port, including emulated USB serial ports.</p>\n<h3 id=\"patches\">Patches</h3>\n<p>Patch releases for Wasmtime have been issued as 24.0.2, 25.0.3, and 26.0.1. Users of Wasmtime 23.0.x and prior are recommended to upgrade to one of these patched versions.</p>\n<h3 id=\"workarounds\">Workarounds</h3>\n<p>There are no known workarounds for this issue. Affected Windows users are recommended to upgrade.</p>\n<h3 id=\"references\">References</h3>\n<ul>\n<li><a href=\"https://learn.microsoft.com/en-us/windows/win32/fileio/naming-a-file#naming-conventions\">Microsoft's documentation</a> of the special device filenames</li>\n<li><a href=\"https://en.wikipedia.org/wiki/ISO/IEC_8859-1\">ISO-8859-1</a></li>\n<li><a href=\"https://github.com/bytecodealliance/cap-std/pull/371\">The original PR reporting the issue</a></li>\n</ul>\n<h3 id=\"references-1\">References</h3>\n<ul>\n<li><a href=\"https://github.com/bytecodealliance/wasmtime/security/advisories/GHSA-c2f5-jxjv-2hh8\">https://github.com/bytecodealliance/wasmtime/security/advisories/GHSA-c2f5-jxjv-2hh8</a></li>\n<li><a href=\"https://github.com/bytecodealliance/cap-std/pull/371\">https://github.com/bytecodealliance/cap-std/pull/371</a></li>\n<li><a href=\"https://en.wikipedia.org/wiki/ISO/IEC_8859-1\">https://en.wikipedia.org/wiki/ISO/IEC_8859-1</a></li>\n<li><a href=\"https://learn.microsoft.com/en-us/windows/win32/fileio/naming-a-file#naming-conventions\">https://learn.microsoft.com/en-us/windows/win32/fileio/naming-a-file#naming-conventions</a></li>\n<li><a href=\"https://nvd.nist.gov/vuln/detail/CVE-2024-51745\">https://nvd.nist.gov/vuln/detail/CVE-2024-51745</a></li>\n<li><a href=\"https://github.com/advisories/GHSA-c2f5-jxjv-2hh8\">https://github.com/advisories/GHSA-c2f5-jxjv-2hh8</a></li>\n</ul>\n",
            "url": "https://github.com/advisories/GHSA-c2f5-jxjv-2hh8",
            "title": "[wasmtime] Wasmtime doesn't fully sandbox all the Windows device filenames",
            "date_modified": "2024-11-06T14:28:17.000Z",
            "date_published": "2024-11-05T22:18:49.000Z",
            "author": {
                "name": "GitHub",
                "url": "https://github.com/advisories/GHSA-c2f5-jxjv-2hh8"
            },
            "tags": [
                "severity"
            ]
        },
        {
            "content_html": "<h3 id=\"impact\">Impact</h3>\n<p>Wasmtime's filesystem sandbox implementation on Windows blocks access to special device filenames such as \"COM1\", \"COM2\", \"LPT0\", \"LPT1\", and so on, however it did not block access to the special device filenames which use superscript digits, such as \"COM¹\", \"COM²\", \"LPT⁰\", \"LPT¹\", and so on. Untrusted Wasm programs that are given access to any filesystem directory could bypass the sandbox and access devices through those special device filenames with superscript digits, and through them gain access peripheral devices connected to the computer, or network resources mapped to those devices. This can include modems, printers, network printers, and any other device connected to a serial or parallel port, including emulated USB serial ports.</p>\n<h3 id=\"patches\">Patches</h3>\n<p>Patch releases for Wasmtime have been issued as 24.0.2, 25.0.3, and 26.0.1. Users of Wasmtime 23.0.x and prior are recommended to upgrade to one of these patched versions.</p>\n<h3 id=\"workarounds\">Workarounds</h3>\n<p>There are no known workarounds for this issue. Affected Windows users are recommended to upgrade.</p>\n<h3 id=\"references\">References</h3>\n<ul>\n<li><a href=\"https://learn.microsoft.com/en-us/windows/win32/fileio/naming-a-file#naming-conventions\">Microsoft's documentation</a> of the special device filenames</li>\n<li><a href=\"https://en.wikipedia.org/wiki/ISO/IEC_8859-1\">ISO-8859-1</a></li>\n<li><a href=\"https://github.com/bytecodealliance/cap-std/pull/371\">The original PR reporting the issue</a></li>\n</ul>\n<h3 id=\"references-1\">References</h3>\n<ul>\n<li><a href=\"https://github.com/bytecodealliance/wasmtime/security/advisories/GHSA-c2f5-jxjv-2hh8\">https://github.com/bytecodealliance/wasmtime/security/advisories/GHSA-c2f5-jxjv-2hh8</a></li>\n<li><a href=\"https://github.com/bytecodealliance/cap-std/pull/371\">https://github.com/bytecodealliance/cap-std/pull/371</a></li>\n<li><a href=\"https://en.wikipedia.org/wiki/ISO/IEC_8859-1\">https://en.wikipedia.org/wiki/ISO/IEC_8859-1</a></li>\n<li><a href=\"https://learn.microsoft.com/en-us/windows/win32/fileio/naming-a-file#naming-conventions\">https://learn.microsoft.com/en-us/windows/win32/fileio/naming-a-file#naming-conventions</a></li>\n<li><a href=\"https://nvd.nist.gov/vuln/detail/CVE-2024-51745\">https://nvd.nist.gov/vuln/detail/CVE-2024-51745</a></li>\n<li><a href=\"https://github.com/advisories/GHSA-c2f5-jxjv-2hh8\">https://github.com/advisories/GHSA-c2f5-jxjv-2hh8</a></li>\n</ul>\n",
            "url": "https://github.com/advisories/GHSA-c2f5-jxjv-2hh8",
            "title": "[wasmtime] Wasmtime doesn't fully sandbox all the Windows device filenames",
            "date_modified": "2024-11-06T14:28:17.000Z",
            "date_published": "2024-11-05T22:18:49.000Z",
            "author": {
                "name": "GitHub",
                "url": "https://github.com/advisories/GHSA-c2f5-jxjv-2hh8"
            },
            "tags": [
                "severity"
            ]
        }
    ]
}