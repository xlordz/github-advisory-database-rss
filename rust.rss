<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://azu.github.io/github-advisory-database-rss/rust.rss</id>
    <title>Security Advisory for Rust crates</title>
    <updated>2024-11-15T15:01:32.257Z</updated>
    <generator>github-advisory-database-rss</generator>
    <link rel="alternate" href="https://github.com/advisories?query=type%3Areviewed+ecosystem%3Arust"/>
    <subtitle>Security Advisory for Rust crates on GitHub</subtitle>
    <rights>github-advisory-database-rss</rights>
    <category term="CRITICAL"/>
    <category term="HIGH"/>
    <category term="MODERATE"/>
    <category term="LOW"/>
    <entry>
        <title type="html"><![CDATA[[libz-rs-sys-cdylib] zlib-rs stack overflow during decompression with malicious input]]></title>
        <id>https://github.com/advisories/GHSA-j3px-q95c-9683</id>
        <link href="https://github.com/advisories/GHSA-j3px-q95c-9683"/>
        <updated>2024-11-14T18:09:34.000Z</updated>
        <content type="html"><![CDATA[<p>A denial of service vulnerability was found in zlib-rs, triggered by specially constructed input. This input causes a stack overflow, resulting in the process using zlib-rs to crash.</p>
<h3 id="impact">Impact</h3>
<p>Due to the way LLVM handles the zlib-rs codebase, tail calls were not guaranteed. This caused certain input patterns to result in a large number of stack frames being required, quickly resulting in a stack overflow. These are unlikely to occur in practice, but a dedicated attacker can construct malicious input files.</p>
<p>After stack overflows were found by @inahga with a fuzzer, we dove into the assembly, and found some cases where the stack grew</p>
<pre><code class="language-asm">.LBB109_326:
    mov rdi, rbx
    call zlib_rs::inflate::State::type_do
    jmp .LBB109_311

.LBB109_311:
    lea rsp, [rbp - 40]
    pop rbx
    pop r12
    pop r13
    pop r14
    pop r15
    pop rbp
    .cfi_def_cfa rsp, 8
    ret
</code></pre>
<p>LLVM wants to centralize the cleanup before the return (many other blocks jump to <code>LBB109_311</code>), thereby invalidating a tail call to <code>type_do</code>. We were not able to get rid of this call without introducing one elsewhere: we just don't currently have the power to tell LLVM what we want it to do.</p>
<p>So, we switch back to loop+match waiting for changes to rust to make a more efficient implementation possible. Performance-wise, the damage is relatively minimal: we're just slower in cases where we already were slower than C. We are faster in cases where the relevant code is barely touched (in these cases the logic quickly moves into a hot inner loop and just spends most of its time there).</p>
<h3 id="patches">Patches</h3>
<p>Version 0.4.0 patches the problem and is no longer vulnerable.</p>
<h3 id="workarounds">Workarounds</h3>
<p>Users of zlib-rs should upgrade to the latest version. Users could alternatively run zlib-rs in a separate process to prevent a stack overflow crashing the entire program. In some situations a signal handler can be used to catch a stack overflow happening.</p>
<h3 id="references">References</h3>
<ul>
<li><a href="https://github.com/trifectatechfoundation/zlib-rs/security/advisories/GHSA-j3px-q95c-9683">https://github.com/trifectatechfoundation/zlib-rs/security/advisories/GHSA-j3px-q95c-9683</a></li>
<li><a href="https://github.com/advisories/GHSA-j3px-q95c-9683">https://github.com/advisories/GHSA-j3px-q95c-9683</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-j3px-q95c-9683</uri>
        </author>
        <category label="severity" term="MODERATE"/>
        <published>2024-11-14T18:09:33.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[[libz-rs-sys] zlib-rs stack overflow during decompression with malicious input]]></title>
        <id>https://github.com/advisories/GHSA-j3px-q95c-9683</id>
        <link href="https://github.com/advisories/GHSA-j3px-q95c-9683"/>
        <updated>2024-11-14T18:09:34.000Z</updated>
        <content type="html"><![CDATA[<p>A denial of service vulnerability was found in zlib-rs, triggered by specially constructed input. This input causes a stack overflow, resulting in the process using zlib-rs to crash.</p>
<h3 id="impact">Impact</h3>
<p>Due to the way LLVM handles the zlib-rs codebase, tail calls were not guaranteed. This caused certain input patterns to result in a large number of stack frames being required, quickly resulting in a stack overflow. These are unlikely to occur in practice, but a dedicated attacker can construct malicious input files.</p>
<p>After stack overflows were found by @inahga with a fuzzer, we dove into the assembly, and found some cases where the stack grew</p>
<pre><code class="language-asm">.LBB109_326:
    mov rdi, rbx
    call zlib_rs::inflate::State::type_do
    jmp .LBB109_311

.LBB109_311:
    lea rsp, [rbp - 40]
    pop rbx
    pop r12
    pop r13
    pop r14
    pop r15
    pop rbp
    .cfi_def_cfa rsp, 8
    ret
</code></pre>
<p>LLVM wants to centralize the cleanup before the return (many other blocks jump to <code>LBB109_311</code>), thereby invalidating a tail call to <code>type_do</code>. We were not able to get rid of this call without introducing one elsewhere: we just don't currently have the power to tell LLVM what we want it to do.</p>
<p>So, we switch back to loop+match waiting for changes to rust to make a more efficient implementation possible. Performance-wise, the damage is relatively minimal: we're just slower in cases where we already were slower than C. We are faster in cases where the relevant code is barely touched (in these cases the logic quickly moves into a hot inner loop and just spends most of its time there).</p>
<h3 id="patches">Patches</h3>
<p>Version 0.4.0 patches the problem and is no longer vulnerable.</p>
<h3 id="workarounds">Workarounds</h3>
<p>Users of zlib-rs should upgrade to the latest version. Users could alternatively run zlib-rs in a separate process to prevent a stack overflow crashing the entire program. In some situations a signal handler can be used to catch a stack overflow happening.</p>
<h3 id="references">References</h3>
<ul>
<li><a href="https://github.com/trifectatechfoundation/zlib-rs/security/advisories/GHSA-j3px-q95c-9683">https://github.com/trifectatechfoundation/zlib-rs/security/advisories/GHSA-j3px-q95c-9683</a></li>
<li><a href="https://github.com/advisories/GHSA-j3px-q95c-9683">https://github.com/advisories/GHSA-j3px-q95c-9683</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-j3px-q95c-9683</uri>
        </author>
        <category label="severity" term="MODERATE"/>
        <published>2024-11-14T18:09:33.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[[zlib-rs] zlib-rs stack overflow during decompression with malicious input]]></title>
        <id>https://github.com/advisories/GHSA-j3px-q95c-9683</id>
        <link href="https://github.com/advisories/GHSA-j3px-q95c-9683"/>
        <updated>2024-11-14T18:09:34.000Z</updated>
        <content type="html"><![CDATA[<p>A denial of service vulnerability was found in zlib-rs, triggered by specially constructed input. This input causes a stack overflow, resulting in the process using zlib-rs to crash.</p>
<h3 id="impact">Impact</h3>
<p>Due to the way LLVM handles the zlib-rs codebase, tail calls were not guaranteed. This caused certain input patterns to result in a large number of stack frames being required, quickly resulting in a stack overflow. These are unlikely to occur in practice, but a dedicated attacker can construct malicious input files.</p>
<p>After stack overflows were found by @inahga with a fuzzer, we dove into the assembly, and found some cases where the stack grew</p>
<pre><code class="language-asm">.LBB109_326:
    mov rdi, rbx
    call zlib_rs::inflate::State::type_do
    jmp .LBB109_311

.LBB109_311:
    lea rsp, [rbp - 40]
    pop rbx
    pop r12
    pop r13
    pop r14
    pop r15
    pop rbp
    .cfi_def_cfa rsp, 8
    ret
</code></pre>
<p>LLVM wants to centralize the cleanup before the return (many other blocks jump to <code>LBB109_311</code>), thereby invalidating a tail call to <code>type_do</code>. We were not able to get rid of this call without introducing one elsewhere: we just don't currently have the power to tell LLVM what we want it to do.</p>
<p>So, we switch back to loop+match waiting for changes to rust to make a more efficient implementation possible. Performance-wise, the damage is relatively minimal: we're just slower in cases where we already were slower than C. We are faster in cases where the relevant code is barely touched (in these cases the logic quickly moves into a hot inner loop and just spends most of its time there).</p>
<h3 id="patches">Patches</h3>
<p>Version 0.4.0 patches the problem and is no longer vulnerable.</p>
<h3 id="workarounds">Workarounds</h3>
<p>Users of zlib-rs should upgrade to the latest version. Users could alternatively run zlib-rs in a separate process to prevent a stack overflow crashing the entire program. In some situations a signal handler can be used to catch a stack overflow happening.</p>
<h3 id="references">References</h3>
<ul>
<li><a href="https://github.com/trifectatechfoundation/zlib-rs/security/advisories/GHSA-j3px-q95c-9683">https://github.com/trifectatechfoundation/zlib-rs/security/advisories/GHSA-j3px-q95c-9683</a></li>
<li><a href="https://github.com/advisories/GHSA-j3px-q95c-9683">https://github.com/advisories/GHSA-j3px-q95c-9683</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-j3px-q95c-9683</uri>
        </author>
        <category label="severity" term="MODERATE"/>
        <published>2024-11-14T18:09:33.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[[s2n-tls] s2n-tls has undefined behavior at process exit]]></title>
        <id>https://github.com/advisories/GHSA-rp9h-rf7g-hwgr</id>
        <link href="https://github.com/advisories/GHSA-rp9h-rf7g-hwgr"/>
        <updated>2024-11-14T15:45:56.000Z</updated>
        <content type="html"><![CDATA[<h3 id="impact">Impact</h3>
<p>s2n-tls uses the Linux atexit function to register functions that clean up the global state when the process exits. In multi-threaded environments, the atexit handler may clean up state which is still in use by other threads. When this occurs, the exiting process may experience a segmentation fault or other undefined behavior. </p>
<p>Customers of AWS services do not need to take action. Applications using s2n-tls should upgrade to the most recent release of s2n-tls.</p>
<p><strong>Impacted versions</strong>: &lt; v1.5.9.</p>
<h3 id="patches">Patches</h3>
<p>The patch commit <a href="https://github.com/aws/s2n-tls/commit/493b77167dc367c394de23cfe78a029298e2a254">493b771</a> is included in s2n-tls v1.5.9 [1]</p>
<h3 id="workarounds">Workarounds</h3>
<p>The atexit handler may be disabled by calling <code>s2n_disable_atexit()</code> prior to initializing s2n-tls. The atexit handler is off by default in the patched versions. For further details, refer to <a href="https://github.com/aws/s2n-tls/blob/main/docs/usage-guide/topics/ch02-initialization.md">s2n-tls Usage Guide: Initialization and Teardown</a>.</p>
<p>If you have any questions or comments about this advisory, we ask that you contact AWS/Amazon Security via our vulnerability reporting page [2] or directly via email to <a href="mailto:aws-security@amazon.com">aws-security@amazon.com</a>. Please do not create a public GitHub issue.</p>
<p>[1] <a href="https://github.com/aws/s2n-tls/releases/tag/v1.5.9">https://github.com/aws/s2n-tls/releases/tag/v1.5.9</a>
[2] Vulnerability reporting page: <a href="https://aws.amazon.com/security/vulnerability-reporting">https://aws.amazon.com/security/vulnerability-reporting</a></p>
<h3 id="references">References</h3>
<ul>
<li><a href="https://github.com/aws/s2n-tls/security/advisories/GHSA-rp9h-rf7g-hwgr">https://github.com/aws/s2n-tls/security/advisories/GHSA-rp9h-rf7g-hwgr</a></li>
<li><a href="https://github.com/aws/s2n-tls/commit/493b77167dc367c394de23cfe78a029298e2a254">https://github.com/aws/s2n-tls/commit/493b77167dc367c394de23cfe78a029298e2a254</a></li>
<li><a href="https://github.com/aws/s2n-tls/releases/tag/v1.5.9">https://github.com/aws/s2n-tls/releases/tag/v1.5.9</a></li>
<li><a href="https://github.com/advisories/GHSA-rp9h-rf7g-hwgr">https://github.com/advisories/GHSA-rp9h-rf7g-hwgr</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-rp9h-rf7g-hwgr</uri>
        </author>
        <category label="severity" term="LOW"/>
        <published>2024-11-14T15:45:55.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[[mimalloc] Mimalloc Can Allocate Memory with Bad Alignment]]></title>
        <id>https://github.com/advisories/GHSA-g23h-7vf9-xc25</id>
        <link href="https://github.com/advisories/GHSA-g23h-7vf9-xc25"/>
        <updated>2024-11-12T21:21:37.000Z</updated>
        <content type="html"><![CDATA[<p>This crate depended on a promise regarding alignments made by the author of the mimalloc allocator to avoid using aligned allocation functions where possible for performance reasons.
Since then, the mimalloc allocator's logic changed, making it break this promise.
This caused this crate to return memory with an incorrect alignment for some allocations, particularly those with large alignments.
The flaw was fixed by always using the aligned allocation functions.</p>
<h3 id="references">References</h3>
<ul>
<li><a href="https://github.com/purpleprotocol/mimalloc_rust/issues/87">https://github.com/purpleprotocol/mimalloc_rust/issues/87</a></li>
<li><a href="https://rustsec.org/advisories/RUSTSEC-2022-0094.html">https://rustsec.org/advisories/RUSTSEC-2022-0094.html</a></li>
<li><a href="https://github.com/advisories/GHSA-g23h-7vf9-xc25">https://github.com/advisories/GHSA-g23h-7vf9-xc25</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-g23h-7vf9-xc25</uri>
        </author>
        <category label="severity" term="MODERATE"/>
        <published>2024-11-12T21:21:36.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[[paillier-zk] paillier-zk has ambiguous challenge derivation]]></title>
        <id>https://github.com/advisories/GHSA-fpr5-jp2j-4q2f</id>
        <link href="https://github.com/advisories/GHSA-fpr5-jp2j-4q2f"/>
        <updated>2024-11-12T21:20:27.000Z</updated>
        <content type="html"><![CDATA[<p>Challenge derivation in non-interactive ZK proofs was ambiguous and that could lead to security vulnerability (however, it's unknown if it could be exploited).</p>
<h3 id="references">References</h3>
<ul>
<li><a href="https://github.com/dfns/paillier-zk/pull/49">https://github.com/dfns/paillier-zk/pull/49</a></li>
<li><a href="https://rustsec.org/advisories/RUSTSEC-2024-0391.html">https://rustsec.org/advisories/RUSTSEC-2024-0391.html</a></li>
<li><a href="https://github.com/advisories/GHSA-fpr5-jp2j-4q2f">https://github.com/advisories/GHSA-fpr5-jp2j-4q2f</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-fpr5-jp2j-4q2f</uri>
        </author>
        <category label="severity" term="LOW"/>
        <published>2024-11-12T21:20:26.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[[cggmp21] cggmp21 vulnerable to ambiguous challenge derivation]]></title>
        <id>https://github.com/advisories/GHSA-rm66-9gh4-4gp8</id>
        <link href="https://github.com/advisories/GHSA-rm66-9gh4-4gp8"/>
        <updated>2024-11-12T20:54:59.000Z</updated>
        <content type="html"><![CDATA[<p>Challenge derivation in non-interactive ZK proofs was ambiguous and that could lead to security vulnerability (however, it's unknown if it could be exploited).</p>
<h3 id="references">References</h3>
<ul>
<li><a href="https://github.com/dfns/cggmp21/pull/103">https://github.com/dfns/cggmp21/pull/103</a></li>
<li><a href="https://rustsec.org/advisories/RUSTSEC-2024-0393.html">https://rustsec.org/advisories/RUSTSEC-2024-0393.html</a></li>
<li><a href="https://github.com/advisories/GHSA-rm66-9gh4-4gp8">https://github.com/advisories/GHSA-rm66-9gh4-4gp8</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-rm66-9gh4-4gp8</uri>
        </author>
        <category label="severity" term="LOW"/>
        <published>2024-11-12T20:54:58.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[[simd-json-derive] `simd-json-derive` vulnerable to `MaybeUninit` misuse]]></title>
        <id>https://github.com/advisories/GHSA-pqpw-89w5-82v5</id>
        <link href="https://github.com/advisories/GHSA-pqpw-89w5-82v5"/>
        <updated>2024-11-12T20:53:55.000Z</updated>
        <content type="html"><![CDATA[<p>An invalid use of <code>MaybeUninit::uninit().assume_init()</code> in <code>simd-json-derive</code>'s derive macro can cause undefined behavior. The original code used <code>MaybeUninit</code> to avoid initialisation of the struct and then set the fields using <code>ptr::write</code>. The undefined behavior triggered by this misuse of <code>MaybeUninit</code> can lead to invlaid memory access and panics in binaries compiled in release mode (aka simd-json-derive prior to version 0.12 has UB and optimizes into some nonsense)</p>
<p>The version <code>0.12.0</code> removes this section of code, avoiding the use of MaybeUninit alltogether.</p>
<h3 id="references">References</h3>
<ul>
<li><a href="https://github.com/simd-lite/simd-json-derive/issues/67">https://github.com/simd-lite/simd-json-derive/issues/67</a></li>
<li><a href="https://rustsec.org/advisories/RUSTSEC-2023-0087.html">https://rustsec.org/advisories/RUSTSEC-2023-0087.html</a></li>
<li><a href="https://github.com/advisories/GHSA-pqpw-89w5-82v5">https://github.com/advisories/GHSA-pqpw-89w5-82v5</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-pqpw-89w5-82v5</uri>
        </author>
        <category label="severity" term="MODERATE"/>
        <published>2024-11-12T20:53:54.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[[cggmp21-keygen] cggmp21-keygen has ambiguous challenge derivation]]></title>
        <id>https://github.com/advisories/GHSA-7jjx-3qw9-j6h6</id>
        <link href="https://github.com/advisories/GHSA-7jjx-3qw9-j6h6"/>
        <updated>2024-11-12T20:53:01.000Z</updated>
        <content type="html"><![CDATA[<p>Challenge derivation in non-interactive ZK proofs was ambiguous and that could lead to security vulnerability (however, it's unknown if it could be exploited).</p>
<h3 id="references">References</h3>
<ul>
<li><a href="https://github.com/dfns/cggmp21/pull/103">https://github.com/dfns/cggmp21/pull/103</a></li>
<li><a href="https://rustsec.org/advisories/RUSTSEC-2024-0392.html">https://rustsec.org/advisories/RUSTSEC-2024-0392.html</a></li>
<li><a href="https://github.com/advisories/GHSA-7jjx-3qw9-j6h6">https://github.com/advisories/GHSA-7jjx-3qw9-j6h6</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-7jjx-3qw9-j6h6</uri>
        </author>
        <category label="severity" term="LOW"/>
        <published>2024-11-12T20:53:00.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[[fast-float] `fast-float` has multiple soundness issues]]></title>
        <id>https://github.com/advisories/GHSA-x8jh-xj3x-gx3c</id>
        <link href="https://github.com/advisories/GHSA-x8jh-xj3x-gx3c"/>
        <updated>2024-11-12T20:48:39.000Z</updated>
        <content type="html"><![CDATA[<p><code>fast-float</code> contains multiple soundness issues:</p>
<ol>
<li><a href="https://github.com/aldanor/fast-float-rust/issues/28">Undefined behavior when checking input length</a>, which has been merged but no package <a href="https://github.com/aldanor/fast-float-rust/issues/35">pubished</a>.</li>
<li><a href="https://github.com/aldanor/fast-float-rust/issues/37">Many functions marked as safe with non-local safety guarantees</a></li>
</ol>
<p>The library is also unmaintained.</p>
<h2 id="alternatives">Alternatives</h2>
<p>For quickly parsing floating-point numbers third-party crates are generally no longer needed. A fast float parsing algorithm by the author of <code>lexical</code> has been <a href="https://github.com/rust-lang/rust/pull/86761">merged</a> into libcore. When requiring direct parsing from bytes and/or partial parsers, the <a href="https://crates.io/crates/fast-float2"><code>fast-float2</code></a> fork of <code>fast-float</code> containing these security patches and reduces overall usage of unsafe.</p>
<h3 id="references">References</h3>
<ul>
<li><a href="https://github.com/aldanor/fast-float-rust/issues/28">https://github.com/aldanor/fast-float-rust/issues/28</a></li>
<li><a href="https://github.com/aldanor/fast-float-rust/issues/35">https://github.com/aldanor/fast-float-rust/issues/35</a></li>
<li><a href="https://github.com/aldanor/fast-float-rust/issues/37">https://github.com/aldanor/fast-float-rust/issues/37</a></li>
<li><a href="https://rustsec.org/advisories/RUSTSEC-2024-0379.html">https://rustsec.org/advisories/RUSTSEC-2024-0379.html</a></li>
<li><a href="https://github.com/advisories/GHSA-x8jh-xj3x-gx3c">https://github.com/advisories/GHSA-x8jh-xj3x-gx3c</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-x8jh-xj3x-gx3c</uri>
        </author>
        <category label="severity" term="LOW"/>
        <published>2024-11-12T20:48:39.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[[wasm3] wasm3 uncontrolled memory allocation vulnerability]]></title>
        <id>https://github.com/advisories/GHSA-fmq6-4w57-2w3v</id>
        <link href="https://github.com/advisories/GHSA-fmq6-4w57-2w3v"/>
        <updated>2024-11-12T20:46:55.000Z</updated>
        <content type="html"><![CDATA[<p>wasm3 at commit 139076a contains a memory leak in the Read_utf8 function.</p>
<h3 id="references">References</h3>
<ul>
<li><a href="https://nvd.nist.gov/vuln/detail/CVE-2024-27529">https://nvd.nist.gov/vuln/detail/CVE-2024-27529</a></li>
<li><a href="https://github.com/wasm3/wasm3/issues/462">https://github.com/wasm3/wasm3/issues/462</a></li>
<li><a href="https://gist.github.com/haruki3hhh/ac70bd83b9c0ed1de6289d818488da78">https://gist.github.com/haruki3hhh/ac70bd83b9c0ed1de6289d818488da78</a></li>
<li><a href="https://github.com/wasm3/wasm3/pull/490">https://github.com/wasm3/wasm3/pull/490</a></li>
<li><a href="https://github.com/wasm3/wasm3/commit/526c1251b64e6e9fdc0d40c768ae46cd20338594">https://github.com/wasm3/wasm3/commit/526c1251b64e6e9fdc0d40c768ae46cd20338594</a></li>
<li><a href="https://github.com/advisories/GHSA-fmq6-4w57-2w3v">https://github.com/advisories/GHSA-fmq6-4w57-2w3v</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-fmq6-4w57-2w3v</uri>
        </author>
        <category label="severity" term="MODERATE"/>
        <published>2024-11-09T00:30:42.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[[sp1-recursion-circuit] sp1 has insufficient observation of cumulative sum]]></title>
        <id>https://github.com/advisories/GHSA-8m24-3cfx-9fjw</id>
        <link href="https://github.com/advisories/GHSA-8m24-3cfx-9fjw"/>
        <updated>2024-11-08T16:44:16.000Z</updated>
        <content type="html"><![CDATA[<p>During proof generation, the prover must observe all values sent to the verifier to generate valid Fiat-Shamir challenges. Prior to v3.0.0 the cumulative sum of the permutation argument was not observed when sampling zeta, which is a random challenge sampled to force the constraints to be true. In v3.0.0, this is fixed by observing the cumulative sum into the challenger, which can is done by observing the commit to the entire permutation trace.</p>
<p>While this vulnerability is theoretically present in v2.0.0 and below, exploiting it is quite a difficult task as the cumulative sum one can get from manipulation is essentially random. It requires practically infeasible amount of computation and deep knowledge of cryptographic attacks to carry out.</p>
<p>This issue was discovered during the audit of SP1 V3.0.0 and was officially fixed on October 17th. Out of abundance of caution, we will be deprecating all versions of SP1 before 3.0.0.</p>
<h3 id="references">References</h3>
<ul>
<li><a href="https://github.com/succinctlabs/sp1/security/advisories/GHSA-8m24-3cfx-9fjw">https://github.com/succinctlabs/sp1/security/advisories/GHSA-8m24-3cfx-9fjw</a></li>
<li><a href="https://github.com/succinctlabs/sp1/commit/79884ffb1a2d10bfd2c272f864033577a052468a">https://github.com/succinctlabs/sp1/commit/79884ffb1a2d10bfd2c272f864033577a052468a</a></li>
<li><a href="https://github.com/advisories/GHSA-8m24-3cfx-9fjw">https://github.com/advisories/GHSA-8m24-3cfx-9fjw</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-8m24-3cfx-9fjw</uri>
        </author>
        <category label="severity" term="LOW"/>
        <published>2024-11-08T16:44:15.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[[jj-lib] jj vulnerable to path traversal via crafted Git repositories]]></title>
        <id>https://github.com/advisories/GHSA-88h5-6w7m-5w56</id>
        <link href="https://github.com/advisories/GHSA-88h5-6w7m-5w56"/>
        <updated>2024-11-07T16:18:47.000Z</updated>
        <content type="html"><![CDATA[<h3 id="impact">Impact</h3>
<p>Specially crafted Git repositories can cause <code>jj</code> to write files outside the clone.</p>
<h3 id="patches">Patches</h3>
<p>Fixed in 0.23.0.</p>
<h3 id="workarounds">Workarounds</h3>
<p>Not much other than to not clone repositories from untrusted sources.</p>
<h3 id="references">References</h3>
<p>Here's the original report from @joernchen:</p>
<blockquote>
<p>When cloning a crafted Git repository it is possible to let <code>jj</code> write
into arbitrary directories. This can be achieved by having file objects
which contain path traversals.</p>
<p>Reproduction steps:</p>
<p>Apply the following patch to Git version v.2.47.0:</p>
<pre><code class="language-diff">diff --git a/path.c b/path.c
index 93491bab14..2f47e69fd1 100644
--- a/path.c
+++ b/path.c
@@ -44,11 +44,11 @@ struct strbuf *get_pathname(void)

 static const char *cleanup_path(const char *path)
 {
-       /* Clean it up */
+       /* Clean it up
        if (skip_prefix(path, "./", &amp;path)) {
                while (*path == '/')
                        path++;
-       }
+       }*/
        return path;
 }

@@ -1101,7 +1101,9 @@ int normalize_path_copy_len(char *dst, const char *src, int *prefix_len)

 int normalize_path_copy(char *dst, const char *src)
 {
-       return normalize_path_copy_len(dst, src, NULL);
+//     return normalize_path_copy_len(dst, src, NULL);
+       memcpy(dst, src, strlen(dst));
+       return 0;
 }

 int strbuf_normalize_path(struct strbuf *src)
diff --git a/read-cache.c b/read-cache.c
index 3c078afadb..2eb44cb26f 100644
--- a/read-cache.c
+++ b/read-cache.c
@@ -977,6 +977,7 @@ static enum verify_path_result verify_path_internal(const char *path,
                                                    unsigned mode)
 {
        char c = 0;
+       return PATH_OK;

        if (has_dos_drive_prefix(path))
                return PATH_INVALID;
</code></pre>
<p>With this patched <code>git</code> binary we can now apply a crafted
patch containing a path traversal to a repository.</p>
<p>The patch would look like:</p>
<pre><code class="language-patch">From ecea96264bd3f9785e5ebec8640be4847ba28e22 Mon Sep 17 00:00:00 2001
From: joernchen &lt;[joernchen@phenoelit.de](mailto:joernchen@phenoelit.de)&gt;
Date: Sun, 13 Oct 2024 18:09:50 +0200
Subject: [PATCH] z123

---
 z | 0
 1 file changed, 0 insertions(+), 0 deletions(-)
 create mode 100644 z

diff --git a/../joernchen_was_here b/../joernchen_was_here
new file mode 100644
index 0000000..e69de29
--
2.46.1
</code></pre>
<p>Note the traversal <code>../joernchen_was_here</code> in the patch. This now can be committed to a repository
using the modified <code>git</code> binary:</p>
<pre><code class="language-bash">mkdir demo
cd demo
git init
./path/to/modified/git/git --exec-path=./path/to/modified/git am the_traversal.patch
rm ../joernchen_was_here # remove the file the modified git wrote
</code></pre>
<p>Now, when cloning that repository with <code>jj git clone</code> the path traversal will write above the worktree
directory, allowing arbitrary file writes.</p>
<p>I've attached a tar.gz with the demo repo so you don't have to mess with the patched Git at all. For
reproduction it should be sufficient to do <code>jj git clone demo.git</code> after unpacking the tarball.</p>
<p>The demo repository after being cloned with <code>jj</code> will create an empty file <code>joernchen_was_here</code> right next
to the <code>demo</code> directory to demonstrate the traversal.</p>
</blockquote>
<h3 id="references-1">References</h3>
<ul>
<li><a href="https://github.com/martinvonz/jj/security/advisories/GHSA-88h5-6w7m-5w56">https://github.com/martinvonz/jj/security/advisories/GHSA-88h5-6w7m-5w56</a></li>
<li><a href="https://nvd.nist.gov/vuln/detail/CVE-2024-51990">https://nvd.nist.gov/vuln/detail/CVE-2024-51990</a></li>
<li><a href="https://github.com/advisories/GHSA-88h5-6w7m-5w56">https://github.com/advisories/GHSA-88h5-6w7m-5w56</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-88h5-6w7m-5w56</uri>
        </author>
        <category label="severity" term="CRITICAL"/>
        <published>2024-11-07T16:18:44.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[[cap-primitives] cap-std doesn't fully sandbox all the Windows device filenames]]></title>
        <id>https://github.com/advisories/GHSA-hxf5-99xg-86hw</id>
        <link href="https://github.com/advisories/GHSA-hxf5-99xg-86hw"/>
        <updated>2024-11-06T14:28:27.000Z</updated>
        <content type="html"><![CDATA[<h3 id="impact">Impact</h3>
<p>cap-std's filesystem sandbox implementation on Windows blocks access to special device filenames such as "COM1", "COM2", "LPT0", "LPT1", and so on, however it did not block access to the special device filenames which use superscript digits, such as "COM¹", "COM²", "LPT⁰", "LPT¹", and so on. Untrusted filesystem paths could bypass the sandbox and access devices through those special device filenames with superscript digits, and through them provide access peripheral devices connected to the computer, or network resources mapped to those devices. This can include modems, printers, network printers, and any other device connected to a serial or parallel port, including emulated USB serial ports.</p>
<h3 id="patches">Patches</h3>
<p>The bug is fixed in <a href="https://github.com/bytecodealliance/cap-std/pull/371">https://github.com/bytecodealliance/cap-std/pull/371</a>, which is published in cap-primitives 3.4.1, cap-std 3.4.1, and cap-async-std 3.4.1.</p>
<h3 id="workarounds">Workarounds</h3>
<p>There are no known workarounds for this issue. Affected Windows users are recommended to upgrade.</p>
<h3 id="references">References</h3>
<ul>
<li><a href="https://learn.microsoft.com/en-us/windows/win32/fileio/naming-a-file#naming-conventions">Microsoft's documentation</a> of the special device filenames</li>
<li><a href="https://en.wikipedia.org/wiki/ISO/IEC_8859-1">ISO-8859-1</a></li>
<li><a href="https://github.com/bytecodealliance/cap-std/pull/371">https://github.com/bytecodealliance/cap-std/pull/371</a></li>
</ul>
<h3 id="references-1">References</h3>
<ul>
<li><a href="https://github.com/bytecodealliance/cap-std/security/advisories/GHSA-hxf5-99xg-86hw">https://github.com/bytecodealliance/cap-std/security/advisories/GHSA-hxf5-99xg-86hw</a></li>
<li><a href="https://github.com/bytecodealliance/cap-std/pull/371">https://github.com/bytecodealliance/cap-std/pull/371</a></li>
<li><a href="https://en.wikipedia.org/wiki/ISO/IEC_8859-1">https://en.wikipedia.org/wiki/ISO/IEC_8859-1</a></li>
<li><a href="https://learn.microsoft.com/en-us/windows/win32/fileio/naming-a-file#naming-conventions">https://learn.microsoft.com/en-us/windows/win32/fileio/naming-a-file#naming-conventions</a></li>
<li><a href="https://nvd.nist.gov/vuln/detail/CVE-2024-51756">https://nvd.nist.gov/vuln/detail/CVE-2024-51756</a></li>
<li><a href="https://github.com/bytecodealliance/cap-std/commit/dcc3818039761331fbeacbb3a40c542b65b5ebf7">https://github.com/bytecodealliance/cap-std/commit/dcc3818039761331fbeacbb3a40c542b65b5ebf7</a></li>
<li><a href="https://github.com/advisories/GHSA-hxf5-99xg-86hw">https://github.com/advisories/GHSA-hxf5-99xg-86hw</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-hxf5-99xg-86hw</uri>
        </author>
        <category label="severity" term="LOW"/>
        <published>2024-11-05T22:19:59.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[[cap-async-std] cap-std doesn't fully sandbox all the Windows device filenames]]></title>
        <id>https://github.com/advisories/GHSA-hxf5-99xg-86hw</id>
        <link href="https://github.com/advisories/GHSA-hxf5-99xg-86hw"/>
        <updated>2024-11-06T14:28:27.000Z</updated>
        <content type="html"><![CDATA[<h3 id="impact">Impact</h3>
<p>cap-std's filesystem sandbox implementation on Windows blocks access to special device filenames such as "COM1", "COM2", "LPT0", "LPT1", and so on, however it did not block access to the special device filenames which use superscript digits, such as "COM¹", "COM²", "LPT⁰", "LPT¹", and so on. Untrusted filesystem paths could bypass the sandbox and access devices through those special device filenames with superscript digits, and through them provide access peripheral devices connected to the computer, or network resources mapped to those devices. This can include modems, printers, network printers, and any other device connected to a serial or parallel port, including emulated USB serial ports.</p>
<h3 id="patches">Patches</h3>
<p>The bug is fixed in <a href="https://github.com/bytecodealliance/cap-std/pull/371">https://github.com/bytecodealliance/cap-std/pull/371</a>, which is published in cap-primitives 3.4.1, cap-std 3.4.1, and cap-async-std 3.4.1.</p>
<h3 id="workarounds">Workarounds</h3>
<p>There are no known workarounds for this issue. Affected Windows users are recommended to upgrade.</p>
<h3 id="references">References</h3>
<ul>
<li><a href="https://learn.microsoft.com/en-us/windows/win32/fileio/naming-a-file#naming-conventions">Microsoft's documentation</a> of the special device filenames</li>
<li><a href="https://en.wikipedia.org/wiki/ISO/IEC_8859-1">ISO-8859-1</a></li>
<li><a href="https://github.com/bytecodealliance/cap-std/pull/371">https://github.com/bytecodealliance/cap-std/pull/371</a></li>
</ul>
<h3 id="references-1">References</h3>
<ul>
<li><a href="https://github.com/bytecodealliance/cap-std/security/advisories/GHSA-hxf5-99xg-86hw">https://github.com/bytecodealliance/cap-std/security/advisories/GHSA-hxf5-99xg-86hw</a></li>
<li><a href="https://github.com/bytecodealliance/cap-std/pull/371">https://github.com/bytecodealliance/cap-std/pull/371</a></li>
<li><a href="https://en.wikipedia.org/wiki/ISO/IEC_8859-1">https://en.wikipedia.org/wiki/ISO/IEC_8859-1</a></li>
<li><a href="https://learn.microsoft.com/en-us/windows/win32/fileio/naming-a-file#naming-conventions">https://learn.microsoft.com/en-us/windows/win32/fileio/naming-a-file#naming-conventions</a></li>
<li><a href="https://nvd.nist.gov/vuln/detail/CVE-2024-51756">https://nvd.nist.gov/vuln/detail/CVE-2024-51756</a></li>
<li><a href="https://github.com/bytecodealliance/cap-std/commit/dcc3818039761331fbeacbb3a40c542b65b5ebf7">https://github.com/bytecodealliance/cap-std/commit/dcc3818039761331fbeacbb3a40c542b65b5ebf7</a></li>
<li><a href="https://github.com/advisories/GHSA-hxf5-99xg-86hw">https://github.com/advisories/GHSA-hxf5-99xg-86hw</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-hxf5-99xg-86hw</uri>
        </author>
        <category label="severity" term="LOW"/>
        <published>2024-11-05T22:19:59.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[[cap-std] cap-std doesn't fully sandbox all the Windows device filenames]]></title>
        <id>https://github.com/advisories/GHSA-hxf5-99xg-86hw</id>
        <link href="https://github.com/advisories/GHSA-hxf5-99xg-86hw"/>
        <updated>2024-11-06T14:28:27.000Z</updated>
        <content type="html"><![CDATA[<h3 id="impact">Impact</h3>
<p>cap-std's filesystem sandbox implementation on Windows blocks access to special device filenames such as "COM1", "COM2", "LPT0", "LPT1", and so on, however it did not block access to the special device filenames which use superscript digits, such as "COM¹", "COM²", "LPT⁰", "LPT¹", and so on. Untrusted filesystem paths could bypass the sandbox and access devices through those special device filenames with superscript digits, and through them provide access peripheral devices connected to the computer, or network resources mapped to those devices. This can include modems, printers, network printers, and any other device connected to a serial or parallel port, including emulated USB serial ports.</p>
<h3 id="patches">Patches</h3>
<p>The bug is fixed in <a href="https://github.com/bytecodealliance/cap-std/pull/371">https://github.com/bytecodealliance/cap-std/pull/371</a>, which is published in cap-primitives 3.4.1, cap-std 3.4.1, and cap-async-std 3.4.1.</p>
<h3 id="workarounds">Workarounds</h3>
<p>There are no known workarounds for this issue. Affected Windows users are recommended to upgrade.</p>
<h3 id="references">References</h3>
<ul>
<li><a href="https://learn.microsoft.com/en-us/windows/win32/fileio/naming-a-file#naming-conventions">Microsoft's documentation</a> of the special device filenames</li>
<li><a href="https://en.wikipedia.org/wiki/ISO/IEC_8859-1">ISO-8859-1</a></li>
<li><a href="https://github.com/bytecodealliance/cap-std/pull/371">https://github.com/bytecodealliance/cap-std/pull/371</a></li>
</ul>
<h3 id="references-1">References</h3>
<ul>
<li><a href="https://github.com/bytecodealliance/cap-std/security/advisories/GHSA-hxf5-99xg-86hw">https://github.com/bytecodealliance/cap-std/security/advisories/GHSA-hxf5-99xg-86hw</a></li>
<li><a href="https://github.com/bytecodealliance/cap-std/pull/371">https://github.com/bytecodealliance/cap-std/pull/371</a></li>
<li><a href="https://en.wikipedia.org/wiki/ISO/IEC_8859-1">https://en.wikipedia.org/wiki/ISO/IEC_8859-1</a></li>
<li><a href="https://learn.microsoft.com/en-us/windows/win32/fileio/naming-a-file#naming-conventions">https://learn.microsoft.com/en-us/windows/win32/fileio/naming-a-file#naming-conventions</a></li>
<li><a href="https://nvd.nist.gov/vuln/detail/CVE-2024-51756">https://nvd.nist.gov/vuln/detail/CVE-2024-51756</a></li>
<li><a href="https://github.com/bytecodealliance/cap-std/commit/dcc3818039761331fbeacbb3a40c542b65b5ebf7">https://github.com/bytecodealliance/cap-std/commit/dcc3818039761331fbeacbb3a40c542b65b5ebf7</a></li>
<li><a href="https://github.com/advisories/GHSA-hxf5-99xg-86hw">https://github.com/advisories/GHSA-hxf5-99xg-86hw</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-hxf5-99xg-86hw</uri>
        </author>
        <category label="severity" term="LOW"/>
        <published>2024-11-05T22:19:59.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[[wasmtime] Wasmtime doesn't fully sandbox all the Windows device filenames]]></title>
        <id>https://github.com/advisories/GHSA-c2f5-jxjv-2hh8</id>
        <link href="https://github.com/advisories/GHSA-c2f5-jxjv-2hh8"/>
        <updated>2024-11-06T14:28:17.000Z</updated>
        <content type="html"><![CDATA[<h3 id="impact">Impact</h3>
<p>Wasmtime's filesystem sandbox implementation on Windows blocks access to special device filenames such as "COM1", "COM2", "LPT0", "LPT1", and so on, however it did not block access to the special device filenames which use superscript digits, such as "COM¹", "COM²", "LPT⁰", "LPT¹", and so on. Untrusted Wasm programs that are given access to any filesystem directory could bypass the sandbox and access devices through those special device filenames with superscript digits, and through them gain access peripheral devices connected to the computer, or network resources mapped to those devices. This can include modems, printers, network printers, and any other device connected to a serial or parallel port, including emulated USB serial ports.</p>
<h3 id="patches">Patches</h3>
<p>Patch releases for Wasmtime have been issued as 24.0.2, 25.0.3, and 26.0.1. Users of Wasmtime 23.0.x and prior are recommended to upgrade to one of these patched versions.</p>
<h3 id="workarounds">Workarounds</h3>
<p>There are no known workarounds for this issue. Affected Windows users are recommended to upgrade.</p>
<h3 id="references">References</h3>
<ul>
<li><a href="https://learn.microsoft.com/en-us/windows/win32/fileio/naming-a-file#naming-conventions">Microsoft's documentation</a> of the special device filenames</li>
<li><a href="https://en.wikipedia.org/wiki/ISO/IEC_8859-1">ISO-8859-1</a></li>
<li><a href="https://github.com/bytecodealliance/cap-std/pull/371">The original PR reporting the issue</a></li>
</ul>
<h3 id="references-1">References</h3>
<ul>
<li><a href="https://github.com/bytecodealliance/wasmtime/security/advisories/GHSA-c2f5-jxjv-2hh8">https://github.com/bytecodealliance/wasmtime/security/advisories/GHSA-c2f5-jxjv-2hh8</a></li>
<li><a href="https://github.com/bytecodealliance/cap-std/pull/371">https://github.com/bytecodealliance/cap-std/pull/371</a></li>
<li><a href="https://en.wikipedia.org/wiki/ISO/IEC_8859-1">https://en.wikipedia.org/wiki/ISO/IEC_8859-1</a></li>
<li><a href="https://learn.microsoft.com/en-us/windows/win32/fileio/naming-a-file#naming-conventions">https://learn.microsoft.com/en-us/windows/win32/fileio/naming-a-file#naming-conventions</a></li>
<li><a href="https://nvd.nist.gov/vuln/detail/CVE-2024-51745">https://nvd.nist.gov/vuln/detail/CVE-2024-51745</a></li>
<li><a href="https://github.com/advisories/GHSA-c2f5-jxjv-2hh8">https://github.com/advisories/GHSA-c2f5-jxjv-2hh8</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-c2f5-jxjv-2hh8</uri>
        </author>
        <category label="severity" term="LOW"/>
        <published>2024-11-05T22:18:49.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[[wasmtime] Wasmtime doesn't fully sandbox all the Windows device filenames]]></title>
        <id>https://github.com/advisories/GHSA-c2f5-jxjv-2hh8</id>
        <link href="https://github.com/advisories/GHSA-c2f5-jxjv-2hh8"/>
        <updated>2024-11-06T14:28:17.000Z</updated>
        <content type="html"><![CDATA[<h3 id="impact">Impact</h3>
<p>Wasmtime's filesystem sandbox implementation on Windows blocks access to special device filenames such as "COM1", "COM2", "LPT0", "LPT1", and so on, however it did not block access to the special device filenames which use superscript digits, such as "COM¹", "COM²", "LPT⁰", "LPT¹", and so on. Untrusted Wasm programs that are given access to any filesystem directory could bypass the sandbox and access devices through those special device filenames with superscript digits, and through them gain access peripheral devices connected to the computer, or network resources mapped to those devices. This can include modems, printers, network printers, and any other device connected to a serial or parallel port, including emulated USB serial ports.</p>
<h3 id="patches">Patches</h3>
<p>Patch releases for Wasmtime have been issued as 24.0.2, 25.0.3, and 26.0.1. Users of Wasmtime 23.0.x and prior are recommended to upgrade to one of these patched versions.</p>
<h3 id="workarounds">Workarounds</h3>
<p>There are no known workarounds for this issue. Affected Windows users are recommended to upgrade.</p>
<h3 id="references">References</h3>
<ul>
<li><a href="https://learn.microsoft.com/en-us/windows/win32/fileio/naming-a-file#naming-conventions">Microsoft's documentation</a> of the special device filenames</li>
<li><a href="https://en.wikipedia.org/wiki/ISO/IEC_8859-1">ISO-8859-1</a></li>
<li><a href="https://github.com/bytecodealliance/cap-std/pull/371">The original PR reporting the issue</a></li>
</ul>
<h3 id="references-1">References</h3>
<ul>
<li><a href="https://github.com/bytecodealliance/wasmtime/security/advisories/GHSA-c2f5-jxjv-2hh8">https://github.com/bytecodealliance/wasmtime/security/advisories/GHSA-c2f5-jxjv-2hh8</a></li>
<li><a href="https://github.com/bytecodealliance/cap-std/pull/371">https://github.com/bytecodealliance/cap-std/pull/371</a></li>
<li><a href="https://en.wikipedia.org/wiki/ISO/IEC_8859-1">https://en.wikipedia.org/wiki/ISO/IEC_8859-1</a></li>
<li><a href="https://learn.microsoft.com/en-us/windows/win32/fileio/naming-a-file#naming-conventions">https://learn.microsoft.com/en-us/windows/win32/fileio/naming-a-file#naming-conventions</a></li>
<li><a href="https://nvd.nist.gov/vuln/detail/CVE-2024-51745">https://nvd.nist.gov/vuln/detail/CVE-2024-51745</a></li>
<li><a href="https://github.com/advisories/GHSA-c2f5-jxjv-2hh8">https://github.com/advisories/GHSA-c2f5-jxjv-2hh8</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-c2f5-jxjv-2hh8</uri>
        </author>
        <category label="severity" term="LOW"/>
        <published>2024-11-05T22:18:49.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[[wasmtime] Wasmtime doesn't fully sandbox all the Windows device filenames]]></title>
        <id>https://github.com/advisories/GHSA-c2f5-jxjv-2hh8</id>
        <link href="https://github.com/advisories/GHSA-c2f5-jxjv-2hh8"/>
        <updated>2024-11-06T14:28:17.000Z</updated>
        <content type="html"><![CDATA[<h3 id="impact">Impact</h3>
<p>Wasmtime's filesystem sandbox implementation on Windows blocks access to special device filenames such as "COM1", "COM2", "LPT0", "LPT1", and so on, however it did not block access to the special device filenames which use superscript digits, such as "COM¹", "COM²", "LPT⁰", "LPT¹", and so on. Untrusted Wasm programs that are given access to any filesystem directory could bypass the sandbox and access devices through those special device filenames with superscript digits, and through them gain access peripheral devices connected to the computer, or network resources mapped to those devices. This can include modems, printers, network printers, and any other device connected to a serial or parallel port, including emulated USB serial ports.</p>
<h3 id="patches">Patches</h3>
<p>Patch releases for Wasmtime have been issued as 24.0.2, 25.0.3, and 26.0.1. Users of Wasmtime 23.0.x and prior are recommended to upgrade to one of these patched versions.</p>
<h3 id="workarounds">Workarounds</h3>
<p>There are no known workarounds for this issue. Affected Windows users are recommended to upgrade.</p>
<h3 id="references">References</h3>
<ul>
<li><a href="https://learn.microsoft.com/en-us/windows/win32/fileio/naming-a-file#naming-conventions">Microsoft's documentation</a> of the special device filenames</li>
<li><a href="https://en.wikipedia.org/wiki/ISO/IEC_8859-1">ISO-8859-1</a></li>
<li><a href="https://github.com/bytecodealliance/cap-std/pull/371">The original PR reporting the issue</a></li>
</ul>
<h3 id="references-1">References</h3>
<ul>
<li><a href="https://github.com/bytecodealliance/wasmtime/security/advisories/GHSA-c2f5-jxjv-2hh8">https://github.com/bytecodealliance/wasmtime/security/advisories/GHSA-c2f5-jxjv-2hh8</a></li>
<li><a href="https://github.com/bytecodealliance/cap-std/pull/371">https://github.com/bytecodealliance/cap-std/pull/371</a></li>
<li><a href="https://en.wikipedia.org/wiki/ISO/IEC_8859-1">https://en.wikipedia.org/wiki/ISO/IEC_8859-1</a></li>
<li><a href="https://learn.microsoft.com/en-us/windows/win32/fileio/naming-a-file#naming-conventions">https://learn.microsoft.com/en-us/windows/win32/fileio/naming-a-file#naming-conventions</a></li>
<li><a href="https://nvd.nist.gov/vuln/detail/CVE-2024-51745">https://nvd.nist.gov/vuln/detail/CVE-2024-51745</a></li>
<li><a href="https://github.com/advisories/GHSA-c2f5-jxjv-2hh8">https://github.com/advisories/GHSA-c2f5-jxjv-2hh8</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-c2f5-jxjv-2hh8</uri>
        </author>
        <category label="severity" term="LOW"/>
        <published>2024-11-05T22:18:49.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[[loona-hpack] loona-hpack Panic Vulnerability]]></title>
        <id>https://github.com/advisories/GHSA-7vm6-qwh5-9x44</id>
        <link href="https://github.com/advisories/GHSA-7vm6-qwh5-9x44"/>
        <updated>2024-11-05T18:35:40.000Z</updated>
        <content type="html"><![CDATA[<h3 id="summary">Summary</h3>
<p><code>loona-hpack</code> suffers from the same vulnerability as the original <code>hpack</code> as documented in <a href="https://github.com/mlalic/hpack-rs/issues/11">https://github.com/mlalic/hpack-rs/issues/11</a> </p>
<h3 id="details">Details</h3>
<p>The original includes a very nice description of the problem, as well as an easy-enough fix for it.</p>
<h3 id="poc">PoC</h3>
<p>The original example pretty much still applies:</p>
<pre><code class="language-rust">use loona_hpack::Decoder;

pub fn main() {
    let input = &amp;[0x3f];
    let mut decoder = Decoder::new();
    let _ = decoder.decode(input);
}
</code></pre>
<h3 id="impact">Impact</h3>
<p>From the original:
<code>All users who try to decode untrusted input using the Decoder are vulnerable to this exploit. A patched version of the crate is available on [crates.io](https://crates.io/crates/hpack-patched) under the name hpack-patched. See [Cargo's documentation on overriding dependencies](https://doc.rust-lang.org/cargo/reference/overriding-dependencies.html) for more information.</code></p>
<h3 id="references">References</h3>
<ul>
<li><a href="https://github.com/bearcove/loona/security/advisories/GHSA-7vm6-qwh5-9x44">https://github.com/bearcove/loona/security/advisories/GHSA-7vm6-qwh5-9x44</a></li>
<li><a href="https://github.com/mlalic/hpack-rs/issues/11">https://github.com/mlalic/hpack-rs/issues/11</a></li>
<li><a href="https://github.com/bearcove/loona/commit/9a4028ec6484f50a320281271a41a5040ddb1ba8">https://github.com/bearcove/loona/commit/9a4028ec6484f50a320281271a41a5040ddb1ba8</a></li>
<li><a href="https://github.com/advisories/GHSA-w7hm-hmxv-pvhf">https://github.com/advisories/GHSA-w7hm-hmxv-pvhf</a></li>
<li><a href="https://nvd.nist.gov/vuln/detail/CVE-2024-51502">https://nvd.nist.gov/vuln/detail/CVE-2024-51502</a></li>
<li><a href="https://github.com/advisories/GHSA-7vm6-qwh5-9x44">https://github.com/advisories/GHSA-7vm6-qwh5-9x44</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-7vm6-qwh5-9x44</uri>
        </author>
        <category label="severity" term="MODERATE"/>
        <published>2024-11-04T23:22:33.000Z</published>
    </entry>
</feed>