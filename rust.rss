<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://azu.github.io/github-advisory-database-rss/rust.rss</id>
    <title>Security Advisory for Rust crates</title>
    <updated>2025-04-08T06:02:03.156Z</updated>
    <generator>github-advisory-database-rss</generator>
    <link rel="alternate" href="https://github.com/advisories?query=type%3Areviewed+ecosystem%3Arust"/>
    <subtitle>Security Advisory for Rust crates on GitHub</subtitle>
    <rights>github-advisory-database-rss</rights>
    <category term="CRITICAL"/>
    <category term="HIGH"/>
    <category term="MODERATE"/>
    <category term="LOW"/>
    <entry>
        <title type="html"><![CDATA[[tokio] Tokio broadcast channel calls clone in parallel, but does not require `Sync`]]></title>
        <id>https://github.com/advisories/GHSA-rr8g-9fpq-6wmg</id>
        <link href="https://github.com/advisories/GHSA-rr8g-9fpq-6wmg"/>
        <updated>2025-04-07T21:12:51.000Z</updated>
        <content type="html"><![CDATA[<p>The broadcast channel internally calls <code>clone</code> on the stored value when receiving it, and only requires <code>T:Send</code>. This means that using the broadcast channel with values that are <code>Send</code> but not <code>Sync</code> can trigger unsoundness if the <code>clone</code> implementation makes use of the value being <code>!Sync</code>.</p>
<p>Thank you to Austin Bonander for finding and reporting this issue.</p>
<h3 id="references">References</h3>
<ul>
<li><a href="https://github.com/tokio-rs/tokio/pull/7232">https://github.com/tokio-rs/tokio/pull/7232</a></li>
<li><a href="https://github.com/tokio-rs/tokio">https://github.com/tokio-rs/tokio</a></li>
<li><a href="https://rustsec.org/advisories/RUSTSEC-2025-0023.html">https://rustsec.org/advisories/RUSTSEC-2025-0023.html</a></li>
<li><a href="https://github.com/advisories/GHSA-rr8g-9fpq-6wmg">https://github.com/advisories/GHSA-rr8g-9fpq-6wmg</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-rr8g-9fpq-6wmg</uri>
        </author>
        <category label="severity" term="LOW"/>
        <published>2025-04-07T21:12:50.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[[tokio] Tokio broadcast channel calls clone in parallel, but does not require `Sync`]]></title>
        <id>https://github.com/advisories/GHSA-rr8g-9fpq-6wmg</id>
        <link href="https://github.com/advisories/GHSA-rr8g-9fpq-6wmg"/>
        <updated>2025-04-07T21:12:51.000Z</updated>
        <content type="html"><![CDATA[<p>The broadcast channel internally calls <code>clone</code> on the stored value when receiving it, and only requires <code>T:Send</code>. This means that using the broadcast channel with values that are <code>Send</code> but not <code>Sync</code> can trigger unsoundness if the <code>clone</code> implementation makes use of the value being <code>!Sync</code>.</p>
<p>Thank you to Austin Bonander for finding and reporting this issue.</p>
<h3 id="references">References</h3>
<ul>
<li><a href="https://github.com/tokio-rs/tokio/pull/7232">https://github.com/tokio-rs/tokio/pull/7232</a></li>
<li><a href="https://github.com/tokio-rs/tokio">https://github.com/tokio-rs/tokio</a></li>
<li><a href="https://rustsec.org/advisories/RUSTSEC-2025-0023.html">https://rustsec.org/advisories/RUSTSEC-2025-0023.html</a></li>
<li><a href="https://github.com/advisories/GHSA-rr8g-9fpq-6wmg">https://github.com/advisories/GHSA-rr8g-9fpq-6wmg</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-rr8g-9fpq-6wmg</uri>
        </author>
        <category label="severity" term="LOW"/>
        <published>2025-04-07T21:12:50.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[[tokio] Tokio broadcast channel calls clone in parallel, but does not require `Sync`]]></title>
        <id>https://github.com/advisories/GHSA-rr8g-9fpq-6wmg</id>
        <link href="https://github.com/advisories/GHSA-rr8g-9fpq-6wmg"/>
        <updated>2025-04-07T21:12:51.000Z</updated>
        <content type="html"><![CDATA[<p>The broadcast channel internally calls <code>clone</code> on the stored value when receiving it, and only requires <code>T:Send</code>. This means that using the broadcast channel with values that are <code>Send</code> but not <code>Sync</code> can trigger unsoundness if the <code>clone</code> implementation makes use of the value being <code>!Sync</code>.</p>
<p>Thank you to Austin Bonander for finding and reporting this issue.</p>
<h3 id="references">References</h3>
<ul>
<li><a href="https://github.com/tokio-rs/tokio/pull/7232">https://github.com/tokio-rs/tokio/pull/7232</a></li>
<li><a href="https://github.com/tokio-rs/tokio">https://github.com/tokio-rs/tokio</a></li>
<li><a href="https://rustsec.org/advisories/RUSTSEC-2025-0023.html">https://rustsec.org/advisories/RUSTSEC-2025-0023.html</a></li>
<li><a href="https://github.com/advisories/GHSA-rr8g-9fpq-6wmg">https://github.com/advisories/GHSA-rr8g-9fpq-6wmg</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-rr8g-9fpq-6wmg</uri>
        </author>
        <category label="severity" term="LOW"/>
        <published>2025-04-07T21:12:50.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[[apollo-compiler] Apollo Compiler Named Fragment Processing Vulnerability]]></title>
        <id>https://github.com/advisories/GHSA-7mpv-9xg6-5r79</id>
        <link href="https://github.com/advisories/GHSA-7mpv-9xg6-5r79"/>
        <updated>2025-04-07T19:09:18.000Z</updated>
        <content type="html"><![CDATA[<h1 id="impact">Impact</h1>
<h2 id="summary">Summary</h2>
<p>A vulnerability in Apollo Compiler allowed queries with deeply nested and reused named fragments to be prohibitively expensive to validate. This could lead to excessive resource consumption and denial of service in applications.</p>
<h2 id="details">Details</h2>
<p>Named fragments were being processed once per fragment spread in some cases during query validation, leading to exponential resource usage when deeply nested and reused fragments were involved.</p>
<h2 id="fixmitigation">Fix/Mitigation</h2>
<p>The validation logic has been updated to process each named fragment only once, preventing redundant traversal.</p>
<h1 id="patches">Patches</h1>
<p>This has been remediated in <code>apollo-compiler</code> version 1.27.0.</p>
<h1 id="workarounds">Workarounds</h1>
<p>No known direct workarounds exist.</p>
<h2 id="acknowledgements">Acknowledgements</h2>
<p>We appreciate the efforts of the security community in identifying and improving the performance and security of query validation mechanisms.</p>
<h3 id="references">References</h3>
<ul>
<li><a href="https://github.com/apollographql/apollo-rs/security/advisories/GHSA-7mpv-9xg6-5r79">https://github.com/apollographql/apollo-rs/security/advisories/GHSA-7mpv-9xg6-5r79</a></li>
<li><a href="https://github.com/apollographql/apollo-rs/pull/952">https://github.com/apollographql/apollo-rs/pull/952</a></li>
<li><a href="https://github.com/advisories/GHSA-7mpv-9xg6-5r79">https://github.com/advisories/GHSA-7mpv-9xg6-5r79</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-7mpv-9xg6-5r79</uri>
        </author>
        <category label="severity" term="HIGH"/>
        <published>2025-04-07T19:09:14.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[[apollo-router] Apollo Router Query Validation Vulnerable to Excessive Resource Consumption via Named Fragment Processing]]></title>
        <id>https://github.com/advisories/GHSA-3j43-9v8v-cp3f</id>
        <link href="https://github.com/advisories/GHSA-3j43-9v8v-cp3f"/>
        <updated>2025-04-07T19:00:32.000Z</updated>
        <content type="html"><![CDATA[<h1 id="impact">Impact</h1>
<h2 id="summary">Summary</h2>
<p>A vulnerability in Apollo Router's usage of Apollo Compiler allowed queries with deeply nested and reused named fragments to be prohibitively expensive to validate. This could lead to excessive resource consumption and denial of service.</p>
<h2 id="details">Details</h2>
<p>Named fragments were being processed once per fragment spread in some cases during query validation, leading to exponential resource usage when deeply nested and reused fragments were involved.</p>
<h2 id="fixmitigation">Fix/Mitigation</h2>
<p>Apollo Router's usage of Apollo Compiler has been updated so that validation logic processes each named fragment only once, preventing redundant traversal.</p>
<h1 id="patches">Patches</h1>
<p>This has been remediated in <code>apollo-router</code> versions 1.61.2 and 2.1.1.</p>
<h1 id="workarounds">Workarounds</h1>
<p>The only known workaround is "Safelisting with IDs only" per <a href="https://www.apollographql.com/docs/graphos/routing/security/persisted-queries#router-security-levels">Safelisting with Persisted Queries - Apollo GraphQL Docs</a>. The "Safelisting" security level is not sufficient, since that level allows freeform GraphQL queries to be sent to Apollo Router.</p>
<h1 id="references">References</h1>
<p><a href="https://www.apollographql.com/docs/graphos/reference/federation/query-plans">Query Planning Documentation</a></p>
<h2 id="acknowledgements">Acknowledgements</h2>
<p>We appreciate the efforts of the security community in identifying and improving the performance and security of query validation mechanisms.</p>
<h3 id="references-1">References</h3>
<ul>
<li><a href="https://github.com/apollographql/router/security/advisories/GHSA-3j43-9v8v-cp3f">https://github.com/apollographql/router/security/advisories/GHSA-3j43-9v8v-cp3f</a></li>
<li><a href="https://github.com/apollographql/router/commit/ab6675a63174715ea6ff50881fc957831d4e9564">https://github.com/apollographql/router/commit/ab6675a63174715ea6ff50881fc957831d4e9564</a></li>
<li><a href="https://github.com/apollographql/router/commit/bba032e183b861348a466d3123c7137a1ae18952">https://github.com/apollographql/router/commit/bba032e183b861348a466d3123c7137a1ae18952</a></li>
<li><a href="https://github.com/advisories/GHSA-3j43-9v8v-cp3f">https://github.com/advisories/GHSA-3j43-9v8v-cp3f</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-3j43-9v8v-cp3f</uri>
        </author>
        <category label="severity" term="HIGH"/>
        <published>2025-04-07T19:00:30.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[[apollo-router] Apollo Router Query Validation Vulnerable to Excessive Resource Consumption via Named Fragment Processing]]></title>
        <id>https://github.com/advisories/GHSA-3j43-9v8v-cp3f</id>
        <link href="https://github.com/advisories/GHSA-3j43-9v8v-cp3f"/>
        <updated>2025-04-07T19:00:32.000Z</updated>
        <content type="html"><![CDATA[<h1 id="impact">Impact</h1>
<h2 id="summary">Summary</h2>
<p>A vulnerability in Apollo Router's usage of Apollo Compiler allowed queries with deeply nested and reused named fragments to be prohibitively expensive to validate. This could lead to excessive resource consumption and denial of service.</p>
<h2 id="details">Details</h2>
<p>Named fragments were being processed once per fragment spread in some cases during query validation, leading to exponential resource usage when deeply nested and reused fragments were involved.</p>
<h2 id="fixmitigation">Fix/Mitigation</h2>
<p>Apollo Router's usage of Apollo Compiler has been updated so that validation logic processes each named fragment only once, preventing redundant traversal.</p>
<h1 id="patches">Patches</h1>
<p>This has been remediated in <code>apollo-router</code> versions 1.61.2 and 2.1.1.</p>
<h1 id="workarounds">Workarounds</h1>
<p>The only known workaround is "Safelisting with IDs only" per <a href="https://www.apollographql.com/docs/graphos/routing/security/persisted-queries#router-security-levels">Safelisting with Persisted Queries - Apollo GraphQL Docs</a>. The "Safelisting" security level is not sufficient, since that level allows freeform GraphQL queries to be sent to Apollo Router.</p>
<h1 id="references">References</h1>
<p><a href="https://www.apollographql.com/docs/graphos/reference/federation/query-plans">Query Planning Documentation</a></p>
<h2 id="acknowledgements">Acknowledgements</h2>
<p>We appreciate the efforts of the security community in identifying and improving the performance and security of query validation mechanisms.</p>
<h3 id="references-1">References</h3>
<ul>
<li><a href="https://github.com/apollographql/router/security/advisories/GHSA-3j43-9v8v-cp3f">https://github.com/apollographql/router/security/advisories/GHSA-3j43-9v8v-cp3f</a></li>
<li><a href="https://github.com/apollographql/router/commit/ab6675a63174715ea6ff50881fc957831d4e9564">https://github.com/apollographql/router/commit/ab6675a63174715ea6ff50881fc957831d4e9564</a></li>
<li><a href="https://github.com/apollographql/router/commit/bba032e183b861348a466d3123c7137a1ae18952">https://github.com/apollographql/router/commit/bba032e183b861348a466d3123c7137a1ae18952</a></li>
<li><a href="https://github.com/advisories/GHSA-3j43-9v8v-cp3f">https://github.com/advisories/GHSA-3j43-9v8v-cp3f</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-3j43-9v8v-cp3f</uri>
        </author>
        <category label="severity" term="HIGH"/>
        <published>2025-04-07T19:00:30.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[[apollo-router] Apollo Router Operation Limits Vulnerable to Bypass via Integer Overflow]]></title>
        <id>https://github.com/advisories/GHSA-84m6-5m72-45fp</id>
        <link href="https://github.com/advisories/GHSA-84m6-5m72-45fp"/>
        <updated>2025-04-07T21:11:24.000Z</updated>
        <content type="html"><![CDATA[<h1 id="impact">Impact</h1>
<h2 id="summary">Summary</h2>
<p>A vulnerability in Apollo Router allowed certain queries to bypass configured operation limits, specifically due to integer overflow.</p>
<h2 id="details">Details</h2>
<p>The operation limits plugin uses unsigned 32-bit integers to track limit counters (e.g. for a query's height). If a counter exceeded the maximum value for this data type (4,294,967,295), it wrapped around to 0, unintentionally allowing queries to bypass configured thresholds. This could occur for large queries if the payload limit were sufficiently increased, but could also occur for small queries with deeply nested and reused named fragments.</p>
<h2 id="fixmitigation">Fix/Mitigation</h2>
<p>Logic was updated to ensure counter overflow is handled correctly and does not wrap around to 0.</p>
<h1 id="patches">Patches</h1>
<p>This has been remediated in <code>apollo-router</code> versions 1.61.2 and 2.1.1.</p>
<h1 id="workarounds">Workarounds</h1>
<p>The only known workaround is "Safelisting" or "Safelisting with IDs only" per <a href="https://www.apollographql.com/docs/graphos/routing/security/persisted-queries#router-security-levels">Safelisting with Persisted Queries - Apollo GraphQL Docs</a>.</p>
<h2 id="acknowledgements">Acknowledgements</h2>
<p>We appreciate the efforts of the security community in identifying and improving the performance and security of operation limiting mechanisms.</p>
<h3 id="references">References</h3>
<ul>
<li><a href="https://github.com/apollographql/router/security/advisories/GHSA-84m6-5m72-45fp">https://github.com/apollographql/router/security/advisories/GHSA-84m6-5m72-45fp</a></li>
<li><a href="https://github.com/apollographql/router/commit/ab6675a63174715ea6ff50881fc957831d4e9564">https://github.com/apollographql/router/commit/ab6675a63174715ea6ff50881fc957831d4e9564</a></li>
<li><a href="https://github.com/apollographql/router/commit/bba032e183b861348a466d3123c7137a1ae18952">https://github.com/apollographql/router/commit/bba032e183b861348a466d3123c7137a1ae18952</a></li>
<li><a href="https://github.com/advisories/GHSA-84m6-5m72-45fp">https://github.com/advisories/GHSA-84m6-5m72-45fp</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-84m6-5m72-45fp</uri>
        </author>
        <category label="severity" term="HIGH"/>
        <published>2025-04-07T18:59:21.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[[apollo-router] Apollo Router Operation Limits Vulnerable to Bypass via Integer Overflow]]></title>
        <id>https://github.com/advisories/GHSA-84m6-5m72-45fp</id>
        <link href="https://github.com/advisories/GHSA-84m6-5m72-45fp"/>
        <updated>2025-04-07T21:11:24.000Z</updated>
        <content type="html"><![CDATA[<h1 id="impact">Impact</h1>
<h2 id="summary">Summary</h2>
<p>A vulnerability in Apollo Router allowed certain queries to bypass configured operation limits, specifically due to integer overflow.</p>
<h2 id="details">Details</h2>
<p>The operation limits plugin uses unsigned 32-bit integers to track limit counters (e.g. for a query's height). If a counter exceeded the maximum value for this data type (4,294,967,295), it wrapped around to 0, unintentionally allowing queries to bypass configured thresholds. This could occur for large queries if the payload limit were sufficiently increased, but could also occur for small queries with deeply nested and reused named fragments.</p>
<h2 id="fixmitigation">Fix/Mitigation</h2>
<p>Logic was updated to ensure counter overflow is handled correctly and does not wrap around to 0.</p>
<h1 id="patches">Patches</h1>
<p>This has been remediated in <code>apollo-router</code> versions 1.61.2 and 2.1.1.</p>
<h1 id="workarounds">Workarounds</h1>
<p>The only known workaround is "Safelisting" or "Safelisting with IDs only" per <a href="https://www.apollographql.com/docs/graphos/routing/security/persisted-queries#router-security-levels">Safelisting with Persisted Queries - Apollo GraphQL Docs</a>.</p>
<h2 id="acknowledgements">Acknowledgements</h2>
<p>We appreciate the efforts of the security community in identifying and improving the performance and security of operation limiting mechanisms.</p>
<h3 id="references">References</h3>
<ul>
<li><a href="https://github.com/apollographql/router/security/advisories/GHSA-84m6-5m72-45fp">https://github.com/apollographql/router/security/advisories/GHSA-84m6-5m72-45fp</a></li>
<li><a href="https://github.com/apollographql/router/commit/ab6675a63174715ea6ff50881fc957831d4e9564">https://github.com/apollographql/router/commit/ab6675a63174715ea6ff50881fc957831d4e9564</a></li>
<li><a href="https://github.com/apollographql/router/commit/bba032e183b861348a466d3123c7137a1ae18952">https://github.com/apollographql/router/commit/bba032e183b861348a466d3123c7137a1ae18952</a></li>
<li><a href="https://github.com/advisories/GHSA-84m6-5m72-45fp">https://github.com/advisories/GHSA-84m6-5m72-45fp</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-84m6-5m72-45fp</uri>
        </author>
        <category label="severity" term="HIGH"/>
        <published>2025-04-07T18:59:21.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[[apollo-router] Apollo Router Query Planner Vulnerable to Excessive Resource Consumption via Named Fragment Expansion]]></title>
        <id>https://github.com/advisories/GHSA-75m2-jhh5-j5g2</id>
        <link href="https://github.com/advisories/GHSA-75m2-jhh5-j5g2"/>
        <updated>2025-04-07T21:11:46.000Z</updated>
        <content type="html"><![CDATA[<h1 id="impact">Impact</h1>
<h2 id="summary">Summary</h2>
<p>A vulnerability in Apollo Router allowed queries with deeply nested and reused named fragments to be prohibitively expensive to query plan, specifically during named fragment expansion. This could lead to excessive resource consumption and denial of service.</p>
<h2 id="details">Details</h2>
<p>Named fragments were being expanded once per fragment spread during query planning, leading to exponential resource usage when deeply nested and reused fragments were involved.</p>
<h2 id="fixmitigation">Fix/Mitigation</h2>
<p>A new <strong>Query Fragment Expansion Limit</strong> metric has been introduced:</p>
<ul>
<li>This metric computes the number of selections a query would have if its fragment spreads were fully expanded.</li>
<li>The metric is checked against a limit to prevent excessive computation.</li>
</ul>
<h1 id="patches">Patches</h1>
<p>This has been remediated in <code>apollo-router</code> versions 1.61.2 and 2.1.1.</p>
<h1 id="workarounds">Workarounds</h1>
<p>The only known workaround is "Safelisting" or "Safelisting with IDs only" per <a href="https://www.apollographql.com/docs/graphos/routing/security/persisted-queries#router-security-levels">Safelisting with Persisted Queries - Apollo GraphQL Docs</a>.</p>
<h1 id="references">References</h1>
<p><a href="https://www.apollographql.com/docs/graphos/reference/federation/query-plans">Query Planning Documentation</a></p>
<h2 id="acknowledgements">Acknowledgements</h2>
<p>We appreciate the efforts of the security community in identifying and improving the performance and security of query planning mechanisms.</p>
<h3 id="references-1">References</h3>
<ul>
<li><a href="https://github.com/apollographql/router/security/advisories/GHSA-75m2-jhh5-j5g2">https://github.com/apollographql/router/security/advisories/GHSA-75m2-jhh5-j5g2</a></li>
<li><a href="https://github.com/apollographql/router/commit/ab6675a63174715ea6ff50881fc957831d4e9564">https://github.com/apollographql/router/commit/ab6675a63174715ea6ff50881fc957831d4e9564</a></li>
<li><a href="https://github.com/apollographql/router/commit/bba032e183b861348a466d3123c7137a1ae18952">https://github.com/apollographql/router/commit/bba032e183b861348a466d3123c7137a1ae18952</a></li>
<li><a href="https://github.com/advisories/GHSA-75m2-jhh5-j5g2">https://github.com/advisories/GHSA-75m2-jhh5-j5g2</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-75m2-jhh5-j5g2</uri>
        </author>
        <category label="severity" term="HIGH"/>
        <published>2025-04-07T18:57:56.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[[apollo-router] Apollo Router Query Planner Vulnerable to Excessive Resource Consumption via Named Fragment Expansion]]></title>
        <id>https://github.com/advisories/GHSA-75m2-jhh5-j5g2</id>
        <link href="https://github.com/advisories/GHSA-75m2-jhh5-j5g2"/>
        <updated>2025-04-07T21:11:46.000Z</updated>
        <content type="html"><![CDATA[<h1 id="impact">Impact</h1>
<h2 id="summary">Summary</h2>
<p>A vulnerability in Apollo Router allowed queries with deeply nested and reused named fragments to be prohibitively expensive to query plan, specifically during named fragment expansion. This could lead to excessive resource consumption and denial of service.</p>
<h2 id="details">Details</h2>
<p>Named fragments were being expanded once per fragment spread during query planning, leading to exponential resource usage when deeply nested and reused fragments were involved.</p>
<h2 id="fixmitigation">Fix/Mitigation</h2>
<p>A new <strong>Query Fragment Expansion Limit</strong> metric has been introduced:</p>
<ul>
<li>This metric computes the number of selections a query would have if its fragment spreads were fully expanded.</li>
<li>The metric is checked against a limit to prevent excessive computation.</li>
</ul>
<h1 id="patches">Patches</h1>
<p>This has been remediated in <code>apollo-router</code> versions 1.61.2 and 2.1.1.</p>
<h1 id="workarounds">Workarounds</h1>
<p>The only known workaround is "Safelisting" or "Safelisting with IDs only" per <a href="https://www.apollographql.com/docs/graphos/routing/security/persisted-queries#router-security-levels">Safelisting with Persisted Queries - Apollo GraphQL Docs</a>.</p>
<h1 id="references">References</h1>
<p><a href="https://www.apollographql.com/docs/graphos/reference/federation/query-plans">Query Planning Documentation</a></p>
<h2 id="acknowledgements">Acknowledgements</h2>
<p>We appreciate the efforts of the security community in identifying and improving the performance and security of query planning mechanisms.</p>
<h3 id="references-1">References</h3>
<ul>
<li><a href="https://github.com/apollographql/router/security/advisories/GHSA-75m2-jhh5-j5g2">https://github.com/apollographql/router/security/advisories/GHSA-75m2-jhh5-j5g2</a></li>
<li><a href="https://github.com/apollographql/router/commit/ab6675a63174715ea6ff50881fc957831d4e9564">https://github.com/apollographql/router/commit/ab6675a63174715ea6ff50881fc957831d4e9564</a></li>
<li><a href="https://github.com/apollographql/router/commit/bba032e183b861348a466d3123c7137a1ae18952">https://github.com/apollographql/router/commit/bba032e183b861348a466d3123c7137a1ae18952</a></li>
<li><a href="https://github.com/advisories/GHSA-75m2-jhh5-j5g2">https://github.com/advisories/GHSA-75m2-jhh5-j5g2</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-75m2-jhh5-j5g2</uri>
        </author>
        <category label="severity" term="HIGH"/>
        <published>2025-04-07T18:57:56.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[[apollo-router] Apollo Router Query Planner Vulnerable to Excessive Resource Consumption via Optimization Bypass]]></title>
        <id>https://github.com/advisories/GHSA-94hh-jmq8-2fgp</id>
        <link href="https://github.com/advisories/GHSA-94hh-jmq8-2fgp"/>
        <updated>2025-04-07T21:10:49.000Z</updated>
        <content type="html"><![CDATA[<h1 id="impact">Impact</h1>
<h2 id="summary">Summary</h2>
<p>A vulnerability in Apollo Router allowed queries with deeply nested and reused named fragments to be prohibitively expensive to query plan, specifically due to internal optimizations being frequently bypassed. This could lead to excessive resource consumption and denial of service.</p>
<h2 id="details">Details</h2>
<p>The query planner includes an optimization that significantly speeds up planning for applicable GraphQL selections. However, queries with deeply nested and reused named fragments can generate many selections where this optimization does not apply, leading to significantly longer planning times. Because the query planner does not enforce a timeout, a small number of such queries can exhaust router's thread pool, rendering it inoperable.</p>
<h2 id="fixmitigation">Fix/Mitigation</h2>
<ul>
<li>A new <strong>Query Optimization Limit</strong> metric has been added:<ul>
<li>This metric approximates the number of selections that cannot be skipped by the existing optimization.</li>
<li>The metric is checked against a limit to prevent excessive computation.</li>
</ul>
</li>
</ul>
<p>Given the complexity of query planning optimizations, we will continue refining these solutions based on real-world performance and accuracy tests.</p>
<h1 id="patches">Patches</h1>
<p>This has been remediated in <code>apollo-router</code> versions 1.61.2 and 2.1.1.</p>
<h1 id="workarounds">Workarounds</h1>
<p>The only known workaround is "Safelisting" or "Safelisting with IDs only" per <a href="https://www.apollographql.com/docs/graphos/routing/security/persisted-queries#router-security-levels">Safelisting with Persisted Queries - Apollo GraphQL Docs</a>.</p>
<h1 id="references">References</h1>
<p><a href="https://www.apollographql.com/docs/graphos/reference/federation/query-plans">Query Planning Documentation</a></p>
<h2 id="acknowledgements">Acknowledgements</h2>
<p>We appreciate the efforts of the security community in identifying and improving the performance and security of query planning mechanisms.</p>
<h3 id="references-1">References</h3>
<ul>
<li><a href="https://github.com/apollographql/router/security/advisories/GHSA-94hh-jmq8-2fgp">https://github.com/apollographql/router/security/advisories/GHSA-94hh-jmq8-2fgp</a></li>
<li><a href="https://github.com/apollographql/router/commit/ab6675a63174715ea6ff50881fc957831d4e9564">https://github.com/apollographql/router/commit/ab6675a63174715ea6ff50881fc957831d4e9564</a></li>
<li><a href="https://github.com/apollographql/router/commit/bba032e183b861348a466d3123c7137a1ae18952">https://github.com/apollographql/router/commit/bba032e183b861348a466d3123c7137a1ae18952</a></li>
<li><a href="https://github.com/advisories/GHSA-94hh-jmq8-2fgp">https://github.com/advisories/GHSA-94hh-jmq8-2fgp</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-94hh-jmq8-2fgp</uri>
        </author>
        <category label="severity" term="HIGH"/>
        <published>2025-04-07T18:56:30.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[[apollo-router] Apollo Router Query Planner Vulnerable to Excessive Resource Consumption via Optimization Bypass]]></title>
        <id>https://github.com/advisories/GHSA-94hh-jmq8-2fgp</id>
        <link href="https://github.com/advisories/GHSA-94hh-jmq8-2fgp"/>
        <updated>2025-04-07T21:10:49.000Z</updated>
        <content type="html"><![CDATA[<h1 id="impact">Impact</h1>
<h2 id="summary">Summary</h2>
<p>A vulnerability in Apollo Router allowed queries with deeply nested and reused named fragments to be prohibitively expensive to query plan, specifically due to internal optimizations being frequently bypassed. This could lead to excessive resource consumption and denial of service.</p>
<h2 id="details">Details</h2>
<p>The query planner includes an optimization that significantly speeds up planning for applicable GraphQL selections. However, queries with deeply nested and reused named fragments can generate many selections where this optimization does not apply, leading to significantly longer planning times. Because the query planner does not enforce a timeout, a small number of such queries can exhaust router's thread pool, rendering it inoperable.</p>
<h2 id="fixmitigation">Fix/Mitigation</h2>
<ul>
<li>A new <strong>Query Optimization Limit</strong> metric has been added:<ul>
<li>This metric approximates the number of selections that cannot be skipped by the existing optimization.</li>
<li>The metric is checked against a limit to prevent excessive computation.</li>
</ul>
</li>
</ul>
<p>Given the complexity of query planning optimizations, we will continue refining these solutions based on real-world performance and accuracy tests.</p>
<h1 id="patches">Patches</h1>
<p>This has been remediated in <code>apollo-router</code> versions 1.61.2 and 2.1.1.</p>
<h1 id="workarounds">Workarounds</h1>
<p>The only known workaround is "Safelisting" or "Safelisting with IDs only" per <a href="https://www.apollographql.com/docs/graphos/routing/security/persisted-queries#router-security-levels">Safelisting with Persisted Queries - Apollo GraphQL Docs</a>.</p>
<h1 id="references">References</h1>
<p><a href="https://www.apollographql.com/docs/graphos/reference/federation/query-plans">Query Planning Documentation</a></p>
<h2 id="acknowledgements">Acknowledgements</h2>
<p>We appreciate the efforts of the security community in identifying and improving the performance and security of query planning mechanisms.</p>
<h3 id="references-1">References</h3>
<ul>
<li><a href="https://github.com/apollographql/router/security/advisories/GHSA-94hh-jmq8-2fgp">https://github.com/apollographql/router/security/advisories/GHSA-94hh-jmq8-2fgp</a></li>
<li><a href="https://github.com/apollographql/router/commit/ab6675a63174715ea6ff50881fc957831d4e9564">https://github.com/apollographql/router/commit/ab6675a63174715ea6ff50881fc957831d4e9564</a></li>
<li><a href="https://github.com/apollographql/router/commit/bba032e183b861348a466d3123c7137a1ae18952">https://github.com/apollographql/router/commit/bba032e183b861348a466d3123c7137a1ae18952</a></li>
<li><a href="https://github.com/advisories/GHSA-94hh-jmq8-2fgp">https://github.com/advisories/GHSA-94hh-jmq8-2fgp</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-94hh-jmq8-2fgp</uri>
        </author>
        <category label="severity" term="HIGH"/>
        <published>2025-04-07T18:56:30.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[[jj-cli] Jujutsu does not have SHA-1 collision detection]]></title>
        <id>https://github.com/advisories/GHSA-794x-2rpg-rfgr</id>
        <link href="https://github.com/advisories/GHSA-794x-2rpg-rfgr"/>
        <updated>2025-04-07T16:40:26.000Z</updated>
        <content type="html"><![CDATA[<h3 id="summary">Summary</h3>
<p>Jujutsu 0.28.0 and earlier rely on versions of gitoxide that use SHA-1 hash implementations without any collision detection, leaving them vulnerable to hash collision attacks.</p>
<h3 id="details">Details</h3>
<p>This is a result of the underlying <a href="https://github.com/GitoxideLabs/gitoxide/security/advisories/GHSA-2frx-2596-x5r6">CVE-2025-31130 / GHSA-2frx-2596-x5r6</a> vulnerability in the gitoxide library Jujutsu uses to interact with Git repositories; see that advisory for technical details. This separate advisory is being issued due to the downstream impact on users of Jujutsu.</p>
<h3 id="impact">Impact</h3>
<p>An attacker with the ability to mount a collision attack on SHA-1 like the <a href="https://shattered.io/">SHAttered</a> or <a href="https://sha-mbles.github.io/">SHA-1 is a Shambles</a> attacks could create two distinct Git objects with the same hash. This is becoming increasingly affordable for well‐resourced attackers, with the Shambles researchers in 2020 estimating $45k for a chosen‐prefix collision or $11k for a classical collision, and projecting less than $10k for a chosen‐prefix collision by 2025. The result could be used to disguise malicious repository contents, or potentially exploit assumptions in Jujutsu’s logic to cause further vulnerabilities.</p>
<h3 id="references">References</h3>
<ul>
<li><a href="https://github.com/jj-vcs/jj/security/advisories/GHSA-794x-2rpg-rfgr">https://github.com/jj-vcs/jj/security/advisories/GHSA-794x-2rpg-rfgr</a></li>
<li><a href="https://github.com/jj-vcs/jj/commit/350da7d013773377aec0d3a4bf4374d3c941460e">https://github.com/jj-vcs/jj/commit/350da7d013773377aec0d3a4bf4374d3c941460e</a></li>
<li><a href="https://github.com/advisories/GHSA-794x-2rpg-rfgr">https://github.com/advisories/GHSA-794x-2rpg-rfgr</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-794x-2rpg-rfgr</uri>
        </author>
        <category label="severity" term="MODERATE"/>
        <published>2025-04-07T16:40:25.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[[jj-lib] Jujutsu does not have SHA-1 collision detection]]></title>
        <id>https://github.com/advisories/GHSA-794x-2rpg-rfgr</id>
        <link href="https://github.com/advisories/GHSA-794x-2rpg-rfgr"/>
        <updated>2025-04-07T16:40:26.000Z</updated>
        <content type="html"><![CDATA[<h3 id="summary">Summary</h3>
<p>Jujutsu 0.28.0 and earlier rely on versions of gitoxide that use SHA-1 hash implementations without any collision detection, leaving them vulnerable to hash collision attacks.</p>
<h3 id="details">Details</h3>
<p>This is a result of the underlying <a href="https://github.com/GitoxideLabs/gitoxide/security/advisories/GHSA-2frx-2596-x5r6">CVE-2025-31130 / GHSA-2frx-2596-x5r6</a> vulnerability in the gitoxide library Jujutsu uses to interact with Git repositories; see that advisory for technical details. This separate advisory is being issued due to the downstream impact on users of Jujutsu.</p>
<h3 id="impact">Impact</h3>
<p>An attacker with the ability to mount a collision attack on SHA-1 like the <a href="https://shattered.io/">SHAttered</a> or <a href="https://sha-mbles.github.io/">SHA-1 is a Shambles</a> attacks could create two distinct Git objects with the same hash. This is becoming increasingly affordable for well‐resourced attackers, with the Shambles researchers in 2020 estimating $45k for a chosen‐prefix collision or $11k for a classical collision, and projecting less than $10k for a chosen‐prefix collision by 2025. The result could be used to disguise malicious repository contents, or potentially exploit assumptions in Jujutsu’s logic to cause further vulnerabilities.</p>
<h3 id="references">References</h3>
<ul>
<li><a href="https://github.com/jj-vcs/jj/security/advisories/GHSA-794x-2rpg-rfgr">https://github.com/jj-vcs/jj/security/advisories/GHSA-794x-2rpg-rfgr</a></li>
<li><a href="https://github.com/jj-vcs/jj/commit/350da7d013773377aec0d3a4bf4374d3c941460e">https://github.com/jj-vcs/jj/commit/350da7d013773377aec0d3a4bf4374d3c941460e</a></li>
<li><a href="https://github.com/advisories/GHSA-794x-2rpg-rfgr">https://github.com/advisories/GHSA-794x-2rpg-rfgr</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-794x-2rpg-rfgr</uri>
        </author>
        <category label="severity" term="MODERATE"/>
        <published>2025-04-07T16:40:25.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[[openssl] rust-openssl Use-After-Free in `Md::fetch` and `Cipher::fetch`]]></title>
        <id>https://github.com/advisories/GHSA-4fcv-w3qc-ppgg</id>
        <link href="https://github.com/advisories/GHSA-4fcv-w3qc-ppgg"/>
        <updated>2025-04-04T20:31:09.000Z</updated>
        <content type="html"><![CDATA[<p>When a <code>Some(...)</code> value was passed to the <code>properties</code> argument of either of these functions, a use-after-free would result.</p>
<p>In practice this would nearly always result in OpenSSL treating the properties as an empty string (due to <code>CString::drop</code>'s behavior).</p>
<p>The maintainers thank <a href="https://github.com/quitbug/">quitbug</a> for reporting this vulnerability to us.</p>
<h3 id="references">References</h3>
<ul>
<li><a href="https://github.com/sfackler/rust-openssl/pull/2390">https://github.com/sfackler/rust-openssl/pull/2390</a></li>
<li><a href="https://github.com/sfackler/rust-openssl/commit/87085bd67896b7f92e6de35d081f607a334beae4">https://github.com/sfackler/rust-openssl/commit/87085bd67896b7f92e6de35d081f607a334beae4</a></li>
<li><a href="https://rustsec.org/advisories/RUSTSEC-2025-0022.html">https://rustsec.org/advisories/RUSTSEC-2025-0022.html</a></li>
<li><a href="https://github.com/advisories/GHSA-4fcv-w3qc-ppgg">https://github.com/advisories/GHSA-4fcv-w3qc-ppgg</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-4fcv-w3qc-ppgg</uri>
        </author>
        <category label="severity" term="MODERATE"/>
        <published>2025-04-04T20:31:08.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[[gix-worktree-state] gitoxide does not detect SHA-1 collision attacks]]></title>
        <id>https://github.com/advisories/GHSA-2frx-2596-x5r6</id>
        <link href="https://github.com/advisories/GHSA-2frx-2596-x5r6"/>
        <updated>2025-04-04T16:06:11.000Z</updated>
        <content type="html"><![CDATA[<h3 id="summary">Summary</h3>
<p>gitoxide uses SHA-1 hash implementations without any collision detection, leaving it vulnerable to hash collision attacks.</p>
<h3 id="details">Details</h3>
<p>gitoxide uses the <code>sha1_smol</code> or <code>sha1</code> crate, both of which implement standard SHA-1 without any mitigations for collision attacks. This means that two distinct Git objects with colliding SHA-1 hashes would break the Git object model and integrity checks when used with gitoxide.</p>
<p>The SHA-1 function is considered cryptographically insecure. However, in the wake of the SHAttered attacks, this issue was mitigated in Git 2.13.0 in 2017 by using the <a href="https://github.com/crmarcstevens/sha1collisiondetection">sha1collisiondetection</a> algorithm by default and producing an error when known SHA-1 collisions are detected. Git is in the process of migrating to using SHA-256 for object hashes, but this has not been rolled out widely yet and gitoxide does not support SHA-256 object hashes.</p>
<h3 id="poc">PoC</h3>
<p>The following program demonstrates the problem, using the two <a href="https://shattered.io/">SHAttered PDFs</a>:</p>
<pre><code class="language-rust">use sha1_checked::{CollisionResult, Digest};

fn sha1_oid_of_file(filename: &amp;str) -&gt; gix::ObjectId {
    let mut hasher = gix::features::hash::hasher(gix::hash::Kind::Sha1);
    hasher.update(&amp;std::fs::read(filename).unwrap());
    gix::ObjectId::Sha1(hasher.digest())
}

fn sha1dc_oid_of_file(filename: &amp;str) -&gt; Result&lt;gix::ObjectId, String&gt; {
    // Matches Git’s behaviour.
    let mut hasher = sha1_checked::Builder::default().safe_hash(false).build();
    hasher.update(&amp;std::fs::read(filename).unwrap());
    match hasher.try_finalize() {
        CollisionResult::Ok(digest) =&gt; Ok(gix::ObjectId::Sha1(digest.into())),
        CollisionResult::Mitigated(_) =&gt; unreachable!(),
        CollisionResult::Collision(digest) =&gt; Err(format!(
            "Collision attack: {}",
            gix::ObjectId::Sha1(digest.into()).to_hex()
        )),
    }
}

fn main() {
    dbg!(sha1_oid_of_file("shattered-1.pdf"));
    dbg!(sha1_oid_of_file("shattered-2.pdf"));
    dbg!(sha1dc_oid_of_file("shattered-1.pdf"));
    dbg!(sha1dc_oid_of_file("shattered-2.pdf"));
}
</code></pre>
<p>The output is as follows:</p>
<pre><code>[src/main.rs:24:5] sha1_oid_of_file("shattered-1.pdf") = Sha1(38762cf7f55934b34d179ae6a4c80cadccbb7f0a)
[src/main.rs:25:5] sha1_oid_of_file("shattered-2.pdf") = Sha1(38762cf7f55934b34d179ae6a4c80cadccbb7f0a)
[src/main.rs:26:5] sha1dc_oid_of_file("shattered-1.pdf") = Err(
    "Collision attack: 38762cf7f55934b34d179ae6a4c80cadccbb7f0a",
)
[src/main.rs:27:5] sha1dc_oid_of_file("shattered-2.pdf") = Err(
    "Collision attack: 38762cf7f55934b34d179ae6a4c80cadccbb7f0a",
)
</code></pre>
<p>The latter behaviour matches Git.</p>
<p>Since the SHAttered PDFs are not in a valid format for Git objects, a direct proof‐of‐concept using higher‐level APIs cannot be immediately demonstrated without significant computational resources.</p>
<h3 id="impact">Impact</h3>
<p>An attacker with the ability to mount a collision attack on SHA-1 like the <a href="https://shattered.io/">SHAttered</a> or <a href="https://sha-mbles.github.io/">SHA-1 is a Shambles</a> attacks could create two distinct Git objects with the same hash. This is becoming increasingly affordable for well‐resourced attackers, with the Shambles researchers in 2020 estimating $45k for a chosen‐prefix collision or $11k for a classical collision, and projecting less than $10k for a chosen‐prefix collision by 2025. The result could be used to disguise malicious repository contents, or potentially exploit assumptions in the logic of programs using gitoxide to cause further vulnerabilities.</p>
<p>This vulnerability affects any user of gitoxide, including <code>gix-*</code> library crates, that reads or writes Git objects.</p>
<h3 id="references">References</h3>
<ul>
<li><a href="https://github.com/GitoxideLabs/gitoxide/security/advisories/GHSA-2frx-2596-x5r6">https://github.com/GitoxideLabs/gitoxide/security/advisories/GHSA-2frx-2596-x5r6</a></li>
<li><a href="https://nvd.nist.gov/vuln/detail/CVE-2025-31130">https://nvd.nist.gov/vuln/detail/CVE-2025-31130</a></li>
<li><a href="https://github.com/GitoxideLabs/gitoxide/commit/4660f7a6f71873311f68f170b0f1f6659a02829d">https://github.com/GitoxideLabs/gitoxide/commit/4660f7a6f71873311f68f170b0f1f6659a02829d</a></li>
<li><a href="https://rustsec.org/advisories/RUSTSEC-2025-0021.html">https://rustsec.org/advisories/RUSTSEC-2025-0021.html</a></li>
<li><a href="https://github.com/advisories/GHSA-2frx-2596-x5r6">https://github.com/advisories/GHSA-2frx-2596-x5r6</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-2frx-2596-x5r6</uri>
        </author>
        <category label="severity" term="MODERATE"/>
        <published>2025-04-04T16:06:08.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[[gix-worktree] gitoxide does not detect SHA-1 collision attacks]]></title>
        <id>https://github.com/advisories/GHSA-2frx-2596-x5r6</id>
        <link href="https://github.com/advisories/GHSA-2frx-2596-x5r6"/>
        <updated>2025-04-04T16:06:11.000Z</updated>
        <content type="html"><![CDATA[<h3 id="summary">Summary</h3>
<p>gitoxide uses SHA-1 hash implementations without any collision detection, leaving it vulnerable to hash collision attacks.</p>
<h3 id="details">Details</h3>
<p>gitoxide uses the <code>sha1_smol</code> or <code>sha1</code> crate, both of which implement standard SHA-1 without any mitigations for collision attacks. This means that two distinct Git objects with colliding SHA-1 hashes would break the Git object model and integrity checks when used with gitoxide.</p>
<p>The SHA-1 function is considered cryptographically insecure. However, in the wake of the SHAttered attacks, this issue was mitigated in Git 2.13.0 in 2017 by using the <a href="https://github.com/crmarcstevens/sha1collisiondetection">sha1collisiondetection</a> algorithm by default and producing an error when known SHA-1 collisions are detected. Git is in the process of migrating to using SHA-256 for object hashes, but this has not been rolled out widely yet and gitoxide does not support SHA-256 object hashes.</p>
<h3 id="poc">PoC</h3>
<p>The following program demonstrates the problem, using the two <a href="https://shattered.io/">SHAttered PDFs</a>:</p>
<pre><code class="language-rust">use sha1_checked::{CollisionResult, Digest};

fn sha1_oid_of_file(filename: &amp;str) -&gt; gix::ObjectId {
    let mut hasher = gix::features::hash::hasher(gix::hash::Kind::Sha1);
    hasher.update(&amp;std::fs::read(filename).unwrap());
    gix::ObjectId::Sha1(hasher.digest())
}

fn sha1dc_oid_of_file(filename: &amp;str) -&gt; Result&lt;gix::ObjectId, String&gt; {
    // Matches Git’s behaviour.
    let mut hasher = sha1_checked::Builder::default().safe_hash(false).build();
    hasher.update(&amp;std::fs::read(filename).unwrap());
    match hasher.try_finalize() {
        CollisionResult::Ok(digest) =&gt; Ok(gix::ObjectId::Sha1(digest.into())),
        CollisionResult::Mitigated(_) =&gt; unreachable!(),
        CollisionResult::Collision(digest) =&gt; Err(format!(
            "Collision attack: {}",
            gix::ObjectId::Sha1(digest.into()).to_hex()
        )),
    }
}

fn main() {
    dbg!(sha1_oid_of_file("shattered-1.pdf"));
    dbg!(sha1_oid_of_file("shattered-2.pdf"));
    dbg!(sha1dc_oid_of_file("shattered-1.pdf"));
    dbg!(sha1dc_oid_of_file("shattered-2.pdf"));
}
</code></pre>
<p>The output is as follows:</p>
<pre><code>[src/main.rs:24:5] sha1_oid_of_file("shattered-1.pdf") = Sha1(38762cf7f55934b34d179ae6a4c80cadccbb7f0a)
[src/main.rs:25:5] sha1_oid_of_file("shattered-2.pdf") = Sha1(38762cf7f55934b34d179ae6a4c80cadccbb7f0a)
[src/main.rs:26:5] sha1dc_oid_of_file("shattered-1.pdf") = Err(
    "Collision attack: 38762cf7f55934b34d179ae6a4c80cadccbb7f0a",
)
[src/main.rs:27:5] sha1dc_oid_of_file("shattered-2.pdf") = Err(
    "Collision attack: 38762cf7f55934b34d179ae6a4c80cadccbb7f0a",
)
</code></pre>
<p>The latter behaviour matches Git.</p>
<p>Since the SHAttered PDFs are not in a valid format for Git objects, a direct proof‐of‐concept using higher‐level APIs cannot be immediately demonstrated without significant computational resources.</p>
<h3 id="impact">Impact</h3>
<p>An attacker with the ability to mount a collision attack on SHA-1 like the <a href="https://shattered.io/">SHAttered</a> or <a href="https://sha-mbles.github.io/">SHA-1 is a Shambles</a> attacks could create two distinct Git objects with the same hash. This is becoming increasingly affordable for well‐resourced attackers, with the Shambles researchers in 2020 estimating $45k for a chosen‐prefix collision or $11k for a classical collision, and projecting less than $10k for a chosen‐prefix collision by 2025. The result could be used to disguise malicious repository contents, or potentially exploit assumptions in the logic of programs using gitoxide to cause further vulnerabilities.</p>
<p>This vulnerability affects any user of gitoxide, including <code>gix-*</code> library crates, that reads or writes Git objects.</p>
<h3 id="references">References</h3>
<ul>
<li><a href="https://github.com/GitoxideLabs/gitoxide/security/advisories/GHSA-2frx-2596-x5r6">https://github.com/GitoxideLabs/gitoxide/security/advisories/GHSA-2frx-2596-x5r6</a></li>
<li><a href="https://nvd.nist.gov/vuln/detail/CVE-2025-31130">https://nvd.nist.gov/vuln/detail/CVE-2025-31130</a></li>
<li><a href="https://github.com/GitoxideLabs/gitoxide/commit/4660f7a6f71873311f68f170b0f1f6659a02829d">https://github.com/GitoxideLabs/gitoxide/commit/4660f7a6f71873311f68f170b0f1f6659a02829d</a></li>
<li><a href="https://rustsec.org/advisories/RUSTSEC-2025-0021.html">https://rustsec.org/advisories/RUSTSEC-2025-0021.html</a></li>
<li><a href="https://github.com/advisories/GHSA-2frx-2596-x5r6">https://github.com/advisories/GHSA-2frx-2596-x5r6</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-2frx-2596-x5r6</uri>
        </author>
        <category label="severity" term="MODERATE"/>
        <published>2025-04-04T16:06:08.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[[gix-traverse] gitoxide does not detect SHA-1 collision attacks]]></title>
        <id>https://github.com/advisories/GHSA-2frx-2596-x5r6</id>
        <link href="https://github.com/advisories/GHSA-2frx-2596-x5r6"/>
        <updated>2025-04-04T16:06:11.000Z</updated>
        <content type="html"><![CDATA[<h3 id="summary">Summary</h3>
<p>gitoxide uses SHA-1 hash implementations without any collision detection, leaving it vulnerable to hash collision attacks.</p>
<h3 id="details">Details</h3>
<p>gitoxide uses the <code>sha1_smol</code> or <code>sha1</code> crate, both of which implement standard SHA-1 without any mitigations for collision attacks. This means that two distinct Git objects with colliding SHA-1 hashes would break the Git object model and integrity checks when used with gitoxide.</p>
<p>The SHA-1 function is considered cryptographically insecure. However, in the wake of the SHAttered attacks, this issue was mitigated in Git 2.13.0 in 2017 by using the <a href="https://github.com/crmarcstevens/sha1collisiondetection">sha1collisiondetection</a> algorithm by default and producing an error when known SHA-1 collisions are detected. Git is in the process of migrating to using SHA-256 for object hashes, but this has not been rolled out widely yet and gitoxide does not support SHA-256 object hashes.</p>
<h3 id="poc">PoC</h3>
<p>The following program demonstrates the problem, using the two <a href="https://shattered.io/">SHAttered PDFs</a>:</p>
<pre><code class="language-rust">use sha1_checked::{CollisionResult, Digest};

fn sha1_oid_of_file(filename: &amp;str) -&gt; gix::ObjectId {
    let mut hasher = gix::features::hash::hasher(gix::hash::Kind::Sha1);
    hasher.update(&amp;std::fs::read(filename).unwrap());
    gix::ObjectId::Sha1(hasher.digest())
}

fn sha1dc_oid_of_file(filename: &amp;str) -&gt; Result&lt;gix::ObjectId, String&gt; {
    // Matches Git’s behaviour.
    let mut hasher = sha1_checked::Builder::default().safe_hash(false).build();
    hasher.update(&amp;std::fs::read(filename).unwrap());
    match hasher.try_finalize() {
        CollisionResult::Ok(digest) =&gt; Ok(gix::ObjectId::Sha1(digest.into())),
        CollisionResult::Mitigated(_) =&gt; unreachable!(),
        CollisionResult::Collision(digest) =&gt; Err(format!(
            "Collision attack: {}",
            gix::ObjectId::Sha1(digest.into()).to_hex()
        )),
    }
}

fn main() {
    dbg!(sha1_oid_of_file("shattered-1.pdf"));
    dbg!(sha1_oid_of_file("shattered-2.pdf"));
    dbg!(sha1dc_oid_of_file("shattered-1.pdf"));
    dbg!(sha1dc_oid_of_file("shattered-2.pdf"));
}
</code></pre>
<p>The output is as follows:</p>
<pre><code>[src/main.rs:24:5] sha1_oid_of_file("shattered-1.pdf") = Sha1(38762cf7f55934b34d179ae6a4c80cadccbb7f0a)
[src/main.rs:25:5] sha1_oid_of_file("shattered-2.pdf") = Sha1(38762cf7f55934b34d179ae6a4c80cadccbb7f0a)
[src/main.rs:26:5] sha1dc_oid_of_file("shattered-1.pdf") = Err(
    "Collision attack: 38762cf7f55934b34d179ae6a4c80cadccbb7f0a",
)
[src/main.rs:27:5] sha1dc_oid_of_file("shattered-2.pdf") = Err(
    "Collision attack: 38762cf7f55934b34d179ae6a4c80cadccbb7f0a",
)
</code></pre>
<p>The latter behaviour matches Git.</p>
<p>Since the SHAttered PDFs are not in a valid format for Git objects, a direct proof‐of‐concept using higher‐level APIs cannot be immediately demonstrated without significant computational resources.</p>
<h3 id="impact">Impact</h3>
<p>An attacker with the ability to mount a collision attack on SHA-1 like the <a href="https://shattered.io/">SHAttered</a> or <a href="https://sha-mbles.github.io/">SHA-1 is a Shambles</a> attacks could create two distinct Git objects with the same hash. This is becoming increasingly affordable for well‐resourced attackers, with the Shambles researchers in 2020 estimating $45k for a chosen‐prefix collision or $11k for a classical collision, and projecting less than $10k for a chosen‐prefix collision by 2025. The result could be used to disguise malicious repository contents, or potentially exploit assumptions in the logic of programs using gitoxide to cause further vulnerabilities.</p>
<p>This vulnerability affects any user of gitoxide, including <code>gix-*</code> library crates, that reads or writes Git objects.</p>
<h3 id="references">References</h3>
<ul>
<li><a href="https://github.com/GitoxideLabs/gitoxide/security/advisories/GHSA-2frx-2596-x5r6">https://github.com/GitoxideLabs/gitoxide/security/advisories/GHSA-2frx-2596-x5r6</a></li>
<li><a href="https://nvd.nist.gov/vuln/detail/CVE-2025-31130">https://nvd.nist.gov/vuln/detail/CVE-2025-31130</a></li>
<li><a href="https://github.com/GitoxideLabs/gitoxide/commit/4660f7a6f71873311f68f170b0f1f6659a02829d">https://github.com/GitoxideLabs/gitoxide/commit/4660f7a6f71873311f68f170b0f1f6659a02829d</a></li>
<li><a href="https://rustsec.org/advisories/RUSTSEC-2025-0021.html">https://rustsec.org/advisories/RUSTSEC-2025-0021.html</a></li>
<li><a href="https://github.com/advisories/GHSA-2frx-2596-x5r6">https://github.com/advisories/GHSA-2frx-2596-x5r6</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-2frx-2596-x5r6</uri>
        </author>
        <category label="severity" term="MODERATE"/>
        <published>2025-04-04T16:06:08.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[[gix-status] gitoxide does not detect SHA-1 collision attacks]]></title>
        <id>https://github.com/advisories/GHSA-2frx-2596-x5r6</id>
        <link href="https://github.com/advisories/GHSA-2frx-2596-x5r6"/>
        <updated>2025-04-04T16:06:11.000Z</updated>
        <content type="html"><![CDATA[<h3 id="summary">Summary</h3>
<p>gitoxide uses SHA-1 hash implementations without any collision detection, leaving it vulnerable to hash collision attacks.</p>
<h3 id="details">Details</h3>
<p>gitoxide uses the <code>sha1_smol</code> or <code>sha1</code> crate, both of which implement standard SHA-1 without any mitigations for collision attacks. This means that two distinct Git objects with colliding SHA-1 hashes would break the Git object model and integrity checks when used with gitoxide.</p>
<p>The SHA-1 function is considered cryptographically insecure. However, in the wake of the SHAttered attacks, this issue was mitigated in Git 2.13.0 in 2017 by using the <a href="https://github.com/crmarcstevens/sha1collisiondetection">sha1collisiondetection</a> algorithm by default and producing an error when known SHA-1 collisions are detected. Git is in the process of migrating to using SHA-256 for object hashes, but this has not been rolled out widely yet and gitoxide does not support SHA-256 object hashes.</p>
<h3 id="poc">PoC</h3>
<p>The following program demonstrates the problem, using the two <a href="https://shattered.io/">SHAttered PDFs</a>:</p>
<pre><code class="language-rust">use sha1_checked::{CollisionResult, Digest};

fn sha1_oid_of_file(filename: &amp;str) -&gt; gix::ObjectId {
    let mut hasher = gix::features::hash::hasher(gix::hash::Kind::Sha1);
    hasher.update(&amp;std::fs::read(filename).unwrap());
    gix::ObjectId::Sha1(hasher.digest())
}

fn sha1dc_oid_of_file(filename: &amp;str) -&gt; Result&lt;gix::ObjectId, String&gt; {
    // Matches Git’s behaviour.
    let mut hasher = sha1_checked::Builder::default().safe_hash(false).build();
    hasher.update(&amp;std::fs::read(filename).unwrap());
    match hasher.try_finalize() {
        CollisionResult::Ok(digest) =&gt; Ok(gix::ObjectId::Sha1(digest.into())),
        CollisionResult::Mitigated(_) =&gt; unreachable!(),
        CollisionResult::Collision(digest) =&gt; Err(format!(
            "Collision attack: {}",
            gix::ObjectId::Sha1(digest.into()).to_hex()
        )),
    }
}

fn main() {
    dbg!(sha1_oid_of_file("shattered-1.pdf"));
    dbg!(sha1_oid_of_file("shattered-2.pdf"));
    dbg!(sha1dc_oid_of_file("shattered-1.pdf"));
    dbg!(sha1dc_oid_of_file("shattered-2.pdf"));
}
</code></pre>
<p>The output is as follows:</p>
<pre><code>[src/main.rs:24:5] sha1_oid_of_file("shattered-1.pdf") = Sha1(38762cf7f55934b34d179ae6a4c80cadccbb7f0a)
[src/main.rs:25:5] sha1_oid_of_file("shattered-2.pdf") = Sha1(38762cf7f55934b34d179ae6a4c80cadccbb7f0a)
[src/main.rs:26:5] sha1dc_oid_of_file("shattered-1.pdf") = Err(
    "Collision attack: 38762cf7f55934b34d179ae6a4c80cadccbb7f0a",
)
[src/main.rs:27:5] sha1dc_oid_of_file("shattered-2.pdf") = Err(
    "Collision attack: 38762cf7f55934b34d179ae6a4c80cadccbb7f0a",
)
</code></pre>
<p>The latter behaviour matches Git.</p>
<p>Since the SHAttered PDFs are not in a valid format for Git objects, a direct proof‐of‐concept using higher‐level APIs cannot be immediately demonstrated without significant computational resources.</p>
<h3 id="impact">Impact</h3>
<p>An attacker with the ability to mount a collision attack on SHA-1 like the <a href="https://shattered.io/">SHAttered</a> or <a href="https://sha-mbles.github.io/">SHA-1 is a Shambles</a> attacks could create two distinct Git objects with the same hash. This is becoming increasingly affordable for well‐resourced attackers, with the Shambles researchers in 2020 estimating $45k for a chosen‐prefix collision or $11k for a classical collision, and projecting less than $10k for a chosen‐prefix collision by 2025. The result could be used to disguise malicious repository contents, or potentially exploit assumptions in the logic of programs using gitoxide to cause further vulnerabilities.</p>
<p>This vulnerability affects any user of gitoxide, including <code>gix-*</code> library crates, that reads or writes Git objects.</p>
<h3 id="references">References</h3>
<ul>
<li><a href="https://github.com/GitoxideLabs/gitoxide/security/advisories/GHSA-2frx-2596-x5r6">https://github.com/GitoxideLabs/gitoxide/security/advisories/GHSA-2frx-2596-x5r6</a></li>
<li><a href="https://nvd.nist.gov/vuln/detail/CVE-2025-31130">https://nvd.nist.gov/vuln/detail/CVE-2025-31130</a></li>
<li><a href="https://github.com/GitoxideLabs/gitoxide/commit/4660f7a6f71873311f68f170b0f1f6659a02829d">https://github.com/GitoxideLabs/gitoxide/commit/4660f7a6f71873311f68f170b0f1f6659a02829d</a></li>
<li><a href="https://rustsec.org/advisories/RUSTSEC-2025-0021.html">https://rustsec.org/advisories/RUSTSEC-2025-0021.html</a></li>
<li><a href="https://github.com/advisories/GHSA-2frx-2596-x5r6">https://github.com/advisories/GHSA-2frx-2596-x5r6</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-2frx-2596-x5r6</uri>
        </author>
        <category label="severity" term="MODERATE"/>
        <published>2025-04-04T16:06:08.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[[gix-revwalk] gitoxide does not detect SHA-1 collision attacks]]></title>
        <id>https://github.com/advisories/GHSA-2frx-2596-x5r6</id>
        <link href="https://github.com/advisories/GHSA-2frx-2596-x5r6"/>
        <updated>2025-04-04T16:06:11.000Z</updated>
        <content type="html"><![CDATA[<h3 id="summary">Summary</h3>
<p>gitoxide uses SHA-1 hash implementations without any collision detection, leaving it vulnerable to hash collision attacks.</p>
<h3 id="details">Details</h3>
<p>gitoxide uses the <code>sha1_smol</code> or <code>sha1</code> crate, both of which implement standard SHA-1 without any mitigations for collision attacks. This means that two distinct Git objects with colliding SHA-1 hashes would break the Git object model and integrity checks when used with gitoxide.</p>
<p>The SHA-1 function is considered cryptographically insecure. However, in the wake of the SHAttered attacks, this issue was mitigated in Git 2.13.0 in 2017 by using the <a href="https://github.com/crmarcstevens/sha1collisiondetection">sha1collisiondetection</a> algorithm by default and producing an error when known SHA-1 collisions are detected. Git is in the process of migrating to using SHA-256 for object hashes, but this has not been rolled out widely yet and gitoxide does not support SHA-256 object hashes.</p>
<h3 id="poc">PoC</h3>
<p>The following program demonstrates the problem, using the two <a href="https://shattered.io/">SHAttered PDFs</a>:</p>
<pre><code class="language-rust">use sha1_checked::{CollisionResult, Digest};

fn sha1_oid_of_file(filename: &amp;str) -&gt; gix::ObjectId {
    let mut hasher = gix::features::hash::hasher(gix::hash::Kind::Sha1);
    hasher.update(&amp;std::fs::read(filename).unwrap());
    gix::ObjectId::Sha1(hasher.digest())
}

fn sha1dc_oid_of_file(filename: &amp;str) -&gt; Result&lt;gix::ObjectId, String&gt; {
    // Matches Git’s behaviour.
    let mut hasher = sha1_checked::Builder::default().safe_hash(false).build();
    hasher.update(&amp;std::fs::read(filename).unwrap());
    match hasher.try_finalize() {
        CollisionResult::Ok(digest) =&gt; Ok(gix::ObjectId::Sha1(digest.into())),
        CollisionResult::Mitigated(_) =&gt; unreachable!(),
        CollisionResult::Collision(digest) =&gt; Err(format!(
            "Collision attack: {}",
            gix::ObjectId::Sha1(digest.into()).to_hex()
        )),
    }
}

fn main() {
    dbg!(sha1_oid_of_file("shattered-1.pdf"));
    dbg!(sha1_oid_of_file("shattered-2.pdf"));
    dbg!(sha1dc_oid_of_file("shattered-1.pdf"));
    dbg!(sha1dc_oid_of_file("shattered-2.pdf"));
}
</code></pre>
<p>The output is as follows:</p>
<pre><code>[src/main.rs:24:5] sha1_oid_of_file("shattered-1.pdf") = Sha1(38762cf7f55934b34d179ae6a4c80cadccbb7f0a)
[src/main.rs:25:5] sha1_oid_of_file("shattered-2.pdf") = Sha1(38762cf7f55934b34d179ae6a4c80cadccbb7f0a)
[src/main.rs:26:5] sha1dc_oid_of_file("shattered-1.pdf") = Err(
    "Collision attack: 38762cf7f55934b34d179ae6a4c80cadccbb7f0a",
)
[src/main.rs:27:5] sha1dc_oid_of_file("shattered-2.pdf") = Err(
    "Collision attack: 38762cf7f55934b34d179ae6a4c80cadccbb7f0a",
)
</code></pre>
<p>The latter behaviour matches Git.</p>
<p>Since the SHAttered PDFs are not in a valid format for Git objects, a direct proof‐of‐concept using higher‐level APIs cannot be immediately demonstrated without significant computational resources.</p>
<h3 id="impact">Impact</h3>
<p>An attacker with the ability to mount a collision attack on SHA-1 like the <a href="https://shattered.io/">SHAttered</a> or <a href="https://sha-mbles.github.io/">SHA-1 is a Shambles</a> attacks could create two distinct Git objects with the same hash. This is becoming increasingly affordable for well‐resourced attackers, with the Shambles researchers in 2020 estimating $45k for a chosen‐prefix collision or $11k for a classical collision, and projecting less than $10k for a chosen‐prefix collision by 2025. The result could be used to disguise malicious repository contents, or potentially exploit assumptions in the logic of programs using gitoxide to cause further vulnerabilities.</p>
<p>This vulnerability affects any user of gitoxide, including <code>gix-*</code> library crates, that reads or writes Git objects.</p>
<h3 id="references">References</h3>
<ul>
<li><a href="https://github.com/GitoxideLabs/gitoxide/security/advisories/GHSA-2frx-2596-x5r6">https://github.com/GitoxideLabs/gitoxide/security/advisories/GHSA-2frx-2596-x5r6</a></li>
<li><a href="https://nvd.nist.gov/vuln/detail/CVE-2025-31130">https://nvd.nist.gov/vuln/detail/CVE-2025-31130</a></li>
<li><a href="https://github.com/GitoxideLabs/gitoxide/commit/4660f7a6f71873311f68f170b0f1f6659a02829d">https://github.com/GitoxideLabs/gitoxide/commit/4660f7a6f71873311f68f170b0f1f6659a02829d</a></li>
<li><a href="https://rustsec.org/advisories/RUSTSEC-2025-0021.html">https://rustsec.org/advisories/RUSTSEC-2025-0021.html</a></li>
<li><a href="https://github.com/advisories/GHSA-2frx-2596-x5r6">https://github.com/advisories/GHSA-2frx-2596-x5r6</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-2frx-2596-x5r6</uri>
        </author>
        <category label="severity" term="MODERATE"/>
        <published>2025-04-04T16:06:08.000Z</published>
    </entry>
</feed>