<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://azu.github.io/github-advisory-database-rss/rust.rss</id>
    <title>Security Advisory for Rust crates</title>
    <updated>2025-02-19T12:02:09.466Z</updated>
    <generator>github-advisory-database-rss</generator>
    <link rel="alternate" href="https://github.com/advisories?query=type%3Areviewed+ecosystem%3Arust"/>
    <subtitle>Security Advisory for Rust crates on GitHub</subtitle>
    <rights>github-advisory-database-rss</rights>
    <category term="CRITICAL"/>
    <category term="HIGH"/>
    <category term="MODERATE"/>
    <category term="LOW"/>
    <entry>
        <title type="html"><![CDATA[[fyrox-core] Fyrox has unsound usages of `Vec::from_raw_parts` ]]></title>
        <id>https://github.com/advisories/GHSA-h7h7-6mx3-r89v</id>
        <link href="https://github.com/advisories/GHSA-h7h7-6mx3-r89v"/>
        <updated>2025-02-14T17:31:17.000Z</updated>
        <content type="html"><![CDATA[<p>The library provides a public safe API <code>transmute_vec_as_bytes</code>, which incorrectly assumes that any generic type <code>T</code> could have stable layout, causing to uninitialized memory exposure if the users pass any types with padding bytes as <code>T</code> and cast it to <code>u8</code> pointer.  </p>
<p>In the <a href="https://github.com/FyroxEngine/Fyrox/issues/630">issue</a>, we develop a PoC to show passing struct type to <code>transmute_vec_as_bytes</code> could lead to undefined behavior with <code>Vec::from_raw_parts</code>.  </p>
<p>The developers provide a patch by changing trait of <code>Copy</code> to <code>Pod</code>, which can make sure <code>T</code> should be plain data. This was patched in the latest version of <a href="https://github.com/FyroxEngine/Fyrox/blob/3f9ad6f9667047dac051b0e97d544e5b38e5ae72/fyrox-core/src/lib.rs#L351-L360">master</a> branch, but still not on the latest release (0.28.1).</p>
<h3 id="references">References</h3>
<ul>
<li><a href="https://github.com/FyroxEngine/Fyrox/issues/630">https://github.com/FyroxEngine/Fyrox/issues/630</a></li>
<li><a href="https://github.com/FyroxEngine/Fyrox/pull/662">https://github.com/FyroxEngine/Fyrox/pull/662</a></li>
<li><a href="https://github.com/FyroxEngine/Fyrox/commit/474e3b01a884366cdb7d704f7456ef692e992232">https://github.com/FyroxEngine/Fyrox/commit/474e3b01a884366cdb7d704f7456ef692e992232</a></li>
<li><a href="https://rustsec.org/advisories/RUSTSEC-2024-0435.html">https://rustsec.org/advisories/RUSTSEC-2024-0435.html</a></li>
<li><a href="https://github.com/advisories/GHSA-h7h7-6mx3-r89v">https://github.com/advisories/GHSA-h7h7-6mx3-r89v</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-h7h7-6mx3-r89v</uri>
        </author>
        <category label="severity" term="LOW"/>
        <published>2025-02-14T17:31:16.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[[orml-rewards] Uncaught Panic in ORML Rewards Pallet]]></title>
        <id>https://github.com/advisories/GHSA-5v93-9mqw-p9mh</id>
        <link href="https://github.com/advisories/GHSA-5v93-9mqw-p9mh"/>
        <updated>2025-02-14T17:26:09.000Z</updated>
        <content type="html"><![CDATA[<h2 id="summary">Summary</h2>
<p>A vulnerability in the <code>add_share</code> function of the <strong>Rewards</strong> pallet (part of the ORML repository) can lead to an uncaught Rust panic when handling user-provided input exceeding the <code>u128</code> range.</p>
<h2 id="affected-components">Affected Components</h2>
<ul>
<li><strong>ORML Rewards</strong> pallet (<code>rewards/src/lib.rs</code>)</li>
<li>Any Substrate-based chain using ORML Rewards with <code>add_share</code> accepting unvalidated large <code>u128</code> inputs</li>
</ul>
<h2 id="technical-details">Technical Details</h2>
<ul>
<li><code>add_share</code> performs arithmetic on user-supplied values (<code>add_amount</code>) of type <code>T::Share</code> (mapped to <code>u128</code> in Acala).</li>
<li>If <code>add_amount</code> is large enough (e.g., <code>i128::MAX</code>), the intermediate result may overflow and panic on the cast to <code>u128</code>.</li>
<li>Validation occurs only after arithmetic, enabling a crafted input to trigger an overflow.</li>
</ul>
<h2 id="impact">Impact</h2>
<p>A malicious user submitting a specially crafted extrinsic can cause a panic in the runtime:</p>
<ul>
<li><strong>Denial of Service</strong> by crashing the node process.</li>
<li><strong>Potential for invalid blocks</strong> produced by validators.</li>
</ul>
<h2 id="likelihood">Likelihood</h2>
<p>This issue is exploitable in production if there exists at least one rewards pool where reward tokens exceed twice the collateral tokens, allowing sufficiently large multiplication to exceed <code>u128</code> bounds.</p>
<h2 id="remediation">Remediation</h2>
<ul>
<li>This issue is fixed in <a href="https://github.com/open-web3-stack/open-runtime-module-library/pull/1016">https://github.com/open-web3-stack/open-runtime-module-library/pull/1016</a></li>
</ul>
<h2 id="backport">Backport</h2>
<p>The patch have been backported to following release branches:</p>
<ul>
<li>polkadot-stable2407</li>
<li>polkadot-stable2409</li>
</ul>
<p>A 1.0.1 patch release is made with this fix.</p>
<h3 id="references">References</h3>
<ul>
<li><a href="https://github.com/open-web3-stack/open-runtime-module-library/security/advisories/GHSA-5v93-9mqw-p9mh">https://github.com/open-web3-stack/open-runtime-module-library/security/advisories/GHSA-5v93-9mqw-p9mh</a></li>
<li><a href="https://github.com/open-web3-stack/open-runtime-module-library/pull/1016">https://github.com/open-web3-stack/open-runtime-module-library/pull/1016</a></li>
<li><a href="https://github.com/open-web3-stack/open-runtime-module-library/commit/6720fcd92f44e5f204741b04fdef3b67b0fcf6bc">https://github.com/open-web3-stack/open-runtime-module-library/commit/6720fcd92f44e5f204741b04fdef3b67b0fcf6bc</a></li>
<li><a href="https://github.com/advisories/GHSA-5v93-9mqw-p9mh">https://github.com/advisories/GHSA-5v93-9mqw-p9mh</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-5v93-9mqw-p9mh</uri>
        </author>
        <category label="severity" term="HIGH"/>
        <published>2025-02-14T17:26:08.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[[hickory-proto] Hickory DNS failure to verify self-signed RRSIG for DNSKEYs]]></title>
        <id>https://github.com/advisories/GHSA-v7pc-74h8-xq2h</id>
        <link href="https://github.com/advisories/GHSA-v7pc-74h8-xq2h"/>
        <updated>2025-02-10T21:52:30.000Z</updated>
        <content type="html"><![CDATA[<p>Summary</p>
<p>The DNSSEC validation routines treat entire RRsets of DNSKEY records as trusted once they have established trust in only one of the DNSKEYs. As a result, if a zone includes a DNSKEY with a public key that matches a configured trust anchor, all keys in that zone will be trusted to authenticate other records in the zone. There is a second variant of this vulnerability involving DS records, where an authenticated DS record covering one DNSKEY leads to trust in signatures made by an unrelated DNSKEY in the same zone.</p>
<p>Details</p>
<p>verify_dnskey_rrset() will return Ok(true) if any record's public key matches a trust anchor. This results in verify_rrset() returning a Secure proof. This ultimately results in successfully verifying a response containing DNSKEY records. verify_default_rrset() looks up DNSKEY records by calling handle.lookup(), which takes the above code path. There's a comment following this that says "DNSKEYs were already validated by the inner query in the above lookup", but this is not the case. To fully verify the whole RRset of DNSKEYs, it would be necessary to check self-signatures by the trusted key over the other keys. Later in verify_default_rrset(), verify_rrset_with_dnskey() is called multiple times with different keys and signatures, and if any call succeeds, then its Proof is returned.</p>
<p>Similarly, verify_dnskey_rrset() returns Ok(false) if any DNSKEY record is covered by a DS record. A comment says "If all the keys are valid, then we are secure", but this is only checking that one key is authenticated by a DS in the parent zone's delegation point. This time, after control flow returns to verify_rrset(), it will call verify_default_rrset(). The special handling for DNSKEYs in verify_default_rrset() will then call verify_rrset_with_dnskey() using each KSK DNSKEY record, and if one call succeeds, return its Proof. If there are multiple KSK DNSKEYs in the RRset, then this leads to another authentication break. We need to either pass the authenticated DNSKEYs from the DS covering check to the RRSIG validation, or we need to perform this RRSIG validation of the DNSKEY RRset inside verify_dnskey_rrset() and cut verify_default_rrset() out of DNSKEY RRset validation entirely.</p>
<h3 id="references">References</h3>
<ul>
<li><a href="https://github.com/hickory-dns/hickory-dns/security/advisories/GHSA-37wc-h8xc-5hc4">https://github.com/hickory-dns/hickory-dns/security/advisories/GHSA-37wc-h8xc-5hc4</a></li>
<li><a href="https://rustsec.org/advisories/RUSTSEC-2025-0006.html">https://rustsec.org/advisories/RUSTSEC-2025-0006.html</a></li>
<li><a href="https://github.com/advisories/GHSA-v7pc-74h8-xq2h">https://github.com/advisories/GHSA-v7pc-74h8-xq2h</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-v7pc-74h8-xq2h</uri>
        </author>
        <category label="severity" term="MODERATE"/>
        <published>2025-02-10T21:52:28.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[[hickory-proto] Hickory DNS failure to verify self-signed RRSIG for DNSKEYs]]></title>
        <id>https://github.com/advisories/GHSA-v7pc-74h8-xq2h</id>
        <link href="https://github.com/advisories/GHSA-v7pc-74h8-xq2h"/>
        <updated>2025-02-10T21:52:30.000Z</updated>
        <content type="html"><![CDATA[<p>Summary</p>
<p>The DNSSEC validation routines treat entire RRsets of DNSKEY records as trusted once they have established trust in only one of the DNSKEYs. As a result, if a zone includes a DNSKEY with a public key that matches a configured trust anchor, all keys in that zone will be trusted to authenticate other records in the zone. There is a second variant of this vulnerability involving DS records, where an authenticated DS record covering one DNSKEY leads to trust in signatures made by an unrelated DNSKEY in the same zone.</p>
<p>Details</p>
<p>verify_dnskey_rrset() will return Ok(true) if any record's public key matches a trust anchor. This results in verify_rrset() returning a Secure proof. This ultimately results in successfully verifying a response containing DNSKEY records. verify_default_rrset() looks up DNSKEY records by calling handle.lookup(), which takes the above code path. There's a comment following this that says "DNSKEYs were already validated by the inner query in the above lookup", but this is not the case. To fully verify the whole RRset of DNSKEYs, it would be necessary to check self-signatures by the trusted key over the other keys. Later in verify_default_rrset(), verify_rrset_with_dnskey() is called multiple times with different keys and signatures, and if any call succeeds, then its Proof is returned.</p>
<p>Similarly, verify_dnskey_rrset() returns Ok(false) if any DNSKEY record is covered by a DS record. A comment says "If all the keys are valid, then we are secure", but this is only checking that one key is authenticated by a DS in the parent zone's delegation point. This time, after control flow returns to verify_rrset(), it will call verify_default_rrset(). The special handling for DNSKEYs in verify_default_rrset() will then call verify_rrset_with_dnskey() using each KSK DNSKEY record, and if one call succeeds, return its Proof. If there are multiple KSK DNSKEYs in the RRset, then this leads to another authentication break. We need to either pass the authenticated DNSKEYs from the DS covering check to the RRSIG validation, or we need to perform this RRSIG validation of the DNSKEY RRset inside verify_dnskey_rrset() and cut verify_default_rrset() out of DNSKEY RRset validation entirely.</p>
<h3 id="references">References</h3>
<ul>
<li><a href="https://github.com/hickory-dns/hickory-dns/security/advisories/GHSA-37wc-h8xc-5hc4">https://github.com/hickory-dns/hickory-dns/security/advisories/GHSA-37wc-h8xc-5hc4</a></li>
<li><a href="https://rustsec.org/advisories/RUSTSEC-2025-0006.html">https://rustsec.org/advisories/RUSTSEC-2025-0006.html</a></li>
<li><a href="https://github.com/advisories/GHSA-v7pc-74h8-xq2h">https://github.com/advisories/GHSA-v7pc-74h8-xq2h</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-v7pc-74h8-xq2h</uri>
        </author>
        <category label="severity" term="MODERATE"/>
        <published>2025-02-10T21:52:28.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[[activitypub_federation] Server-Side Request Forgery (SSRF) in activitypub_federation]]></title>
        <id>https://github.com/advisories/GHSA-7723-35v7-qcxw</id>
        <link href="https://github.com/advisories/GHSA-7723-35v7-qcxw"/>
        <updated>2025-02-11T00:33:49.000Z</updated>
        <content type="html"><![CDATA[<h3 id="summary">Summary</h3>
<p>This vulnerability allows a user to bypass any predefined hardcoded URL path or security anti-Localhost mechanism and perform an arbitrary GET request to any Host, Port and URL using a Webfinger Request.</p>
<h3 id="details">Details</h3>
<p>The Webfinger endpoint takes a remote domain for checking accounts as a feature, however, as per the ActivityPub spec (<a href="https://www.w3.org/TR/activitypub/#security-considerations">https://www.w3.org/TR/activitypub/#security-considerations</a>), on the security considerations section at B.3, access to Localhost services should be prevented while running in production.
The library attempts to prevent Localhost access using the following mechanism (/src/config.rs):</p>
<pre><code class="language-rust">pub(crate) async fn verify_url_valid(&amp;self, url: &amp;Url) -&gt; Result&lt;(), Error&gt; {
        match url.scheme() {
            "https" =&gt; {}
            "http" =&gt; {
                if !self.allow_http_urls {
                    return Err(Error::UrlVerificationError(
                        "Http urls are only allowed in debug mode",
                    ));
                }
            }
            _ =&gt; return Err(Error::UrlVerificationError("Invalid url scheme")),
        };

        // Urls which use our local domain are not a security risk, no further verification needed
        if self.is_local_url(url) {
            return Ok(());
        }

        if url.domain().is_none() {
            return Err(Error::UrlVerificationError("Url must have a domain"));
        }

        if url.domain() == Some("localhost") &amp;&amp; !self.debug {
            return Err(Error::UrlVerificationError(
                "Localhost is only allowed in debug mode",
            ));
        }

        self.url_verifier.verify(url).await?;

        Ok(())
    }
</code></pre>
<p>There are multiple issues with the current anti-Localhost implementation: </p>
<ol>
<li>It does not resolve the domain address supplied by the user.</li>
<li>The Localhost check is using only a simple comparison method while ignoring more complex malicious tampering attempts.</li>
<li>It filters only localhost domains, without any regard for alternative local IP domains or other sensitive domains, such internal network or cloud metadata domains.</li>
</ol>
<p>We can reach the verify_url_valid function while sending a Webfinger request to lookup a user’s account (/src/fetch/webfinger.rs):</p>
<pre><code class="language-rust">pub async fn webfinger_resolve_actor&lt;T: Clone, Kind&gt;(
    identifier: &amp;str,
    data: &amp;Data&lt;T&gt;,
) -&gt; Result&lt;Kind, &lt;Kind as Object&gt;::Error&gt;
where
    Kind: Object + Actor + Send + 'static + Object&lt;DataType = T&gt;,
    for&lt;'de2&gt; &lt;Kind as Object&gt;::Kind: serde::Deserialize&lt;'de2&gt;,
    &lt;Kind as Object&gt;::Error: From&lt;crate::error::Error&gt; + Send + Sync + Display,
{
    let (_, domain) = identifier
        .splitn(2, '@')
        .collect_tuple()
        .ok_or(WebFingerError::WrongFormat.into_crate_error())?;
    let protocol = if data.config.debug { "http" } else { "https" };
    let fetch_url =
        format!("{protocol}://{domain}/.well-known/webfinger?resource=acct:{identifier}");
    debug!("Fetching webfinger url: {}", &amp;fetch_url);

    let res: Webfinger = fetch_object_http_with_accept(
        &amp;Url::parse(&amp;fetch_url).map_err(Error::UrlParse)?,
        data,
        &amp;WEBFINGER_CONTENT_TYPE,
    )
    .await?
    .object;

    debug_assert_eq!(res.subject, format!("acct:{identifier}"));
    let links: Vec&lt;Url&gt; = res
        .links
        .iter()
        .filter(|link| {
            if let Some(type_) = &amp;link.kind {
                type_.starts_with("application/")
            } else {
                false
            }
        })
        .filter_map(|l| l.href.clone())
        .collect();

    for l in links {
        let object = ObjectId::&lt;Kind&gt;::from(l).dereference(data).await;
        match object {
            Ok(obj) =&gt; return Ok(obj),
            Err(error) =&gt; debug!(%error, "Failed to dereference link"),
        }
    }
    Err(WebFingerError::NoValidLink.into_crate_error().into())
}
</code></pre>
<p>The Webfinger logic takes the user account from the GET parameter “resource” and sinks the domain directly into the hardcoded Webfinger URL (“{protocol}://{domain}/.well-known/webfinger?resource=acct:{identifier}”) without any additional checks.
Afterwards the user domain input will pass into the “fetch_object_http_with_accept” function and finally into the security check on “verify_url_valid” function, again, without any form of sanitizing or input validation.
An adversary can cause unwanted behaviours using multiple techniques:</p>
<ol>
<li><p><strong><em>Gaining control over the query’s path:</em></strong>
An adversary can manipulate the Webfinger hard-coded URL, gaining full control over the GET request domain, path and port by submitting malicious input like: hacker@hacker_host:1337/hacker_path?hacker_param#, which in turn will result in the following string:
http[s]://hacker_host:1337/hacker_path?hacker_param#/.well-known/webfinger?resource=acct:{identifier}, directing the URL into another domain and path without any issues as the hash character renders the rest of the URL path unrecognized by the webserver.</p>
</li>
<li><p><strong><em>Bypassing the domain’s restriction using DNS resolving mechanism:</em></strong>
An adversary can manipulate the security check and force it to look for internal services regardless the Localhost check by using a domain name that resolves into a local IP (such as: localh.st, for example), as the security check does not verify the resolved IP at all - any service under the Localhost domain can be reached.</p>
</li>
<li><p><em><strong>Bypassing the domain’s restriction using official Fully Qualified Domain Names (FQDNs):</strong></em>
In the official DNS specifications, a fully qualified domain name actually should end with a dot.
While most of the time a domain name is presented without any trailing dot, the resolver will assume it exists, however - it is still possible to use a domain name with a trailing dot which will resolve correctly.
As the Localhost check is mainly a simple comparison check - if we register a “hacker@localhost.” domain it will pass the test as “localhost” is not equal to “localhost.”, however the domain will be valid (Using this mechanism it is also possible to bypass any domain blocklist mechanism).</p>
</li>
</ol>
<h3 id="poc">PoC</h3>
<ol>
<li>Activate a local HTTP server listening to port 1234 with a “secret.txt” file:
<code>python3 -m http.server 1234</code></li>
<li>Open the “main.rs” file inside the “example” folder on the activitypub-federated-rust project, and modify the “beta@localhost” string into “<a href="mailto:hacker@localh.st">hacker@localh.st</a>:1234/secret.txt?something=1#”.</li>
<li>Run the example using the following command:
<code>cargo run --example local_federation axum</code></li>
<li>View the console of the Python’s HTTP server and see that a request for a “secret.txt” file was performed.</li>
</ol>
<p>This proves that we can redirect the URL to any domain and path we choose.
Now on the next steps we will prove that the security checks of Localhost and blocked domains can be easily bypassed (both checks use the same comparison mechanism).</p>
<ol>
<li>Now open the “instance.rs” file inside the “example” folder and view that the domain “malicious.com” is blocked (you can switch it to any desired domain address).</li>
<li>Change the same “beta@localhost” string into “<a href="mailto:hacker@malicious.com">hacker@malicious.com</a>” and run the example command to see that the malicious domain blocking mechanism is working as expected.</li>
<li>Now change the “<a href="mailto:hacker@malicious.com">hacker@malicious.com</a>” string into  “<a href="mailto:hacker@malicious.com">hacker@malicious.com</a>.” string and re-initiate the example, view now that the check passed successfully.</li>
<li>You can combine both methods on “localhost.” domain (or any other domain) to verify that the FQDNs resolving is indeed successful.</li>
</ol>
<h3 id="impact">Impact</h3>
<p>Due to this issue, any user can cause the server to send GET requests with controlled path and port in an attempt to query services running on the instance’s host, and attempt to execute a Blind-SSRF gadget in hope of targeting a known vulnerable local service running on the victim’s machine.</p>
<h3 id="fix-suggestion">Fix Suggestion</h3>
<p>Modify the domain validation mechanism and implement the following checks:</p>
<ol>
<li>Resolve the domain and validate it is not using any invalid IP address (internal, or cloud metadata IPs) using regexes of both IPv4 and IPv6 addresses.
For Implementation example of a good SSRF prevention practice you can review a similiar project such as “Fedify” (<a href="https://github.com/dahlia/fedify/blob/main/src/runtime/url.ts">https://github.com/dahlia/fedify/blob/main/src/runtime/url.ts</a>) which handles external URL resource correctly.
Note that it is still needed to remove unwanted characters from the URL. </li>
<li>Filter the user’s input for any unwanted characters that should not be present on a domain name, such as #,?,/, etc.</li>
<li>Perform checks that make sure the desired request path is the executed path with the same port.</li>
<li>Disable automatic HTTP redirect follows on the implemented client, as redirects can be used for security mechanisms circumvention.</li>
</ol>
<h3 id="references">References</h3>
<ul>
<li><a href="https://github.com/LemmyNet/lemmy/security/advisories/GHSA-7723-35v7-qcxw">https://github.com/LemmyNet/lemmy/security/advisories/GHSA-7723-35v7-qcxw</a></li>
<li><a href="https://nvd.nist.gov/vuln/detail/CVE-2025-25194">https://nvd.nist.gov/vuln/detail/CVE-2025-25194</a></li>
<li><a href="https://github.com/advisories/GHSA-7723-35v7-qcxw">https://github.com/advisories/GHSA-7723-35v7-qcxw</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-7723-35v7-qcxw</uri>
        </author>
        <category label="severity" term="MODERATE"/>
        <published>2025-02-10T20:25:37.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[[grcov] grcov has an out of bounds write triggered by crafted coverage data]]></title>
        <id>https://github.com/advisories/GHSA-qm2p-4w45-v2vr</id>
        <link href="https://github.com/advisories/GHSA-qm2p-4w45-v2vr"/>
        <updated>2025-02-10T18:07:31.000Z</updated>
        <content type="html"><![CDATA[<p>Function <code>grcov::covdir::get_coverage</code> uses the <code>unsafe</code> function <code>get_unchecked_mut</code> without validating that the index is in bounds.</p>
<p>This results in memory corruption, and could potentially allow arbitrary code execution provided that an attacker can feed the tool crafted coverage data.</p>
<h3 id="references">References</h3>
<ul>
<li><a href="https://github.com/mozilla/grcov/commit/c8219563bc91615dd4a27884a5c63f09db8d03bb">https://github.com/mozilla/grcov/commit/c8219563bc91615dd4a27884a5c63f09db8d03bb</a></li>
<li><a href="https://bugzilla.mozilla.org/show_bug.cgi?id=1917475">https://bugzilla.mozilla.org/show_bug.cgi?id=1917475</a></li>
<li><a href="https://rustsec.org/advisories/RUSTSEC-2025-0005.html">https://rustsec.org/advisories/RUSTSEC-2025-0005.html</a></li>
<li><a href="https://github.com/advisories/GHSA-qm2p-4w45-v2vr">https://github.com/advisories/GHSA-qm2p-4w45-v2vr</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-qm2p-4w45-v2vr</uri>
        </author>
        <category label="severity" term="MODERATE"/>
        <published>2025-02-10T18:07:30.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[[hickory-proto] Hickory DNS's DNSSEC validation may accept broken authentication chains]]></title>
        <id>https://github.com/advisories/GHSA-37wc-h8xc-5hc4</id>
        <link href="https://github.com/advisories/GHSA-37wc-h8xc-5hc4"/>
        <updated>2025-02-10T19:51:26.000Z</updated>
        <content type="html"><![CDATA[<h3 id="summary">Summary</h3>
<p>The DNSSEC validation routines treat entire RRsets of DNSKEY records as trusted once they have established trust in only one of the DNSKEYs. As a result, if a zone includes a DNSKEY with a public key that matches a configured trust anchor, all keys in that zone will be trusted to authenticate other records in the zone. There is a second variant of this vulnerability involving DS records, where an authenticated DS record covering one DNSKEY leads to trust in signatures made by an unrelated DNSKEY in the same zone.</p>
<h3 id="details">Details</h3>
<p><code>verify_dnskey_rrset()</code> will return <code>Ok(true)</code> if any record's public key matches a trust anchor. This results in <code>verify_rrset()</code> returning a <code>Secure</code> proof. This ultimately results in successfully verifying a response containing DNSKEY records. <code>verify_default_rrset()</code> looks up DNSKEY records by calling <code>handle.lookup()</code>, which takes the above code path. There's a comment following this that says "DNSKEYs were already validated by the inner query in the above lookup", but this is not the case. To fully verify the whole RRset of DNSKEYs, it would be necessary to check self-signatures by the trusted key over the other keys. Later in <code>verify_default_rrset()</code>, <code>verify_rrset_with_dnskey()</code> is called multiple times with different keys and signatures, and if any call succeeds, then its <code>Proof</code> is returned.</p>
<p>Similarly, <code>verify_dnskey_rrset()</code> returns <code>Ok(false)</code> if any DNSKEY record is covered by a DS record. A comment says "If all the keys are valid, then we are secure", but this is only checking that one key is authenticated by a DS in the parent zone's delegation point. This time, after control flow returns to <code>verify_rrset()</code>, it will call <code>verify_default_rrset()</code>. The special handling for DNSKEYs in <code>verify_default_rrset()</code> will then call <code>verify_rrset_with_dnskey()</code> using each KSK DNSKEY record, and if one call succeeds, return its <code>Proof</code>. If there are multiple KSK DNSKEYs in the RRset, then this leads to another authentication break. We need to either pass the authenticated DNSKEYs from the DS covering check to the RRSIG validation, or we need to perform this RRSIG validation of the DNSKEY RRset inside <code>verify_dnskey_rrset()</code> and cut <code>verify_default_rrset()</code> out of DNSKEY RRset validation entirely.</p>
<h3 id="poc">PoC</h3>
<p>The proof of concepts have been integrated into the conformance test suite, as <code>resolver::dnssec::scenarios::bogus::bogus_zone_plus_trust_anchor_dnskey</code> and <code>resolver::dnssec::scenarios::bogus::bogus_zone_plus_ds_covered_dnskey</code>.</p>
<h3 id="impact">Impact</h3>
<p>This impacts Hickory DNS users relying on DNSSEC verification in the client library, stub resolver, or recursive resolver.</p>
<h3 id="references">References</h3>
<ul>
<li><a href="https://github.com/hickory-dns/hickory-dns/security/advisories/GHSA-37wc-h8xc-5hc4">https://github.com/hickory-dns/hickory-dns/security/advisories/GHSA-37wc-h8xc-5hc4</a></li>
<li><a href="https://nvd.nist.gov/vuln/detail/CVE-2025-25188">https://nvd.nist.gov/vuln/detail/CVE-2025-25188</a></li>
<li><a href="https://github.com/hickory-dns/hickory-dns/commit/e118c6eec569f4340421f86ee0686714010c63e9">https://github.com/hickory-dns/hickory-dns/commit/e118c6eec569f4340421f86ee0686714010c63e9</a></li>
<li><a href="https://github.com/advisories/GHSA-37wc-h8xc-5hc4">https://github.com/advisories/GHSA-37wc-h8xc-5hc4</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-37wc-h8xc-5hc4</uri>
        </author>
        <category label="severity" term="MODERATE"/>
        <published>2025-02-10T17:46:00.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[[cosmwasm-vm] wasmvm: Malicious smart contract can slow down block production]]></title>
        <id>https://github.com/advisories/GHSA-mx2j-7cmv-353c</id>
        <link href="https://github.com/advisories/GHSA-mx2j-7cmv-353c"/>
        <updated>2025-02-06T18:03:26.000Z</updated>
        <content type="html"><![CDATA[<h1 id="cwa-2025-002">CWA-2025-002</h1>
<p><strong>Severity</strong></p>
<p>Medium (Moderate + Likely)[^1]</p>
<p><strong>Affected versions:</strong></p>
<ul>
<li>wasmvm &gt;= 2.2.0, &lt; 2.2.2</li>
<li>wasmvm &gt;= 2.1.0, &lt; 2.1.5</li>
<li>wasmvm &gt;= 2.0.0, &lt; 2.0.6</li>
<li>wasmvm &lt; 1.5.8</li>
</ul>
<p><strong>Patched versions:</strong></p>
<ul>
<li>wasmvm 1.5.8, 2.0.6, 2.1.5, 2.2.2</li>
</ul>
<h2 id="description-of-the-bug">Description of the bug</h2>
<p>The vulnerability can be used to slow down block production. The attack requires a malicious contract,
so permissioned chains are unlikely to be affected.</p>
<p>(We'll add more detail once chains had a chance to upgrade.)</p>
<h2 id="patch">Patch</h2>
<ul>
<li>1.5: <a href="https://github.com/CosmWasm/cosmwasm/commit/2b7f2faa57a1efc8207455c37f87f1eee6035a27">https://github.com/CosmWasm/cosmwasm/commit/2b7f2faa57a1efc8207455c37f87f1eee6035a27</a></li>
<li>2.0: <a href="https://github.com/CosmWasm/cosmwasm/commit/d6143b0aff16a39bbea4be37597d8e9d9b213d3b">https://github.com/CosmWasm/cosmwasm/commit/d6143b0aff16a39bbea4be37597d8e9d9b213d3b</a></li>
<li>2.1: <a href="https://github.com/CosmWasm/cosmwasm/commit/f0c04c03cbe2557634c1bbcdc2ce203fe7caca58">https://github.com/CosmWasm/cosmwasm/commit/f0c04c03cbe2557634c1bbcdc2ce203fe7caca58</a></li>
<li>2.2: <a href="https://github.com/CosmWasm/cosmwasm/commit/a5d62f65b5eb947ebe40e2085b1c48a9d0a244d0">https://github.com/CosmWasm/cosmwasm/commit/a5d62f65b5eb947ebe40e2085b1c48a9d0a244d0</a></li>
</ul>
<h2 id="applying-the-patch">Applying the patch</h2>
<p>The patch will be shipped in releases of wasmvm. You can update more or less as follows:</p>
<ol>
<li>Check the current wasmvm version: <code>go list -m github.com/CosmWasm/wasmvm</code></li>
<li>Bump the <code>github.com/CosmWasm/wasmvm</code> dependency in your go.mod to one of the patched version
depending on which minor version you are on; <code>go mod tidy</code>; commit.</li>
<li>If you use the static libraries <code>libwasmvm_muslc.aarch64.a</code>/<code>libwasmvm_muslc.x86_64.a</code>, update them accordingly.</li>
<li>Check the updated wasmvm version: <code>go list -m github.com/CosmWasm/wasmvm</code> and ensure you see 1.5.8, 2.0.6, 2.1.5 or 2.2.2.</li>
<li>Follow your regular practices to deploy chain upgrades.</li>
</ol>
<p>The patch is consensus breaking and requires a coordinated upgrade.</p>
<h2 id="acknowledgement">Acknowledgement</h2>
<p>This issue was found by meadow101 who reported it to the Cosmos Bug Bounty Program on HackerOne.</p>
<p>If you believe you have found a bug in the Interchain Stack or would like to contribute to the
program by reporting a bug, please see <a href="https://hackerone.com/cosmos">https://hackerone.com/cosmos</a>.</p>
<h2 id="timeline">Timeline</h2>
<ul>
<li>2024-11-24: Confio receives a report through the Cosmos bug bounty program maintained by Amulet.</li>
<li>2024-12-20: Confio security contributors confirm the report.</li>
<li>2024-01-27: Confio developed the patch internally.</li>
<li>2025-02-04: Patch gets released.</li>
</ul>
<p>[^1]: following Amulet's Severity Classification Framework ACMv1.2: <a href="https://github.com/interchainio/security/blob/0295254e8645301ccb606d46108a45cede0a73e0/resources/CLASSIFICATION_MATRIX.md">https://github.com/interchainio/security/blob/0295254e8645301ccb606d46108a45cede0a73e0/resources/CLASSIFICATION_MATRIX.md</a></p>
<h3 id="references">References</h3>
<ul>
<li><a href="https://github.com/CosmWasm/wasmvm/security/advisories/GHSA-mx2j-7cmv-353c">https://github.com/CosmWasm/wasmvm/security/advisories/GHSA-mx2j-7cmv-353c</a></li>
<li><a href="https://github.com/CosmWasm/cosmwasm/commit/2b7f2faa57a1efc8207455c37f87f1eee6035a27">https://github.com/CosmWasm/cosmwasm/commit/2b7f2faa57a1efc8207455c37f87f1eee6035a27</a></li>
<li><a href="https://github.com/CosmWasm/cosmwasm/commit/a5d62f65b5eb947ebe40e2085b1c48a9d0a244d0">https://github.com/CosmWasm/cosmwasm/commit/a5d62f65b5eb947ebe40e2085b1c48a9d0a244d0</a></li>
<li><a href="https://github.com/CosmWasm/cosmwasm/commit/d6143b0aff16a39bbea4be37597d8e9d9b213d3b">https://github.com/CosmWasm/cosmwasm/commit/d6143b0aff16a39bbea4be37597d8e9d9b213d3b</a></li>
<li><a href="https://github.com/CosmWasm/cosmwasm/commit/f0c04c03cbe2557634c1bbcdc2ce203fe7caca58">https://github.com/CosmWasm/cosmwasm/commit/f0c04c03cbe2557634c1bbcdc2ce203fe7caca58</a></li>
<li><a href="https://github.com/CosmWasm/advisories/blob/main/CWAs/CWA-2025-002.md">https://github.com/CosmWasm/advisories/blob/main/CWAs/CWA-2025-002.md</a></li>
<li><a href="https://pkg.go.dev/vuln/GO-2025-3449">https://pkg.go.dev/vuln/GO-2025-3449</a></li>
<li><a href="https://github.com/advisories/GHSA-mx2j-7cmv-353c">https://github.com/advisories/GHSA-mx2j-7cmv-353c</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-mx2j-7cmv-353c</uri>
        </author>
        <category label="severity" term="MODERATE"/>
        <published>2025-02-04T18:57:21.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[[cosmwasm-vm] wasmvm: Malicious smart contract can slow down block production]]></title>
        <id>https://github.com/advisories/GHSA-mx2j-7cmv-353c</id>
        <link href="https://github.com/advisories/GHSA-mx2j-7cmv-353c"/>
        <updated>2025-02-06T18:03:26.000Z</updated>
        <content type="html"><![CDATA[<h1 id="cwa-2025-002">CWA-2025-002</h1>
<p><strong>Severity</strong></p>
<p>Medium (Moderate + Likely)[^1]</p>
<p><strong>Affected versions:</strong></p>
<ul>
<li>wasmvm &gt;= 2.2.0, &lt; 2.2.2</li>
<li>wasmvm &gt;= 2.1.0, &lt; 2.1.5</li>
<li>wasmvm &gt;= 2.0.0, &lt; 2.0.6</li>
<li>wasmvm &lt; 1.5.8</li>
</ul>
<p><strong>Patched versions:</strong></p>
<ul>
<li>wasmvm 1.5.8, 2.0.6, 2.1.5, 2.2.2</li>
</ul>
<h2 id="description-of-the-bug">Description of the bug</h2>
<p>The vulnerability can be used to slow down block production. The attack requires a malicious contract,
so permissioned chains are unlikely to be affected.</p>
<p>(We'll add more detail once chains had a chance to upgrade.)</p>
<h2 id="patch">Patch</h2>
<ul>
<li>1.5: <a href="https://github.com/CosmWasm/cosmwasm/commit/2b7f2faa57a1efc8207455c37f87f1eee6035a27">https://github.com/CosmWasm/cosmwasm/commit/2b7f2faa57a1efc8207455c37f87f1eee6035a27</a></li>
<li>2.0: <a href="https://github.com/CosmWasm/cosmwasm/commit/d6143b0aff16a39bbea4be37597d8e9d9b213d3b">https://github.com/CosmWasm/cosmwasm/commit/d6143b0aff16a39bbea4be37597d8e9d9b213d3b</a></li>
<li>2.1: <a href="https://github.com/CosmWasm/cosmwasm/commit/f0c04c03cbe2557634c1bbcdc2ce203fe7caca58">https://github.com/CosmWasm/cosmwasm/commit/f0c04c03cbe2557634c1bbcdc2ce203fe7caca58</a></li>
<li>2.2: <a href="https://github.com/CosmWasm/cosmwasm/commit/a5d62f65b5eb947ebe40e2085b1c48a9d0a244d0">https://github.com/CosmWasm/cosmwasm/commit/a5d62f65b5eb947ebe40e2085b1c48a9d0a244d0</a></li>
</ul>
<h2 id="applying-the-patch">Applying the patch</h2>
<p>The patch will be shipped in releases of wasmvm. You can update more or less as follows:</p>
<ol>
<li>Check the current wasmvm version: <code>go list -m github.com/CosmWasm/wasmvm</code></li>
<li>Bump the <code>github.com/CosmWasm/wasmvm</code> dependency in your go.mod to one of the patched version
depending on which minor version you are on; <code>go mod tidy</code>; commit.</li>
<li>If you use the static libraries <code>libwasmvm_muslc.aarch64.a</code>/<code>libwasmvm_muslc.x86_64.a</code>, update them accordingly.</li>
<li>Check the updated wasmvm version: <code>go list -m github.com/CosmWasm/wasmvm</code> and ensure you see 1.5.8, 2.0.6, 2.1.5 or 2.2.2.</li>
<li>Follow your regular practices to deploy chain upgrades.</li>
</ol>
<p>The patch is consensus breaking and requires a coordinated upgrade.</p>
<h2 id="acknowledgement">Acknowledgement</h2>
<p>This issue was found by meadow101 who reported it to the Cosmos Bug Bounty Program on HackerOne.</p>
<p>If you believe you have found a bug in the Interchain Stack or would like to contribute to the
program by reporting a bug, please see <a href="https://hackerone.com/cosmos">https://hackerone.com/cosmos</a>.</p>
<h2 id="timeline">Timeline</h2>
<ul>
<li>2024-11-24: Confio receives a report through the Cosmos bug bounty program maintained by Amulet.</li>
<li>2024-12-20: Confio security contributors confirm the report.</li>
<li>2024-01-27: Confio developed the patch internally.</li>
<li>2025-02-04: Patch gets released.</li>
</ul>
<p>[^1]: following Amulet's Severity Classification Framework ACMv1.2: <a href="https://github.com/interchainio/security/blob/0295254e8645301ccb606d46108a45cede0a73e0/resources/CLASSIFICATION_MATRIX.md">https://github.com/interchainio/security/blob/0295254e8645301ccb606d46108a45cede0a73e0/resources/CLASSIFICATION_MATRIX.md</a></p>
<h3 id="references">References</h3>
<ul>
<li><a href="https://github.com/CosmWasm/wasmvm/security/advisories/GHSA-mx2j-7cmv-353c">https://github.com/CosmWasm/wasmvm/security/advisories/GHSA-mx2j-7cmv-353c</a></li>
<li><a href="https://github.com/CosmWasm/cosmwasm/commit/2b7f2faa57a1efc8207455c37f87f1eee6035a27">https://github.com/CosmWasm/cosmwasm/commit/2b7f2faa57a1efc8207455c37f87f1eee6035a27</a></li>
<li><a href="https://github.com/CosmWasm/cosmwasm/commit/a5d62f65b5eb947ebe40e2085b1c48a9d0a244d0">https://github.com/CosmWasm/cosmwasm/commit/a5d62f65b5eb947ebe40e2085b1c48a9d0a244d0</a></li>
<li><a href="https://github.com/CosmWasm/cosmwasm/commit/d6143b0aff16a39bbea4be37597d8e9d9b213d3b">https://github.com/CosmWasm/cosmwasm/commit/d6143b0aff16a39bbea4be37597d8e9d9b213d3b</a></li>
<li><a href="https://github.com/CosmWasm/cosmwasm/commit/f0c04c03cbe2557634c1bbcdc2ce203fe7caca58">https://github.com/CosmWasm/cosmwasm/commit/f0c04c03cbe2557634c1bbcdc2ce203fe7caca58</a></li>
<li><a href="https://github.com/CosmWasm/advisories/blob/main/CWAs/CWA-2025-002.md">https://github.com/CosmWasm/advisories/blob/main/CWAs/CWA-2025-002.md</a></li>
<li><a href="https://pkg.go.dev/vuln/GO-2025-3449">https://pkg.go.dev/vuln/GO-2025-3449</a></li>
<li><a href="https://github.com/advisories/GHSA-mx2j-7cmv-353c">https://github.com/advisories/GHSA-mx2j-7cmv-353c</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-mx2j-7cmv-353c</uri>
        </author>
        <category label="severity" term="MODERATE"/>
        <published>2025-02-04T18:57:21.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[[cosmwasm-vm] wasmvm: Malicious smart contract can slow down block production]]></title>
        <id>https://github.com/advisories/GHSA-mx2j-7cmv-353c</id>
        <link href="https://github.com/advisories/GHSA-mx2j-7cmv-353c"/>
        <updated>2025-02-06T18:03:26.000Z</updated>
        <content type="html"><![CDATA[<h1 id="cwa-2025-002">CWA-2025-002</h1>
<p><strong>Severity</strong></p>
<p>Medium (Moderate + Likely)[^1]</p>
<p><strong>Affected versions:</strong></p>
<ul>
<li>wasmvm &gt;= 2.2.0, &lt; 2.2.2</li>
<li>wasmvm &gt;= 2.1.0, &lt; 2.1.5</li>
<li>wasmvm &gt;= 2.0.0, &lt; 2.0.6</li>
<li>wasmvm &lt; 1.5.8</li>
</ul>
<p><strong>Patched versions:</strong></p>
<ul>
<li>wasmvm 1.5.8, 2.0.6, 2.1.5, 2.2.2</li>
</ul>
<h2 id="description-of-the-bug">Description of the bug</h2>
<p>The vulnerability can be used to slow down block production. The attack requires a malicious contract,
so permissioned chains are unlikely to be affected.</p>
<p>(We'll add more detail once chains had a chance to upgrade.)</p>
<h2 id="patch">Patch</h2>
<ul>
<li>1.5: <a href="https://github.com/CosmWasm/cosmwasm/commit/2b7f2faa57a1efc8207455c37f87f1eee6035a27">https://github.com/CosmWasm/cosmwasm/commit/2b7f2faa57a1efc8207455c37f87f1eee6035a27</a></li>
<li>2.0: <a href="https://github.com/CosmWasm/cosmwasm/commit/d6143b0aff16a39bbea4be37597d8e9d9b213d3b">https://github.com/CosmWasm/cosmwasm/commit/d6143b0aff16a39bbea4be37597d8e9d9b213d3b</a></li>
<li>2.1: <a href="https://github.com/CosmWasm/cosmwasm/commit/f0c04c03cbe2557634c1bbcdc2ce203fe7caca58">https://github.com/CosmWasm/cosmwasm/commit/f0c04c03cbe2557634c1bbcdc2ce203fe7caca58</a></li>
<li>2.2: <a href="https://github.com/CosmWasm/cosmwasm/commit/a5d62f65b5eb947ebe40e2085b1c48a9d0a244d0">https://github.com/CosmWasm/cosmwasm/commit/a5d62f65b5eb947ebe40e2085b1c48a9d0a244d0</a></li>
</ul>
<h2 id="applying-the-patch">Applying the patch</h2>
<p>The patch will be shipped in releases of wasmvm. You can update more or less as follows:</p>
<ol>
<li>Check the current wasmvm version: <code>go list -m github.com/CosmWasm/wasmvm</code></li>
<li>Bump the <code>github.com/CosmWasm/wasmvm</code> dependency in your go.mod to one of the patched version
depending on which minor version you are on; <code>go mod tidy</code>; commit.</li>
<li>If you use the static libraries <code>libwasmvm_muslc.aarch64.a</code>/<code>libwasmvm_muslc.x86_64.a</code>, update them accordingly.</li>
<li>Check the updated wasmvm version: <code>go list -m github.com/CosmWasm/wasmvm</code> and ensure you see 1.5.8, 2.0.6, 2.1.5 or 2.2.2.</li>
<li>Follow your regular practices to deploy chain upgrades.</li>
</ol>
<p>The patch is consensus breaking and requires a coordinated upgrade.</p>
<h2 id="acknowledgement">Acknowledgement</h2>
<p>This issue was found by meadow101 who reported it to the Cosmos Bug Bounty Program on HackerOne.</p>
<p>If you believe you have found a bug in the Interchain Stack or would like to contribute to the
program by reporting a bug, please see <a href="https://hackerone.com/cosmos">https://hackerone.com/cosmos</a>.</p>
<h2 id="timeline">Timeline</h2>
<ul>
<li>2024-11-24: Confio receives a report through the Cosmos bug bounty program maintained by Amulet.</li>
<li>2024-12-20: Confio security contributors confirm the report.</li>
<li>2024-01-27: Confio developed the patch internally.</li>
<li>2025-02-04: Patch gets released.</li>
</ul>
<p>[^1]: following Amulet's Severity Classification Framework ACMv1.2: <a href="https://github.com/interchainio/security/blob/0295254e8645301ccb606d46108a45cede0a73e0/resources/CLASSIFICATION_MATRIX.md">https://github.com/interchainio/security/blob/0295254e8645301ccb606d46108a45cede0a73e0/resources/CLASSIFICATION_MATRIX.md</a></p>
<h3 id="references">References</h3>
<ul>
<li><a href="https://github.com/CosmWasm/wasmvm/security/advisories/GHSA-mx2j-7cmv-353c">https://github.com/CosmWasm/wasmvm/security/advisories/GHSA-mx2j-7cmv-353c</a></li>
<li><a href="https://github.com/CosmWasm/cosmwasm/commit/2b7f2faa57a1efc8207455c37f87f1eee6035a27">https://github.com/CosmWasm/cosmwasm/commit/2b7f2faa57a1efc8207455c37f87f1eee6035a27</a></li>
<li><a href="https://github.com/CosmWasm/cosmwasm/commit/a5d62f65b5eb947ebe40e2085b1c48a9d0a244d0">https://github.com/CosmWasm/cosmwasm/commit/a5d62f65b5eb947ebe40e2085b1c48a9d0a244d0</a></li>
<li><a href="https://github.com/CosmWasm/cosmwasm/commit/d6143b0aff16a39bbea4be37597d8e9d9b213d3b">https://github.com/CosmWasm/cosmwasm/commit/d6143b0aff16a39bbea4be37597d8e9d9b213d3b</a></li>
<li><a href="https://github.com/CosmWasm/cosmwasm/commit/f0c04c03cbe2557634c1bbcdc2ce203fe7caca58">https://github.com/CosmWasm/cosmwasm/commit/f0c04c03cbe2557634c1bbcdc2ce203fe7caca58</a></li>
<li><a href="https://github.com/CosmWasm/advisories/blob/main/CWAs/CWA-2025-002.md">https://github.com/CosmWasm/advisories/blob/main/CWAs/CWA-2025-002.md</a></li>
<li><a href="https://pkg.go.dev/vuln/GO-2025-3449">https://pkg.go.dev/vuln/GO-2025-3449</a></li>
<li><a href="https://github.com/advisories/GHSA-mx2j-7cmv-353c">https://github.com/advisories/GHSA-mx2j-7cmv-353c</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-mx2j-7cmv-353c</uri>
        </author>
        <category label="severity" term="MODERATE"/>
        <published>2025-02-04T18:57:21.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[[cosmwasm-vm] wasmvm: Malicious smart contract can slow down block production]]></title>
        <id>https://github.com/advisories/GHSA-mx2j-7cmv-353c</id>
        <link href="https://github.com/advisories/GHSA-mx2j-7cmv-353c"/>
        <updated>2025-02-06T18:03:26.000Z</updated>
        <content type="html"><![CDATA[<h1 id="cwa-2025-002">CWA-2025-002</h1>
<p><strong>Severity</strong></p>
<p>Medium (Moderate + Likely)[^1]</p>
<p><strong>Affected versions:</strong></p>
<ul>
<li>wasmvm &gt;= 2.2.0, &lt; 2.2.2</li>
<li>wasmvm &gt;= 2.1.0, &lt; 2.1.5</li>
<li>wasmvm &gt;= 2.0.0, &lt; 2.0.6</li>
<li>wasmvm &lt; 1.5.8</li>
</ul>
<p><strong>Patched versions:</strong></p>
<ul>
<li>wasmvm 1.5.8, 2.0.6, 2.1.5, 2.2.2</li>
</ul>
<h2 id="description-of-the-bug">Description of the bug</h2>
<p>The vulnerability can be used to slow down block production. The attack requires a malicious contract,
so permissioned chains are unlikely to be affected.</p>
<p>(We'll add more detail once chains had a chance to upgrade.)</p>
<h2 id="patch">Patch</h2>
<ul>
<li>1.5: <a href="https://github.com/CosmWasm/cosmwasm/commit/2b7f2faa57a1efc8207455c37f87f1eee6035a27">https://github.com/CosmWasm/cosmwasm/commit/2b7f2faa57a1efc8207455c37f87f1eee6035a27</a></li>
<li>2.0: <a href="https://github.com/CosmWasm/cosmwasm/commit/d6143b0aff16a39bbea4be37597d8e9d9b213d3b">https://github.com/CosmWasm/cosmwasm/commit/d6143b0aff16a39bbea4be37597d8e9d9b213d3b</a></li>
<li>2.1: <a href="https://github.com/CosmWasm/cosmwasm/commit/f0c04c03cbe2557634c1bbcdc2ce203fe7caca58">https://github.com/CosmWasm/cosmwasm/commit/f0c04c03cbe2557634c1bbcdc2ce203fe7caca58</a></li>
<li>2.2: <a href="https://github.com/CosmWasm/cosmwasm/commit/a5d62f65b5eb947ebe40e2085b1c48a9d0a244d0">https://github.com/CosmWasm/cosmwasm/commit/a5d62f65b5eb947ebe40e2085b1c48a9d0a244d0</a></li>
</ul>
<h2 id="applying-the-patch">Applying the patch</h2>
<p>The patch will be shipped in releases of wasmvm. You can update more or less as follows:</p>
<ol>
<li>Check the current wasmvm version: <code>go list -m github.com/CosmWasm/wasmvm</code></li>
<li>Bump the <code>github.com/CosmWasm/wasmvm</code> dependency in your go.mod to one of the patched version
depending on which minor version you are on; <code>go mod tidy</code>; commit.</li>
<li>If you use the static libraries <code>libwasmvm_muslc.aarch64.a</code>/<code>libwasmvm_muslc.x86_64.a</code>, update them accordingly.</li>
<li>Check the updated wasmvm version: <code>go list -m github.com/CosmWasm/wasmvm</code> and ensure you see 1.5.8, 2.0.6, 2.1.5 or 2.2.2.</li>
<li>Follow your regular practices to deploy chain upgrades.</li>
</ol>
<p>The patch is consensus breaking and requires a coordinated upgrade.</p>
<h2 id="acknowledgement">Acknowledgement</h2>
<p>This issue was found by meadow101 who reported it to the Cosmos Bug Bounty Program on HackerOne.</p>
<p>If you believe you have found a bug in the Interchain Stack or would like to contribute to the
program by reporting a bug, please see <a href="https://hackerone.com/cosmos">https://hackerone.com/cosmos</a>.</p>
<h2 id="timeline">Timeline</h2>
<ul>
<li>2024-11-24: Confio receives a report through the Cosmos bug bounty program maintained by Amulet.</li>
<li>2024-12-20: Confio security contributors confirm the report.</li>
<li>2024-01-27: Confio developed the patch internally.</li>
<li>2025-02-04: Patch gets released.</li>
</ul>
<p>[^1]: following Amulet's Severity Classification Framework ACMv1.2: <a href="https://github.com/interchainio/security/blob/0295254e8645301ccb606d46108a45cede0a73e0/resources/CLASSIFICATION_MATRIX.md">https://github.com/interchainio/security/blob/0295254e8645301ccb606d46108a45cede0a73e0/resources/CLASSIFICATION_MATRIX.md</a></p>
<h3 id="references">References</h3>
<ul>
<li><a href="https://github.com/CosmWasm/wasmvm/security/advisories/GHSA-mx2j-7cmv-353c">https://github.com/CosmWasm/wasmvm/security/advisories/GHSA-mx2j-7cmv-353c</a></li>
<li><a href="https://github.com/CosmWasm/cosmwasm/commit/2b7f2faa57a1efc8207455c37f87f1eee6035a27">https://github.com/CosmWasm/cosmwasm/commit/2b7f2faa57a1efc8207455c37f87f1eee6035a27</a></li>
<li><a href="https://github.com/CosmWasm/cosmwasm/commit/a5d62f65b5eb947ebe40e2085b1c48a9d0a244d0">https://github.com/CosmWasm/cosmwasm/commit/a5d62f65b5eb947ebe40e2085b1c48a9d0a244d0</a></li>
<li><a href="https://github.com/CosmWasm/cosmwasm/commit/d6143b0aff16a39bbea4be37597d8e9d9b213d3b">https://github.com/CosmWasm/cosmwasm/commit/d6143b0aff16a39bbea4be37597d8e9d9b213d3b</a></li>
<li><a href="https://github.com/CosmWasm/cosmwasm/commit/f0c04c03cbe2557634c1bbcdc2ce203fe7caca58">https://github.com/CosmWasm/cosmwasm/commit/f0c04c03cbe2557634c1bbcdc2ce203fe7caca58</a></li>
<li><a href="https://github.com/CosmWasm/advisories/blob/main/CWAs/CWA-2025-002.md">https://github.com/CosmWasm/advisories/blob/main/CWAs/CWA-2025-002.md</a></li>
<li><a href="https://pkg.go.dev/vuln/GO-2025-3449">https://pkg.go.dev/vuln/GO-2025-3449</a></li>
<li><a href="https://github.com/advisories/GHSA-mx2j-7cmv-353c">https://github.com/advisories/GHSA-mx2j-7cmv-353c</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-mx2j-7cmv-353c</uri>
        </author>
        <category label="severity" term="MODERATE"/>
        <published>2025-02-04T18:57:21.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[[openssl] rust-openssl ssl::select_next_proto use after free]]></title>
        <id>https://github.com/advisories/GHSA-rpmj-rpgj-qmpm</id>
        <link href="https://github.com/advisories/GHSA-rpmj-rpgj-qmpm"/>
        <updated>2025-02-11T09:30:32.000Z</updated>
        <content type="html"><![CDATA[<h3 id="impact">Impact</h3>
<p><code>ssl::select_next_proto</code> can return a slice pointing into the <code>server</code> argument's buffer but with a lifetime bound to the <code>client</code> argument. In situations where the <code>server</code> buffer's lifetime is shorter than the <code>client</code> buffer's, this can cause a use after free. This could cause the server to crash or to return arbitrary memory contents to the client.</p>
<h3 id="patches">Patches</h3>
<p><code>openssl</code> 0.10.70 fixes the signature of <code>ssl::select_next_proto</code> to properly constrain the output buffer's lifetime to that of both input buffers.</p>
<h3 id="workarounds">Workarounds</h3>
<p>In standard usage of <code>ssl::select_next_proto</code> in the callback passed to <code>SslContextBuilder::set_alpn_select_callback</code>, code is only affected if the <code>server</code> buffer is constructed <em>within</em> the callback. For example:</p>
<p>Not vulnerable - the server buffer has a <code>'static</code> lifetime:</p>
<pre><code class="language-rust">builder.set_alpn_select_callback(|_, client_protos| {
    ssl::select_next_proto(b"\x02h2", client_protos).ok_or_else(AlpnError::NOACK)
});
</code></pre>
<p>Not vulnerable - the server buffer outlives the handshake:</p>
<pre><code class="language-rust">let server_protos = b"\x02h2".to_vec();
builder.set_alpn_select_callback(|_, client_protos| {
    ssl::select_next_proto(&amp;server_protos, client_protos).ok_or_else(AlpnError::NOACK)
});
</code></pre>
<p>Vulnerable - the server buffer is freed when the callback returns:</p>
<pre><code class="language-rust">builder.set_alpn_select_callback(|_, client_protos| {
    let server_protos = b"\x02h2".to_vec();
    ssl::select_next_proto(&amp;server_protos, client_protos).ok_or_else(AlpnError::NOACK)
});
</code></pre>
<h3 id="references">References</h3>
<p><a href="https://github.com/sfackler/rust-openssl/pull/2360">https://github.com/sfackler/rust-openssl/pull/2360</a></p>
<h3 id="references-1">References</h3>
<ul>
<li><a href="https://github.com/sfackler/rust-openssl/security/advisories/GHSA-rpmj-rpgj-qmpm">https://github.com/sfackler/rust-openssl/security/advisories/GHSA-rpmj-rpgj-qmpm</a></li>
<li><a href="https://github.com/sfackler/rust-openssl/pull/2360">https://github.com/sfackler/rust-openssl/pull/2360</a></li>
<li><a href="https://github.com/sfackler/rust-openssl/commit/f014afb230de4d77bc79dea60e7e58c2f47b60f2">https://github.com/sfackler/rust-openssl/commit/f014afb230de4d77bc79dea60e7e58c2f47b60f2</a></li>
<li><a href="https://rustsec.org/advisories/RUSTSEC-2025-0004.html">https://rustsec.org/advisories/RUSTSEC-2025-0004.html</a></li>
<li><a href="https://nvd.nist.gov/vuln/detail/CVE-2025-24898">https://nvd.nist.gov/vuln/detail/CVE-2025-24898</a></li>
<li><a href="https://crates.io/crates/openssl">https://crates.io/crates/openssl</a></li>
<li><a href="https://lists.debian.org/debian-lts-announce/2025/02/msg00009.html">https://lists.debian.org/debian-lts-announce/2025/02/msg00009.html</a></li>
<li><a href="https://github.com/advisories/GHSA-rpmj-rpgj-qmpm">https://github.com/advisories/GHSA-rpmj-rpgj-qmpm</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-rpmj-rpgj-qmpm</uri>
        </author>
        <category label="severity" term="MODERATE"/>
        <published>2025-02-03T17:56:46.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[[plonky2] Soundness issue with Plonky2 look up tables]]></title>
        <id>https://github.com/advisories/GHSA-hj49-h7fq-px5h</id>
        <link href="https://github.com/advisories/GHSA-hj49-h7fq-px5h"/>
        <updated>2025-01-30T21:36:55.000Z</updated>
        <content type="html"><![CDATA[<h3 id="impact">Impact</h3>
<p>Lookup tables, whose length is not divisible by <code>26 = floor(num_routed_wires / 3)</code> always include the <code>0 -&gt; 0</code> input-output pair. Thus a malicious prover can always prove that <code>f(0) = 0</code> for any lookup table f (unless its length happens to be divisible by 26).</p>
<p>The cause of problem is that the <code>LookupTableGate</code>-s are <a href="https://github.com/0xPolygonZero/plonky2/blob/main/plonky2/src/plonk/prover.rs#L97">padded with zeros</a>.</p>
<p>The fix is done by padding with an existing table pair, similarly to <code>LookupGate</code>.</p>
<p>A workaround from the user side is to extend the table (by repeating some entries) so that its length becomes divisible by 26.</p>
<p>Fortunately, the seemingly most common use case, namely, hash functions with table-based sbox-es, are not vulnerable:</p>
<ul>
<li>both Monolith's and Tip5/Tip4's s-box tables already map 0 to 0;</li>
<li>more generally, forcing several (0,0) pairs inside such a hash function appears to be a too strong restriction to find an otherwise valid trace.</li>
</ul>
<p>A malicious prover exploiting this could cheat a circuit which statement is the following:</p>
<ul>
<li>output <code>x + f(x)</code> for some private input <code>x</code>, where <code>f(x) := 100 - x</code> is implemented by a lookup table.</li>
</ul>
<p>A malicious prover would be able to convince an honest verifier that they know an <code>0 &lt;= x &lt; 64</code> such that <code>x + (100 - x) = 0</code>.</p>
<h3 id="patches">Patches</h3>
<p>Yes, upgrade to v1.0.1</p>
<h3 id="workarounds">Workarounds</h3>
<p>No</p>
<h3 id="references">References</h3>
<h3 id="references-1">References</h3>
<ul>
<li><a href="https://github.com/0xPolygonZero/plonky2/security/advisories/GHSA-hj49-h7fq-px5h">https://github.com/0xPolygonZero/plonky2/security/advisories/GHSA-hj49-h7fq-px5h</a></li>
<li><a href="https://github.com/0xPolygonZero/plonky2/commit/091047f7f10cae082716f3738ad59a583835f7b6">https://github.com/0xPolygonZero/plonky2/commit/091047f7f10cae082716f3738ad59a583835f7b6</a></li>
<li><a href="https://nvd.nist.gov/vuln/detail/CVE-2025-24802">https://nvd.nist.gov/vuln/detail/CVE-2025-24802</a></li>
<li><a href="https://github.com/0xPolygonZero/plonky2/blob/main/plonky2/src/plonk/prover.rs#L97">https://github.com/0xPolygonZero/plonky2/blob/main/plonky2/src/plonk/prover.rs#L97</a></li>
<li><a href="https://github.com/advisories/GHSA-hj49-h7fq-px5h">https://github.com/advisories/GHSA-hj49-h7fq-px5h</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-hj49-h7fq-px5h</uri>
        </author>
        <category label="severity" term="HIGH"/>
        <published>2025-01-30T19:28:51.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[[fast-float] fast-fault has a segmentation fault due to lack of bound check]]></title>
        <id>https://github.com/advisories/GHSA-8655-xgh5-5vvq</id>
        <link href="https://github.com/advisories/GHSA-8655-xgh5-5vvq"/>
        <updated>2025-01-29T22:21:18.000Z</updated>
        <content type="html"><![CDATA[<p>In this case, the "fast_float::common::AsciiStr::first" method within the "AsciiStr" struct 
uses the unsafe keyword to reading from memory without performing bounds checking. 
Specifically, it directly dereferences a pointer offset by "self.ptr".
Because of the above reason, the method accesses invalid memory address when it takes an empty string as its input.
This approach violates Rust’s memory safety guarantees, as it can lead to invalid memory access if empty buffer is provided.</p>
<p>No patched version for fast-float crate has been released, but a patch is available in the fast-float2 fork.</p>
<h3 id="references">References</h3>
<ul>
<li><a href="https://github.com/aldanor/fast-float-rust/issues/38">https://github.com/aldanor/fast-float-rust/issues/38</a></li>
<li><a href="https://rustsec.org/advisories/RUSTSEC-2025-0003.html">https://rustsec.org/advisories/RUSTSEC-2025-0003.html</a></li>
<li><a href="https://github.com/advisories/GHSA-8655-xgh5-5vvq">https://github.com/advisories/GHSA-8655-xgh5-5vvq</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-8655-xgh5-5vvq</uri>
        </author>
        <category label="severity" term="MODERATE"/>
        <published>2025-01-29T22:21:17.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[[fast-float2] fast-float2 has a segmentation fault due to lack of bound check]]></title>
        <id>https://github.com/advisories/GHSA-jqcp-xc3v-f446</id>
        <link href="https://github.com/advisories/GHSA-jqcp-xc3v-f446"/>
        <updated>2025-01-29T22:21:13.000Z</updated>
        <content type="html"><![CDATA[<p>In this case, the "fast_float2::common::AsciiStr::first" method within the "AsciiStr" struct 
uses the unsafe keyword to reading from memory without performing bounds checking. 
Specifically, it directly dereferences a pointer offset by "self.ptr".
Because of the above reason, the method accesses invalid memory address when it takes an empty string as its input.
This approach violates Rust’s memory safety guarantees, as it can lead to invalid memory access if empty buffer is provided.</p>
<h3 id="references">References</h3>
<ul>
<li><a href="https://github.com/aldanor/fast-float-rust/issues/38">https://github.com/aldanor/fast-float-rust/issues/38</a></li>
<li><a href="https://rustsec.org/advisories/RUSTSEC-2025-0002.html">https://rustsec.org/advisories/RUSTSEC-2025-0002.html</a></li>
<li><a href="https://github.com/Alexhuszagh/fast-float-rust/pull/7">https://github.com/Alexhuszagh/fast-float-rust/pull/7</a></li>
<li><a href="https://github.com/advisories/GHSA-jqcp-xc3v-f446">https://github.com/advisories/GHSA-jqcp-xc3v-f446</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-jqcp-xc3v-f446</uri>
        </author>
        <category label="severity" term="MODERATE"/>
        <published>2025-01-29T22:19:01.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[[grandpa-verifier] ismp-grandpa crate accepted incorrect signatures]]></title>
        <id>https://github.com/advisories/GHSA-wwx5-gpgr-vxr7</id>
        <link href="https://github.com/advisories/GHSA-wwx5-gpgr-vxr7"/>
        <updated>2025-01-28T20:15:50.000Z</updated>
        <content type="html"><![CDATA[<p>A critical vulnerability was discovered in the <code>ismp-grandpa</code> crate, that allowed a malicious prover easily convince the verifier of the finality of arbitrary headers.</p>
<h3 id="description">Description</h3>
<p>The vulnerability manifests as a verifer that only accepts incorrect signatures of Grandpa precommits and was introduced in this <a href="https://github.com/polytope-labs/ismp-substrate/pull/64/commits/5ca3351a19151f1a439c30d5cbdbfdc72a11f1a8#diff-3835cc24fb2011b3e8246036059acd8c2c2a9a869eedf7a210d18edb6543318dL262">specific commit</a>. Perhaps due to unfamiliarity with core substrate APIs.  The <code>if</code> statement should have included a negation check, similar to the previous code, but this was omitted. Causing the verifier to <strong>only</strong> accept invalid signatures.</p>
<p>This vulnerability remained undetected even with <a href="https://github.com/polytope-labs/ismp-substrate/pull/64/commits/04d5be207b082eb61d586d52e1685e2e060347e6#diff-4aedbca82d26bebc03f274e23fd5697c3346ffff54405c87af9018f3aef708b2R1-R160">integration tests</a>, as the prover was also <a href="https://github.com/polytope-labs/ismp-substrate/pull/64/commits/b26894913b301061b07db61af841ca2586415f08#diff-493a6129d75fe31185e28695a4d2adc1582fe9df12462e380fe994f170fc1e70L159">misconfigured</a> to initialize the Grandpa verifier with the incorrect authority <code>set_id</code>. This causes verification of honest precommit signatures to fail as the message is now malformed, but  the verifier indeed only accepts signatures or messages that fail the verification check.</p>
<p>But even more devastatingly, the verifier will also accept malicious GRANDPA signatures for any precommit message.</p>
<p>This vulnerability has been fixed in this <a href="https://github.com/polytope-labs/hyperbridge/pull/372/commits/f0e85db718f5165b06585a49b14a66f8ad643aea">commit</a> and a patch release has been published.</p>
<h3 id="impact">Impact</h3>
<p>This could be used to steal funds or compromise other kinds of cross-chain applications.</p>
<h3 id="patches">Patches</h3>
<p>This vulnerability has been fixed in the latest version of <code>ismp-granpda</code> <code>v15.0.1</code></p>
<h3 id="recommendations">Recommendations</h3>
<p>Users who rely on the compromised versions must upgrade immediately, as all vulnerable versions of the crate has been yanked.</p>
<h3 id="references">References</h3>
<ul>
<li><a href="https://github.com/polytope-labs/hyperbridge/security/advisories/GHSA-wwx5-gpgr-vxr7">https://github.com/polytope-labs/hyperbridge/security/advisories/GHSA-wwx5-gpgr-vxr7</a></li>
<li><a href="https://github.com/polytope-labs/hyperbridge/pull/372/commits/f0e85db718f5165b06585a49b14a66f8ad643aea">https://github.com/polytope-labs/hyperbridge/pull/372/commits/f0e85db718f5165b06585a49b14a66f8ad643aea</a></li>
<li><a href="https://github.com/polytope-labs/ismp-substrate/pull/64/commits/04d5be207b082eb61d586d52e1685e2e060347e6#diff-4aedbca82d26bebc03f274e23fd5697c3346ffff54405c87af9018f3aef708b2R1-R160">https://github.com/polytope-labs/ismp-substrate/pull/64/commits/04d5be207b082eb61d586d52e1685e2e060347e6#diff-4aedbca82d26bebc03f274e23fd5697c3346ffff54405c87af9018f3aef708b2R1-R160</a></li>
<li><a href="https://github.com/polytope-labs/ismp-substrate/pull/64/commits/5ca3351a19151f1a439c30d5cbdbfdc72a11f1a8#diff-3835cc24fb2011b3e8246036059acd8c2c2a9a869eedf7a210d18edb6543318dL262">https://github.com/polytope-labs/ismp-substrate/pull/64/commits/5ca3351a19151f1a439c30d5cbdbfdc72a11f1a8#diff-3835cc24fb2011b3e8246036059acd8c2c2a9a869eedf7a210d18edb6543318dL262</a></li>
<li><a href="https://github.com/polytope-labs/ismp-substrate/pull/64/commits/b26894913b301061b07db61af841ca2586415f08#diff-493a6129d75fe31185e28695a4d2adc1582fe9df12462e380fe994f170fc1e70L159">https://github.com/polytope-labs/ismp-substrate/pull/64/commits/b26894913b301061b07db61af841ca2586415f08#diff-493a6129d75fe31185e28695a4d2adc1582fe9df12462e380fe994f170fc1e70L159</a></li>
<li><a href="https://nvd.nist.gov/vuln/detail/CVE-2025-24800">https://nvd.nist.gov/vuln/detail/CVE-2025-24800</a></li>
<li><a href="https://github.com/advisories/GHSA-wwx5-gpgr-vxr7">https://github.com/advisories/GHSA-wwx5-gpgr-vxr7</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-wwx5-gpgr-vxr7</uri>
        </author>
        <category label="severity" term="CRITICAL"/>
        <published>2025-01-28T17:29:17.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[[grandpa-verifier-primitives] ismp-grandpa crate accepted incorrect signatures]]></title>
        <id>https://github.com/advisories/GHSA-wwx5-gpgr-vxr7</id>
        <link href="https://github.com/advisories/GHSA-wwx5-gpgr-vxr7"/>
        <updated>2025-01-28T20:15:50.000Z</updated>
        <content type="html"><![CDATA[<p>A critical vulnerability was discovered in the <code>ismp-grandpa</code> crate, that allowed a malicious prover easily convince the verifier of the finality of arbitrary headers.</p>
<h3 id="description">Description</h3>
<p>The vulnerability manifests as a verifer that only accepts incorrect signatures of Grandpa precommits and was introduced in this <a href="https://github.com/polytope-labs/ismp-substrate/pull/64/commits/5ca3351a19151f1a439c30d5cbdbfdc72a11f1a8#diff-3835cc24fb2011b3e8246036059acd8c2c2a9a869eedf7a210d18edb6543318dL262">specific commit</a>. Perhaps due to unfamiliarity with core substrate APIs.  The <code>if</code> statement should have included a negation check, similar to the previous code, but this was omitted. Causing the verifier to <strong>only</strong> accept invalid signatures.</p>
<p>This vulnerability remained undetected even with <a href="https://github.com/polytope-labs/ismp-substrate/pull/64/commits/04d5be207b082eb61d586d52e1685e2e060347e6#diff-4aedbca82d26bebc03f274e23fd5697c3346ffff54405c87af9018f3aef708b2R1-R160">integration tests</a>, as the prover was also <a href="https://github.com/polytope-labs/ismp-substrate/pull/64/commits/b26894913b301061b07db61af841ca2586415f08#diff-493a6129d75fe31185e28695a4d2adc1582fe9df12462e380fe994f170fc1e70L159">misconfigured</a> to initialize the Grandpa verifier with the incorrect authority <code>set_id</code>. This causes verification of honest precommit signatures to fail as the message is now malformed, but  the verifier indeed only accepts signatures or messages that fail the verification check.</p>
<p>But even more devastatingly, the verifier will also accept malicious GRANDPA signatures for any precommit message.</p>
<p>This vulnerability has been fixed in this <a href="https://github.com/polytope-labs/hyperbridge/pull/372/commits/f0e85db718f5165b06585a49b14a66f8ad643aea">commit</a> and a patch release has been published.</p>
<h3 id="impact">Impact</h3>
<p>This could be used to steal funds or compromise other kinds of cross-chain applications.</p>
<h3 id="patches">Patches</h3>
<p>This vulnerability has been fixed in the latest version of <code>ismp-granpda</code> <code>v15.0.1</code></p>
<h3 id="recommendations">Recommendations</h3>
<p>Users who rely on the compromised versions must upgrade immediately, as all vulnerable versions of the crate has been yanked.</p>
<h3 id="references">References</h3>
<ul>
<li><a href="https://github.com/polytope-labs/hyperbridge/security/advisories/GHSA-wwx5-gpgr-vxr7">https://github.com/polytope-labs/hyperbridge/security/advisories/GHSA-wwx5-gpgr-vxr7</a></li>
<li><a href="https://github.com/polytope-labs/hyperbridge/pull/372/commits/f0e85db718f5165b06585a49b14a66f8ad643aea">https://github.com/polytope-labs/hyperbridge/pull/372/commits/f0e85db718f5165b06585a49b14a66f8ad643aea</a></li>
<li><a href="https://github.com/polytope-labs/ismp-substrate/pull/64/commits/04d5be207b082eb61d586d52e1685e2e060347e6#diff-4aedbca82d26bebc03f274e23fd5697c3346ffff54405c87af9018f3aef708b2R1-R160">https://github.com/polytope-labs/ismp-substrate/pull/64/commits/04d5be207b082eb61d586d52e1685e2e060347e6#diff-4aedbca82d26bebc03f274e23fd5697c3346ffff54405c87af9018f3aef708b2R1-R160</a></li>
<li><a href="https://github.com/polytope-labs/ismp-substrate/pull/64/commits/5ca3351a19151f1a439c30d5cbdbfdc72a11f1a8#diff-3835cc24fb2011b3e8246036059acd8c2c2a9a869eedf7a210d18edb6543318dL262">https://github.com/polytope-labs/ismp-substrate/pull/64/commits/5ca3351a19151f1a439c30d5cbdbfdc72a11f1a8#diff-3835cc24fb2011b3e8246036059acd8c2c2a9a869eedf7a210d18edb6543318dL262</a></li>
<li><a href="https://github.com/polytope-labs/ismp-substrate/pull/64/commits/b26894913b301061b07db61af841ca2586415f08#diff-493a6129d75fe31185e28695a4d2adc1582fe9df12462e380fe994f170fc1e70L159">https://github.com/polytope-labs/ismp-substrate/pull/64/commits/b26894913b301061b07db61af841ca2586415f08#diff-493a6129d75fe31185e28695a4d2adc1582fe9df12462e380fe994f170fc1e70L159</a></li>
<li><a href="https://nvd.nist.gov/vuln/detail/CVE-2025-24800">https://nvd.nist.gov/vuln/detail/CVE-2025-24800</a></li>
<li><a href="https://github.com/advisories/GHSA-wwx5-gpgr-vxr7">https://github.com/advisories/GHSA-wwx5-gpgr-vxr7</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-wwx5-gpgr-vxr7</uri>
        </author>
        <category label="severity" term="CRITICAL"/>
        <published>2025-01-28T17:29:17.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[[ismp-grandpa] ismp-grandpa crate accepted incorrect signatures]]></title>
        <id>https://github.com/advisories/GHSA-wwx5-gpgr-vxr7</id>
        <link href="https://github.com/advisories/GHSA-wwx5-gpgr-vxr7"/>
        <updated>2025-01-28T20:15:50.000Z</updated>
        <content type="html"><![CDATA[<p>A critical vulnerability was discovered in the <code>ismp-grandpa</code> crate, that allowed a malicious prover easily convince the verifier of the finality of arbitrary headers.</p>
<h3 id="description">Description</h3>
<p>The vulnerability manifests as a verifer that only accepts incorrect signatures of Grandpa precommits and was introduced in this <a href="https://github.com/polytope-labs/ismp-substrate/pull/64/commits/5ca3351a19151f1a439c30d5cbdbfdc72a11f1a8#diff-3835cc24fb2011b3e8246036059acd8c2c2a9a869eedf7a210d18edb6543318dL262">specific commit</a>. Perhaps due to unfamiliarity with core substrate APIs.  The <code>if</code> statement should have included a negation check, similar to the previous code, but this was omitted. Causing the verifier to <strong>only</strong> accept invalid signatures.</p>
<p>This vulnerability remained undetected even with <a href="https://github.com/polytope-labs/ismp-substrate/pull/64/commits/04d5be207b082eb61d586d52e1685e2e060347e6#diff-4aedbca82d26bebc03f274e23fd5697c3346ffff54405c87af9018f3aef708b2R1-R160">integration tests</a>, as the prover was also <a href="https://github.com/polytope-labs/ismp-substrate/pull/64/commits/b26894913b301061b07db61af841ca2586415f08#diff-493a6129d75fe31185e28695a4d2adc1582fe9df12462e380fe994f170fc1e70L159">misconfigured</a> to initialize the Grandpa verifier with the incorrect authority <code>set_id</code>. This causes verification of honest precommit signatures to fail as the message is now malformed, but  the verifier indeed only accepts signatures or messages that fail the verification check.</p>
<p>But even more devastatingly, the verifier will also accept malicious GRANDPA signatures for any precommit message.</p>
<p>This vulnerability has been fixed in this <a href="https://github.com/polytope-labs/hyperbridge/pull/372/commits/f0e85db718f5165b06585a49b14a66f8ad643aea">commit</a> and a patch release has been published.</p>
<h3 id="impact">Impact</h3>
<p>This could be used to steal funds or compromise other kinds of cross-chain applications.</p>
<h3 id="patches">Patches</h3>
<p>This vulnerability has been fixed in the latest version of <code>ismp-granpda</code> <code>v15.0.1</code></p>
<h3 id="recommendations">Recommendations</h3>
<p>Users who rely on the compromised versions must upgrade immediately, as all vulnerable versions of the crate has been yanked.</p>
<h3 id="references">References</h3>
<ul>
<li><a href="https://github.com/polytope-labs/hyperbridge/security/advisories/GHSA-wwx5-gpgr-vxr7">https://github.com/polytope-labs/hyperbridge/security/advisories/GHSA-wwx5-gpgr-vxr7</a></li>
<li><a href="https://github.com/polytope-labs/hyperbridge/pull/372/commits/f0e85db718f5165b06585a49b14a66f8ad643aea">https://github.com/polytope-labs/hyperbridge/pull/372/commits/f0e85db718f5165b06585a49b14a66f8ad643aea</a></li>
<li><a href="https://github.com/polytope-labs/ismp-substrate/pull/64/commits/04d5be207b082eb61d586d52e1685e2e060347e6#diff-4aedbca82d26bebc03f274e23fd5697c3346ffff54405c87af9018f3aef708b2R1-R160">https://github.com/polytope-labs/ismp-substrate/pull/64/commits/04d5be207b082eb61d586d52e1685e2e060347e6#diff-4aedbca82d26bebc03f274e23fd5697c3346ffff54405c87af9018f3aef708b2R1-R160</a></li>
<li><a href="https://github.com/polytope-labs/ismp-substrate/pull/64/commits/5ca3351a19151f1a439c30d5cbdbfdc72a11f1a8#diff-3835cc24fb2011b3e8246036059acd8c2c2a9a869eedf7a210d18edb6543318dL262">https://github.com/polytope-labs/ismp-substrate/pull/64/commits/5ca3351a19151f1a439c30d5cbdbfdc72a11f1a8#diff-3835cc24fb2011b3e8246036059acd8c2c2a9a869eedf7a210d18edb6543318dL262</a></li>
<li><a href="https://github.com/polytope-labs/ismp-substrate/pull/64/commits/b26894913b301061b07db61af841ca2586415f08#diff-493a6129d75fe31185e28695a4d2adc1582fe9df12462e380fe994f170fc1e70L159">https://github.com/polytope-labs/ismp-substrate/pull/64/commits/b26894913b301061b07db61af841ca2586415f08#diff-493a6129d75fe31185e28695a4d2adc1582fe9df12462e380fe994f170fc1e70L159</a></li>
<li><a href="https://nvd.nist.gov/vuln/detail/CVE-2025-24800">https://nvd.nist.gov/vuln/detail/CVE-2025-24800</a></li>
<li><a href="https://github.com/advisories/GHSA-wwx5-gpgr-vxr7">https://github.com/advisories/GHSA-wwx5-gpgr-vxr7</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-wwx5-gpgr-vxr7</uri>
        </author>
        <category label="severity" term="CRITICAL"/>
        <published>2025-01-28T17:29:17.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[[gix-worktree-state] gix-worktree-state nonexclusive checkout sets executable files world-writable]]></title>
        <id>https://github.com/advisories/GHSA-fqmf-w4xh-33rh</id>
        <link href="https://github.com/advisories/GHSA-fqmf-w4xh-33rh"/>
        <updated>2025-01-21T21:13:07.000Z</updated>
        <content type="html"><![CDATA[<h3 id="summary">Summary</h3>
<p><code>gix-worktree-state</code> specifies 0777 permissions when checking out executable files, intending that the umask will restrict them appropriately. But one of the strategies it uses to set permissions is not subject to the umask. This causes files in a repository to be world-writable in some situations.</p>
<h3 id="details">Details</h3>
<p>Git repositories track executable bits for regular files. In tree objects and the index, regular file modes are stored as 0644 if not executable, or 0755 if executable. But this is independent of how the permissions are set in the filesystem (where supported).</p>
<p><a href="https://github.com/GitoxideLabs/gitoxide/blob/8d84818240d44e1f5fe78a231b5d9bffd0283918/gix-worktree-state/src/checkout/function.rs#L8-L35"><code>gix_worktree_state::checkout</code></a> has two strategies for checking out a file and marking it executable on a Unix-like operating system, one of which is vulnerable:</p>
<ul>
<li>If the file is created by assuming it does not already exist, correct permissions are applied, because permissions specified when opening a file are subject to the umask.</li>
<li>If the file is considered possibly already to exist—even in a clean checkout if the application does not specify the option to treat the destination directory as empty—then permissions conferring unrestricted access to any user account on the system are wrongly applied, because permissions specified when calling chmod on an existing file are not subject to the umask.</li>
</ul>
<p>&nbsp;</p>
<p>Specifically, <a href="https://github.com/GitoxideLabs/gitoxide/blob/8d84818240d44e1f5fe78a231b5d9bffd0283918/gix-worktree-state/src/checkout/entry.rs#L56-L191"><code>checkout::entry::checkout</code></a> chooses the strategy for each file. The same strategy is usually chosen for each executable file, if no <a href="https://github.com/git/git/blob/a60673e9252b08d4eca90543b3729f4798b9aafd/Documentation/RelNotes/2.11.0.txt#L149-L154">process</a> (i.e. <a href="https://github.com/GitoxideLabs/gitoxide/discussions/996">long running</a>) smudge filter is in use. The strategy depends on the <a href="https://github.com/GitoxideLabs/gitoxide/blob/8d84818240d44e1f5fe78a231b5d9bffd0283918/gix-worktree-state/src/checkout/mod.rs#L50-L53"><code>checkout::Options::destination_is_initially_empty</code></a> value, which is passed along to <a href="https://github.com/GitoxideLabs/gitoxide/blob/8d84818240d44e1f5fe78a231b5d9bffd0283918/gix-worktree-state/src/checkout/entry.rs#L253-L277"><code>checkout::entry::open_file</code></a>, whose return value includes a flag indicating whether permissions still need to be set:</p>
<ul>
<li><p>With <code>destination_is_initially_empty: true</code>, executable permissions are specified when opening the file, via <a href="https://doc.rust-lang.org/std/os/unix/fs/trait.OpenOptionsExt.html#tymethod.mode"><code>OpenOptionsEx::mode</code></a>, by its effect on the behavior of <a href="https://doc.rust-lang.org/std/fs/struct.OpenOptions.html#method.open"><code>OpenOptions::open</code></a>. A mode of 0777 is safe here, for the same reason the default mode of 0666 is safe. When creating a file, the applied mode is the specified mode with any bits unset from it that are set in the umask.</p>
<p> <a href="https://github.com/GitoxideLabs/gitoxide/blob/8d84818240d44e1f5fe78a231b5d9bffd0283918/gix-worktree-state/src/checkout/entry.rs#L265-L268">https://github.com/GitoxideLabs/gitoxide/blob/8d84818240d44e1f5fe78a231b5d9bffd0283918/gix-worktree-state/src/checkout/entry.rs#L265-L268</a></p>
<p>The <code>set_executable_after_creation</code> flag in the <code>open_file</code> return value is then <code>false</code>.</p>
</li>
<li><p>With <code>destination_is_initially_empty: false</code>, executable permissions are set in a separate step, via <a href="https://doc.rust-lang.org/beta/std/os/unix/fs/trait.PermissionsExt.html#tymethod.set_mode"><code>PermissionsExt::set_mode</code></a> and <a href="https://doc.rust-lang.org/beta/std/fs/fn.set_permissions.html"><code>set_permissions</code></a>. A mode of 0777 is not safe here, because the umask is not applied. The vulnerable code appears in <a href="https://github.com/GitoxideLabs/gitoxide/blob/8d84818240d44e1f5fe78a231b5d9bffd0283918/gix-worktree-state/src/checkout/entry.rs#L279-L299"><code>checkout::entry::finalize_entry</code></a>, which receives the <code>set_executable_after_creation</code> flag originally from <code>open_file</code>:</p>
<p><a href="https://github.com/GitoxideLabs/gitoxide/blob/8d84818240d44e1f5fe78a231b5d9bffd0283918/gix-worktree-state/src/checkout/entry.rs#L288-L293">https://github.com/GitoxideLabs/gitoxide/blob/8d84818240d44e1f5fe78a231b5d9bffd0283918/gix-worktree-state/src/checkout/entry.rs#L288-L293</a></p>
<p>The file has unrestricted permissions.</p>
</li>
</ul>
<p><code>finalize_entry</code> is <a href="https://github.com/GitoxideLabs/gitoxide/blob/8d84818240d44e1f5fe78a231b5d9bffd0283918/gix-worktree-state/src/checkout/chunk.rs#L229-L236">likewise called</a> from <a href="https://github.com/GitoxideLabs/gitoxide/blob/8d84818240d44e1f5fe78a231b5d9bffd0283918/gix-worktree-state/src/checkout/chunk.rs#L157-L259"><code>checkout::chunk::process_delayed_filter_results</code></a>.</p>
<h3 id="poc">PoC</h3>
<ol>
<li><p>On a Unix-like system such as GNU/Linux or macOS, create a new project and define its dependencies. While the vulnerability is in <code>gix-worktree-state</code>, this example will use vulnerable code through the <code>gix</code> crate, which exposes it. Run:</p>
<pre><code class="language-sh">cargo new checkout-index
cd checkout-index
cargo add gix gix-object
</code></pre>
</li>
<li><p>In the <code>checkout-index</code> directory, edit <code>src/main.rs</code> so that its entire contents are:</p>
<pre><code class="language-rust">fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
    let repo = gix::discover("has-executable")?;
    let mut index = repo.open_index()?;
    gix::worktree::state::checkout(
        &amp;mut index,
        repo.work_dir().ok_or("need non-bare repo")?,
        gix_object::find::Never, // Can also use: repo.objects.clone()
        &amp;gix::progress::Discard,
        &amp;gix::progress::Discard,
        &amp;Default::default(),
        Default::default(),
    )?;
    Ok(())
}
</code></pre>
</li>
<li><p>Create the test repository that the vulnerable program will operate on. Still in the <code>checkout-index</code> directory, run:</p>
<pre><code class="language-sh">git init has-executable
touch has-executable/a has-executable/b
chmod +x has-executable/b
git -C has-executable add .
</code></pre>
<p>It is not necessary to commit the changes, only to stage them, since the test program will check  out the index.</p>
</li>
<li><p><em>Optionally</em>, run <code>rm has-executable/[ab]</code> to remove the staged files from disk.</p>
</li>
<li><p>Run the program by issuing <code>cargo run</code>. The program uses <code>gix-worktree-state</code> to check out the index. It should terminate successfully and not issue any errors.</p>
</li>
<li><p>Run <code>ls -l has-executable</code> to inspect the permissions of the checked out files. Observe that owner, group, and other all have read, write, and execute permissions on <code>b</code>.</p>
<pre><code class="language-text">-rw-r--r-- 1 ek ek 0 Jan  9 03:38 a
-rwxrwxrwx 1 ek ek 0 Jan  9 03:38 b
</code></pre>
<p>With affected versions of <code>gix-worktree-state</code>, the output shows <code>-rwxrwxrwx</code> for <code>b</code>, whether the files were removed in step 4 or not.</p>
</li>
<li><p>It was not necessary to set <code>destination_is_initially_empty</code> to <code>false</code> explicitly to trigger the bug, because that is its default value. If desired, modify the program to pass <code>true</code> and rerun the experiment to verify that <code>b</code> is no longer created with excessive permissions. The modified program would change the last <code>checkout</code> argument from <code>Default::default(),</code> to:</p>
<pre><code class="language-rust">        gix::worktree::state::checkout::Options {
            destination_is_initially_empty: true,
            ..Default::default()
        },
</code></pre>
</li>
</ol>
<h3 id="impact">Impact</h3>
<p>Setting unlimited file permissions is a problem on systems where a user account exists on the system that should not have the ability to access and modify the files. That applies to multi-user systems, or when an account is used to run software with reduced abilities. (Some programs may also treat broad write permissions to mean less validation is required.)</p>
<p>This bug affects Unix-like systems but not Windows. The <code>gix clone</code> command is not believed to be affected, due to <a href="https://github.com/GitoxideLabs/gitoxide/blob/af704f57bb9480c47cdd393465264d586f1d4562/gitoxide-core/src/index/checkout.rs#L14-L172"><code>checkout_exclusive</code></a>'s <a href="https://github.com/GitoxideLabs/gitoxide/blob/af704f57bb9480c47cdd393465264d586f1d4562/gitoxide-core/src/index/checkout.rs#L61">use</a> of <code>destination_is_initially_empty: true</code>. Specialized uses in which repositories are known never to have any files marked executable are unaffected. Repositories that no untrusted users can access, due to not having the ability to traverse the directories to them or due to sufficiently restrictive ACLs, are likewise unaffected.</p>
<p>The default value of <code>destination_is_initially_empty</code> is <code>false</code>, so some applications may be affected even if they don't attempt checkouts in nonempty directories. The 0777 permissions are applied to files that are created earlier in the same checkout, as well as those that already existed, regardless of their prior permissions. On preexisting files, 0777 is set <em>even if <a href="https://github.com/GitoxideLabs/gitoxide/blob/8d84818240d44e1f5fe78a231b5d9bffd0283918/gix-worktree-state/src/checkout/mod.rs#L54-L58"><code>overwrite_existing</code></a> is <code>false</code></em>, as that prevents the checkout from changing file contents but not permissions.</p>
<p>Files not tracked/staged as executable are not checked out with insecure permissions. Such a file that previously existed keeps its old permissions. However, this may include executable permissions that no longer match repository metadata, as well as undesired write permissions acquired from a previous vulnerable checkout. <code>set_mode(0o777)</code> clears other bits, so the bug is not exacerbated by the presence of setuid/setgid bits. In some applications, the vulnerable strategy may be used only for files rewritten by a <a href="https://git-scm.com/docs/gitattributes/2.40.0#_long_running_filter_process">long running</a> smudge filter or only in the presence of <a href="https://git-scm.com/docs/gitattributes/2.40.0#_delay">delays</a>.</p>
<h3 id="references">References</h3>
<ul>
<li><a href="https://github.com/GitoxideLabs/gitoxide/security/advisories/GHSA-fqmf-w4xh-33rh">https://github.com/GitoxideLabs/gitoxide/security/advisories/GHSA-fqmf-w4xh-33rh</a></li>
<li><a href="https://nvd.nist.gov/vuln/detail/CVE-2025-22620">https://nvd.nist.gov/vuln/detail/CVE-2025-22620</a></li>
<li><a href="https://rustsec.org/advisories/RUSTSEC-2025-0001.html">https://rustsec.org/advisories/RUSTSEC-2025-0001.html</a></li>
<li><a href="https://github.com/advisories/GHSA-fqmf-w4xh-33rh">https://github.com/advisories/GHSA-fqmf-w4xh-33rh</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-fqmf-w4xh-33rh</uri>
        </author>
        <category label="severity" term="MODERATE"/>
        <published>2025-01-21T21:13:06.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[[gitoxide] gitoxide-core does not neutralize special characters for terminals]]></title>
        <id>https://github.com/advisories/GHSA-88g2-r9rw-g55h</id>
        <link href="https://github.com/advisories/GHSA-88g2-r9rw-g55h"/>
        <updated>2025-01-21T18:31:59.000Z</updated>
        <content type="html"><![CDATA[<h3 id="summary">Summary</h3>
<p>The <code>gix</code> and <code>ein</code> commands write pathnames and other metadata literally to terminals, even if they contain characters terminals treat specially, including ANSI escape sequences. This sometimes allows an untrusted repository to misrepresent its contents and to alter or concoct error messages.</p>
<h3 id="details">Details</h3>
<p><code>gitoxide-core</code>, which provides most underlying functionality of the <code>gix</code> and <code>ein</code> commands, does not neutralize newlines, backspaces, or control characters—including those that form ANSI escape sequences—that appear in a repository's paths, author and committer names, commit messages, or other metadata. Such text may be written as part of the output of a command, as well as appearing in error messages when an operation fails.</p>
<p>ANSI escape sequences are of particular concern because, when printed to a terminal, they can change colors, including to render subsequent text unreadable; reposition the cursor to write text in a different location, including where text has already been written; clear the terminal; set the terminal title-bar text to arbitrary values; render the terminal temporarily unusable; and other such operations.</p>
<p>The effect is mostly an annoyance. But the author of a malicious repository who can predict how information from the repository may be accessed can cause files in the repository to be concealed or otherwise misrepresented, as well as rewrite all or part of error messages, or mimic error messages convincingly by repositioning the cursor and writing colored text.</p>
<h3 id="poc">PoC</h3>
<p>On a Unix-like system in a POSIX-compatible shell, run:</p>
<pre><code class="language-sh">git init misleading-path
cd misleading-path
touch "$(printf '\033]0;Boo!\007\033[2K\r\033[91mError: Repository is corrupted. Run \033[96mEVIL_COMMAND\033[91m to attempt recovery.\033[0m')"
git add .
git commit -m 'Initial commit'
</code></pre>
<p>In the repository—or, if desired, in a clone of it, to show that this is exploitable by getting a user to clone an untrusted repository—run this command, which outputs entries in a three-column form showing type, hash, and filename:</p>
<pre><code class="language-sh">gix tree entries
</code></pre>
<p>Although the output is of that form, it does not appear to be. Instead, the output in a terminal looks like this, colorized to appear to be an error message, with <code>EVIL_COMMAND</code> in another color, and with no other text:</p>
<pre><code class="language-text">Error: Repository is corrupted. Run EVIL_COMMAND to attempt recovery.
</code></pre>
<p>In some terminals, a beep or other sound will be made. In most terminals, the title bar text will be changed to <code>Boo!</code>, though in some shells this may be immediately undone when printing the prompt. These elements are included to showcase the abilities of ANSI escape sequences, but they are not usually themselves threats.</p>
<p>To see what is actually produced, <code>gix tree entries</code> can be piped to a command that displays special characters symbolically, such as <code>less</code> or <code>cat -v</code> if available.</p>
<pre><code class="language-text">BLOB e69de29bb2d1d6434b8b29ae775ad8c2e48c5391 ESC]0;Boo!^GESC[2K^MESC[91mError: Repository is corrupted. Run ESC[96mEVIL_COMMANDESC[91m to attempt recovery.ESC[0m
</code></pre>
<p>That shows the effect on <code>gix tree entries</code>, but various other commands are also affected, and the escape sequences and other special characters can also appear in non-path metadata, such as in the <code>user.name</code> used to create a commit.</p>
<h3 id="impact">Impact</h3>
<p>For users who do not clone or operate in clones of untrusted repositories, there is no impact.
Windows is much less affected than Unix-like systems due to limitations on what characters can appear in filenames, and because traditionally Windows terminals do not support as many ANSI escape sequences.</p>
<p>Because different <code>gix</code> and <code>ein</code> commands display different data in different formats, the author of a malicious repository must guess how it will be used, which complicates crafting truly convincing output, though it may be possible to craft a repository where <code>gix clone</code> fails to clone it but produces a misleading message.</p>
<p>Although this is mainly exploitable on systems <em>other</em> than Windows, in the ability to produce misleading output this superficially resembles CVE-2024-35197. But this is much more limited, because:</p>
<ul>
<li>The misleading output can only be made to go where the application is already sending output. Redirection is not defeated, and devices to access cannot be chosen by the attacker.</li>
<li>The misleading output can only be take place <em>when</em> the application is already producing output. This limitation complicates the production of believable messages.</li>
<li>Only terminals are affected. Even if a standard stream is redirected to another file or device, these special characters would not have a special effect, unless echoed later without sanitization.</li>
<li>Reading and blocking cannot be performed.</li>
<li>Applications other than the gitoxide <code>gix</code> and <code>ein</code> executables are unaffected. The exception is if another application uses <code>gitoxide-core</code>. But this is explicitly discouraged in the <code>gitoxide-core</code> documentation and is believed to be rare.</li>
</ul>
<h3 id="references">References</h3>
<ul>
<li><a href="https://github.com/Byron/gitoxide/security/advisories/GHSA-88g2-r9rw-g55h">https://github.com/Byron/gitoxide/security/advisories/GHSA-88g2-r9rw-g55h</a></li>
<li><a href="https://nvd.nist.gov/vuln/detail/CVE-2024-43785">https://nvd.nist.gov/vuln/detail/CVE-2024-43785</a></li>
<li><a href="https://rustsec.org/advisories/RUSTSEC-2024-0364.html">https://rustsec.org/advisories/RUSTSEC-2024-0364.html</a></li>
<li><a href="https://github.com/GitoxideLabs/gitoxide/security/advisories/GHSA-88g2-r9rw-g55h">https://github.com/GitoxideLabs/gitoxide/security/advisories/GHSA-88g2-r9rw-g55h</a></li>
<li><a href="https://github.com/advisories/GHSA-88g2-r9rw-g55h">https://github.com/advisories/GHSA-88g2-r9rw-g55h</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-88g2-r9rw-g55h</uri>
        </author>
        <category label="severity" term="LOW"/>
        <published>2024-08-22T16:41:28.000Z</published>
    </entry>
</feed>