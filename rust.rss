<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://azu.github.io/github-advisory-database-rss/rust.rss</id>
    <title>Security Advisory for Rust crates</title>
    <updated>2025-03-19T12:02:10.509Z</updated>
    <generator>github-advisory-database-rss</generator>
    <link rel="alternate" href="https://github.com/advisories?query=type%3Areviewed+ecosystem%3Arust"/>
    <subtitle>Security Advisory for Rust crates on GitHub</subtitle>
    <rights>github-advisory-database-rss</rights>
    <category term="CRITICAL"/>
    <category term="HIGH"/>
    <category term="MODERATE"/>
    <category term="LOW"/>
    <entry>
        <title type="html"><![CDATA[[cosmwasm] CosmWasm Allows Bypass of Capability Restrictions in Blockchains]]></title>
        <id>https://github.com/advisories/GHSA-cg8r-jwg7-r2x4</id>
        <link href="https://github.com/advisories/GHSA-cg8r-jwg7-r2x4"/>
        <updated>2025-03-18T22:17:54.000Z</updated>
        <content type="html"><![CDATA[<p>An issue in CosmWasm prior to v2.2.0 allows attackers to bypass capability restrictions in blockchains by exploiting a lack of runtime capability validation. This allows attackers to deploy a contract without capability enforcement, and execute unauthorized actions on the blockchain.</p>
<h3 id="references">References</h3>
<ul>
<li><a href="https://nvd.nist.gov/vuln/detail/CVE-2025-25500">https://nvd.nist.gov/vuln/detail/CVE-2025-25500</a></li>
<li><a href="https://gist.github.com/H3T76/8096a6ff9410f3a6d9a25db1a68ae657#file-cve-2025-25500">https://gist.github.com/H3T76/8096a6ff9410f3a6d9a25db1a68ae657#file-cve-2025-25500</a></li>
<li><a href="https://github.com/CVEProject/cveproject.github.io/blob/gh-pages/requester/reservation-guidelines.md">https://github.com/CVEProject/cveproject.github.io/blob/gh-pages/requester/reservation-guidelines.md</a></li>
<li><a href="https://github.com/CosmWasm/cosmwasm/blob/v2.2.0/CHANGELOG.md">https://github.com/CosmWasm/cosmwasm/blob/v2.2.0/CHANGELOG.md</a></li>
<li><a href="https://github.com/advisories/GHSA-cg8r-jwg7-r2x4">https://github.com/advisories/GHSA-cg8r-jwg7-r2x4</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-cg8r-jwg7-r2x4</uri>
        </author>
        <category label="severity" term="MODERATE"/>
        <published>2025-03-18T15:30:47.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[[zip] zip Incorrectly Canonicalizes Paths during Archive Extraction Leading to Arbitrary File Write]]></title>
        <id>https://github.com/advisories/GHSA-94vh-gphv-8pm8</id>
        <link href="https://github.com/advisories/GHSA-94vh-gphv-8pm8"/>
        <updated>2025-03-17T21:26:35.000Z</updated>
        <content type="html"><![CDATA[<h3 id="summary">Summary</h3>
<p>In the archive extraction routine of affected versions of the <code>zip</code> crate, symbolic links earlier in the archive are allowed to be used for later files in the archive without validation of the final canonicalized path, allowing maliciously crafted archives to overwrite arbitrary files in the file system when extracted.</p>
<h3 id="details">Details</h3>
<p>This is a variant of the <a href="https://github.com/snyk/zip-slip-vulnerability">zip-slip</a> vulnerability, we can make the extraction logic step outside of the target directory by creating a symlink to the parent directory and then extracting further files through that symlink.</p>
<p>The documentation of the [<code>::zip::read::ZipArchive::extract</code>] method is in my opinion implying this should not happen:</p>
<blockquote>
<p>"Paths are sanitized with ZipFile::enclosed_name." ...
[<code>::zip::read::FileOptions::enclosed_name</code>] ... is resistant to path-based exploits ... can’t resolve to a path outside the current directory.</p>
</blockquote>
<p>Most archive software either decline to extract symlinks that traverse out of the directory or defer creation of symlinks after all files have been created to prevent unexpected behavior when later entries depend on earlier symbolic link entries.</p>
<h3 id="poc">PoC</h3>
<p><a href="https://gist.github.com/eternal-flame-AD/bf71ef4f6828e741eb12ce7fd47b7b85">https://gist.github.com/eternal-flame-AD/bf71ef4f6828e741eb12ce7fd47b7b85</a></p>
<h3 id="impact">Impact</h3>
<p>Users who extract untrusted archive files using the following high-level API method may be affected and critical files on the system may be overwritten with arbitrary file permissions, which can potentially lead to code execution.</p>
<ul>
<li>zip::unstable::stream::ZipStreamReader::extract</li>
<li>zip::read::ZipArchive::extract</li>
</ul>
<h3 id="references">References</h3>
<ul>
<li><a href="https://github.com/zip-rs/zip2/security/advisories/GHSA-94vh-gphv-8pm8">https://github.com/zip-rs/zip2/security/advisories/GHSA-94vh-gphv-8pm8</a></li>
<li><a href="https://nvd.nist.gov/vuln/detail/CVE-2025-29787">https://nvd.nist.gov/vuln/detail/CVE-2025-29787</a></li>
<li><a href="https://github.com/zip-rs/zip2/commit/a2e062f37066c3b12860a32eb1cb44856cfb7afe">https://github.com/zip-rs/zip2/commit/a2e062f37066c3b12860a32eb1cb44856cfb7afe</a></li>
<li><a href="https://gist.github.com/eternal-flame-AD/bf71ef4f6828e741eb12ce7fd47b7b85">https://gist.github.com/eternal-flame-AD/bf71ef4f6828e741eb12ce7fd47b7b85</a></li>
<li><a href="https://github.com/zip-rs/zip2/releases/tag/v2.3.0">https://github.com/zip-rs/zip2/releases/tag/v2.3.0</a></li>
<li><a href="https://github.com/advisories/GHSA-94vh-gphv-8pm8">https://github.com/advisories/GHSA-94vh-gphv-8pm8</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-94vh-gphv-8pm8</uri>
        </author>
        <category label="severity" term="HIGH"/>
        <published>2025-03-17T21:26:32.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[[zincati] Zincati allows unprivileged access to rpm-ostree D-Bus `Deploy()` and `FinalizeDeployment()` methods]]></title>
        <id>https://github.com/advisories/GHSA-w6fv-6gcc-x825</id>
        <link href="https://github.com/advisories/GHSA-w6fv-6gcc-x825"/>
        <updated>2025-03-17T21:55:53.000Z</updated>
        <content type="html"><![CDATA[<h3 id="impact">Impact</h3>
<p>Zincati ships a polkit rule which allows the <code>zincati</code> system user to use the following actions:</p>
<ul>
<li><code>org.projectatomic.rpmostree1.deploy</code>: used to deploy updates to the system</li>
<li><code>org.projectatomic.rpmostree1.finalize-deployment</code>: used to reboot the system into the deployed update</li>
</ul>
<p>Since Zincati <a href="https://github.com/coreos/zincati/releases/tag/v0.0.24">v0.0.24</a>, this polkit rule contains a logic error which broadens access of those polkit actions to any unprivileged user rather than just the <code>zincati</code> system user.</p>
<p>In practice, this means that any unprivileged user with access to the system D-Bus socket is able to deploy older Fedora CoreOS versions (which may have other known vulnerabilities). Note that rpm-ostree enforces that the selected version must be from the same branch the system is currently on so this cannot directly be used to deploy an attacker-controlled update payload.</p>
<p>This primarily impacts users running untrusted workloads with access to the system D-Bus socket. Note that in general, untrusted workloads should not be given this access, whether containerized or not. By default, containers do not have access to the system D-Bus socket.</p>
<h3 id="patches">Patches</h3>
<p>The logic error is fixed in Zincati v0.0.30. FCOS releases containing the fix are pending. This advisory will be updated with the final FCOS versions once available.</p>
<h3 id="workarounds">Workarounds</h3>
<p>A workaround is to add the following polkit rule:</p>
<pre><code class="language-javascript">polkit.addRule(function(action, subject) {
    if (action.id == "org.projectatomic.rpmostree1.deploy" ||
        action.id == "org.projectatomic.rpmostree1.finalize-deployment" ||
        action.id == "org.projectatomic.rpmostree1.cleanup") {
        if (subject.user != "zincati") {
                return polkit.Result.NO;
        }
    }
});
</code></pre>
<p>to e.g. <code>/etc/polkit-1/rules.d/00-zincati-fix.rules</code> (it must sort earlier than <code>zincati.rules</code> lexicographically).</p>
<p>Note that this rule will deny all non-root users other than <code>zincati</code> from using those actions. If you've added polkit rules to allow e.g. the <code>core</code> user or other users, you will need to adjust the policy (or make sure the ordering is appropriate).</p>
<h3 id="references">References</h3>
<p>This issue was introduced by <a href="https://github.com/coreos/zincati/commit/28a43aa2c1edda091ba659677d73c13e6e3ea99d">this commit</a>, and is fixed in <a href="https://github.com/coreos/zincati/releases/tag/v0.0.30">v0.0.30</a>.</p>
<h3 id="references-1">References</h3>
<ul>
<li><a href="https://github.com/coreos/zincati/security/advisories/GHSA-w6fv-6gcc-x825">https://github.com/coreos/zincati/security/advisories/GHSA-w6fv-6gcc-x825</a></li>
<li><a href="https://github.com/coreos/zincati/commit/01d8e89f799e6ba21bdf7dc668abce23bd0d8f78">https://github.com/coreos/zincati/commit/01d8e89f799e6ba21bdf7dc668abce23bd0d8f78</a></li>
<li><a href="https://github.com/coreos/zincati/commit/28a43aa2c1edda091ba659677d73c13e6e3ea99d">https://github.com/coreos/zincati/commit/28a43aa2c1edda091ba659677d73c13e6e3ea99d</a></li>
<li><a href="https://github.com/coreos/zincati/releases/tag/v0.0.24">https://github.com/coreos/zincati/releases/tag/v0.0.24</a></li>
<li><a href="https://github.com/coreos/zincati/releases/tag/v0.0.30">https://github.com/coreos/zincati/releases/tag/v0.0.30</a></li>
<li><a href="https://nvd.nist.gov/vuln/detail/CVE-2025-27512">https://nvd.nist.gov/vuln/detail/CVE-2025-27512</a></li>
<li><a href="https://github.com/advisories/GHSA-w6fv-6gcc-x825">https://github.com/advisories/GHSA-w6fv-6gcc-x825</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-w6fv-6gcc-x825</uri>
        </author>
        <category label="severity" term="LOW"/>
        <published>2025-03-17T14:46:56.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[[gurk] gurk (aka gurk-rs) mishandles ANSI escape sequences]]></title>
        <id>https://github.com/advisories/GHSA-89xp-c3mq-qj84</id>
        <link href="https://github.com/advisories/GHSA-89xp-c3mq-qj84"/>
        <updated>2025-03-17T14:45:41.000Z</updated>
        <content type="html"><![CDATA[<p>gurk (aka gurk-rs) through 0.6.3 mishandles ANSI escape sequences.</p>
<h3 id="references">References</h3>
<ul>
<li><a href="https://nvd.nist.gov/vuln/detail/CVE-2025-30089">https://nvd.nist.gov/vuln/detail/CVE-2025-30089</a></li>
<li><a href="https://github.com/boxdot/gurk-rs/issues/384">https://github.com/boxdot/gurk-rs/issues/384</a></li>
<li><a href="https://crates.io/crates/gurk">https://crates.io/crates/gurk</a></li>
<li><a href="https://github.com/advisories/GHSA-89xp-c3mq-qj84">https://github.com/advisories/GHSA-89xp-c3mq-qj84</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-89xp-c3mq-qj84</uri>
        </author>
        <category label="severity" term="MODERATE"/>
        <published>2025-03-17T00:30:21.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[[below] Below has Incorrect Permission Assignment for Critical Resource]]></title>
        <id>https://github.com/advisories/GHSA-9mc5-7qhg-fp3w</id>
        <link href="https://github.com/advisories/GHSA-9mc5-7qhg-fp3w"/>
        <updated>2025-03-12T21:55:49.000Z</updated>
        <content type="html"><![CDATA[<h3 id="impact">Impact</h3>
<p>A privilege escalation vulnerability existed in the Below service prior to v0.9.0 due to the creation of a world-writable directory at /var/log/below. This could have allowed local unprivileged users to escalate to root privileges through symlink attacks that manipulate files such as /etc/shadow.</p>
<h3 id="patches">Patches</h3>
<p><a href="https://github.com/facebookincubator/below/commit/10e73a21d67baa2cd613ee92ce999cda145e1a83">https://github.com/facebookincubator/below/commit/10e73a21d67baa2cd613ee92ce999cda145e1a83</a></p>
<p>This is included in version 0.9.0</p>
<h3 id="workarounds">Workarounds</h3>
<p>Change the permission on <code>/var/log/below</code> manually</p>
<h3 id="references">References</h3>
<p><a href="https://www.facebook.com/security/advisories/cve-2025-27591">https://www.facebook.com/security/advisories/cve-2025-27591</a>
<a href="https://www.cve.org/CVERecord?id=CVE-2025-27591">https://www.cve.org/CVERecord?id=CVE-2025-27591</a></p>
<h3 id="references-1">References</h3>
<ul>
<li><a href="https://github.com/facebookincubator/below/security/advisories/GHSA-9mc5-7qhg-fp3w">https://github.com/facebookincubator/below/security/advisories/GHSA-9mc5-7qhg-fp3w</a></li>
<li><a href="https://github.com/facebookincubator/below/commit/10e73a21d67baa2cd613ee92ce999cda145e1a83">https://github.com/facebookincubator/below/commit/10e73a21d67baa2cd613ee92ce999cda145e1a83</a></li>
<li><a href="https://www.facebook.com/security/advisories/cve-2025-27591">https://www.facebook.com/security/advisories/cve-2025-27591</a></li>
<li><a href="https://nvd.nist.gov/vuln/detail/CVE-2025-27591">https://nvd.nist.gov/vuln/detail/CVE-2025-27591</a></li>
<li><a href="http://www.openwall.com/lists/oss-security/2025/03/12/1">http://www.openwall.com/lists/oss-security/2025/03/12/1</a></li>
<li><a href="https://github.com/advisories/GHSA-9mc5-7qhg-fp3w">https://github.com/advisories/GHSA-9mc5-7qhg-fp3w</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-9mc5-7qhg-fp3w</uri>
        </author>
        <category label="severity" term="HIGH"/>
        <published>2025-03-11T21:12:54.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[[protobuf] Crash due to uncontrolled recursion in protobuf crate]]></title>
        <id>https://github.com/advisories/GHSA-2gh3-rmm4-6rq5</id>
        <link href="https://github.com/advisories/GHSA-2gh3-rmm4-6rq5"/>
        <updated>2025-03-11T17:08:08.000Z</updated>
        <content type="html"><![CDATA[<p>Affected version of this crate did not properly parse unknown fields when parsing a user-supplied input.</p>
<p>This allows an attacker to cause a stack overflow when parsing the message on untrusted data.</p>
<h3 id="references">References</h3>
<ul>
<li><a href="https://github.com/stepancheg/rust-protobuf/issues/749">https://github.com/stepancheg/rust-protobuf/issues/749</a></li>
<li><a href="https://rustsec.org/advisories/RUSTSEC-2024-0437.html">https://rustsec.org/advisories/RUSTSEC-2024-0437.html</a></li>
<li><a href="https://github.com/stepancheg/rust-protobuf/commit/f06992f46771c0a092593b9ebf7afd48740b3ed6">https://github.com/stepancheg/rust-protobuf/commit/f06992f46771c0a092593b9ebf7afd48740b3ed6</a></li>
<li><a href="https://github.com/advisories/GHSA-2gh3-rmm4-6rq5">https://github.com/advisories/GHSA-2gh3-rmm4-6rq5</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-2gh3-rmm4-6rq5</uri>
        </author>
        <category label="severity" term="MODERATE"/>
        <published>2025-03-07T20:02:37.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[[qcp] qcp has possible crash/DOS in some build configurations]]></title>
        <id>https://github.com/advisories/GHSA-fmwf-c46w-r8qm</id>
        <link href="https://github.com/advisories/GHSA-fmwf-c46w-r8qm"/>
        <updated>2025-03-08T01:30:19.000Z</updated>
        <content type="html"><![CDATA[<p><strong>Nature of issue:</strong> Crash (Denial of Service)
<strong>Source of issue:</strong> Dependent package (ring)
<strong>Affected versions of qcp:</strong> 0.1.0-0.3.2
<strong>Recommendation:</strong> Upgrade to qcp 0.3.3 or later</p>
<h3 id="who-is-affected">Who is affected</h3>
<p>All versions of qcp from 0.1.0 to 0.3.2 are affected, but <strong>only if built with runtime overflow checks.</strong></p>
<ul>
<li>Released qcp binaries do not enable runtime overflow checks by default. <strong>If you use an official released qcp binary download, you are not affected.</strong></li>
<li>If you built qcp yourself in debug mode, you are affected unless your debug configuration explicitly disables overflow checks.</li>
<li>If you built qcp yourself in release mode, you are only affected if you explicitly requested runtime overflow checks at build time by setting the appropriate <code>RUSTFLAGS</code>, or in your Cargo.toml profile.</li>
</ul>
<h3 id="what-to-do-if-you-are-affected">What to do if you are affected</h3>
<p><strong>We recommend you upgrade to qcp 0.3.3 or later.</strong>
Users upgrading from versions prior to 0.3.0 should note that an incompatible protocol change was introduced in version 0.3.0, so should stage their upgrade carefully.</p>
<p>Alternatively, it is possible to avoid upgrading by rebuilding qcp locally. The following alternative mitigations have been identified:</p>
<ul>
<li>Rebuild locally with runtime overflow checks disabled</li>
<li>Rebuild locally using a fixed version of the <code>ring</code> dependency (0.17.12 or later).</li>
</ul>
<h3 id="detail">Detail</h3>
<p>The upstream advisory describes a crash in the implementation of the QUIC protocol that can be induced by a specially-crafted packet, and which happens naturally approximately every 1 in 2**32 packets sent and/or received.</p>
<p>The crash only happens when runtime overflow checking is enabled. Note that the upstream advisory describes the overflow check causing this issue as "unwanted". Their response, to remove the overflow check in one place, does not introduce any additional issue.</p>
<h3 id="impact">Impact</h3>
<p>During qcp file transfer sessions, it is possible for an attacker to send a specially-crafted packet that could trigger this issue.</p>
<ul>
<li>In that case, and only if qcp was built with runtime overflow checks enabled, the effect is a Rust panic which immediately aborts the transfer. There is no additional impact on system resources at either end, nor on other file transfers in progress.</li>
<li>As qcp runs a separate process for every connected user, the impact of the attack is limited to a single session.</li>
</ul>
<p>The underlying issue may also affect particularly large file transfers. The maximum TLS packet size is 16KB, so 2**32 packets will transfer up to 68TB (including the protocol/retransmit overhead). Again, this is only the case if qcp was built with runtime overflow checks enabled.</p>
<p>As of the time of writing, we are not aware of any reports of this issue being exploited.</p>
<h4 id="additional-notes">Additional notes</h4>
<ul>
<li>The qcp protocol itself does not rely on runtime overflow checks for its security.</li>
<li>While QUIC servers are normally public-facing, <a href="https://docs.rs/qcp/latest/qcp/protocol/index.html">qcp is a hybrid protocol</a> that first requires an authenticated ssh session in order to set up the QUIC session. The window of attackability is therefore reduced, though will depend on your usage profile.</li>
<li>An additional layer of obscurity is provided by qcp using ephemeral, random port numbers for its QUIC traffic (subject to user configuration).</li>
</ul>
<h3 id="references">References</h3>
<p>Upstream advisories:</p>
<ul>
<li><a href="https://rustsec.org/advisories/RUSTSEC-2025-0009.html">RUSTSEC-2025-0009</a></li>
<li><a href="https://github.com/advisories/GHSA-4p46-pwfr-66x6">https://github.com/advisories/GHSA-4p46-pwfr-66x6</a></li>
</ul>
<h3 id="references-1">References</h3>
<ul>
<li><a href="https://github.com/crazyscot/qcp/security/advisories/GHSA-fmwf-c46w-r8qm">https://github.com/crazyscot/qcp/security/advisories/GHSA-fmwf-c46w-r8qm</a></li>
<li><a href="https://github.com/advisories/GHSA-4p46-pwfr-66x6">https://github.com/advisories/GHSA-4p46-pwfr-66x6</a></li>
<li><a href="https://github.com/briansmith/ring/blob/main/RELEASES.md#version-01712-2025-03-05">https://github.com/briansmith/ring/blob/main/RELEASES.md#version-01712-2025-03-05</a></li>
<li><a href="https://rustsec.org/advisories/RUSTSEC-2025-0009.html">https://rustsec.org/advisories/RUSTSEC-2025-0009.html</a></li>
<li><a href="https://github.com/advisories/GHSA-fmwf-c46w-r8qm">https://github.com/advisories/GHSA-fmwf-c46w-r8qm</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-fmwf-c46w-r8qm</uri>
        </author>
        <category label="severity" term="MODERATE"/>
        <published>2025-03-08T01:30:18.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[[ring] Some AES functions may panic when overflow checking is enabled in ring]]></title>
        <id>https://github.com/advisories/GHSA-4p46-pwfr-66x6</id>
        <link href="https://github.com/advisories/GHSA-4p46-pwfr-66x6"/>
        <updated>2025-03-07T16:23:51.000Z</updated>
        <content type="html"><![CDATA[<p><code>ring::aead::quic::HeaderProtectionKey::new_mask()</code> may panic when overflow checking is enabled. In the QUIC protocol, an attacker can induce this panic by sending a specially-crafted packet. Even unintentionally it is likely to occur in 1 out of every 2**32 packets sent and/or received.</p>
<p>On 64-bit targets operations using <code>ring::aead::{AES_128_GCM, AES_256_GCM}</code> may panic when overflow checking is enabled, when encrypting/decrypting approximately 68,719,476,700 bytes (about 64 gigabytes) of data in a single chunk. Protocols like TLS and SSH are not affected by this because those protocols break large amounts of data into small chunks. Similarly, most applications will not attempt to encrypt/decrypt 64GB of data in one chunk.</p>
<p>Overflow checking is not enabled in release mode by default, but <code>RUSTFLAGS="-C overflow-checks"</code> or <code>overflow-checks = true</code> in the Cargo.toml profile can override this. Overflow checking is usually enabled by default in debug mode.</p>
<h3 id="references">References</h3>
<ul>
<li><a href="https://github.com/briansmith/ring/pull/2447">https://github.com/briansmith/ring/pull/2447</a></li>
<li><a href="https://github.com/briansmith/ring/commit/ec2d3cf1d91f148c84e4806b4f0b3c98f6df3b38">https://github.com/briansmith/ring/commit/ec2d3cf1d91f148c84e4806b4f0b3c98f6df3b38</a></li>
<li><a href="https://github.com/briansmith/ring/blob/main/RELEASES.md#version-01712-2025-03-05">https://github.com/briansmith/ring/blob/main/RELEASES.md#version-01712-2025-03-05</a></li>
<li><a href="https://rustsec.org/advisories/RUSTSEC-2025-0009.html">https://rustsec.org/advisories/RUSTSEC-2025-0009.html</a></li>
<li><a href="https://github.com/advisories/GHSA-4p46-pwfr-66x6">https://github.com/advisories/GHSA-4p46-pwfr-66x6</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-4p46-pwfr-66x6</uri>
        </author>
        <category label="severity" term="MODERATE"/>
        <published>2025-03-07T16:23:50.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[[ascon_aead] AEADs/ascon-aead: Plaintext exposed in decrypt_in_place_detached even on tag verification failure]]></title>
        <id>https://github.com/advisories/GHSA-r38m-44fw-h886</id>
        <link href="https://github.com/advisories/GHSA-r38m-44fw-h886"/>
        <updated>2025-03-03T20:22:20.000Z</updated>
        <content type="html"><![CDATA[<h3 id="summary">Summary</h3>
<p>In <code>decrypt_in_place_detached</code>, the decrypted ciphertext (which is the correct ciphertext) is exposed even if the tag is incorrect.</p>
<h3 id="details">Details</h3>
<p>This is because in <a href="https://github.com/RustCrypto/AEADs/blob/8cda109f1128c4c7953a0bb0f53e1056d537e462/ascon-aead/src/asconcore.rs#L350-L364">decrypt_inplace</a> in asconcore.rs, tag verification causes an error to be returned with the plaintext contents still in <code>buffer</code>. The root cause of this vulnerability is similar to <a href="https://github.com/RustCrypto/AEADs/security/advisories/GHSA-423w-p2w9-r7vq">https://github.com/RustCrypto/AEADs/security/advisories/GHSA-423w-p2w9-r7vq</a></p>
<h3 id="poc">PoC</h3>
<pre><code class="language-rust">use ascon_aead::Tag;
use ascon_aead::{Ascon128, Key, Nonce};
use ascon_aead::aead::{AeadInPlace, KeyInit};

fn main() {

    let key = Key::&lt;Ascon128&gt;::from_slice(b"very secret key.");
    let cipher = Ascon128::new(key);

    let nonce = Nonce::&lt;Ascon128&gt;::from_slice(b"unique nonce 012"); // 128-bits; unique per message

    let mut buffer: Vec&lt;u8&gt; = Vec::new(); // Buffer needs 16-bytes overhead for authentication tag
    buffer.extend_from_slice(b"plaintext message");

    // Encrypt `buffer` in-place detached, replacing the plaintext contents with ciphertext
    cipher.encrypt_in_place_detached(nonce, b"", &amp;mut buffer).expect("encryption failure!");
    
    // Decrypt `buffer` in-place with the wrong tag, ignoring the decryption error
    let _ = cipher.decrypt_in_place_detached(nonce, b"", &amp;mut buffer, Tag::&lt;Ascon128&gt;::from_slice(b"\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"));

    assert_eq!(&amp;buffer, b"plaintext message");
}
</code></pre>
<h3 id="impact">Impact</h3>
<p>If a program continues to use the result of <code>decrypt_in_place_detached</code> after a decryption failure, the result will be unauthenticated. This may permit some forms of chosen ciphertext attacks (CCAs).</p>
<h3 id="references">References</h3>
<ul>
<li><a href="https://github.com/RustCrypto/AEADs/security/advisories/GHSA-r38m-44fw-h886">https://github.com/RustCrypto/AEADs/security/advisories/GHSA-r38m-44fw-h886</a></li>
<li><a href="https://nvd.nist.gov/vuln/detail/CVE-2025-27498">https://nvd.nist.gov/vuln/detail/CVE-2025-27498</a></li>
<li><a href="https://github.com/RustCrypto/AEADs/commit/d1d749ba57e38e65b0e037cd744d0b17f7254037">https://github.com/RustCrypto/AEADs/commit/d1d749ba57e38e65b0e037cd744d0b17f7254037</a></li>
<li><a href="https://github.com/advisories/GHSA-r38m-44fw-h886">https://github.com/advisories/GHSA-r38m-44fw-h886</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-r38m-44fw-h886</uri>
        </author>
        <category label="severity" term="MODERATE"/>
        <published>2025-03-03T20:22:19.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[[ntpd] ntpd NTS client denial of service via wrongly sized cookies]]></title>
        <id>https://github.com/advisories/GHSA-v83q-83hj-rw38</id>
        <link href="https://github.com/advisories/GHSA-v83q-83hj-rw38"/>
        <updated>2025-03-15T20:37:11.000Z</updated>
        <content type="html"><![CDATA[<p>Two denial of service vulnerabilities were found in ntpd-rs related to the handling of NTS cookies in our client functionality. Whenever an NTS source is configured and the server behind that source is sending zero-sized cookies or cookies larger than what would fit in our buffer size, ntpd-rs would crash. Only configured NTS sources can abuse these vulnerabilities. NTP sources or third parties that are not configured cannot make use of these vulnerabilities.</p>
<p>For zero-sized cookies: a division by zero would force an exit when the number of new cookies that would need to be requested is calculated. In ntpd-rs 1.5.0 a check was added to prevent the division by zero.</p>
<p>For large cookies: while trying to send a NTP request with the cookie included, the buffer is too small to handle the cookie and an exit of ntpd-rs is forced once a write to the buffer is attempted. The memory outside the buffer would not be written to in this case. In ntpd-rs 1.5.0 a check was added that prevents accepting cookies larger than 350 bytes.</p>
<p>Users of older versions of ntpd-rs are recommended to update to the latest version. If an update is impossible, it is recommended to only add NTS sources to ntpd-rs that are trusted to not abuse this bug.</p>
<h3 id="references">References</h3>
<ul>
<li><a href="https://github.com/pendulum-project/ntpd-rs/security/advisories/GHSA-v83q-83hj-rw38">https://github.com/pendulum-project/ntpd-rs/security/advisories/GHSA-v83q-83hj-rw38</a></li>
<li><a href="https://github.com/pendulum-project/ntpd-rs/commit/10a103b471dae25ac598140df0c195b6531bf716">https://github.com/pendulum-project/ntpd-rs/commit/10a103b471dae25ac598140df0c195b6531bf716</a></li>
<li><a href="https://github.com/pendulum-project/ntpd-rs/commit/37dd8d9a0faa03e7dfe3a4bf64953010f075c3e2">https://github.com/pendulum-project/ntpd-rs/commit/37dd8d9a0faa03e7dfe3a4bf64953010f075c3e2</a></li>
<li><a href="https://github.com/advisories/GHSA-v83q-83hj-rw38">https://github.com/advisories/GHSA-v83q-83hj-rw38</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-v83q-83hj-rw38</uri>
        </author>
        <category label="severity" term="MODERATE"/>
        <published>2025-02-28T17:46:36.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[[openh264-sys2] OpenH264 Rust API Openh264 Decoding Functions Heap Overflow Vulnerability]]></title>
        <id>https://github.com/advisories/GHSA-5pmw-9j92-3c4c</id>
        <link href="https://github.com/advisories/GHSA-5pmw-9j92-3c4c"/>
        <updated>2025-02-24T18:27:26.000Z</updated>
        <content type="html"><![CDATA[<p>OpenH264 recently reported a <a href="https://github.com/cisco/openh264/security/advisories/GHSA-m99q-5j7x-7m9x">heap overflow</a> that was fixed in upstream <a href="https://github.com/cisco/openh264/commit/63db555e30986e3a5f07871368dc90ae78c27449">63db555</a> and <a href="https://github.com/ralfbiedert/openh264-rs/commit/3a822fff0b4c9a984622ca2b179fe8898ac54b14">integrated into</a> our 0.6.6 release. For users relying on Cisco's pre-compiled DLL, we also published 0.8.0, which is compatible with their latest fixed DLL version  2.6.0. </p>
<p>In other words:</p>
<ul>
<li>if you rely on our <code>source</code> feature only, &gt;=0.6.6 should be safe,</li>
<li>if you rely on <code>libloading</code>, you must upgrade to 0.8.0 <em>and</em> use their latest DLL &gt;=2.6.0.</li>
</ul>
<p>Users handling untrusted video files should update immediately.</p>
<h3 id="references">References</h3>
<ul>
<li><a href="https://nvd.nist.gov/vuln/detail/CVE-2025-27091">https://nvd.nist.gov/vuln/detail/CVE-2025-27091</a></li>
<li><a href="https://github.com/cisco/openh264/pull/3818">https://github.com/cisco/openh264/pull/3818</a></li>
<li><a href="https://github.com/ralfbiedert/openh264-rs/commit/3a822fff0b4c9a984622ca2b179fe8898ac54b14">https://github.com/ralfbiedert/openh264-rs/commit/3a822fff0b4c9a984622ca2b179fe8898ac54b14</a></li>
<li><a href="https://rustsec.org/advisories/RUSTSEC-2025-0008.html">https://rustsec.org/advisories/RUSTSEC-2025-0008.html</a></li>
<li><a href="https://github.com/advisories/GHSA-5pmw-9j92-3c4c">https://github.com/advisories/GHSA-5pmw-9j92-3c4c</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-5pmw-9j92-3c4c</uri>
        </author>
        <category label="severity" term="HIGH"/>
        <published>2025-02-24T18:27:25.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[[namada-apps] Namada-apps allows Excessive Computation in Mempool Validation]]></title>
        <id>https://github.com/advisories/GHSA-f8qm-hmm3-fv7f</id>
        <link href="https://github.com/advisories/GHSA-f8qm-hmm3-fv7f"/>
        <updated>2025-02-20T20:34:05.000Z</updated>
        <content type="html"><![CDATA[<h3 id="impact">Impact</h3>
<p>A malicious transaction may cause an expensive computation in mempool validation.</p>
<p>A transaction with multiple repeated sections causes the section hash calculation used for signature validation to grow exponentially (and potentially even cubic) in proportion to number of sections. This may be used to significantly slow down operation of nodes.</p>
<h3 id="patches">Patches</h3>
<p>This issue has been patched in apps version 1.1.0. The transaction sections are now being checked for uniqueness and the number of permitted sections contained in a single transaction has been limited to 10,000.</p>
<h3 id="workarounds">Workarounds</h3>
<p>There are no workarounds and users are advised to upgrade.</p>
<h3 id="references">References</h3>
<ul>
<li><a href="https://github.com/anoma/namada/security/advisories/GHSA-f8qm-hmm3-fv7f">https://github.com/anoma/namada/security/advisories/GHSA-f8qm-hmm3-fv7f</a></li>
<li><a href="https://github.com/advisories/GHSA-f8qm-hmm3-fv7f">https://github.com/advisories/GHSA-f8qm-hmm3-fv7f</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-f8qm-hmm3-fv7f</uri>
        </author>
        <category label="severity" term="CRITICAL"/>
        <published>2025-02-20T20:34:04.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[[namada-apps] Namada-apps can Crash with Excessive Computation in Mempool Validation]]></title>
        <id>https://github.com/advisories/GHSA-82vg-5v4f-f9wq</id>
        <link href="https://github.com/advisories/GHSA-82vg-5v4f-f9wq"/>
        <updated>2025-02-20T20:33:58.000Z</updated>
        <content type="html"><![CDATA[<h3 id="impact">Impact</h3>
<p>A malicious transaction may cause a crash in mempool validation.</p>
<p>A transaction with authorization section containing 256 public keys or more with valid matching signatures triggers an integer overflow in signature verification that causes a the node to panic.</p>
<h3 id="patches">Patches</h3>
<p>This issue has been patched in apps version 1.1.0. The mempool validation has been fixed to avoid overflow.</p>
<h3 id="workarounds">Workarounds</h3>
<p>There are no workarounds and users are advised to upgrade.</p>
<h3 id="references">References</h3>
<ul>
<li><a href="https://github.com/anoma/namada/security/advisories/GHSA-82vg-5v4f-f9wq">https://github.com/anoma/namada/security/advisories/GHSA-82vg-5v4f-f9wq</a></li>
<li><a href="https://github.com/advisories/GHSA-82vg-5v4f-f9wq">https://github.com/advisories/GHSA-82vg-5v4f-f9wq</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-82vg-5v4f-f9wq</uri>
        </author>
        <category label="severity" term="CRITICAL"/>
        <published>2025-02-20T20:33:56.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[[namada-apps] Namada-apps allows Post-Genesis Validator Bypass]]></title>
        <id>https://github.com/advisories/GHSA-2gw2-qgjg-xh6p</id>
        <link href="https://github.com/advisories/GHSA-2gw2-qgjg-xh6p"/>
        <updated>2025-02-20T20:24:20.000Z</updated>
        <content type="html"><![CDATA[<h3 id="impact">Impact</h3>
<p>Ledger crash. A user is able to initialize a post-genesis validator with a negative commission rate using the <code>--force</code> flag. If this validator gets into the consensus set, then when computing PoS inflation inside <code>fn update_rewards_products_and_mint_inflation</code>, an instance of <code>mul_floor</code> will cause the return of an <code>Err</code>, which causes <code>finalize_block</code> to error.</p>
<h3 id="patches">Patches</h3>
<p>This issue has been patched in apps version 1.1.0. The PoS validity predicate now enforces that the commission rate is not negative and any transaction that fails the check will be rejected, both for newly initialized validators and for commission rate change of an existing validator.</p>
<h3 id="workarounds">Workarounds</h3>
<p>There are no workarounds and users are advised to upgrade.</p>
<h3 id="references">References</h3>
<ul>
<li><a href="https://github.com/anoma/namada/security/advisories/GHSA-2gw2-qgjg-xh6p">https://github.com/anoma/namada/security/advisories/GHSA-2gw2-qgjg-xh6p</a></li>
<li><a href="https://github.com/advisories/GHSA-2gw2-qgjg-xh6p">https://github.com/advisories/GHSA-2gw2-qgjg-xh6p</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-2gw2-qgjg-xh6p</uri>
        </author>
        <category label="severity" term="CRITICAL"/>
        <published>2025-02-20T20:24:19.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[[fyrox-core] Fyrox has unsound usages of `Vec::from_raw_parts` ]]></title>
        <id>https://github.com/advisories/GHSA-h7h7-6mx3-r89v</id>
        <link href="https://github.com/advisories/GHSA-h7h7-6mx3-r89v"/>
        <updated>2025-02-14T17:31:17.000Z</updated>
        <content type="html"><![CDATA[<p>The library provides a public safe API <code>transmute_vec_as_bytes</code>, which incorrectly assumes that any generic type <code>T</code> could have stable layout, causing to uninitialized memory exposure if the users pass any types with padding bytes as <code>T</code> and cast it to <code>u8</code> pointer.  </p>
<p>In the <a href="https://github.com/FyroxEngine/Fyrox/issues/630">issue</a>, we develop a PoC to show passing struct type to <code>transmute_vec_as_bytes</code> could lead to undefined behavior with <code>Vec::from_raw_parts</code>.  </p>
<p>The developers provide a patch by changing trait of <code>Copy</code> to <code>Pod</code>, which can make sure <code>T</code> should be plain data. This was patched in the latest version of <a href="https://github.com/FyroxEngine/Fyrox/blob/3f9ad6f9667047dac051b0e97d544e5b38e5ae72/fyrox-core/src/lib.rs#L351-L360">master</a> branch, but still not on the latest release (0.28.1).</p>
<h3 id="references">References</h3>
<ul>
<li><a href="https://github.com/FyroxEngine/Fyrox/issues/630">https://github.com/FyroxEngine/Fyrox/issues/630</a></li>
<li><a href="https://github.com/FyroxEngine/Fyrox/pull/662">https://github.com/FyroxEngine/Fyrox/pull/662</a></li>
<li><a href="https://github.com/FyroxEngine/Fyrox/commit/474e3b01a884366cdb7d704f7456ef692e992232">https://github.com/FyroxEngine/Fyrox/commit/474e3b01a884366cdb7d704f7456ef692e992232</a></li>
<li><a href="https://rustsec.org/advisories/RUSTSEC-2024-0435.html">https://rustsec.org/advisories/RUSTSEC-2024-0435.html</a></li>
<li><a href="https://github.com/advisories/GHSA-h7h7-6mx3-r89v">https://github.com/advisories/GHSA-h7h7-6mx3-r89v</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-h7h7-6mx3-r89v</uri>
        </author>
        <category label="severity" term="LOW"/>
        <published>2025-02-14T17:31:16.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[[orml-rewards] Uncaught Panic in ORML Rewards Pallet]]></title>
        <id>https://github.com/advisories/GHSA-5v93-9mqw-p9mh</id>
        <link href="https://github.com/advisories/GHSA-5v93-9mqw-p9mh"/>
        <updated>2025-02-14T17:26:09.000Z</updated>
        <content type="html"><![CDATA[<h2 id="summary">Summary</h2>
<p>A vulnerability in the <code>add_share</code> function of the <strong>Rewards</strong> pallet (part of the ORML repository) can lead to an uncaught Rust panic when handling user-provided input exceeding the <code>u128</code> range.</p>
<h2 id="affected-components">Affected Components</h2>
<ul>
<li><strong>ORML Rewards</strong> pallet (<code>rewards/src/lib.rs</code>)</li>
<li>Any Substrate-based chain using ORML Rewards with <code>add_share</code> accepting unvalidated large <code>u128</code> inputs</li>
</ul>
<h2 id="technical-details">Technical Details</h2>
<ul>
<li><code>add_share</code> performs arithmetic on user-supplied values (<code>add_amount</code>) of type <code>T::Share</code> (mapped to <code>u128</code> in Acala).</li>
<li>If <code>add_amount</code> is large enough (e.g., <code>i128::MAX</code>), the intermediate result may overflow and panic on the cast to <code>u128</code>.</li>
<li>Validation occurs only after arithmetic, enabling a crafted input to trigger an overflow.</li>
</ul>
<h2 id="impact">Impact</h2>
<p>A malicious user submitting a specially crafted extrinsic can cause a panic in the runtime:</p>
<ul>
<li><strong>Denial of Service</strong> by crashing the node process.</li>
<li><strong>Potential for invalid blocks</strong> produced by validators.</li>
</ul>
<h2 id="likelihood">Likelihood</h2>
<p>This issue is exploitable in production if there exists at least one rewards pool where reward tokens exceed twice the collateral tokens, allowing sufficiently large multiplication to exceed <code>u128</code> bounds.</p>
<h2 id="remediation">Remediation</h2>
<ul>
<li>This issue is fixed in <a href="https://github.com/open-web3-stack/open-runtime-module-library/pull/1016">https://github.com/open-web3-stack/open-runtime-module-library/pull/1016</a></li>
</ul>
<h2 id="backport">Backport</h2>
<p>The patch have been backported to following release branches:</p>
<ul>
<li>polkadot-stable2407</li>
<li>polkadot-stable2409</li>
</ul>
<p>A 1.0.1 patch release is made with this fix.</p>
<h3 id="references">References</h3>
<ul>
<li><a href="https://github.com/open-web3-stack/open-runtime-module-library/security/advisories/GHSA-5v93-9mqw-p9mh">https://github.com/open-web3-stack/open-runtime-module-library/security/advisories/GHSA-5v93-9mqw-p9mh</a></li>
<li><a href="https://github.com/open-web3-stack/open-runtime-module-library/pull/1016">https://github.com/open-web3-stack/open-runtime-module-library/pull/1016</a></li>
<li><a href="https://github.com/open-web3-stack/open-runtime-module-library/commit/6720fcd92f44e5f204741b04fdef3b67b0fcf6bc">https://github.com/open-web3-stack/open-runtime-module-library/commit/6720fcd92f44e5f204741b04fdef3b67b0fcf6bc</a></li>
<li><a href="https://github.com/advisories/GHSA-5v93-9mqw-p9mh">https://github.com/advisories/GHSA-5v93-9mqw-p9mh</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-5v93-9mqw-p9mh</uri>
        </author>
        <category label="severity" term="HIGH"/>
        <published>2025-02-14T17:26:08.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[[hickory-proto] Hickory DNS failure to verify self-signed RRSIG for DNSKEYs]]></title>
        <id>https://github.com/advisories/GHSA-v7pc-74h8-xq2h</id>
        <link href="https://github.com/advisories/GHSA-v7pc-74h8-xq2h"/>
        <updated>2025-02-10T21:52:30.000Z</updated>
        <content type="html"><![CDATA[<p>Summary</p>
<p>The DNSSEC validation routines treat entire RRsets of DNSKEY records as trusted once they have established trust in only one of the DNSKEYs. As a result, if a zone includes a DNSKEY with a public key that matches a configured trust anchor, all keys in that zone will be trusted to authenticate other records in the zone. There is a second variant of this vulnerability involving DS records, where an authenticated DS record covering one DNSKEY leads to trust in signatures made by an unrelated DNSKEY in the same zone.</p>
<p>Details</p>
<p>verify_dnskey_rrset() will return Ok(true) if any record's public key matches a trust anchor. This results in verify_rrset() returning a Secure proof. This ultimately results in successfully verifying a response containing DNSKEY records. verify_default_rrset() looks up DNSKEY records by calling handle.lookup(), which takes the above code path. There's a comment following this that says "DNSKEYs were already validated by the inner query in the above lookup", but this is not the case. To fully verify the whole RRset of DNSKEYs, it would be necessary to check self-signatures by the trusted key over the other keys. Later in verify_default_rrset(), verify_rrset_with_dnskey() is called multiple times with different keys and signatures, and if any call succeeds, then its Proof is returned.</p>
<p>Similarly, verify_dnskey_rrset() returns Ok(false) if any DNSKEY record is covered by a DS record. A comment says "If all the keys are valid, then we are secure", but this is only checking that one key is authenticated by a DS in the parent zone's delegation point. This time, after control flow returns to verify_rrset(), it will call verify_default_rrset(). The special handling for DNSKEYs in verify_default_rrset() will then call verify_rrset_with_dnskey() using each KSK DNSKEY record, and if one call succeeds, return its Proof. If there are multiple KSK DNSKEYs in the RRset, then this leads to another authentication break. We need to either pass the authenticated DNSKEYs from the DS covering check to the RRSIG validation, or we need to perform this RRSIG validation of the DNSKEY RRset inside verify_dnskey_rrset() and cut verify_default_rrset() out of DNSKEY RRset validation entirely.</p>
<h3 id="references">References</h3>
<ul>
<li><a href="https://github.com/hickory-dns/hickory-dns/security/advisories/GHSA-37wc-h8xc-5hc4">https://github.com/hickory-dns/hickory-dns/security/advisories/GHSA-37wc-h8xc-5hc4</a></li>
<li><a href="https://rustsec.org/advisories/RUSTSEC-2025-0006.html">https://rustsec.org/advisories/RUSTSEC-2025-0006.html</a></li>
<li><a href="https://github.com/advisories/GHSA-v7pc-74h8-xq2h">https://github.com/advisories/GHSA-v7pc-74h8-xq2h</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-v7pc-74h8-xq2h</uri>
        </author>
        <category label="severity" term="MODERATE"/>
        <published>2025-02-10T21:52:28.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[[hickory-proto] Hickory DNS failure to verify self-signed RRSIG for DNSKEYs]]></title>
        <id>https://github.com/advisories/GHSA-v7pc-74h8-xq2h</id>
        <link href="https://github.com/advisories/GHSA-v7pc-74h8-xq2h"/>
        <updated>2025-02-10T21:52:30.000Z</updated>
        <content type="html"><![CDATA[<p>Summary</p>
<p>The DNSSEC validation routines treat entire RRsets of DNSKEY records as trusted once they have established trust in only one of the DNSKEYs. As a result, if a zone includes a DNSKEY with a public key that matches a configured trust anchor, all keys in that zone will be trusted to authenticate other records in the zone. There is a second variant of this vulnerability involving DS records, where an authenticated DS record covering one DNSKEY leads to trust in signatures made by an unrelated DNSKEY in the same zone.</p>
<p>Details</p>
<p>verify_dnskey_rrset() will return Ok(true) if any record's public key matches a trust anchor. This results in verify_rrset() returning a Secure proof. This ultimately results in successfully verifying a response containing DNSKEY records. verify_default_rrset() looks up DNSKEY records by calling handle.lookup(), which takes the above code path. There's a comment following this that says "DNSKEYs were already validated by the inner query in the above lookup", but this is not the case. To fully verify the whole RRset of DNSKEYs, it would be necessary to check self-signatures by the trusted key over the other keys. Later in verify_default_rrset(), verify_rrset_with_dnskey() is called multiple times with different keys and signatures, and if any call succeeds, then its Proof is returned.</p>
<p>Similarly, verify_dnskey_rrset() returns Ok(false) if any DNSKEY record is covered by a DS record. A comment says "If all the keys are valid, then we are secure", but this is only checking that one key is authenticated by a DS in the parent zone's delegation point. This time, after control flow returns to verify_rrset(), it will call verify_default_rrset(). The special handling for DNSKEYs in verify_default_rrset() will then call verify_rrset_with_dnskey() using each KSK DNSKEY record, and if one call succeeds, return its Proof. If there are multiple KSK DNSKEYs in the RRset, then this leads to another authentication break. We need to either pass the authenticated DNSKEYs from the DS covering check to the RRSIG validation, or we need to perform this RRSIG validation of the DNSKEY RRset inside verify_dnskey_rrset() and cut verify_default_rrset() out of DNSKEY RRset validation entirely.</p>
<h3 id="references">References</h3>
<ul>
<li><a href="https://github.com/hickory-dns/hickory-dns/security/advisories/GHSA-37wc-h8xc-5hc4">https://github.com/hickory-dns/hickory-dns/security/advisories/GHSA-37wc-h8xc-5hc4</a></li>
<li><a href="https://rustsec.org/advisories/RUSTSEC-2025-0006.html">https://rustsec.org/advisories/RUSTSEC-2025-0006.html</a></li>
<li><a href="https://github.com/advisories/GHSA-v7pc-74h8-xq2h">https://github.com/advisories/GHSA-v7pc-74h8-xq2h</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-v7pc-74h8-xq2h</uri>
        </author>
        <category label="severity" term="MODERATE"/>
        <published>2025-02-10T21:52:28.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[[activitypub_federation] Server-Side Request Forgery (SSRF) in activitypub_federation]]></title>
        <id>https://github.com/advisories/GHSA-7723-35v7-qcxw</id>
        <link href="https://github.com/advisories/GHSA-7723-35v7-qcxw"/>
        <updated>2025-02-11T00:33:49.000Z</updated>
        <content type="html"><![CDATA[<h3 id="summary">Summary</h3>
<p>This vulnerability allows a user to bypass any predefined hardcoded URL path or security anti-Localhost mechanism and perform an arbitrary GET request to any Host, Port and URL using a Webfinger Request.</p>
<h3 id="details">Details</h3>
<p>The Webfinger endpoint takes a remote domain for checking accounts as a feature, however, as per the ActivityPub spec (<a href="https://www.w3.org/TR/activitypub/#security-considerations">https://www.w3.org/TR/activitypub/#security-considerations</a>), on the security considerations section at B.3, access to Localhost services should be prevented while running in production.
The library attempts to prevent Localhost access using the following mechanism (/src/config.rs):</p>
<pre><code class="language-rust">pub(crate) async fn verify_url_valid(&amp;self, url: &amp;Url) -&gt; Result&lt;(), Error&gt; {
        match url.scheme() {
            "https" =&gt; {}
            "http" =&gt; {
                if !self.allow_http_urls {
                    return Err(Error::UrlVerificationError(
                        "Http urls are only allowed in debug mode",
                    ));
                }
            }
            _ =&gt; return Err(Error::UrlVerificationError("Invalid url scheme")),
        };

        // Urls which use our local domain are not a security risk, no further verification needed
        if self.is_local_url(url) {
            return Ok(());
        }

        if url.domain().is_none() {
            return Err(Error::UrlVerificationError("Url must have a domain"));
        }

        if url.domain() == Some("localhost") &amp;&amp; !self.debug {
            return Err(Error::UrlVerificationError(
                "Localhost is only allowed in debug mode",
            ));
        }

        self.url_verifier.verify(url).await?;

        Ok(())
    }
</code></pre>
<p>There are multiple issues with the current anti-Localhost implementation: </p>
<ol>
<li>It does not resolve the domain address supplied by the user.</li>
<li>The Localhost check is using only a simple comparison method while ignoring more complex malicious tampering attempts.</li>
<li>It filters only localhost domains, without any regard for alternative local IP domains or other sensitive domains, such internal network or cloud metadata domains.</li>
</ol>
<p>We can reach the verify_url_valid function while sending a Webfinger request to lookup a user’s account (/src/fetch/webfinger.rs):</p>
<pre><code class="language-rust">pub async fn webfinger_resolve_actor&lt;T: Clone, Kind&gt;(
    identifier: &amp;str,
    data: &amp;Data&lt;T&gt;,
) -&gt; Result&lt;Kind, &lt;Kind as Object&gt;::Error&gt;
where
    Kind: Object + Actor + Send + 'static + Object&lt;DataType = T&gt;,
    for&lt;'de2&gt; &lt;Kind as Object&gt;::Kind: serde::Deserialize&lt;'de2&gt;,
    &lt;Kind as Object&gt;::Error: From&lt;crate::error::Error&gt; + Send + Sync + Display,
{
    let (_, domain) = identifier
        .splitn(2, '@')
        .collect_tuple()
        .ok_or(WebFingerError::WrongFormat.into_crate_error())?;
    let protocol = if data.config.debug { "http" } else { "https" };
    let fetch_url =
        format!("{protocol}://{domain}/.well-known/webfinger?resource=acct:{identifier}");
    debug!("Fetching webfinger url: {}", &amp;fetch_url);

    let res: Webfinger = fetch_object_http_with_accept(
        &amp;Url::parse(&amp;fetch_url).map_err(Error::UrlParse)?,
        data,
        &amp;WEBFINGER_CONTENT_TYPE,
    )
    .await?
    .object;

    debug_assert_eq!(res.subject, format!("acct:{identifier}"));
    let links: Vec&lt;Url&gt; = res
        .links
        .iter()
        .filter(|link| {
            if let Some(type_) = &amp;link.kind {
                type_.starts_with("application/")
            } else {
                false
            }
        })
        .filter_map(|l| l.href.clone())
        .collect();

    for l in links {
        let object = ObjectId::&lt;Kind&gt;::from(l).dereference(data).await;
        match object {
            Ok(obj) =&gt; return Ok(obj),
            Err(error) =&gt; debug!(%error, "Failed to dereference link"),
        }
    }
    Err(WebFingerError::NoValidLink.into_crate_error().into())
}
</code></pre>
<p>The Webfinger logic takes the user account from the GET parameter “resource” and sinks the domain directly into the hardcoded Webfinger URL (“{protocol}://{domain}/.well-known/webfinger?resource=acct:{identifier}”) without any additional checks.
Afterwards the user domain input will pass into the “fetch_object_http_with_accept” function and finally into the security check on “verify_url_valid” function, again, without any form of sanitizing or input validation.
An adversary can cause unwanted behaviours using multiple techniques:</p>
<ol>
<li><p><strong><em>Gaining control over the query’s path:</em></strong>
An adversary can manipulate the Webfinger hard-coded URL, gaining full control over the GET request domain, path and port by submitting malicious input like: hacker@hacker_host:1337/hacker_path?hacker_param#, which in turn will result in the following string:
http[s]://hacker_host:1337/hacker_path?hacker_param#/.well-known/webfinger?resource=acct:{identifier}, directing the URL into another domain and path without any issues as the hash character renders the rest of the URL path unrecognized by the webserver.</p>
</li>
<li><p><strong><em>Bypassing the domain’s restriction using DNS resolving mechanism:</em></strong>
An adversary can manipulate the security check and force it to look for internal services regardless the Localhost check by using a domain name that resolves into a local IP (such as: localh.st, for example), as the security check does not verify the resolved IP at all - any service under the Localhost domain can be reached.</p>
</li>
<li><p><em><strong>Bypassing the domain’s restriction using official Fully Qualified Domain Names (FQDNs):</strong></em>
In the official DNS specifications, a fully qualified domain name actually should end with a dot.
While most of the time a domain name is presented without any trailing dot, the resolver will assume it exists, however - it is still possible to use a domain name with a trailing dot which will resolve correctly.
As the Localhost check is mainly a simple comparison check - if we register a “hacker@localhost.” domain it will pass the test as “localhost” is not equal to “localhost.”, however the domain will be valid (Using this mechanism it is also possible to bypass any domain blocklist mechanism).</p>
</li>
</ol>
<h3 id="poc">PoC</h3>
<ol>
<li>Activate a local HTTP server listening to port 1234 with a “secret.txt” file:
<code>python3 -m http.server 1234</code></li>
<li>Open the “main.rs” file inside the “example” folder on the activitypub-federated-rust project, and modify the “beta@localhost” string into “<a href="mailto:hacker@localh.st">hacker@localh.st</a>:1234/secret.txt?something=1#”.</li>
<li>Run the example using the following command:
<code>cargo run --example local_federation axum</code></li>
<li>View the console of the Python’s HTTP server and see that a request for a “secret.txt” file was performed.</li>
</ol>
<p>This proves that we can redirect the URL to any domain and path we choose.
Now on the next steps we will prove that the security checks of Localhost and blocked domains can be easily bypassed (both checks use the same comparison mechanism).</p>
<ol>
<li>Now open the “instance.rs” file inside the “example” folder and view that the domain “malicious.com” is blocked (you can switch it to any desired domain address).</li>
<li>Change the same “beta@localhost” string into “<a href="mailto:hacker@malicious.com">hacker@malicious.com</a>” and run the example command to see that the malicious domain blocking mechanism is working as expected.</li>
<li>Now change the “<a href="mailto:hacker@malicious.com">hacker@malicious.com</a>” string into  “<a href="mailto:hacker@malicious.com">hacker@malicious.com</a>.” string and re-initiate the example, view now that the check passed successfully.</li>
<li>You can combine both methods on “localhost.” domain (or any other domain) to verify that the FQDNs resolving is indeed successful.</li>
</ol>
<h3 id="impact">Impact</h3>
<p>Due to this issue, any user can cause the server to send GET requests with controlled path and port in an attempt to query services running on the instance’s host, and attempt to execute a Blind-SSRF gadget in hope of targeting a known vulnerable local service running on the victim’s machine.</p>
<h3 id="fix-suggestion">Fix Suggestion</h3>
<p>Modify the domain validation mechanism and implement the following checks:</p>
<ol>
<li>Resolve the domain and validate it is not using any invalid IP address (internal, or cloud metadata IPs) using regexes of both IPv4 and IPv6 addresses.
For Implementation example of a good SSRF prevention practice you can review a similiar project such as “Fedify” (<a href="https://github.com/dahlia/fedify/blob/main/src/runtime/url.ts">https://github.com/dahlia/fedify/blob/main/src/runtime/url.ts</a>) which handles external URL resource correctly.
Note that it is still needed to remove unwanted characters from the URL. </li>
<li>Filter the user’s input for any unwanted characters that should not be present on a domain name, such as #,?,/, etc.</li>
<li>Perform checks that make sure the desired request path is the executed path with the same port.</li>
<li>Disable automatic HTTP redirect follows on the implemented client, as redirects can be used for security mechanisms circumvention.</li>
</ol>
<h3 id="references">References</h3>
<ul>
<li><a href="https://github.com/LemmyNet/lemmy/security/advisories/GHSA-7723-35v7-qcxw">https://github.com/LemmyNet/lemmy/security/advisories/GHSA-7723-35v7-qcxw</a></li>
<li><a href="https://nvd.nist.gov/vuln/detail/CVE-2025-25194">https://nvd.nist.gov/vuln/detail/CVE-2025-25194</a></li>
<li><a href="https://github.com/advisories/GHSA-7723-35v7-qcxw">https://github.com/advisories/GHSA-7723-35v7-qcxw</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-7723-35v7-qcxw</uri>
        </author>
        <category label="severity" term="MODERATE"/>
        <published>2025-02-10T20:25:37.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[[grcov] grcov has an out of bounds write triggered by crafted coverage data]]></title>
        <id>https://github.com/advisories/GHSA-qm2p-4w45-v2vr</id>
        <link href="https://github.com/advisories/GHSA-qm2p-4w45-v2vr"/>
        <updated>2025-02-10T18:07:31.000Z</updated>
        <content type="html"><![CDATA[<p>Function <code>grcov::covdir::get_coverage</code> uses the <code>unsafe</code> function <code>get_unchecked_mut</code> without validating that the index is in bounds.</p>
<p>This results in memory corruption, and could potentially allow arbitrary code execution provided that an attacker can feed the tool crafted coverage data.</p>
<h3 id="references">References</h3>
<ul>
<li><a href="https://github.com/mozilla/grcov/commit/c8219563bc91615dd4a27884a5c63f09db8d03bb">https://github.com/mozilla/grcov/commit/c8219563bc91615dd4a27884a5c63f09db8d03bb</a></li>
<li><a href="https://bugzilla.mozilla.org/show_bug.cgi?id=1917475">https://bugzilla.mozilla.org/show_bug.cgi?id=1917475</a></li>
<li><a href="https://rustsec.org/advisories/RUSTSEC-2025-0005.html">https://rustsec.org/advisories/RUSTSEC-2025-0005.html</a></li>
<li><a href="https://github.com/advisories/GHSA-qm2p-4w45-v2vr">https://github.com/advisories/GHSA-qm2p-4w45-v2vr</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-qm2p-4w45-v2vr</uri>
        </author>
        <category label="severity" term="MODERATE"/>
        <published>2025-02-10T18:07:30.000Z</published>
    </entry>
</feed>