<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://azu.github.io/github-advisory-database-rss/rust.rss</id>
    <title>Security Advisory for Rust crates</title>
    <updated>2025-03-07T04:01:34.845Z</updated>
    <generator>github-advisory-database-rss</generator>
    <link rel="alternate" href="https://github.com/advisories?query=type%3Areviewed+ecosystem%3Arust"/>
    <subtitle>Security Advisory for Rust crates on GitHub</subtitle>
    <rights>github-advisory-database-rss</rights>
    <category term="CRITICAL"/>
    <category term="HIGH"/>
    <category term="MODERATE"/>
    <category term="LOW"/>
    <entry>
        <title type="html"><![CDATA[[ascon_aead] AEADs/ascon-aead: Plaintext exposed in decrypt_in_place_detached even on tag verification failure]]></title>
        <id>https://github.com/advisories/GHSA-r38m-44fw-h886</id>
        <link href="https://github.com/advisories/GHSA-r38m-44fw-h886"/>
        <updated>2025-03-03T20:22:20.000Z</updated>
        <content type="html"><![CDATA[<h3 id="summary">Summary</h3>
<p>In <code>decrypt_in_place_detached</code>, the decrypted ciphertext (which is the correct ciphertext) is exposed even if the tag is incorrect.</p>
<h3 id="details">Details</h3>
<p>This is because in <a href="https://github.com/RustCrypto/AEADs/blob/8cda109f1128c4c7953a0bb0f53e1056d537e462/ascon-aead/src/asconcore.rs#L350-L364">decrypt_inplace</a> in asconcore.rs, tag verification causes an error to be returned with the plaintext contents still in <code>buffer</code>. The root cause of this vulnerability is similar to <a href="https://github.com/RustCrypto/AEADs/security/advisories/GHSA-423w-p2w9-r7vq">https://github.com/RustCrypto/AEADs/security/advisories/GHSA-423w-p2w9-r7vq</a></p>
<h3 id="poc">PoC</h3>
<pre><code class="language-rust">use ascon_aead::Tag;
use ascon_aead::{Ascon128, Key, Nonce};
use ascon_aead::aead::{AeadInPlace, KeyInit};

fn main() {

    let key = Key::&lt;Ascon128&gt;::from_slice(b"very secret key.");
    let cipher = Ascon128::new(key);

    let nonce = Nonce::&lt;Ascon128&gt;::from_slice(b"unique nonce 012"); // 128-bits; unique per message

    let mut buffer: Vec&lt;u8&gt; = Vec::new(); // Buffer needs 16-bytes overhead for authentication tag
    buffer.extend_from_slice(b"plaintext message");

    // Encrypt `buffer` in-place detached, replacing the plaintext contents with ciphertext
    cipher.encrypt_in_place_detached(nonce, b"", &amp;mut buffer).expect("encryption failure!");
    
    // Decrypt `buffer` in-place with the wrong tag, ignoring the decryption error
    let _ = cipher.decrypt_in_place_detached(nonce, b"", &amp;mut buffer, Tag::&lt;Ascon128&gt;::from_slice(b"\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"));

    assert_eq!(&amp;buffer, b"plaintext message");
}
</code></pre>
<h3 id="impact">Impact</h3>
<p>If a program continues to use the result of <code>decrypt_in_place_detached</code> after a decryption failure, the result will be unauthenticated. This may permit some forms of chosen ciphertext attacks (CCAs).</p>
<h3 id="references">References</h3>
<ul>
<li><a href="https://github.com/RustCrypto/AEADs/security/advisories/GHSA-r38m-44fw-h886">https://github.com/RustCrypto/AEADs/security/advisories/GHSA-r38m-44fw-h886</a></li>
<li><a href="https://nvd.nist.gov/vuln/detail/CVE-2025-27498">https://nvd.nist.gov/vuln/detail/CVE-2025-27498</a></li>
<li><a href="https://github.com/RustCrypto/AEADs/commit/d1d749ba57e38e65b0e037cd744d0b17f7254037">https://github.com/RustCrypto/AEADs/commit/d1d749ba57e38e65b0e037cd744d0b17f7254037</a></li>
<li><a href="https://github.com/advisories/GHSA-r38m-44fw-h886">https://github.com/advisories/GHSA-r38m-44fw-h886</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-r38m-44fw-h886</uri>
        </author>
        <category label="severity" term="MODERATE"/>
        <published>2025-03-03T20:22:19.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[[ntpd] ntpd NTS client denial of service via wrongly sized cookies]]></title>
        <id>https://github.com/advisories/GHSA-v83q-83hj-rw38</id>
        <link href="https://github.com/advisories/GHSA-v83q-83hj-rw38"/>
        <updated>2025-02-28T17:46:37.000Z</updated>
        <content type="html"><![CDATA[<p>Two denial of service vulnerabilities were found in ntpd-rs related to the handling of NTS cookies in our client functionality. Whenever an NTS source is configured and the server behind that source is sending zero-sized cookies or cookies larger than what would fit in our buffer size, ntpd-rs would crash. Only configured NTS sources can abuse these vulnerabilities. NTP sources or third parties that are not configured cannot make use of these vulnerabilities.</p>
<p>For zero-sized cookies: a division by zero would force an exit when the number of new cookies that would need to be requested is calculated. In ntpd-rs 1.5.0 a check was added to prevent the division by zero.</p>
<p>For large cookies: while trying to send a NTP request with the cookie included, the buffer is too small to handle the cookie and an exit of ntpd-rs is forced once a write to the buffer is attempted. The memory outside the buffer would not be written to in this case. In ntpd-rs 1.5.0 a check was added that prevents accepting cookies larger than 350 bytes.</p>
<p>Users of older versions of ntpd-rs are recommended to update to the latest version. If an update is impossible, it is recommended to only add NTS sources to ntpd-rs that are trusted to not abuse this bug.</p>
<h3 id="references">References</h3>
<ul>
<li><a href="https://github.com/pendulum-project/ntpd-rs/security/advisories/GHSA-v83q-83hj-rw38">https://github.com/pendulum-project/ntpd-rs/security/advisories/GHSA-v83q-83hj-rw38</a></li>
<li><a href="https://github.com/pendulum-project/ntpd-rs/commit/10a103b471dae25ac598140df0c195b6531bf716">https://github.com/pendulum-project/ntpd-rs/commit/10a103b471dae25ac598140df0c195b6531bf716</a></li>
<li><a href="https://github.com/pendulum-project/ntpd-rs/commit/37dd8d9a0faa03e7dfe3a4bf64953010f075c3e2">https://github.com/pendulum-project/ntpd-rs/commit/37dd8d9a0faa03e7dfe3a4bf64953010f075c3e2</a></li>
<li><a href="https://github.com/advisories/GHSA-v83q-83hj-rw38">https://github.com/advisories/GHSA-v83q-83hj-rw38</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-v83q-83hj-rw38</uri>
        </author>
        <category label="severity" term="MODERATE"/>
        <published>2025-02-28T17:46:36.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[[openh264-sys2] OpenH264 Rust API Openh264 Decoding Functions Heap Overflow Vulnerability]]></title>
        <id>https://github.com/advisories/GHSA-5pmw-9j92-3c4c</id>
        <link href="https://github.com/advisories/GHSA-5pmw-9j92-3c4c"/>
        <updated>2025-02-24T18:27:26.000Z</updated>
        <content type="html"><![CDATA[<p>OpenH264 recently reported a <a href="https://github.com/cisco/openh264/security/advisories/GHSA-m99q-5j7x-7m9x">heap overflow</a> that was fixed in upstream <a href="https://github.com/cisco/openh264/commit/63db555e30986e3a5f07871368dc90ae78c27449">63db555</a> and <a href="https://github.com/ralfbiedert/openh264-rs/commit/3a822fff0b4c9a984622ca2b179fe8898ac54b14">integrated into</a> our 0.6.6 release. For users relying on Cisco's pre-compiled DLL, we also published 0.8.0, which is compatible with their latest fixed DLL version  2.6.0. </p>
<p>In other words:</p>
<ul>
<li>if you rely on our <code>source</code> feature only, &gt;=0.6.6 should be safe,</li>
<li>if you rely on <code>libloading</code>, you must upgrade to 0.8.0 <em>and</em> use their latest DLL &gt;=2.6.0.</li>
</ul>
<p>Users handling untrusted video files should update immediately.</p>
<h3 id="references">References</h3>
<ul>
<li><a href="https://nvd.nist.gov/vuln/detail/CVE-2025-27091">https://nvd.nist.gov/vuln/detail/CVE-2025-27091</a></li>
<li><a href="https://github.com/cisco/openh264/pull/3818">https://github.com/cisco/openh264/pull/3818</a></li>
<li><a href="https://github.com/ralfbiedert/openh264-rs/commit/3a822fff0b4c9a984622ca2b179fe8898ac54b14">https://github.com/ralfbiedert/openh264-rs/commit/3a822fff0b4c9a984622ca2b179fe8898ac54b14</a></li>
<li><a href="https://rustsec.org/advisories/RUSTSEC-2025-0008.html">https://rustsec.org/advisories/RUSTSEC-2025-0008.html</a></li>
<li><a href="https://github.com/advisories/GHSA-5pmw-9j92-3c4c">https://github.com/advisories/GHSA-5pmw-9j92-3c4c</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-5pmw-9j92-3c4c</uri>
        </author>
        <category label="severity" term="HIGH"/>
        <published>2025-02-24T18:27:25.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[[namada-apps] Namada-apps allows Excessive Computation in Mempool Validation]]></title>
        <id>https://github.com/advisories/GHSA-f8qm-hmm3-fv7f</id>
        <link href="https://github.com/advisories/GHSA-f8qm-hmm3-fv7f"/>
        <updated>2025-02-20T20:34:05.000Z</updated>
        <content type="html"><![CDATA[<h3 id="impact">Impact</h3>
<p>A malicious transaction may cause an expensive computation in mempool validation.</p>
<p>A transaction with multiple repeated sections causes the section hash calculation used for signature validation to grow exponentially (and potentially even cubic) in proportion to number of sections. This may be used to significantly slow down operation of nodes.</p>
<h3 id="patches">Patches</h3>
<p>This issue has been patched in apps version 1.1.0. The transaction sections are now being checked for uniqueness and the number of permitted sections contained in a single transaction has been limited to 10,000.</p>
<h3 id="workarounds">Workarounds</h3>
<p>There are no workarounds and users are advised to upgrade.</p>
<h3 id="references">References</h3>
<ul>
<li><a href="https://github.com/anoma/namada/security/advisories/GHSA-f8qm-hmm3-fv7f">https://github.com/anoma/namada/security/advisories/GHSA-f8qm-hmm3-fv7f</a></li>
<li><a href="https://github.com/advisories/GHSA-f8qm-hmm3-fv7f">https://github.com/advisories/GHSA-f8qm-hmm3-fv7f</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-f8qm-hmm3-fv7f</uri>
        </author>
        <category label="severity" term="CRITICAL"/>
        <published>2025-02-20T20:34:04.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[[namada-apps] Namada-apps can Crash with Excessive Computation in Mempool Validation]]></title>
        <id>https://github.com/advisories/GHSA-82vg-5v4f-f9wq</id>
        <link href="https://github.com/advisories/GHSA-82vg-5v4f-f9wq"/>
        <updated>2025-02-20T20:33:58.000Z</updated>
        <content type="html"><![CDATA[<h3 id="impact">Impact</h3>
<p>A malicious transaction may cause a crash in mempool validation.</p>
<p>A transaction with authorization section containing 256 public keys or more with valid matching signatures triggers an integer overflow in signature verification that causes a the node to panic.</p>
<h3 id="patches">Patches</h3>
<p>This issue has been patched in apps version 1.1.0. The mempool validation has been fixed to avoid overflow.</p>
<h3 id="workarounds">Workarounds</h3>
<p>There are no workarounds and users are advised to upgrade.</p>
<h3 id="references">References</h3>
<ul>
<li><a href="https://github.com/anoma/namada/security/advisories/GHSA-82vg-5v4f-f9wq">https://github.com/anoma/namada/security/advisories/GHSA-82vg-5v4f-f9wq</a></li>
<li><a href="https://github.com/advisories/GHSA-82vg-5v4f-f9wq">https://github.com/advisories/GHSA-82vg-5v4f-f9wq</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-82vg-5v4f-f9wq</uri>
        </author>
        <category label="severity" term="CRITICAL"/>
        <published>2025-02-20T20:33:56.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[[namada-apps] Namada-apps allows Post-Genesis Validator Bypass]]></title>
        <id>https://github.com/advisories/GHSA-2gw2-qgjg-xh6p</id>
        <link href="https://github.com/advisories/GHSA-2gw2-qgjg-xh6p"/>
        <updated>2025-02-20T20:24:20.000Z</updated>
        <content type="html"><![CDATA[<h3 id="impact">Impact</h3>
<p>Ledger crash. A user is able to initialize a post-genesis validator with a negative commission rate using the <code>--force</code> flag. If this validator gets into the consensus set, then when computing PoS inflation inside <code>fn update_rewards_products_and_mint_inflation</code>, an instance of <code>mul_floor</code> will cause the return of an <code>Err</code>, which causes <code>finalize_block</code> to error.</p>
<h3 id="patches">Patches</h3>
<p>This issue has been patched in apps version 1.1.0. The PoS validity predicate now enforces that the commission rate is not negative and any transaction that fails the check will be rejected, both for newly initialized validators and for commission rate change of an existing validator.</p>
<h3 id="workarounds">Workarounds</h3>
<p>There are no workarounds and users are advised to upgrade.</p>
<h3 id="references">References</h3>
<ul>
<li><a href="https://github.com/anoma/namada/security/advisories/GHSA-2gw2-qgjg-xh6p">https://github.com/anoma/namada/security/advisories/GHSA-2gw2-qgjg-xh6p</a></li>
<li><a href="https://github.com/advisories/GHSA-2gw2-qgjg-xh6p">https://github.com/advisories/GHSA-2gw2-qgjg-xh6p</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-2gw2-qgjg-xh6p</uri>
        </author>
        <category label="severity" term="CRITICAL"/>
        <published>2025-02-20T20:24:19.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[[fyrox-core] Fyrox has unsound usages of `Vec::from_raw_parts` ]]></title>
        <id>https://github.com/advisories/GHSA-h7h7-6mx3-r89v</id>
        <link href="https://github.com/advisories/GHSA-h7h7-6mx3-r89v"/>
        <updated>2025-02-14T17:31:17.000Z</updated>
        <content type="html"><![CDATA[<p>The library provides a public safe API <code>transmute_vec_as_bytes</code>, which incorrectly assumes that any generic type <code>T</code> could have stable layout, causing to uninitialized memory exposure if the users pass any types with padding bytes as <code>T</code> and cast it to <code>u8</code> pointer.  </p>
<p>In the <a href="https://github.com/FyroxEngine/Fyrox/issues/630">issue</a>, we develop a PoC to show passing struct type to <code>transmute_vec_as_bytes</code> could lead to undefined behavior with <code>Vec::from_raw_parts</code>.  </p>
<p>The developers provide a patch by changing trait of <code>Copy</code> to <code>Pod</code>, which can make sure <code>T</code> should be plain data. This was patched in the latest version of <a href="https://github.com/FyroxEngine/Fyrox/blob/3f9ad6f9667047dac051b0e97d544e5b38e5ae72/fyrox-core/src/lib.rs#L351-L360">master</a> branch, but still not on the latest release (0.28.1).</p>
<h3 id="references">References</h3>
<ul>
<li><a href="https://github.com/FyroxEngine/Fyrox/issues/630">https://github.com/FyroxEngine/Fyrox/issues/630</a></li>
<li><a href="https://github.com/FyroxEngine/Fyrox/pull/662">https://github.com/FyroxEngine/Fyrox/pull/662</a></li>
<li><a href="https://github.com/FyroxEngine/Fyrox/commit/474e3b01a884366cdb7d704f7456ef692e992232">https://github.com/FyroxEngine/Fyrox/commit/474e3b01a884366cdb7d704f7456ef692e992232</a></li>
<li><a href="https://rustsec.org/advisories/RUSTSEC-2024-0435.html">https://rustsec.org/advisories/RUSTSEC-2024-0435.html</a></li>
<li><a href="https://github.com/advisories/GHSA-h7h7-6mx3-r89v">https://github.com/advisories/GHSA-h7h7-6mx3-r89v</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-h7h7-6mx3-r89v</uri>
        </author>
        <category label="severity" term="LOW"/>
        <published>2025-02-14T17:31:16.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[[orml-rewards] Uncaught Panic in ORML Rewards Pallet]]></title>
        <id>https://github.com/advisories/GHSA-5v93-9mqw-p9mh</id>
        <link href="https://github.com/advisories/GHSA-5v93-9mqw-p9mh"/>
        <updated>2025-02-14T17:26:09.000Z</updated>
        <content type="html"><![CDATA[<h2 id="summary">Summary</h2>
<p>A vulnerability in the <code>add_share</code> function of the <strong>Rewards</strong> pallet (part of the ORML repository) can lead to an uncaught Rust panic when handling user-provided input exceeding the <code>u128</code> range.</p>
<h2 id="affected-components">Affected Components</h2>
<ul>
<li><strong>ORML Rewards</strong> pallet (<code>rewards/src/lib.rs</code>)</li>
<li>Any Substrate-based chain using ORML Rewards with <code>add_share</code> accepting unvalidated large <code>u128</code> inputs</li>
</ul>
<h2 id="technical-details">Technical Details</h2>
<ul>
<li><code>add_share</code> performs arithmetic on user-supplied values (<code>add_amount</code>) of type <code>T::Share</code> (mapped to <code>u128</code> in Acala).</li>
<li>If <code>add_amount</code> is large enough (e.g., <code>i128::MAX</code>), the intermediate result may overflow and panic on the cast to <code>u128</code>.</li>
<li>Validation occurs only after arithmetic, enabling a crafted input to trigger an overflow.</li>
</ul>
<h2 id="impact">Impact</h2>
<p>A malicious user submitting a specially crafted extrinsic can cause a panic in the runtime:</p>
<ul>
<li><strong>Denial of Service</strong> by crashing the node process.</li>
<li><strong>Potential for invalid blocks</strong> produced by validators.</li>
</ul>
<h2 id="likelihood">Likelihood</h2>
<p>This issue is exploitable in production if there exists at least one rewards pool where reward tokens exceed twice the collateral tokens, allowing sufficiently large multiplication to exceed <code>u128</code> bounds.</p>
<h2 id="remediation">Remediation</h2>
<ul>
<li>This issue is fixed in <a href="https://github.com/open-web3-stack/open-runtime-module-library/pull/1016">https://github.com/open-web3-stack/open-runtime-module-library/pull/1016</a></li>
</ul>
<h2 id="backport">Backport</h2>
<p>The patch have been backported to following release branches:</p>
<ul>
<li>polkadot-stable2407</li>
<li>polkadot-stable2409</li>
</ul>
<p>A 1.0.1 patch release is made with this fix.</p>
<h3 id="references">References</h3>
<ul>
<li><a href="https://github.com/open-web3-stack/open-runtime-module-library/security/advisories/GHSA-5v93-9mqw-p9mh">https://github.com/open-web3-stack/open-runtime-module-library/security/advisories/GHSA-5v93-9mqw-p9mh</a></li>
<li><a href="https://github.com/open-web3-stack/open-runtime-module-library/pull/1016">https://github.com/open-web3-stack/open-runtime-module-library/pull/1016</a></li>
<li><a href="https://github.com/open-web3-stack/open-runtime-module-library/commit/6720fcd92f44e5f204741b04fdef3b67b0fcf6bc">https://github.com/open-web3-stack/open-runtime-module-library/commit/6720fcd92f44e5f204741b04fdef3b67b0fcf6bc</a></li>
<li><a href="https://github.com/advisories/GHSA-5v93-9mqw-p9mh">https://github.com/advisories/GHSA-5v93-9mqw-p9mh</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-5v93-9mqw-p9mh</uri>
        </author>
        <category label="severity" term="HIGH"/>
        <published>2025-02-14T17:26:08.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[[hickory-proto] Hickory DNS failure to verify self-signed RRSIG for DNSKEYs]]></title>
        <id>https://github.com/advisories/GHSA-v7pc-74h8-xq2h</id>
        <link href="https://github.com/advisories/GHSA-v7pc-74h8-xq2h"/>
        <updated>2025-02-10T21:52:30.000Z</updated>
        <content type="html"><![CDATA[<p>Summary</p>
<p>The DNSSEC validation routines treat entire RRsets of DNSKEY records as trusted once they have established trust in only one of the DNSKEYs. As a result, if a zone includes a DNSKEY with a public key that matches a configured trust anchor, all keys in that zone will be trusted to authenticate other records in the zone. There is a second variant of this vulnerability involving DS records, where an authenticated DS record covering one DNSKEY leads to trust in signatures made by an unrelated DNSKEY in the same zone.</p>
<p>Details</p>
<p>verify_dnskey_rrset() will return Ok(true) if any record's public key matches a trust anchor. This results in verify_rrset() returning a Secure proof. This ultimately results in successfully verifying a response containing DNSKEY records. verify_default_rrset() looks up DNSKEY records by calling handle.lookup(), which takes the above code path. There's a comment following this that says "DNSKEYs were already validated by the inner query in the above lookup", but this is not the case. To fully verify the whole RRset of DNSKEYs, it would be necessary to check self-signatures by the trusted key over the other keys. Later in verify_default_rrset(), verify_rrset_with_dnskey() is called multiple times with different keys and signatures, and if any call succeeds, then its Proof is returned.</p>
<p>Similarly, verify_dnskey_rrset() returns Ok(false) if any DNSKEY record is covered by a DS record. A comment says "If all the keys are valid, then we are secure", but this is only checking that one key is authenticated by a DS in the parent zone's delegation point. This time, after control flow returns to verify_rrset(), it will call verify_default_rrset(). The special handling for DNSKEYs in verify_default_rrset() will then call verify_rrset_with_dnskey() using each KSK DNSKEY record, and if one call succeeds, return its Proof. If there are multiple KSK DNSKEYs in the RRset, then this leads to another authentication break. We need to either pass the authenticated DNSKEYs from the DS covering check to the RRSIG validation, or we need to perform this RRSIG validation of the DNSKEY RRset inside verify_dnskey_rrset() and cut verify_default_rrset() out of DNSKEY RRset validation entirely.</p>
<h3 id="references">References</h3>
<ul>
<li><a href="https://github.com/hickory-dns/hickory-dns/security/advisories/GHSA-37wc-h8xc-5hc4">https://github.com/hickory-dns/hickory-dns/security/advisories/GHSA-37wc-h8xc-5hc4</a></li>
<li><a href="https://rustsec.org/advisories/RUSTSEC-2025-0006.html">https://rustsec.org/advisories/RUSTSEC-2025-0006.html</a></li>
<li><a href="https://github.com/advisories/GHSA-v7pc-74h8-xq2h">https://github.com/advisories/GHSA-v7pc-74h8-xq2h</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-v7pc-74h8-xq2h</uri>
        </author>
        <category label="severity" term="MODERATE"/>
        <published>2025-02-10T21:52:28.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[[hickory-proto] Hickory DNS failure to verify self-signed RRSIG for DNSKEYs]]></title>
        <id>https://github.com/advisories/GHSA-v7pc-74h8-xq2h</id>
        <link href="https://github.com/advisories/GHSA-v7pc-74h8-xq2h"/>
        <updated>2025-02-10T21:52:30.000Z</updated>
        <content type="html"><![CDATA[<p>Summary</p>
<p>The DNSSEC validation routines treat entire RRsets of DNSKEY records as trusted once they have established trust in only one of the DNSKEYs. As a result, if a zone includes a DNSKEY with a public key that matches a configured trust anchor, all keys in that zone will be trusted to authenticate other records in the zone. There is a second variant of this vulnerability involving DS records, where an authenticated DS record covering one DNSKEY leads to trust in signatures made by an unrelated DNSKEY in the same zone.</p>
<p>Details</p>
<p>verify_dnskey_rrset() will return Ok(true) if any record's public key matches a trust anchor. This results in verify_rrset() returning a Secure proof. This ultimately results in successfully verifying a response containing DNSKEY records. verify_default_rrset() looks up DNSKEY records by calling handle.lookup(), which takes the above code path. There's a comment following this that says "DNSKEYs were already validated by the inner query in the above lookup", but this is not the case. To fully verify the whole RRset of DNSKEYs, it would be necessary to check self-signatures by the trusted key over the other keys. Later in verify_default_rrset(), verify_rrset_with_dnskey() is called multiple times with different keys and signatures, and if any call succeeds, then its Proof is returned.</p>
<p>Similarly, verify_dnskey_rrset() returns Ok(false) if any DNSKEY record is covered by a DS record. A comment says "If all the keys are valid, then we are secure", but this is only checking that one key is authenticated by a DS in the parent zone's delegation point. This time, after control flow returns to verify_rrset(), it will call verify_default_rrset(). The special handling for DNSKEYs in verify_default_rrset() will then call verify_rrset_with_dnskey() using each KSK DNSKEY record, and if one call succeeds, return its Proof. If there are multiple KSK DNSKEYs in the RRset, then this leads to another authentication break. We need to either pass the authenticated DNSKEYs from the DS covering check to the RRSIG validation, or we need to perform this RRSIG validation of the DNSKEY RRset inside verify_dnskey_rrset() and cut verify_default_rrset() out of DNSKEY RRset validation entirely.</p>
<h3 id="references">References</h3>
<ul>
<li><a href="https://github.com/hickory-dns/hickory-dns/security/advisories/GHSA-37wc-h8xc-5hc4">https://github.com/hickory-dns/hickory-dns/security/advisories/GHSA-37wc-h8xc-5hc4</a></li>
<li><a href="https://rustsec.org/advisories/RUSTSEC-2025-0006.html">https://rustsec.org/advisories/RUSTSEC-2025-0006.html</a></li>
<li><a href="https://github.com/advisories/GHSA-v7pc-74h8-xq2h">https://github.com/advisories/GHSA-v7pc-74h8-xq2h</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-v7pc-74h8-xq2h</uri>
        </author>
        <category label="severity" term="MODERATE"/>
        <published>2025-02-10T21:52:28.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[[activitypub_federation] Server-Side Request Forgery (SSRF) in activitypub_federation]]></title>
        <id>https://github.com/advisories/GHSA-7723-35v7-qcxw</id>
        <link href="https://github.com/advisories/GHSA-7723-35v7-qcxw"/>
        <updated>2025-02-11T00:33:49.000Z</updated>
        <content type="html"><![CDATA[<h3 id="summary">Summary</h3>
<p>This vulnerability allows a user to bypass any predefined hardcoded URL path or security anti-Localhost mechanism and perform an arbitrary GET request to any Host, Port and URL using a Webfinger Request.</p>
<h3 id="details">Details</h3>
<p>The Webfinger endpoint takes a remote domain for checking accounts as a feature, however, as per the ActivityPub spec (<a href="https://www.w3.org/TR/activitypub/#security-considerations">https://www.w3.org/TR/activitypub/#security-considerations</a>), on the security considerations section at B.3, access to Localhost services should be prevented while running in production.
The library attempts to prevent Localhost access using the following mechanism (/src/config.rs):</p>
<pre><code class="language-rust">pub(crate) async fn verify_url_valid(&amp;self, url: &amp;Url) -&gt; Result&lt;(), Error&gt; {
        match url.scheme() {
            "https" =&gt; {}
            "http" =&gt; {
                if !self.allow_http_urls {
                    return Err(Error::UrlVerificationError(
                        "Http urls are only allowed in debug mode",
                    ));
                }
            }
            _ =&gt; return Err(Error::UrlVerificationError("Invalid url scheme")),
        };

        // Urls which use our local domain are not a security risk, no further verification needed
        if self.is_local_url(url) {
            return Ok(());
        }

        if url.domain().is_none() {
            return Err(Error::UrlVerificationError("Url must have a domain"));
        }

        if url.domain() == Some("localhost") &amp;&amp; !self.debug {
            return Err(Error::UrlVerificationError(
                "Localhost is only allowed in debug mode",
            ));
        }

        self.url_verifier.verify(url).await?;

        Ok(())
    }
</code></pre>
<p>There are multiple issues with the current anti-Localhost implementation: </p>
<ol>
<li>It does not resolve the domain address supplied by the user.</li>
<li>The Localhost check is using only a simple comparison method while ignoring more complex malicious tampering attempts.</li>
<li>It filters only localhost domains, without any regard for alternative local IP domains or other sensitive domains, such internal network or cloud metadata domains.</li>
</ol>
<p>We can reach the verify_url_valid function while sending a Webfinger request to lookup a user’s account (/src/fetch/webfinger.rs):</p>
<pre><code class="language-rust">pub async fn webfinger_resolve_actor&lt;T: Clone, Kind&gt;(
    identifier: &amp;str,
    data: &amp;Data&lt;T&gt;,
) -&gt; Result&lt;Kind, &lt;Kind as Object&gt;::Error&gt;
where
    Kind: Object + Actor + Send + 'static + Object&lt;DataType = T&gt;,
    for&lt;'de2&gt; &lt;Kind as Object&gt;::Kind: serde::Deserialize&lt;'de2&gt;,
    &lt;Kind as Object&gt;::Error: From&lt;crate::error::Error&gt; + Send + Sync + Display,
{
    let (_, domain) = identifier
        .splitn(2, '@')
        .collect_tuple()
        .ok_or(WebFingerError::WrongFormat.into_crate_error())?;
    let protocol = if data.config.debug { "http" } else { "https" };
    let fetch_url =
        format!("{protocol}://{domain}/.well-known/webfinger?resource=acct:{identifier}");
    debug!("Fetching webfinger url: {}", &amp;fetch_url);

    let res: Webfinger = fetch_object_http_with_accept(
        &amp;Url::parse(&amp;fetch_url).map_err(Error::UrlParse)?,
        data,
        &amp;WEBFINGER_CONTENT_TYPE,
    )
    .await?
    .object;

    debug_assert_eq!(res.subject, format!("acct:{identifier}"));
    let links: Vec&lt;Url&gt; = res
        .links
        .iter()
        .filter(|link| {
            if let Some(type_) = &amp;link.kind {
                type_.starts_with("application/")
            } else {
                false
            }
        })
        .filter_map(|l| l.href.clone())
        .collect();

    for l in links {
        let object = ObjectId::&lt;Kind&gt;::from(l).dereference(data).await;
        match object {
            Ok(obj) =&gt; return Ok(obj),
            Err(error) =&gt; debug!(%error, "Failed to dereference link"),
        }
    }
    Err(WebFingerError::NoValidLink.into_crate_error().into())
}
</code></pre>
<p>The Webfinger logic takes the user account from the GET parameter “resource” and sinks the domain directly into the hardcoded Webfinger URL (“{protocol}://{domain}/.well-known/webfinger?resource=acct:{identifier}”) without any additional checks.
Afterwards the user domain input will pass into the “fetch_object_http_with_accept” function and finally into the security check on “verify_url_valid” function, again, without any form of sanitizing or input validation.
An adversary can cause unwanted behaviours using multiple techniques:</p>
<ol>
<li><p><strong><em>Gaining control over the query’s path:</em></strong>
An adversary can manipulate the Webfinger hard-coded URL, gaining full control over the GET request domain, path and port by submitting malicious input like: hacker@hacker_host:1337/hacker_path?hacker_param#, which in turn will result in the following string:
http[s]://hacker_host:1337/hacker_path?hacker_param#/.well-known/webfinger?resource=acct:{identifier}, directing the URL into another domain and path without any issues as the hash character renders the rest of the URL path unrecognized by the webserver.</p>
</li>
<li><p><strong><em>Bypassing the domain’s restriction using DNS resolving mechanism:</em></strong>
An adversary can manipulate the security check and force it to look for internal services regardless the Localhost check by using a domain name that resolves into a local IP (such as: localh.st, for example), as the security check does not verify the resolved IP at all - any service under the Localhost domain can be reached.</p>
</li>
<li><p><em><strong>Bypassing the domain’s restriction using official Fully Qualified Domain Names (FQDNs):</strong></em>
In the official DNS specifications, a fully qualified domain name actually should end with a dot.
While most of the time a domain name is presented without any trailing dot, the resolver will assume it exists, however - it is still possible to use a domain name with a trailing dot which will resolve correctly.
As the Localhost check is mainly a simple comparison check - if we register a “hacker@localhost.” domain it will pass the test as “localhost” is not equal to “localhost.”, however the domain will be valid (Using this mechanism it is also possible to bypass any domain blocklist mechanism).</p>
</li>
</ol>
<h3 id="poc">PoC</h3>
<ol>
<li>Activate a local HTTP server listening to port 1234 with a “secret.txt” file:
<code>python3 -m http.server 1234</code></li>
<li>Open the “main.rs” file inside the “example” folder on the activitypub-federated-rust project, and modify the “beta@localhost” string into “<a href="mailto:hacker@localh.st">hacker@localh.st</a>:1234/secret.txt?something=1#”.</li>
<li>Run the example using the following command:
<code>cargo run --example local_federation axum</code></li>
<li>View the console of the Python’s HTTP server and see that a request for a “secret.txt” file was performed.</li>
</ol>
<p>This proves that we can redirect the URL to any domain and path we choose.
Now on the next steps we will prove that the security checks of Localhost and blocked domains can be easily bypassed (both checks use the same comparison mechanism).</p>
<ol>
<li>Now open the “instance.rs” file inside the “example” folder and view that the domain “malicious.com” is blocked (you can switch it to any desired domain address).</li>
<li>Change the same “beta@localhost” string into “<a href="mailto:hacker@malicious.com">hacker@malicious.com</a>” and run the example command to see that the malicious domain blocking mechanism is working as expected.</li>
<li>Now change the “<a href="mailto:hacker@malicious.com">hacker@malicious.com</a>” string into  “<a href="mailto:hacker@malicious.com">hacker@malicious.com</a>.” string and re-initiate the example, view now that the check passed successfully.</li>
<li>You can combine both methods on “localhost.” domain (or any other domain) to verify that the FQDNs resolving is indeed successful.</li>
</ol>
<h3 id="impact">Impact</h3>
<p>Due to this issue, any user can cause the server to send GET requests with controlled path and port in an attempt to query services running on the instance’s host, and attempt to execute a Blind-SSRF gadget in hope of targeting a known vulnerable local service running on the victim’s machine.</p>
<h3 id="fix-suggestion">Fix Suggestion</h3>
<p>Modify the domain validation mechanism and implement the following checks:</p>
<ol>
<li>Resolve the domain and validate it is not using any invalid IP address (internal, or cloud metadata IPs) using regexes of both IPv4 and IPv6 addresses.
For Implementation example of a good SSRF prevention practice you can review a similiar project such as “Fedify” (<a href="https://github.com/dahlia/fedify/blob/main/src/runtime/url.ts">https://github.com/dahlia/fedify/blob/main/src/runtime/url.ts</a>) which handles external URL resource correctly.
Note that it is still needed to remove unwanted characters from the URL. </li>
<li>Filter the user’s input for any unwanted characters that should not be present on a domain name, such as #,?,/, etc.</li>
<li>Perform checks that make sure the desired request path is the executed path with the same port.</li>
<li>Disable automatic HTTP redirect follows on the implemented client, as redirects can be used for security mechanisms circumvention.</li>
</ol>
<h3 id="references">References</h3>
<ul>
<li><a href="https://github.com/LemmyNet/lemmy/security/advisories/GHSA-7723-35v7-qcxw">https://github.com/LemmyNet/lemmy/security/advisories/GHSA-7723-35v7-qcxw</a></li>
<li><a href="https://nvd.nist.gov/vuln/detail/CVE-2025-25194">https://nvd.nist.gov/vuln/detail/CVE-2025-25194</a></li>
<li><a href="https://github.com/advisories/GHSA-7723-35v7-qcxw">https://github.com/advisories/GHSA-7723-35v7-qcxw</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-7723-35v7-qcxw</uri>
        </author>
        <category label="severity" term="MODERATE"/>
        <published>2025-02-10T20:25:37.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[[grcov] grcov has an out of bounds write triggered by crafted coverage data]]></title>
        <id>https://github.com/advisories/GHSA-qm2p-4w45-v2vr</id>
        <link href="https://github.com/advisories/GHSA-qm2p-4w45-v2vr"/>
        <updated>2025-02-10T18:07:31.000Z</updated>
        <content type="html"><![CDATA[<p>Function <code>grcov::covdir::get_coverage</code> uses the <code>unsafe</code> function <code>get_unchecked_mut</code> without validating that the index is in bounds.</p>
<p>This results in memory corruption, and could potentially allow arbitrary code execution provided that an attacker can feed the tool crafted coverage data.</p>
<h3 id="references">References</h3>
<ul>
<li><a href="https://github.com/mozilla/grcov/commit/c8219563bc91615dd4a27884a5c63f09db8d03bb">https://github.com/mozilla/grcov/commit/c8219563bc91615dd4a27884a5c63f09db8d03bb</a></li>
<li><a href="https://bugzilla.mozilla.org/show_bug.cgi?id=1917475">https://bugzilla.mozilla.org/show_bug.cgi?id=1917475</a></li>
<li><a href="https://rustsec.org/advisories/RUSTSEC-2025-0005.html">https://rustsec.org/advisories/RUSTSEC-2025-0005.html</a></li>
<li><a href="https://github.com/advisories/GHSA-qm2p-4w45-v2vr">https://github.com/advisories/GHSA-qm2p-4w45-v2vr</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-qm2p-4w45-v2vr</uri>
        </author>
        <category label="severity" term="MODERATE"/>
        <published>2025-02-10T18:07:30.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[[hickory-proto] Hickory DNS's DNSSEC validation may accept broken authentication chains]]></title>
        <id>https://github.com/advisories/GHSA-37wc-h8xc-5hc4</id>
        <link href="https://github.com/advisories/GHSA-37wc-h8xc-5hc4"/>
        <updated>2025-02-10T19:51:26.000Z</updated>
        <content type="html"><![CDATA[<h3 id="summary">Summary</h3>
<p>The DNSSEC validation routines treat entire RRsets of DNSKEY records as trusted once they have established trust in only one of the DNSKEYs. As a result, if a zone includes a DNSKEY with a public key that matches a configured trust anchor, all keys in that zone will be trusted to authenticate other records in the zone. There is a second variant of this vulnerability involving DS records, where an authenticated DS record covering one DNSKEY leads to trust in signatures made by an unrelated DNSKEY in the same zone.</p>
<h3 id="details">Details</h3>
<p><code>verify_dnskey_rrset()</code> will return <code>Ok(true)</code> if any record's public key matches a trust anchor. This results in <code>verify_rrset()</code> returning a <code>Secure</code> proof. This ultimately results in successfully verifying a response containing DNSKEY records. <code>verify_default_rrset()</code> looks up DNSKEY records by calling <code>handle.lookup()</code>, which takes the above code path. There's a comment following this that says "DNSKEYs were already validated by the inner query in the above lookup", but this is not the case. To fully verify the whole RRset of DNSKEYs, it would be necessary to check self-signatures by the trusted key over the other keys. Later in <code>verify_default_rrset()</code>, <code>verify_rrset_with_dnskey()</code> is called multiple times with different keys and signatures, and if any call succeeds, then its <code>Proof</code> is returned.</p>
<p>Similarly, <code>verify_dnskey_rrset()</code> returns <code>Ok(false)</code> if any DNSKEY record is covered by a DS record. A comment says "If all the keys are valid, then we are secure", but this is only checking that one key is authenticated by a DS in the parent zone's delegation point. This time, after control flow returns to <code>verify_rrset()</code>, it will call <code>verify_default_rrset()</code>. The special handling for DNSKEYs in <code>verify_default_rrset()</code> will then call <code>verify_rrset_with_dnskey()</code> using each KSK DNSKEY record, and if one call succeeds, return its <code>Proof</code>. If there are multiple KSK DNSKEYs in the RRset, then this leads to another authentication break. We need to either pass the authenticated DNSKEYs from the DS covering check to the RRSIG validation, or we need to perform this RRSIG validation of the DNSKEY RRset inside <code>verify_dnskey_rrset()</code> and cut <code>verify_default_rrset()</code> out of DNSKEY RRset validation entirely.</p>
<h3 id="poc">PoC</h3>
<p>The proof of concepts have been integrated into the conformance test suite, as <code>resolver::dnssec::scenarios::bogus::bogus_zone_plus_trust_anchor_dnskey</code> and <code>resolver::dnssec::scenarios::bogus::bogus_zone_plus_ds_covered_dnskey</code>.</p>
<h3 id="impact">Impact</h3>
<p>This impacts Hickory DNS users relying on DNSSEC verification in the client library, stub resolver, or recursive resolver.</p>
<h3 id="references">References</h3>
<ul>
<li><a href="https://github.com/hickory-dns/hickory-dns/security/advisories/GHSA-37wc-h8xc-5hc4">https://github.com/hickory-dns/hickory-dns/security/advisories/GHSA-37wc-h8xc-5hc4</a></li>
<li><a href="https://nvd.nist.gov/vuln/detail/CVE-2025-25188">https://nvd.nist.gov/vuln/detail/CVE-2025-25188</a></li>
<li><a href="https://github.com/hickory-dns/hickory-dns/commit/e118c6eec569f4340421f86ee0686714010c63e9">https://github.com/hickory-dns/hickory-dns/commit/e118c6eec569f4340421f86ee0686714010c63e9</a></li>
<li><a href="https://github.com/advisories/GHSA-37wc-h8xc-5hc4">https://github.com/advisories/GHSA-37wc-h8xc-5hc4</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-37wc-h8xc-5hc4</uri>
        </author>
        <category label="severity" term="MODERATE"/>
        <published>2025-02-10T17:46:00.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[[cosmwasm-vm] wasmvm: Malicious smart contract can slow down block production]]></title>
        <id>https://github.com/advisories/GHSA-mx2j-7cmv-353c</id>
        <link href="https://github.com/advisories/GHSA-mx2j-7cmv-353c"/>
        <updated>2025-02-06T18:03:26.000Z</updated>
        <content type="html"><![CDATA[<h1 id="cwa-2025-002">CWA-2025-002</h1>
<p><strong>Severity</strong></p>
<p>Medium (Moderate + Likely)[^1]</p>
<p><strong>Affected versions:</strong></p>
<ul>
<li>wasmvm &gt;= 2.2.0, &lt; 2.2.2</li>
<li>wasmvm &gt;= 2.1.0, &lt; 2.1.5</li>
<li>wasmvm &gt;= 2.0.0, &lt; 2.0.6</li>
<li>wasmvm &lt; 1.5.8</li>
</ul>
<p><strong>Patched versions:</strong></p>
<ul>
<li>wasmvm 1.5.8, 2.0.6, 2.1.5, 2.2.2</li>
</ul>
<h2 id="description-of-the-bug">Description of the bug</h2>
<p>The vulnerability can be used to slow down block production. The attack requires a malicious contract,
so permissioned chains are unlikely to be affected.</p>
<p>(We'll add more detail once chains had a chance to upgrade.)</p>
<h2 id="patch">Patch</h2>
<ul>
<li>1.5: <a href="https://github.com/CosmWasm/cosmwasm/commit/2b7f2faa57a1efc8207455c37f87f1eee6035a27">https://github.com/CosmWasm/cosmwasm/commit/2b7f2faa57a1efc8207455c37f87f1eee6035a27</a></li>
<li>2.0: <a href="https://github.com/CosmWasm/cosmwasm/commit/d6143b0aff16a39bbea4be37597d8e9d9b213d3b">https://github.com/CosmWasm/cosmwasm/commit/d6143b0aff16a39bbea4be37597d8e9d9b213d3b</a></li>
<li>2.1: <a href="https://github.com/CosmWasm/cosmwasm/commit/f0c04c03cbe2557634c1bbcdc2ce203fe7caca58">https://github.com/CosmWasm/cosmwasm/commit/f0c04c03cbe2557634c1bbcdc2ce203fe7caca58</a></li>
<li>2.2: <a href="https://github.com/CosmWasm/cosmwasm/commit/a5d62f65b5eb947ebe40e2085b1c48a9d0a244d0">https://github.com/CosmWasm/cosmwasm/commit/a5d62f65b5eb947ebe40e2085b1c48a9d0a244d0</a></li>
</ul>
<h2 id="applying-the-patch">Applying the patch</h2>
<p>The patch will be shipped in releases of wasmvm. You can update more or less as follows:</p>
<ol>
<li>Check the current wasmvm version: <code>go list -m github.com/CosmWasm/wasmvm</code></li>
<li>Bump the <code>github.com/CosmWasm/wasmvm</code> dependency in your go.mod to one of the patched version
depending on which minor version you are on; <code>go mod tidy</code>; commit.</li>
<li>If you use the static libraries <code>libwasmvm_muslc.aarch64.a</code>/<code>libwasmvm_muslc.x86_64.a</code>, update them accordingly.</li>
<li>Check the updated wasmvm version: <code>go list -m github.com/CosmWasm/wasmvm</code> and ensure you see 1.5.8, 2.0.6, 2.1.5 or 2.2.2.</li>
<li>Follow your regular practices to deploy chain upgrades.</li>
</ol>
<p>The patch is consensus breaking and requires a coordinated upgrade.</p>
<h2 id="acknowledgement">Acknowledgement</h2>
<p>This issue was found by meadow101 who reported it to the Cosmos Bug Bounty Program on HackerOne.</p>
<p>If you believe you have found a bug in the Interchain Stack or would like to contribute to the
program by reporting a bug, please see <a href="https://hackerone.com/cosmos">https://hackerone.com/cosmos</a>.</p>
<h2 id="timeline">Timeline</h2>
<ul>
<li>2024-11-24: Confio receives a report through the Cosmos bug bounty program maintained by Amulet.</li>
<li>2024-12-20: Confio security contributors confirm the report.</li>
<li>2024-01-27: Confio developed the patch internally.</li>
<li>2025-02-04: Patch gets released.</li>
</ul>
<p>[^1]: following Amulet's Severity Classification Framework ACMv1.2: <a href="https://github.com/interchainio/security/blob/0295254e8645301ccb606d46108a45cede0a73e0/resources/CLASSIFICATION_MATRIX.md">https://github.com/interchainio/security/blob/0295254e8645301ccb606d46108a45cede0a73e0/resources/CLASSIFICATION_MATRIX.md</a></p>
<h3 id="references">References</h3>
<ul>
<li><a href="https://github.com/CosmWasm/wasmvm/security/advisories/GHSA-mx2j-7cmv-353c">https://github.com/CosmWasm/wasmvm/security/advisories/GHSA-mx2j-7cmv-353c</a></li>
<li><a href="https://github.com/CosmWasm/cosmwasm/commit/2b7f2faa57a1efc8207455c37f87f1eee6035a27">https://github.com/CosmWasm/cosmwasm/commit/2b7f2faa57a1efc8207455c37f87f1eee6035a27</a></li>
<li><a href="https://github.com/CosmWasm/cosmwasm/commit/a5d62f65b5eb947ebe40e2085b1c48a9d0a244d0">https://github.com/CosmWasm/cosmwasm/commit/a5d62f65b5eb947ebe40e2085b1c48a9d0a244d0</a></li>
<li><a href="https://github.com/CosmWasm/cosmwasm/commit/d6143b0aff16a39bbea4be37597d8e9d9b213d3b">https://github.com/CosmWasm/cosmwasm/commit/d6143b0aff16a39bbea4be37597d8e9d9b213d3b</a></li>
<li><a href="https://github.com/CosmWasm/cosmwasm/commit/f0c04c03cbe2557634c1bbcdc2ce203fe7caca58">https://github.com/CosmWasm/cosmwasm/commit/f0c04c03cbe2557634c1bbcdc2ce203fe7caca58</a></li>
<li><a href="https://github.com/CosmWasm/advisories/blob/main/CWAs/CWA-2025-002.md">https://github.com/CosmWasm/advisories/blob/main/CWAs/CWA-2025-002.md</a></li>
<li><a href="https://pkg.go.dev/vuln/GO-2025-3449">https://pkg.go.dev/vuln/GO-2025-3449</a></li>
<li><a href="https://github.com/advisories/GHSA-mx2j-7cmv-353c">https://github.com/advisories/GHSA-mx2j-7cmv-353c</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-mx2j-7cmv-353c</uri>
        </author>
        <category label="severity" term="MODERATE"/>
        <published>2025-02-04T18:57:21.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[[cosmwasm-vm] wasmvm: Malicious smart contract can slow down block production]]></title>
        <id>https://github.com/advisories/GHSA-mx2j-7cmv-353c</id>
        <link href="https://github.com/advisories/GHSA-mx2j-7cmv-353c"/>
        <updated>2025-02-06T18:03:26.000Z</updated>
        <content type="html"><![CDATA[<h1 id="cwa-2025-002">CWA-2025-002</h1>
<p><strong>Severity</strong></p>
<p>Medium (Moderate + Likely)[^1]</p>
<p><strong>Affected versions:</strong></p>
<ul>
<li>wasmvm &gt;= 2.2.0, &lt; 2.2.2</li>
<li>wasmvm &gt;= 2.1.0, &lt; 2.1.5</li>
<li>wasmvm &gt;= 2.0.0, &lt; 2.0.6</li>
<li>wasmvm &lt; 1.5.8</li>
</ul>
<p><strong>Patched versions:</strong></p>
<ul>
<li>wasmvm 1.5.8, 2.0.6, 2.1.5, 2.2.2</li>
</ul>
<h2 id="description-of-the-bug">Description of the bug</h2>
<p>The vulnerability can be used to slow down block production. The attack requires a malicious contract,
so permissioned chains are unlikely to be affected.</p>
<p>(We'll add more detail once chains had a chance to upgrade.)</p>
<h2 id="patch">Patch</h2>
<ul>
<li>1.5: <a href="https://github.com/CosmWasm/cosmwasm/commit/2b7f2faa57a1efc8207455c37f87f1eee6035a27">https://github.com/CosmWasm/cosmwasm/commit/2b7f2faa57a1efc8207455c37f87f1eee6035a27</a></li>
<li>2.0: <a href="https://github.com/CosmWasm/cosmwasm/commit/d6143b0aff16a39bbea4be37597d8e9d9b213d3b">https://github.com/CosmWasm/cosmwasm/commit/d6143b0aff16a39bbea4be37597d8e9d9b213d3b</a></li>
<li>2.1: <a href="https://github.com/CosmWasm/cosmwasm/commit/f0c04c03cbe2557634c1bbcdc2ce203fe7caca58">https://github.com/CosmWasm/cosmwasm/commit/f0c04c03cbe2557634c1bbcdc2ce203fe7caca58</a></li>
<li>2.2: <a href="https://github.com/CosmWasm/cosmwasm/commit/a5d62f65b5eb947ebe40e2085b1c48a9d0a244d0">https://github.com/CosmWasm/cosmwasm/commit/a5d62f65b5eb947ebe40e2085b1c48a9d0a244d0</a></li>
</ul>
<h2 id="applying-the-patch">Applying the patch</h2>
<p>The patch will be shipped in releases of wasmvm. You can update more or less as follows:</p>
<ol>
<li>Check the current wasmvm version: <code>go list -m github.com/CosmWasm/wasmvm</code></li>
<li>Bump the <code>github.com/CosmWasm/wasmvm</code> dependency in your go.mod to one of the patched version
depending on which minor version you are on; <code>go mod tidy</code>; commit.</li>
<li>If you use the static libraries <code>libwasmvm_muslc.aarch64.a</code>/<code>libwasmvm_muslc.x86_64.a</code>, update them accordingly.</li>
<li>Check the updated wasmvm version: <code>go list -m github.com/CosmWasm/wasmvm</code> and ensure you see 1.5.8, 2.0.6, 2.1.5 or 2.2.2.</li>
<li>Follow your regular practices to deploy chain upgrades.</li>
</ol>
<p>The patch is consensus breaking and requires a coordinated upgrade.</p>
<h2 id="acknowledgement">Acknowledgement</h2>
<p>This issue was found by meadow101 who reported it to the Cosmos Bug Bounty Program on HackerOne.</p>
<p>If you believe you have found a bug in the Interchain Stack or would like to contribute to the
program by reporting a bug, please see <a href="https://hackerone.com/cosmos">https://hackerone.com/cosmos</a>.</p>
<h2 id="timeline">Timeline</h2>
<ul>
<li>2024-11-24: Confio receives a report through the Cosmos bug bounty program maintained by Amulet.</li>
<li>2024-12-20: Confio security contributors confirm the report.</li>
<li>2024-01-27: Confio developed the patch internally.</li>
<li>2025-02-04: Patch gets released.</li>
</ul>
<p>[^1]: following Amulet's Severity Classification Framework ACMv1.2: <a href="https://github.com/interchainio/security/blob/0295254e8645301ccb606d46108a45cede0a73e0/resources/CLASSIFICATION_MATRIX.md">https://github.com/interchainio/security/blob/0295254e8645301ccb606d46108a45cede0a73e0/resources/CLASSIFICATION_MATRIX.md</a></p>
<h3 id="references">References</h3>
<ul>
<li><a href="https://github.com/CosmWasm/wasmvm/security/advisories/GHSA-mx2j-7cmv-353c">https://github.com/CosmWasm/wasmvm/security/advisories/GHSA-mx2j-7cmv-353c</a></li>
<li><a href="https://github.com/CosmWasm/cosmwasm/commit/2b7f2faa57a1efc8207455c37f87f1eee6035a27">https://github.com/CosmWasm/cosmwasm/commit/2b7f2faa57a1efc8207455c37f87f1eee6035a27</a></li>
<li><a href="https://github.com/CosmWasm/cosmwasm/commit/a5d62f65b5eb947ebe40e2085b1c48a9d0a244d0">https://github.com/CosmWasm/cosmwasm/commit/a5d62f65b5eb947ebe40e2085b1c48a9d0a244d0</a></li>
<li><a href="https://github.com/CosmWasm/cosmwasm/commit/d6143b0aff16a39bbea4be37597d8e9d9b213d3b">https://github.com/CosmWasm/cosmwasm/commit/d6143b0aff16a39bbea4be37597d8e9d9b213d3b</a></li>
<li><a href="https://github.com/CosmWasm/cosmwasm/commit/f0c04c03cbe2557634c1bbcdc2ce203fe7caca58">https://github.com/CosmWasm/cosmwasm/commit/f0c04c03cbe2557634c1bbcdc2ce203fe7caca58</a></li>
<li><a href="https://github.com/CosmWasm/advisories/blob/main/CWAs/CWA-2025-002.md">https://github.com/CosmWasm/advisories/blob/main/CWAs/CWA-2025-002.md</a></li>
<li><a href="https://pkg.go.dev/vuln/GO-2025-3449">https://pkg.go.dev/vuln/GO-2025-3449</a></li>
<li><a href="https://github.com/advisories/GHSA-mx2j-7cmv-353c">https://github.com/advisories/GHSA-mx2j-7cmv-353c</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-mx2j-7cmv-353c</uri>
        </author>
        <category label="severity" term="MODERATE"/>
        <published>2025-02-04T18:57:21.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[[cosmwasm-vm] wasmvm: Malicious smart contract can slow down block production]]></title>
        <id>https://github.com/advisories/GHSA-mx2j-7cmv-353c</id>
        <link href="https://github.com/advisories/GHSA-mx2j-7cmv-353c"/>
        <updated>2025-02-06T18:03:26.000Z</updated>
        <content type="html"><![CDATA[<h1 id="cwa-2025-002">CWA-2025-002</h1>
<p><strong>Severity</strong></p>
<p>Medium (Moderate + Likely)[^1]</p>
<p><strong>Affected versions:</strong></p>
<ul>
<li>wasmvm &gt;= 2.2.0, &lt; 2.2.2</li>
<li>wasmvm &gt;= 2.1.0, &lt; 2.1.5</li>
<li>wasmvm &gt;= 2.0.0, &lt; 2.0.6</li>
<li>wasmvm &lt; 1.5.8</li>
</ul>
<p><strong>Patched versions:</strong></p>
<ul>
<li>wasmvm 1.5.8, 2.0.6, 2.1.5, 2.2.2</li>
</ul>
<h2 id="description-of-the-bug">Description of the bug</h2>
<p>The vulnerability can be used to slow down block production. The attack requires a malicious contract,
so permissioned chains are unlikely to be affected.</p>
<p>(We'll add more detail once chains had a chance to upgrade.)</p>
<h2 id="patch">Patch</h2>
<ul>
<li>1.5: <a href="https://github.com/CosmWasm/cosmwasm/commit/2b7f2faa57a1efc8207455c37f87f1eee6035a27">https://github.com/CosmWasm/cosmwasm/commit/2b7f2faa57a1efc8207455c37f87f1eee6035a27</a></li>
<li>2.0: <a href="https://github.com/CosmWasm/cosmwasm/commit/d6143b0aff16a39bbea4be37597d8e9d9b213d3b">https://github.com/CosmWasm/cosmwasm/commit/d6143b0aff16a39bbea4be37597d8e9d9b213d3b</a></li>
<li>2.1: <a href="https://github.com/CosmWasm/cosmwasm/commit/f0c04c03cbe2557634c1bbcdc2ce203fe7caca58">https://github.com/CosmWasm/cosmwasm/commit/f0c04c03cbe2557634c1bbcdc2ce203fe7caca58</a></li>
<li>2.2: <a href="https://github.com/CosmWasm/cosmwasm/commit/a5d62f65b5eb947ebe40e2085b1c48a9d0a244d0">https://github.com/CosmWasm/cosmwasm/commit/a5d62f65b5eb947ebe40e2085b1c48a9d0a244d0</a></li>
</ul>
<h2 id="applying-the-patch">Applying the patch</h2>
<p>The patch will be shipped in releases of wasmvm. You can update more or less as follows:</p>
<ol>
<li>Check the current wasmvm version: <code>go list -m github.com/CosmWasm/wasmvm</code></li>
<li>Bump the <code>github.com/CosmWasm/wasmvm</code> dependency in your go.mod to one of the patched version
depending on which minor version you are on; <code>go mod tidy</code>; commit.</li>
<li>If you use the static libraries <code>libwasmvm_muslc.aarch64.a</code>/<code>libwasmvm_muslc.x86_64.a</code>, update them accordingly.</li>
<li>Check the updated wasmvm version: <code>go list -m github.com/CosmWasm/wasmvm</code> and ensure you see 1.5.8, 2.0.6, 2.1.5 or 2.2.2.</li>
<li>Follow your regular practices to deploy chain upgrades.</li>
</ol>
<p>The patch is consensus breaking and requires a coordinated upgrade.</p>
<h2 id="acknowledgement">Acknowledgement</h2>
<p>This issue was found by meadow101 who reported it to the Cosmos Bug Bounty Program on HackerOne.</p>
<p>If you believe you have found a bug in the Interchain Stack or would like to contribute to the
program by reporting a bug, please see <a href="https://hackerone.com/cosmos">https://hackerone.com/cosmos</a>.</p>
<h2 id="timeline">Timeline</h2>
<ul>
<li>2024-11-24: Confio receives a report through the Cosmos bug bounty program maintained by Amulet.</li>
<li>2024-12-20: Confio security contributors confirm the report.</li>
<li>2024-01-27: Confio developed the patch internally.</li>
<li>2025-02-04: Patch gets released.</li>
</ul>
<p>[^1]: following Amulet's Severity Classification Framework ACMv1.2: <a href="https://github.com/interchainio/security/blob/0295254e8645301ccb606d46108a45cede0a73e0/resources/CLASSIFICATION_MATRIX.md">https://github.com/interchainio/security/blob/0295254e8645301ccb606d46108a45cede0a73e0/resources/CLASSIFICATION_MATRIX.md</a></p>
<h3 id="references">References</h3>
<ul>
<li><a href="https://github.com/CosmWasm/wasmvm/security/advisories/GHSA-mx2j-7cmv-353c">https://github.com/CosmWasm/wasmvm/security/advisories/GHSA-mx2j-7cmv-353c</a></li>
<li><a href="https://github.com/CosmWasm/cosmwasm/commit/2b7f2faa57a1efc8207455c37f87f1eee6035a27">https://github.com/CosmWasm/cosmwasm/commit/2b7f2faa57a1efc8207455c37f87f1eee6035a27</a></li>
<li><a href="https://github.com/CosmWasm/cosmwasm/commit/a5d62f65b5eb947ebe40e2085b1c48a9d0a244d0">https://github.com/CosmWasm/cosmwasm/commit/a5d62f65b5eb947ebe40e2085b1c48a9d0a244d0</a></li>
<li><a href="https://github.com/CosmWasm/cosmwasm/commit/d6143b0aff16a39bbea4be37597d8e9d9b213d3b">https://github.com/CosmWasm/cosmwasm/commit/d6143b0aff16a39bbea4be37597d8e9d9b213d3b</a></li>
<li><a href="https://github.com/CosmWasm/cosmwasm/commit/f0c04c03cbe2557634c1bbcdc2ce203fe7caca58">https://github.com/CosmWasm/cosmwasm/commit/f0c04c03cbe2557634c1bbcdc2ce203fe7caca58</a></li>
<li><a href="https://github.com/CosmWasm/advisories/blob/main/CWAs/CWA-2025-002.md">https://github.com/CosmWasm/advisories/blob/main/CWAs/CWA-2025-002.md</a></li>
<li><a href="https://pkg.go.dev/vuln/GO-2025-3449">https://pkg.go.dev/vuln/GO-2025-3449</a></li>
<li><a href="https://github.com/advisories/GHSA-mx2j-7cmv-353c">https://github.com/advisories/GHSA-mx2j-7cmv-353c</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-mx2j-7cmv-353c</uri>
        </author>
        <category label="severity" term="MODERATE"/>
        <published>2025-02-04T18:57:21.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[[cosmwasm-vm] wasmvm: Malicious smart contract can slow down block production]]></title>
        <id>https://github.com/advisories/GHSA-mx2j-7cmv-353c</id>
        <link href="https://github.com/advisories/GHSA-mx2j-7cmv-353c"/>
        <updated>2025-02-06T18:03:26.000Z</updated>
        <content type="html"><![CDATA[<h1 id="cwa-2025-002">CWA-2025-002</h1>
<p><strong>Severity</strong></p>
<p>Medium (Moderate + Likely)[^1]</p>
<p><strong>Affected versions:</strong></p>
<ul>
<li>wasmvm &gt;= 2.2.0, &lt; 2.2.2</li>
<li>wasmvm &gt;= 2.1.0, &lt; 2.1.5</li>
<li>wasmvm &gt;= 2.0.0, &lt; 2.0.6</li>
<li>wasmvm &lt; 1.5.8</li>
</ul>
<p><strong>Patched versions:</strong></p>
<ul>
<li>wasmvm 1.5.8, 2.0.6, 2.1.5, 2.2.2</li>
</ul>
<h2 id="description-of-the-bug">Description of the bug</h2>
<p>The vulnerability can be used to slow down block production. The attack requires a malicious contract,
so permissioned chains are unlikely to be affected.</p>
<p>(We'll add more detail once chains had a chance to upgrade.)</p>
<h2 id="patch">Patch</h2>
<ul>
<li>1.5: <a href="https://github.com/CosmWasm/cosmwasm/commit/2b7f2faa57a1efc8207455c37f87f1eee6035a27">https://github.com/CosmWasm/cosmwasm/commit/2b7f2faa57a1efc8207455c37f87f1eee6035a27</a></li>
<li>2.0: <a href="https://github.com/CosmWasm/cosmwasm/commit/d6143b0aff16a39bbea4be37597d8e9d9b213d3b">https://github.com/CosmWasm/cosmwasm/commit/d6143b0aff16a39bbea4be37597d8e9d9b213d3b</a></li>
<li>2.1: <a href="https://github.com/CosmWasm/cosmwasm/commit/f0c04c03cbe2557634c1bbcdc2ce203fe7caca58">https://github.com/CosmWasm/cosmwasm/commit/f0c04c03cbe2557634c1bbcdc2ce203fe7caca58</a></li>
<li>2.2: <a href="https://github.com/CosmWasm/cosmwasm/commit/a5d62f65b5eb947ebe40e2085b1c48a9d0a244d0">https://github.com/CosmWasm/cosmwasm/commit/a5d62f65b5eb947ebe40e2085b1c48a9d0a244d0</a></li>
</ul>
<h2 id="applying-the-patch">Applying the patch</h2>
<p>The patch will be shipped in releases of wasmvm. You can update more or less as follows:</p>
<ol>
<li>Check the current wasmvm version: <code>go list -m github.com/CosmWasm/wasmvm</code></li>
<li>Bump the <code>github.com/CosmWasm/wasmvm</code> dependency in your go.mod to one of the patched version
depending on which minor version you are on; <code>go mod tidy</code>; commit.</li>
<li>If you use the static libraries <code>libwasmvm_muslc.aarch64.a</code>/<code>libwasmvm_muslc.x86_64.a</code>, update them accordingly.</li>
<li>Check the updated wasmvm version: <code>go list -m github.com/CosmWasm/wasmvm</code> and ensure you see 1.5.8, 2.0.6, 2.1.5 or 2.2.2.</li>
<li>Follow your regular practices to deploy chain upgrades.</li>
</ol>
<p>The patch is consensus breaking and requires a coordinated upgrade.</p>
<h2 id="acknowledgement">Acknowledgement</h2>
<p>This issue was found by meadow101 who reported it to the Cosmos Bug Bounty Program on HackerOne.</p>
<p>If you believe you have found a bug in the Interchain Stack or would like to contribute to the
program by reporting a bug, please see <a href="https://hackerone.com/cosmos">https://hackerone.com/cosmos</a>.</p>
<h2 id="timeline">Timeline</h2>
<ul>
<li>2024-11-24: Confio receives a report through the Cosmos bug bounty program maintained by Amulet.</li>
<li>2024-12-20: Confio security contributors confirm the report.</li>
<li>2024-01-27: Confio developed the patch internally.</li>
<li>2025-02-04: Patch gets released.</li>
</ul>
<p>[^1]: following Amulet's Severity Classification Framework ACMv1.2: <a href="https://github.com/interchainio/security/blob/0295254e8645301ccb606d46108a45cede0a73e0/resources/CLASSIFICATION_MATRIX.md">https://github.com/interchainio/security/blob/0295254e8645301ccb606d46108a45cede0a73e0/resources/CLASSIFICATION_MATRIX.md</a></p>
<h3 id="references">References</h3>
<ul>
<li><a href="https://github.com/CosmWasm/wasmvm/security/advisories/GHSA-mx2j-7cmv-353c">https://github.com/CosmWasm/wasmvm/security/advisories/GHSA-mx2j-7cmv-353c</a></li>
<li><a href="https://github.com/CosmWasm/cosmwasm/commit/2b7f2faa57a1efc8207455c37f87f1eee6035a27">https://github.com/CosmWasm/cosmwasm/commit/2b7f2faa57a1efc8207455c37f87f1eee6035a27</a></li>
<li><a href="https://github.com/CosmWasm/cosmwasm/commit/a5d62f65b5eb947ebe40e2085b1c48a9d0a244d0">https://github.com/CosmWasm/cosmwasm/commit/a5d62f65b5eb947ebe40e2085b1c48a9d0a244d0</a></li>
<li><a href="https://github.com/CosmWasm/cosmwasm/commit/d6143b0aff16a39bbea4be37597d8e9d9b213d3b">https://github.com/CosmWasm/cosmwasm/commit/d6143b0aff16a39bbea4be37597d8e9d9b213d3b</a></li>
<li><a href="https://github.com/CosmWasm/cosmwasm/commit/f0c04c03cbe2557634c1bbcdc2ce203fe7caca58">https://github.com/CosmWasm/cosmwasm/commit/f0c04c03cbe2557634c1bbcdc2ce203fe7caca58</a></li>
<li><a href="https://github.com/CosmWasm/advisories/blob/main/CWAs/CWA-2025-002.md">https://github.com/CosmWasm/advisories/blob/main/CWAs/CWA-2025-002.md</a></li>
<li><a href="https://pkg.go.dev/vuln/GO-2025-3449">https://pkg.go.dev/vuln/GO-2025-3449</a></li>
<li><a href="https://github.com/advisories/GHSA-mx2j-7cmv-353c">https://github.com/advisories/GHSA-mx2j-7cmv-353c</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-mx2j-7cmv-353c</uri>
        </author>
        <category label="severity" term="MODERATE"/>
        <published>2025-02-04T18:57:21.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[[openssl] rust-openssl ssl::select_next_proto use after free]]></title>
        <id>https://github.com/advisories/GHSA-rpmj-rpgj-qmpm</id>
        <link href="https://github.com/advisories/GHSA-rpmj-rpgj-qmpm"/>
        <updated>2025-02-11T09:30:32.000Z</updated>
        <content type="html"><![CDATA[<h3 id="impact">Impact</h3>
<p><code>ssl::select_next_proto</code> can return a slice pointing into the <code>server</code> argument's buffer but with a lifetime bound to the <code>client</code> argument. In situations where the <code>server</code> buffer's lifetime is shorter than the <code>client</code> buffer's, this can cause a use after free. This could cause the server to crash or to return arbitrary memory contents to the client.</p>
<h3 id="patches">Patches</h3>
<p><code>openssl</code> 0.10.70 fixes the signature of <code>ssl::select_next_proto</code> to properly constrain the output buffer's lifetime to that of both input buffers.</p>
<h3 id="workarounds">Workarounds</h3>
<p>In standard usage of <code>ssl::select_next_proto</code> in the callback passed to <code>SslContextBuilder::set_alpn_select_callback</code>, code is only affected if the <code>server</code> buffer is constructed <em>within</em> the callback. For example:</p>
<p>Not vulnerable - the server buffer has a <code>'static</code> lifetime:</p>
<pre><code class="language-rust">builder.set_alpn_select_callback(|_, client_protos| {
    ssl::select_next_proto(b"\x02h2", client_protos).ok_or_else(AlpnError::NOACK)
});
</code></pre>
<p>Not vulnerable - the server buffer outlives the handshake:</p>
<pre><code class="language-rust">let server_protos = b"\x02h2".to_vec();
builder.set_alpn_select_callback(|_, client_protos| {
    ssl::select_next_proto(&amp;server_protos, client_protos).ok_or_else(AlpnError::NOACK)
});
</code></pre>
<p>Vulnerable - the server buffer is freed when the callback returns:</p>
<pre><code class="language-rust">builder.set_alpn_select_callback(|_, client_protos| {
    let server_protos = b"\x02h2".to_vec();
    ssl::select_next_proto(&amp;server_protos, client_protos).ok_or_else(AlpnError::NOACK)
});
</code></pre>
<h3 id="references">References</h3>
<p><a href="https://github.com/sfackler/rust-openssl/pull/2360">https://github.com/sfackler/rust-openssl/pull/2360</a></p>
<h3 id="references-1">References</h3>
<ul>
<li><a href="https://github.com/sfackler/rust-openssl/security/advisories/GHSA-rpmj-rpgj-qmpm">https://github.com/sfackler/rust-openssl/security/advisories/GHSA-rpmj-rpgj-qmpm</a></li>
<li><a href="https://github.com/sfackler/rust-openssl/pull/2360">https://github.com/sfackler/rust-openssl/pull/2360</a></li>
<li><a href="https://github.com/sfackler/rust-openssl/commit/f014afb230de4d77bc79dea60e7e58c2f47b60f2">https://github.com/sfackler/rust-openssl/commit/f014afb230de4d77bc79dea60e7e58c2f47b60f2</a></li>
<li><a href="https://rustsec.org/advisories/RUSTSEC-2025-0004.html">https://rustsec.org/advisories/RUSTSEC-2025-0004.html</a></li>
<li><a href="https://nvd.nist.gov/vuln/detail/CVE-2025-24898">https://nvd.nist.gov/vuln/detail/CVE-2025-24898</a></li>
<li><a href="https://crates.io/crates/openssl">https://crates.io/crates/openssl</a></li>
<li><a href="https://lists.debian.org/debian-lts-announce/2025/02/msg00009.html">https://lists.debian.org/debian-lts-announce/2025/02/msg00009.html</a></li>
<li><a href="https://github.com/advisories/GHSA-rpmj-rpgj-qmpm">https://github.com/advisories/GHSA-rpmj-rpgj-qmpm</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-rpmj-rpgj-qmpm</uri>
        </author>
        <category label="severity" term="MODERATE"/>
        <published>2025-02-03T17:56:46.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[[plonky2] Soundness issue with Plonky2 look up tables]]></title>
        <id>https://github.com/advisories/GHSA-hj49-h7fq-px5h</id>
        <link href="https://github.com/advisories/GHSA-hj49-h7fq-px5h"/>
        <updated>2025-01-30T21:36:55.000Z</updated>
        <content type="html"><![CDATA[<h3 id="impact">Impact</h3>
<p>Lookup tables, whose length is not divisible by <code>26 = floor(num_routed_wires / 3)</code> always include the <code>0 -&gt; 0</code> input-output pair. Thus a malicious prover can always prove that <code>f(0) = 0</code> for any lookup table f (unless its length happens to be divisible by 26).</p>
<p>The cause of problem is that the <code>LookupTableGate</code>-s are <a href="https://github.com/0xPolygonZero/plonky2/blob/main/plonky2/src/plonk/prover.rs#L97">padded with zeros</a>.</p>
<p>The fix is done by padding with an existing table pair, similarly to <code>LookupGate</code>.</p>
<p>A workaround from the user side is to extend the table (by repeating some entries) so that its length becomes divisible by 26.</p>
<p>Fortunately, the seemingly most common use case, namely, hash functions with table-based sbox-es, are not vulnerable:</p>
<ul>
<li>both Monolith's and Tip5/Tip4's s-box tables already map 0 to 0;</li>
<li>more generally, forcing several (0,0) pairs inside such a hash function appears to be a too strong restriction to find an otherwise valid trace.</li>
</ul>
<p>A malicious prover exploiting this could cheat a circuit which statement is the following:</p>
<ul>
<li>output <code>x + f(x)</code> for some private input <code>x</code>, where <code>f(x) := 100 - x</code> is implemented by a lookup table.</li>
</ul>
<p>A malicious prover would be able to convince an honest verifier that they know an <code>0 &lt;= x &lt; 64</code> such that <code>x + (100 - x) = 0</code>.</p>
<h3 id="patches">Patches</h3>
<p>Yes, upgrade to v1.0.1</p>
<h3 id="workarounds">Workarounds</h3>
<p>No</p>
<h3 id="references">References</h3>
<h3 id="references-1">References</h3>
<ul>
<li><a href="https://github.com/0xPolygonZero/plonky2/security/advisories/GHSA-hj49-h7fq-px5h">https://github.com/0xPolygonZero/plonky2/security/advisories/GHSA-hj49-h7fq-px5h</a></li>
<li><a href="https://github.com/0xPolygonZero/plonky2/commit/091047f7f10cae082716f3738ad59a583835f7b6">https://github.com/0xPolygonZero/plonky2/commit/091047f7f10cae082716f3738ad59a583835f7b6</a></li>
<li><a href="https://nvd.nist.gov/vuln/detail/CVE-2025-24802">https://nvd.nist.gov/vuln/detail/CVE-2025-24802</a></li>
<li><a href="https://github.com/0xPolygonZero/plonky2/blob/main/plonky2/src/plonk/prover.rs#L97">https://github.com/0xPolygonZero/plonky2/blob/main/plonky2/src/plonk/prover.rs#L97</a></li>
<li><a href="https://github.com/advisories/GHSA-hj49-h7fq-px5h">https://github.com/advisories/GHSA-hj49-h7fq-px5h</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-hj49-h7fq-px5h</uri>
        </author>
        <category label="severity" term="HIGH"/>
        <published>2025-01-30T19:28:51.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[[fast-float] fast-fault has a segmentation fault due to lack of bound check]]></title>
        <id>https://github.com/advisories/GHSA-8655-xgh5-5vvq</id>
        <link href="https://github.com/advisories/GHSA-8655-xgh5-5vvq"/>
        <updated>2025-01-29T22:21:18.000Z</updated>
        <content type="html"><![CDATA[<p>In this case, the "fast_float::common::AsciiStr::first" method within the "AsciiStr" struct 
uses the unsafe keyword to reading from memory without performing bounds checking. 
Specifically, it directly dereferences a pointer offset by "self.ptr".
Because of the above reason, the method accesses invalid memory address when it takes an empty string as its input.
This approach violates Rust’s memory safety guarantees, as it can lead to invalid memory access if empty buffer is provided.</p>
<p>No patched version for fast-float crate has been released, but a patch is available in the fast-float2 fork.</p>
<h3 id="references">References</h3>
<ul>
<li><a href="https://github.com/aldanor/fast-float-rust/issues/38">https://github.com/aldanor/fast-float-rust/issues/38</a></li>
<li><a href="https://rustsec.org/advisories/RUSTSEC-2025-0003.html">https://rustsec.org/advisories/RUSTSEC-2025-0003.html</a></li>
<li><a href="https://github.com/advisories/GHSA-8655-xgh5-5vvq">https://github.com/advisories/GHSA-8655-xgh5-5vvq</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-8655-xgh5-5vvq</uri>
        </author>
        <category label="severity" term="MODERATE"/>
        <published>2025-01-29T22:21:17.000Z</published>
    </entry>
</feed>